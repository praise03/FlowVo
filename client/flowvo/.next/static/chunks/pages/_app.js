/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@onflow/config/dist/config.module.js":
/*!***********************************************************!*\
  !*** ./node_modules/@onflow/config/dist/config.module.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearConfig: function() { return /* binding */ clearConfig; },\n/* harmony export */   config: function() { return /* binding */ config; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-actor */ \"./node_modules/@onflow/util-actor/dist/actor.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/util-logger */ \"./node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-invariant */ \"./node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n\n\n\n\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\n\n// Inject config into logger to break circular dependency\n_onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.setConfig(config);\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\n(0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.spawn)(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.subscriber)(NAME, () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.spawn)(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn : _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.error\n    });\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isEmulator, `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`);\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n\n//# sourceMappingURL=config.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9jb25maWcvZGlzdC9jb25maWcubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFGO0FBQ3ZDO0FBQ0s7O0FBRW5EO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdHQUFnRyxlQUFlO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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b25maWcubW9kdWxlLmpzPzFmYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24sIFNVQlNDUklCRSwgVU5TVUJTQ1JJQkUsIHNlbmQsIHN1YnNjcmliZXIgfSBmcm9tICdAb25mbG93L3V0aWwtYWN0b3InO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ0BvbmZsb3cvdXRpbC1sb2dnZXInO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnQG9uZmxvdy91dGlsLWludmFyaWFudCc7XG5cbmNvbnN0IHBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4gZnVuYyhyZXMpO1xuICAgIH0sIHYpO1xuICB9O1xufTtcblxuLyoqKlxuICogTWVyZ2UgbXVsdGlwbGUgZnVuY3Rpb25zIHJldHVybmluZyBvYmplY3RzIGludG8gb25lIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb24oKik6IG9iamVjdH0gZnVuY3MgLSBGdW5jdGlvbnMgdG8gbWVyZ2VcbiAqIEByZXR1cm4ge29iamVjdH0gLSBNZXJnZWQgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlUGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGZ1bmNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICAuLi5mdW5jKHYpXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBjaGVja1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBJcyBvYmplY3Qgc3RhdHVzXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVlcCBtZXJnZSBtdWx0aXBsZSBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7Li4ub2JqZWN0W119IHNvdXJjZXMgLSBTb3VyY2Ugb2JqZWN0c1xuICogQHJldHVybnMge29iamVjdH0gLSBNZXJnZWQgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlRGVlcCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBzb3VyY2VzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIXRhcmdldFtrZXldKSBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiBzb3VyY2Vba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVlcCBtZXJnZSBtdWx0aXBsZSBGbG93IEpTT04uXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gdmFsdWUgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge29iamVjdH0gLSBNZXJnZWQgRmxvdyBKU09OXG4gKi9cbmNvbnN0IG1lcmdlRmxvd0pTT05zID0gdmFsdWUgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBtZXJnZURlZXAoe30sIC4uLnZhbHVlKSA6IHZhbHVlO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGaWx0ZXIgb3V0IGNvbnRyYWN0cyBzZWN0aW9uIG9mIGZsb3cuanNvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBvYmogLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdHMgc2VjdGlvbiBvZiBGbG93IEpTT05cbiAqL1xuY29uc3QgZmlsdGVyQ29udHJhY3RzID0gb2JqID0+IG9iai5jb250cmFjdHMgPyBvYmouY29udHJhY3RzIDoge307XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdhdGhlcnMgY29udHJhY3QgYWRkcmVzc2VzIGJ5IG5ldHdvcmtcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBnYXRoZXIgYWRkcmVzc2VzIGZvclxuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdCBuYW1lcyBieSBhZGRyZXNzZXMgbWFwcGluZyBlLmcgeyBcIkhlbGxvV29ybGRcIjogXCIweDEyM1wiIH1cbiAqL1xuY29uc3QgbWFwQ29udHJhY3RBbGlhc2VzVG9OZXR3b3JrQWRkcmVzcyA9IG5ldHdvcmsgPT4gY29udHJhY3RzID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNvbnRyYWN0cykucmVkdWNlKChjLCBfcmVmKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgY29uc3QgbmV0d29ya0NvbnRyYWN0QWxpYXMgPSB2YWx1ZT8uYWxpYXNlcz8uW25ldHdvcmtdO1xuICAgIGlmIChuZXR3b3JrQ29udHJhY3RBbGlhcykge1xuICAgICAgY1trZXldID0gbmV0d29ya0NvbnRyYWN0QWxpYXM7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9LCB7fSk7XG59O1xuY29uc3QgbWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzID0gbmV0d29yayA9PiBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgZGVwbG95bWVudHMgPSB7fSxcbiAgICBhY2NvdW50cyA9IHt9XG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgbmV0d29ya0RlcGxveW1lbnQgPSBkZXBsb3ltZW50cz8uW25ldHdvcmtdO1xuICBpZiAoIW5ldHdvcmtEZXBsb3ltZW50KSByZXR1cm4ge307XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhuZXR3b3JrRGVwbG95bWVudCkucmVkdWNlKChjLCBfcmVmMykgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMztcbiAgICAvLyBSZXNvbHZlIGFjY291bnQgYWRkcmVzc1xuICAgIGNvbnN0IGFjY291bnRBZGRyZXNzID0gYWNjb3VudHNba2V5XT8uYWRkcmVzcztcbiAgICBpZiAoIWFjY291bnRBZGRyZXNzKSByZXR1cm4gYztcblxuICAgIC8vIENyZWF0ZSBhbiBvYmplY3QgYXNzaWduaW5nIHRoZSBhZGRyZXNzIHRvIHRoZSBjb250cmFjdCBuYW1lLlxuICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoKGMsIGNvbnRyYWN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jLFxuICAgICAgICBbY29udHJhY3RdOiBhY2NvdW50QWRkcmVzc1xuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIGZpbGVzIGFuZCByZXR1cm4gY29udHJhY3QgdG8gYWRkcmVzcyBtYXBwaW5nIGJ5IG5ldHdvcmtcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBqc29ucyAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IGdldENvbnRyYWN0cyA9IChqc29ucywgbmV0d29yaykgPT4ge1xuICByZXR1cm4gcGlwZShtZXJnZUZsb3dKU09OcywgbWVyZ2VQaXBlKG1hcERlcGxveW1lbnRzVG9OZXR3b3JrQWRkcmVzcyhuZXR3b3JrKSwgcGlwZShmaWx0ZXJDb250cmFjdHMsIG1hcENvbnRyYWN0QWxpYXNlc1RvTmV0d29ya0FkZHJlc3MobmV0d29yaykpKSkoanNvbnMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHN0cmluZyBpcyBoZXhpZGVjaW1hbFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSXMgaGV4aWRlY2ltYWwgc3RhdHVzXG4gKi9cbmNvbnN0IGlzSGV4aWRlY2ltYWwgPSBzdHIgPT4ge1xuICAvLyBDaGVjayB0aGF0IGl0IGlzIGEgc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvXlswLTlBLUZhLWZdKyQvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBmbG93Lmpzb24gZmlsZSBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdH0gZmxvd0pTT04gLSBGbG93IEpTT05cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhhcyBwcml2YXRlIGtleXMgc3RhdHVzXG4gKi9cbmNvbnN0IGhhc1ByaXZhdGVLZXlzID0gZmxvd0pTT04gPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZmxvd0pTT04/LmFjY291bnRzKS5yZWR1Y2UoKGhhc1ByaXZhdGVLZXksIF9yZWY0KSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY0O1xuICAgIGlmIChoYXNQcml2YXRlS2V5KSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdmFsdWU/Lmhhc093blByb3BlcnR5KFwia2V5XCIpICYmIGlzSGV4aWRlY2ltYWwodmFsdWU/LmtleSk7XG4gIH0sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlcyBhbmQgY2hlY2tzIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBIYXMgcHJpdmF0ZSBrZXlzIHN0YXR1c1xuICovXG5jb25zdCBhbnlIYXNQcml2YXRlS2V5cyA9IHZhbHVlID0+IHtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGhhc1ByaXZhdGVLZXlzKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlLnNvbWUoaGFzUHJpdmF0ZUtleXMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRm9ybWF0IG5ldHdvcmsgdG8gYWx3YXlzIGJlICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZvcm1hdHRlZCBuZXR3b3JrIG5hbWUgKGVpdGhlciAnZW11bGF0b3InLCAndGVzdG5ldCcsIG9yICdtYWlubmV0JylcbiAqL1xuY29uc3QgY2xlYW5OZXR3b3JrID0gbmV0d29yayA9PiBuZXR3b3JrPy50b0xvd2VyQ2FzZSgpID09PSBcImxvY2FsXCIgPyBcImVtdWxhdG9yXCIgOiBuZXR3b3JrPy50b0xvd2VyQ2FzZSgpO1xuXG4vLyBJbmplY3QgY29uZmlnIGludG8gbG9nZ2VyIHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3lcbmxvZ2dlci5zZXRDb25maWcoY29uZmlnKTtcbmNvbnN0IE5BTUUgPSBcImNvbmZpZ1wiO1xuY29uc3QgUFVUID0gXCJQVVRfQ09ORklHXCI7XG5jb25zdCBHRVQgPSBcIkdFVF9DT05GSUdcIjtcbmNvbnN0IEdFVF9BTEwgPSBcIkdFVF9BTExfQ09ORklHXCI7XG5jb25zdCBVUERBVEUgPSBcIlVQREFURV9DT05GSUdcIjtcbmNvbnN0IERFTEVURSA9IFwiREVMRVRFX0NPTkZJR1wiO1xuY29uc3QgQ0xFQVIgPSBcIkNMRUFSX0NPTkZJR1wiO1xuY29uc3QgV0hFUkUgPSBcIldIRVJFX0NPTkZJR1wiO1xuY29uc3QgVVBEQVRFRCA9IFwiQ09ORklHL1VQREFURURcIjtcbmNvbnN0IGlkZW50aXR5ID0gdiA9PiB2O1xuY29uc3QgSEFORExFUlMgPSB7XG4gIFtQVVRdOiAoY3R4LCBfbGV0dGVyLCBfcmVmKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvcHV0LlwiKTtcbiAgICBjdHgucHV0KGtleSwgdmFsdWUpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtHRVRdOiAoY3R4LCBsZXR0ZXIsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZhbGxiYWNrXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL2dldFwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LmdldChrZXksIGZhbGxiYWNrKSk7XG4gIH0sXG4gIFtHRVRfQUxMXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0dGVyLnJlcGx5KHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVVBEQVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmMykgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmblxuICAgIH0gPSBfcmVmMztcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy91cGRhdGVcIik7XG4gICAgY3R4LnVwZGF0ZShrZXksIGZuIHx8IGlkZW50aXR5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbREVMRVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmNCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlcbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZGVsZXRlXCIpO1xuICAgIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbQ0xFQVJdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGN0eC5hbGwoKSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbV0hFUkVdOiAoY3R4LCBsZXR0ZXIsIF9yZWY1KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdHRlcm5cbiAgICB9ID0gX3JlZjU7XG4gICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAncGF0dGVybicgZm9yIGNvbmZpZy93aGVyZVwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LndoZXJlKHBhdHRlcm4pKTtcbiAgfSxcbiAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VOU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnVuc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgfVxufTtcbnNwYXduKEhBTkRMRVJTLCBOQU1FKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQWRkcyBhIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGRcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gIHNlbmQoTkFNRSwgUFVULCB7XG4gICAga2V5LFxuICAgIHZhbHVlXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgYSBrZXktdmFsdWUgcGFpciB3aXRoIGEgZmFsbGJhY2sgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gW2ZhbGxiYWNrXSAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXQoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gc2VuZChOQU1FLCBHRVQsIHtcbiAgICBrZXksXG4gICAgZmFsbGJhY2tcbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCBjb25maWcgdmFsdWUgb3IgdGhlIGZhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YW50cyAtIFRoZSBrZXlzIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7Kn0gZmFsbGJhY2sgLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGxldCB3YW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIXdhbnRzLmxlbmd0aCkgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCBbaGVhZCwgLi4ucmVzdF0gPSB3YW50cztcbiAgY29uc3QgcmV0ID0gYXdhaXQgZ2V0KGhlYWQpO1xuICBpZiAocmV0ID09IG51bGwpIHJldHVybiBmaXJzdChyZXN0LCBmYWxsYmFjayk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGwoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIEdFVF9BTEwsIG51bGwsIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVXBkYXRlcyBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWx1ZSB3aXRoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiB1cGRhdGUoa2V5KSB7XG4gIGxldCBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWRlbnRpdHk7XG4gIHNlbmQoTkFNRSwgVVBEQVRFLCB7XG4gICAga2V5LFxuICAgIGZuXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlbGV0ZXMgYSBrZXktdmFsdWUgcGFpciBmcm9tIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGRlbGV0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgc2VuZChOQU1FLCBERUxFVEUsIHtcbiAgICBrZXlcbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgY29uZmlnIGJhc2VkIG9uIGEgcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCBrZXlzIGFnYWluc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIHN1YnNldCBvZiB0aGUgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHdoZXJlKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgV0hFUkUsIHtcbiAgICBwYXR0ZXJuXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gU3Vic2NyaWJlcyB0byBjb25maWcgdXBkYXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGNvbmZpZyBpcyB1cGRhdGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICByZXR1cm4gc3Vic2NyaWJlcihOQU1FLCAoKSA9PiBzcGF3bihIQU5ETEVSUywgTkFNRSksIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2xlYXJzIHRoZSBjb25maWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjbGVhckNvbmZpZygpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgQ0xFQVIpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIGNvbmZpZyB0byBhIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkQ29uZmlnIC0gVGhlIHByZXZpb3VzIGNvbmZpZyBzdGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb25maWcob2xkQ29uZmlnKSB7XG4gIHJldHVybiBjbGVhckNvbmZpZygpLnRoZW4oY29uZmlnKG9sZENvbmZpZykpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlcyBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjcmVhdGVzIGNvbnRyYWN0IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgLSBUaGUgZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWQoZGF0YSkge1xuICBjb25zdCBuZXR3b3JrID0gYXdhaXQgZ2V0KFwiZmxvdy5uZXR3b3JrXCIpO1xuICBjb25zdCBjbGVhbmVkTmV0d29yayA9IGNsZWFuTmV0d29yayhuZXR3b3JrKTtcbiAgY29uc3Qge1xuICAgIGZsb3dKU09OXG4gIH0gPSBkYXRhO1xuICBpbnZhcmlhbnQoQm9vbGVhbihmbG93SlNPTiksIFwiY29uZmlnLmxvYWQgLS0gJ2Zsb3dKU09OJyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudChjbGVhbmVkTmV0d29yaywgYEZsb3cgTmV0d29yayBSZXF1aXJlZCAtLSBJbiBvcmRlciBmb3IgRkNMIHRvIGxvYWQgeW91ciBjb250cmFjdHMgcGxlYXNlIGRlZmluZSBcImZsb3cubmV0d29ya1wiIHRvIFwiZW11bGF0b3JcIiwgXCJsb2NhbFwiLCBcInRlc3RuZXRcIiwgb3IgXCJtYWlubmV0XCIgaW4geW91ciBjb25maWcuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mY2wtanMvcmVmZXJlbmNlL2NvbmZpZ3VyZS1mY2xgKTtcbiAgaWYgKGFueUhhc1ByaXZhdGVLZXlzKGZsb3dKU09OKSkge1xuICAgIGNvbnN0IGlzRW11bGF0b3IgPSBjbGVhbmVkTmV0d29yayA9PT0gXCJlbXVsYXRvclwiO1xuICAgIGxvZ2dlci5sb2coe1xuICAgICAgdGl0bGU6IFwiUHJpdmF0ZSBLZXlzIERldGVjdGVkXCIsXG4gICAgICBtZXNzYWdlOiBgUHJpdmF0ZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBmbG93Lmpzb24gZmlsZSBmb3Igc2VjdXJpdHkuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mbG93LWNsaS9zZWN1cml0eWAsXG4gICAgICBsZXZlbDogaXNFbXVsYXRvciA/IGxvZ2dlci5MRVZFTFMud2FybiA6IGxvZ2dlci5MRVZFTFMuZXJyb3JcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQoaXNFbXVsYXRvciwgYFByaXZhdGUga2V5cyBzaG91bGQgYmUgc3RvcmVkIGluIGEgc2VwYXJhdGUgZmxvdy5qc29uIGZpbGUgZm9yIHNlY3VyaXR5LiBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3BlcnMuZmxvdy5jb20vdG9vbHMvZmxvdy1jbGkvc2VjdXJpdHlgKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnZXRDb250cmFjdHMoZmxvd0pTT04sIGNsZWFuZWROZXR3b3JrKSkpIHtcbiAgICBjb25zdCBjb250cmFjdENvbmZpZ0tleSA9IGAweCR7a2V5fWA7XG4gICAgY29uc3QgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSA9IGF3YWl0IGdldChjb250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgJiYgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZ2dlci5sb2coe1xuICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBDb25mbGljdCBEZXRlY3RlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQSBnZW5lcmF0ZWQgY29udHJhY3QgcGxhY2Vob2xkZXIgZnJvbSBjb25maWcubG9hZCBjb25mbGljdHMgd2l0aCBhIHBsYWNlaG9sZGVyIHlvdSd2ZSBzZXQgbWFudWFsbHkgaW4gY29uZmlnIGhhdmUgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICBsZXZlbDogbG9nZ2VyLkxFVkVMUy53YXJuXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHV0KGNvbnRyYWN0Q29uZmlnS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5ID0gYHN5c3RlbS5jb250cmFjdHMuJHtrZXl9YDtcbiAgICBjb25zdCBzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgPSBhd2FpdCBnZXQoc3lzdGVtQ29udHJhY3RDb25maWdLZXkpO1xuICAgIGlmIChzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgJiYgc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgbG9nZ2VyLmxvZyh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBsb2dnZXIuTEVWRUxTLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoc3lzdGVtQ29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtcmV0dXJuc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc10gLSBUaGUgdmFsdWVzIHRvIHNldFxuICovXG5mdW5jdGlvbiBjb25maWcodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZCA9PiBwdXQoZCwgdmFsdWVzW2RdKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdXQsXG4gICAgZ2V0LFxuICAgIGFsbCxcbiAgICBmaXJzdCxcbiAgICB1cGRhdGUsXG4gICAgZGVsZXRlOiBfZGVsZXRlLFxuICAgIHdoZXJlLFxuICAgIHN1YnNjcmliZSxcbiAgICBvdmVybG9hZCxcbiAgICBsb2FkXG4gIH07XG59XG5jb25maWcucHV0ID0gcHV0O1xuY29uZmlnLmdldCA9IGdldDtcbmNvbmZpZy5hbGwgPSBhbGw7XG5jb25maWcuZmlyc3QgPSBmaXJzdDtcbmNvbmZpZy51cGRhdGUgPSB1cGRhdGU7XG5jb25maWcuZGVsZXRlID0gX2RlbGV0ZTtcbmNvbmZpZy53aGVyZSA9IHdoZXJlO1xuY29uZmlnLnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbmNvbmZpZy5vdmVybG9hZCA9IG92ZXJsb2FkO1xuY29uZmlnLmxvYWQgPSBsb2FkO1xuY29uc3Qgbm9vcCA9IHYgPT4gdjtcbmZ1bmN0aW9uIG92ZXJsb2FkKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbGRDb25maWcgPSBhd2FpdCBhbGwoKTtcbiAgICB0cnkge1xuICAgICAgY29uZmlnKG9wdHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGF3YWl0IGFsbCgpKTtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IGNsZWFyQ29uZmlnLCBjb25maWcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@onflow/config/dist/config.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/fcl/dist/fcl.module.js":
/*!*****************************************************!*\
  !*** ./node_modules/@onflow/fcl/dist/fcl.module.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppUtils: function() { return /* binding */ index$1; },\n/* harmony export */   InteractionTemplateUtils: function() { return /* binding */ index; },\n/* harmony export */   TestUtils: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.TestUtils; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   WalletUtils: function() { return /* binding */ index$2; },\n/* harmony export */   account: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.account; },\n/* harmony export */   arg: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg; },\n/* harmony export */   args: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args; },\n/* harmony export */   atBlockHeight: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockHeight; },\n/* harmony export */   atBlockId: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockId; },\n/* harmony export */   authenticate: function() { return /* binding */ authenticate; },\n/* harmony export */   authorization: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorization; },\n/* harmony export */   authorizations: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorizations; },\n/* harmony export */   authz: function() { return /* binding */ authz; },\n/* harmony export */   block: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block; },\n/* harmony export */   build: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.build; },\n/* harmony export */   cadence: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__.template; },\n/* harmony export */   cdc: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__.template; },\n/* harmony export */   config: function() { return /* reexport safe */ _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config; },\n/* harmony export */   createSignableVoucher: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.createSignableVoucher; },\n/* harmony export */   currentUser: function() { return /* binding */ currentUser; },\n/* harmony export */   decode: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode; },\n/* harmony export */   discovery: function() { return /* binding */ discovery; },\n/* harmony export */   display: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.display; },\n/* harmony export */   events: function() { return /* binding */ events; },\n/* harmony export */   getAccount: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getAccount; },\n/* harmony export */   getBlock: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getBlock; },\n/* harmony export */   getBlockHeader: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getBlockHeader; },\n/* harmony export */   getChainId: function() { return /* binding */ getChainId; },\n/* harmony export */   getCollection: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getCollection; },\n/* harmony export */   getEvents: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEvents; },\n/* harmony export */   getEventsAtBlockHeightRange: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockHeightRange; },\n/* harmony export */   getEventsAtBlockIds: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockIds; },\n/* harmony export */   getNetworkParameters: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getNetworkParameters; },\n/* harmony export */   getTransaction: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransaction; },\n/* harmony export */   getTransactionStatus: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransactionStatus; },\n/* harmony export */   invariant: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant; },\n/* harmony export */   isBad: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.isBad; },\n/* harmony export */   isOk: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.isOk; },\n/* harmony export */   limit: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit; },\n/* harmony export */   logIn: function() { return /* binding */ logIn; },\n/* harmony export */   mutate: function() { return /* binding */ mutate; },\n/* harmony export */   param: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.param; },\n/* harmony export */   params: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.params; },\n/* harmony export */   payer: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.payer; },\n/* harmony export */   ping: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.ping; },\n/* harmony export */   pipe: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.pipe; },\n/* harmony export */   pluginRegistry: function() { return /* binding */ pluginRegistry; },\n/* harmony export */   proposer: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.proposer; },\n/* harmony export */   query: function() { return /* binding */ query; },\n/* harmony export */   reauthenticate: function() { return /* binding */ reauthenticate; },\n/* harmony export */   ref: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   sansPrefix: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix; },\n/* harmony export */   script: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.script; },\n/* harmony export */   send: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   t: function() { return /* binding */ t; },\n/* harmony export */   transaction: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.transaction; },\n/* harmony export */   tx: function() { return /* binding */ transaction; },\n/* harmony export */   unauthenticate: function() { return /* binding */ unauthenticate; },\n/* harmony export */   validator: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.validator; },\n/* harmony export */   verifyUserSignatures: function() { return /* binding */ verifyUserSignatures; },\n/* harmony export */   voucherIntercept: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.voucherIntercept; },\n/* harmony export */   voucherToTxId: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.voucherToTxId; },\n/* harmony export */   why: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.why; },\n/* harmony export */   withPrefix: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix; }\n/* harmony export */ });\n/* harmony import */ var _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/sdk */ \"./node_modules/@onflow/sdk/dist/sdk.module.js\");\n/* harmony import */ var _onflow_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/types */ \"./node_modules/@onflow/types/dist/types.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-invariant */ \"./node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _onflow_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/config */ \"./node_modules/@onflow/config/dist/config.module.js\");\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @onflow/util-address */ \"./node_modules/@onflow/util-address/dist/util-address.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @onflow/util-logger */ \"./node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @onflow/rlp */ \"./node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @onflow/util-actor */ \"./node_modules/@onflow/util-actor/dist/actor.module.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\n/* harmony import */ var _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @onflow/util-template */ \"./node_modules/@onflow/util-template/dist/template.module.js\");\n/* harmony import */ var _onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @onflow/util-uid */ \"./node_modules/@onflow/util-uid/dist/util-uid.module.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"1.6.0\" ;\n\nconst is = type => d => typeof d === type;\nconst isRequired = d => d != null;\nconst isObject = is(\"object\");\nconst isString = is(\"string\");\nconst isFunc = is(\"function\");\nconst isNumber = is(\"number\");\n\nfunction normalizeArgs(ax) {\n  if (isFunc(ax)) return ax(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg, _onflow_types__WEBPACK_IMPORTED_MODULE_1__);\n  return [];\n}\n\nasync function httpDocumentResolver(_ref) {\n  let {\n    url\n  } = _ref;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  let res;\n  try {\n    res = await cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(url);\n  } catch (e) {\n    throw new Error(\"httpDocumentResolver Error: Failed to retrieve document.\");\n  }\n  let document = res.ok ? await res.json() : null;\n  return document;\n}\nconst DOCUMENT_RESOLVERS = new Map([[\"http\", httpDocumentResolver], [\"https\", httpDocumentResolver]]);\nasync function retrieve(_ref2) {\n  let {\n    url\n  } = _ref2;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url === \"string\", \"retrieve({ url }) -- url must be a string\");\n  const documentResolversFromConfig = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)().where(/^document\\.resolver\\./);\n  Object.keys(documentResolversFromConfig).map(key => {\n    const resolverFromConfig = documentResolversFromConfig[key];\n    const resolverProtocol = key.replace(/^document\\.resolver\\./, \"\");\n    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);\n  });\n  const urlParts = /^(.*):\\/\\/([A-Za-z0-9\\-\\.]+)(:[0-9]+)?(.*)$/.exec(url);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(urlParts, \"Failed to parse URL\");\n  const protocol = urlParts[1];\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(urlParts, \"Failed to parse URL protocol\");\n  const resolver = DOCUMENT_RESOLVERS.get(protocol);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(resolver, `No resolver found for protcol=${protocol}`);\n  let document = await resolver({\n    url\n  });\n  return document;\n}\n\nfunction normalizeInteractionTemplate(template) {\n  if (template == null) return null;\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      return template;\n    default:\n      throw new Error(\"normalizeInteractionTemplate Error: Invalid InteractionTemplate\");\n  }\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n * \n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {string} - Cadence\n */\nfunction deriveCadenceByNetwork(_ref) {\n  let {\n    network,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(network != undefined, \"deriveCadenceByNetwork({ network }) -- network must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof network === \"string\", \"deriveCadenceByNetwork({ network }) -- network must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let networkDependencies = Object.keys(template?.data?.dependencies).map(dependencyPlaceholder => {\n        let dependencyNetworkContracts = Object.values(template?.data?.dependencies?.[dependencyPlaceholder]);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyNetworkContracts, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyNetworkContracts.length === 0, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        let dependencyContract = dependencyNetworkContracts[0];\n        let dependencyContractForNetwork = dependencyContract?.[network];\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyContractForNetwork, `deriveCadenceByNetwork -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);\n        return [dependencyPlaceholder, dependencyContractForNetwork.address];\n      });\n      return networkDependencies.reduce((cadence, _ref2) => {\n        let [placeholder, address] = _ref2;\n        const regex = new RegExp(\"(\\\\b\" + placeholder + \"\\\\b)\", \"g\");\n        return cadence.replace(regex, address);\n      }, template.data.cadence);\n    default:\n      throw new Error(\"deriveCadenceByNetwork Error: Unsupported template version\");\n  }\n}\n\nasync function fetchChainId() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const response = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getNetworkParameters()], opts).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n  return response.chainId;\n}\n\n// Cache of chainId promises for each access node value\n// key: access node, value: chainId promise\nlet chainIdCache = {};\nlet hasWarnedEnv = false;\n\n/**\n * @description\n * Gets the chain ID if its set, otherwise gets the chain ID from the access node\n *\n * @param {object} opts - Optional parameters\n * @returns {Promise<string>} The chain ID of the access node\n * @throws {Error} If the chain ID is not found\n *\n * @example\n * // returns \"testnet\"\n * getChainId()\n */\nasync function getChainId() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let flowNetworkCfg = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"flow.network\");\n  let envCfg = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"env\");\n  if (envCfg && !hasWarnedEnv) {\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log.deprecate({\n      pkg: \"FCL\",\n      subject: 'Using the \"env\" configuration key for specifying the flow network',\n      message: \"Configuring to specify flow network is no longer required\",\n      transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key\"\n    });\n    hasWarnedEnv = true;\n  }\n  const accessNode = opts.node || (await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"accessNode.api\"));\n  if (!accessNode) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg;\n    } else if (envCfg) {\n      return envCfg;\n    }\n    throw new Error(`Either the \"accessNode.api\" config key or opts.node must be set`);\n  }\n\n  // Try using cached chainId first if it exists and access node is the same\n  if (chainIdCache[accessNode]) {\n    try {\n      return await chainIdCache[accessNode];\n    } catch {}\n  }\n\n  // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node\n  // Check if another getChainId() call has already started a new promise, if not, start a new one\n  // There may have been concurrent calls to getChainId() while the first call was waiting for the response\n  if (!chainIdCache[accessNode]) {\n    chainIdCache[accessNode] = fetchChainId(opts).catch(error => {\n      // If there was an error, reset the promise so that the next call will try again\n      chainIdCache[accessNode] = null;\n      throw error;\n    });\n  }\n\n  // Use newly created promise\n  try {\n    return await chainIdCache[accessNode];\n  } catch (e) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg;\n    } else if (envCfg) {\n      return envCfg;\n    }\n    throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`);\n  }\n}\n\n/**\n * @description\n * Watches the config for changes to access node and updates the chain id accordingly\n *\n * @returns {Function} A function that unsubscribes the listener\n *\n */\nfunction watchForChainIdChanges() {\n  return _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.subscribe(() => {\n    // Call getChainId to update the chainId cache if access node has changed\n    getChainId({\n      enableRequestLogging: false\n    }).catch(() => {});\n  });\n}\n\nfunction isAndroid() {\n  return typeof navigator !== \"undefined\" && /android/i.test(navigator.userAgent);\n}\nfunction isSmallIOS() {\n  return typeof navigator !== \"undefined\" && /iPhone|iPod/.test(navigator.userAgent);\n}\nfunction isLargeIOS() {\n  return typeof navigator !== \"undefined\" && /iPad/.test(navigator.userAgent);\n}\nfunction isIOS() {\n  return isSmallIOS() || isLargeIOS();\n}\nfunction isMobile() {\n  return isAndroid() || isIOS();\n}\n\nasync function deriveDependencies() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const template = opts.template;\n  const network = await getChainId(opts);\n  const derivedDependencies = {};\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      const dependencyPlaceholderKeys = Object.keys(template?.data?.dependencies);\n      for (let dependencyPlaceholderKey of dependencyPlaceholderKeys) {\n        let dependencyPlaceholder = template?.data?.dependencies[dependencyPlaceholderKey];\n        const dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependencyPlaceholderContractsKeys.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${dependencyPlaceholderKey}`);\n        const dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];\n        const dependency = dependencyPlaceholderContract[network];\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependency, `FCL configureDependencies Error: No dependency information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependency?.address, `FCL configureDependencies Error: No address information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        derivedDependencies[dependencyPlaceholderKey] = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(dependency?.address);\n      }\n      return derivedDependencies;\n    default:\n      throw new Error(\"FCL configureDependencies Error: Unsupported template version\");\n  }\n}\n\nasync function prepTemplateOpts(opts) {\n  if (isString(opts?.template)) {\n    opts.template = await retrieve({\n      url: opts?.template\n    });\n  }\n  let dependencies = {};\n  if (opts?.template) {\n    opts.template = normalizeInteractionTemplate(opts?.template);\n    dependencies = await deriveDependencies({\n      template: opts.template\n    });\n  }\n  const cadence = opts.cadence || deriveCadenceByNetwork({\n    template: opts.template,\n    network: await getChainId(opts)\n  });\n  opts.cadence = cadence;\n  opts.dependencies = dependencies;\n  return opts;\n}\n\nasync function pre(type, opts) {\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(opts), `${type}(opts) -- opts is required`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isObject(opts), `${type}(opts) -- opts must be an object`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);\n  // // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().get(\"accessNode.api\"), `${type}(opts) -- Required value for \"accessNode.api\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`);\n}\nasync function preMutate(opts) {\n  return pre(\"mutate\", opts);\n}\nasync function preQuery(opts) {\n  return pre(\"query\", opts);\n}\n\n/**\n * @description\n * Allows you to submit scripts to query the blockchain.\n *\n *  @param {object} opts - Query Options and configuration\n *  @param {string} opts.cadence - Cadence Script used to query Flow\n *  @param {import(\"../fcl\").ArgsFn} [opts.args] - Arguments passed to cadence script\n *  @param {object} [opts.template] - Interaction Template for a script\n *  @param {number} [opts.limit]   - Compute Limit for Query\n *  @returns {Promise}\n *\n *  @example\n *    const cadence = `\n *      cadence: `\n *        pub fun main(a: Int, b: Int, c: Address): Int {\n *          log(c)\n *          return a + b\n *        }\n *    `.trim()\n *\n *    const args = (arg, t) => [\n *      arg(5, t.Int),\n *      arg(7, t.Int),\n *      arg(\"0xb2db43ad6bc345fec9\", t.Address),\n *    ]\n *\n *    await query({ cadence, args })\n */\nasync function query() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  await preQuery(opts);\n  opts = await prepTemplateOpts(opts);\n  return _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().overload(opts.dependencies || {}, async () =>\n  // prettier-ignore\n  _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.script(opts.cadence), _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === \"number\" && _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit(opts.limit)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode));\n}\n\nconst FCL_REDIRECT_URL_PARAM_NAME = 'fcl_redirect_url';\nconst FCL_RESPONSE_PARAM_NAME = 'fclResponseJson';\nconst CORE_STRATEGIES = {\n  \"HTTP/RPC\": \"HTTP/RPC\",\n  \"HTTP/POST\": \"HTTP/POST\",\n  \"IFRAME/RPC\": \"IFRAME/RPC\",\n  \"POP/RPC\": \"POP/RPC\",\n  \"TAB/RPC\": \"TAB/RPC\",\n  \"EXT/RPC\": \"EXT/RPC\",\n  \"DEEPLINK/RPC\": \"DEEPLINK/RPC\"\n};\n\n/**\n * @description\n * Listens for messages from FCL\n * \n * @param {string} messageType - Message type\n * @param {Function} cb - Callback function\n * @returns {Function} - Function to remove event listener\n */\nconst onMessageFromFCL = function (messageType) {\n  let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  const buildData = data => {\n    if (data.deprecated) console.warn(\"DEPRECATION NOTICE\", data.deprecated.message);\n    delete data?.body?.interaction;\n    return data;\n  };\n  const internal = e => {\n    const {\n      data\n    } = e;\n    if (typeof data !== \"object\") return;\n    if (typeof data == null) return;\n    if (data.type !== messageType) return;\n    cb(buildData(data));\n  };\n  window.addEventListener(\"message\", internal);\n  return () => window.removeEventListener(\"message\", internal);\n};\n\n// This is a workaround for an ongoing issue with URL in React Native\nconst _URL = globalThis.URL;\nclass URL extends _URL {\n  constructor(url, base) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    super(url, base, ...args);\n\n    // Extra check if in React Native\n    {\n      return;\n    }\n  }\n}\n\n/**\n * @description\n * Sends message to FCL window\n *\n * @param {string} type - Message type\n * @param {object} msg - Message object\n * @returns {void}\n *\n * @example\n * sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n *    f_type: \"PollingResponse\",\n *    f_vsn: \"1.0.0\",\n *    status: \"APPROVED\",\n *    reason: null,\n *    data: data,\n *  })\n */\nconst sendMsgToFCL = function (type) {\n  let msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const data = {\n    ...msg,\n    type\n  };\n  const urlParams = new URLSearchParams(window.location.search);\n  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME);\n  if (redirectUrl) {\n    const url = new URL(redirectUrl);\n    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data));\n    window.location.href = url.href;\n  } else if (window.location !== window.parent.location) {\n    window.parent.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else if (window.opener) {\n    window.opener.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else {\n    throw new Error(\"Unable to communicate with parent FCL instance\");\n  }\n};\n\n/**\n * @description\n * Listens for \"FCL:VIEW:READY:RESPONSE\" and sends \"FCL:VIEW:READY\"\n *\n * @param {Function} cb - Callback function\n * @param {object} msg - Message object\n * @returns {void}\n */\nconst ready = function (cb) {\n  onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", cb);\n  sendMsgToFCL(\"FCL:VIEW:READY\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:CLOSE\"\n *\n * @returns {void}\n */\nconst close = () => {\n  sendMsgToFCL(\"FCL:VIEW:CLOSE\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"APPROVED\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nconst approve = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"APPROVED\",\n    reason: null,\n    data: data\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"DECLINED\"\n *\n * @param {string} reason - Reason for declining\n * @returns {void}\n */\nconst decline = reason => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"DECLINED\",\n    reason: reason,\n    data: null\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"REDIRECT\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nconst redirect = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"REDIRECT\",\n    reason: null,\n    data: data\n  });\n};\n\nconst SERVICE_PRAGMA = {\n  f_type: \"Service\",\n  f_vsn: \"1.0.0\"\n};\nconst IDENTITY_PRAGMA = {\n  f_type: \"Identity\",\n  f_vsn: \"1.0.0\"\n};\nconst USER_PRAGMA = {\n  f_type: \"USER\",\n  f_vsn: \"1.0.0\"\n};\nconst POLLING_RESPONSE_PRAGMA = {\n  f_type: \"PollingResponse\",\n  f_vsn: \"1.0.0\"\n};\nconst COMPOSITE_SIGNATURE_PRAGMA = {\n  f_type: \"CompositeSignature\",\n  f_vsn: \"1.0.0\"\n};\n\n/**\n * @description\n * Constructs a new CompositeSignature instance.\n *\n * @param {string} addr - Flow Address\n * @param {number} keyId - Key ID\n * @param {string} signature - Signature as a hex string\n */\nfunction CompositeSignature(addr, keyId, signature) {\n  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;\n  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;\n  this.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(addr);\n  this.keyId = Number(keyId);\n  this.signature = signature;\n}\n\nconst rightPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(value.padEnd(pad * 2, \"0\"), \"hex\");\nconst leftPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(value.padStart(pad * 2, \"0\"), \"hex\");\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8);\nconst nonceBuffer = nonce => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(nonce, \"hex\");\nconst encodeAccountProof = function (_ref) {\n  let {\n    address,\n    nonce,\n    appIdentifier\n  } = _ref;\n  let includeDomainTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(address, \"Encode Message For Provable Authn Error: address must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(nonce, \"Encode Message For Provable Authn Error: nonce must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(appIdentifier, \"Encode Message For Provable Authn Error: appIdentifier must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(nonce.length >= 64, \"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes\");\n  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(\"FCL-ACCOUNT-PROOF-V0.0\").toString(\"hex\"), 32);\n  if (includeDomainTag) {\n    return _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([appIdentifier, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address)), nonceBuffer(nonce)])]).toString(\"hex\");\n  }\n  return (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([appIdentifier, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address)), nonceBuffer(nonce)]).toString(\"hex\");\n};\n\nfunction injectExtService(service) {\n  if (service.type === \"authn\" && service.endpoint != null) {\n    if (!Array.isArray(window.fcl_extensions)) {\n      window.fcl_extensions = [];\n    }\n    window.fcl_extensions.push(service);\n  } else {\n    console.warn(\"Authn service is required\");\n  }\n}\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sendMsgToFCL: sendMsgToFCL,\n  ready: ready,\n  close: close,\n  approve: approve,\n  decline: decline,\n  redirect: redirect,\n  onMessageFromFCL: onMessageFromFCL,\n  encodeMessageFromSignable: _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeMessageFromSignable,\n  CompositeSignature: CompositeSignature,\n  encodeAccountProof: encodeAccountProof,\n  injectExtService: injectExtService\n});\n\nconst ACCOUNT_PROOF = \"ACCOUNT_PROOF\";\nconst USER_SIGNATURE = \"USER_SIGNATURE\";\nconst validateArgs = args => {\n  if (args.appIdentifier) {\n    const {\n      appIdentifier,\n      address,\n      nonce,\n      signatures\n    } = args;\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(appIdentifier), \"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(address) && (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address).length === 16, \"verifyAccountProof({ address }) -- address must be a valid address\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(nonce), \"nonce must be a hex string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  } else {\n    const {\n      message,\n      address,\n      compSigs\n    } = args;\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(message), \"Signed message must be a hex string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(address) && (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address).length === 16, \"verifyUserSignatures({ address }) -- address must be a valid address\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  }\n};\n\n// TODO: pass in option for contract but we're connected to testnet\n// log address + network -> in sync?\nconst getVerifySignaturesScript = async (sig, opts) => {\n  const verifyFunction = sig === \"ACCOUNT_PROOF\" ? \"verifyAccountProofSignatures\" : \"verifyUserSignatures\";\n  let network = await getChainId(opts);\n  let fclCryptoContract;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(opts.fclCryptoContract || network === \"testnet\" || network === \"mainnet\", \"${verifyFunction}({ fclCryptoContract }) -- fclCrypto contract address must be set for non-mainnet/testnet networks\");\n  if (opts.fclCryptoContract) {\n    fclCryptoContract = opts.fclCryptoContract;\n  } else {\n    fclCryptoContract = network === \"testnet\" ? \"0x74daa6f9c7ef24b1\" : \"0xb4b82a1c9d21d284\";\n  }\n  return `\n      import FCLCrypto from ${fclCryptoContract}\n\n      pub fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `;\n};\n\n/**\n * @description\n * Verify a valid account proof signature or signatures for an account on Flow.\n *\n * @param {string} appIdentifier - A message string in hexadecimal format\n * @param {object} accountProofData - An object consisting of address, nonce, and signatures\n * @param {string} accountProofData.address - A Flow account address\n * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)\n * @param {object[]} accountProofData.signatures - An array of composite signatures to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed\n * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const accountProofData = {\n *   address: \"0x123\",\n *   nonce: \"F0123\"\n *   signatures: [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *  }\n *\n *  const isValid = await fcl.AppUtils.verifyAccountProof(\n *    \"AwesomeAppId\",\n *    accountProofData,\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyAccountProof(appIdentifier, _ref) {\n  let {\n    address,\n    nonce,\n    signatures\n  } = _ref;\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  validateArgs({\n    appIdentifier,\n    address,\n    nonce,\n    signatures\n  });\n  const message = encodeAccountProof({\n    address,\n    nonce,\n    appIdentifier\n  }, false);\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of signatures) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),\n    args: (arg, t) => [arg((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(address), t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\n/**\n * @description\n * Verify a valid signature/s for an account on Flow.\n *\n * @param {string} message - A message string in hexadecimal format\n * @param {Array} compSigs - An array of Composite Signatures\n * @param {string} compSigs[].addr - The account address\n * @param {number} compSigs[].keyId - The account keyId\n * @param {string} compSigs[].signature - The signature to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed\n * @returns {boolean} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const isValid = await fcl.AppUtils.verifyUserSignatures(\n *    Buffer.from('FOO').toString(\"hex\"),\n *    [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyUserSignatures$1(message, compSigs) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const address = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(compSigs[0].addr);\n  validateArgs({\n    message,\n    address,\n    compSigs\n  });\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of compSigs) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),\n    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  verifyAccountProof: verifyAccountProof,\n  verifyUserSignatures: verifyUserSignatures$1\n});\n\n/**\n * Verify a valid signature/s for an account on Flow.\n *\n * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead\n *\n */\nconst verifyUserSignatures = _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log.deprecate({\n  pkg: \"FCL\",\n  subject: \"fcl.verifyUserSignatures()\",\n  message: \"Please use fcl.AppUtils.verifyUserSignatures()\",\n  callback: function verifyUserSignatures(message, compSigs) {\n    return verifyUserSignatures$1(message, compSigs);\n  }\n});\n\nconst serialize = async function () {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolveFunction = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config.first([\"sdk.resolve\"], opts.resolve || _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.resolve);\n  if (Array.isArray(args)) args = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.pipe)((0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.interaction)(), args);\n  return JSON.stringify((0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.createSignableVoucher)(await resolveFunction(args)), null, 2);\n};\n\nasync function configLens(regex) {\n  return Object.fromEntries(Object.entries(await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)().where(regex)).map(_ref => {\n    let [key, value] = _ref;\n    return [key.replace(regex, \"\"), value];\n  }));\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Transaction} Transaction\n */\n\n/**\n * @typedef {import(\"@onflow/typedefs\").TransactionStatus} TransactionStatus\n */\n\nconst RATE$1 = 2500;\nconst POLL = \"POLL\";\nconst fetchTxStatus = async transactionId => {\n  return (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransactionStatus)(transactionId)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n};\nconst isExpired = tx => tx.status === 5;\nconst isSealed = tx => tx.status >= 4;\nconst isExecuted = tx => tx.status >= 3;\nconst isFinalized = tx => tx.status >= 2;\nconst isPending = tx => tx.status >= 1;\nconst isUnknown = tx => tx.status >= 0;\nconst isDiff = (cur, next) => {\n  return JSON.stringify(cur) !== JSON.stringify(next);\n};\nconst HANDLERS$3 = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    ctx.sendSelf(POLL);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UPDATED, ctx.all());\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all());\n  },\n  [POLL]: async ctx => {\n    let tx;\n    try {\n      tx = await fetchTxStatus(ctx.self());\n    } catch (e) {\n      return ctx.fatalError(e);\n    }\n    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE$1);\n    if (isDiff(ctx.all(), tx)) ctx.broadcast(_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UPDATED, tx);\n    ctx.merge(tx);\n  }\n};\nconst scoped = transactionId => {\n  if (typeof transactionId === \"object\") transactionId = transactionId.transactionId;\n  if (transactionId == null) throw new Error(\"transactionId required\");\n  return transactionId;\n};\nconst spawnTransaction = transactionId => {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$3, scoped(transactionId));\n};\n\n/**\n * @callback SubscriptionCallback\n * @param {TransactionStatus} txStatus\n * @returns {void}\n */\n\n/**\n * Provides methods for interacting with a transaction\n * \n * @param {string} transactionId - The transaction ID\n * @returns {{\n *    snapshot: function(): Promise<TransactionStatus>,\n *    subscribe: function(SubscriptionCallback): function(): void,\n *    onceFinalized: function(): Promise<TransactionStatus>,\n *    onceExecuted: function(): Promise<TransactionStatus>,\n *    onceSealed: function(): Promise<TransactionStatus>\n * }}\n */\nfunction transaction(transactionId) {\n  function snapshot() {\n    return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.snapshoter)(transactionId, spawnTransaction);\n  }\n  function subscribe(callback) {\n    return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(scoped(transactionId), spawnTransaction, callback);\n  }\n  function once(predicate) {\n    return function innerOnce() {\n      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const suppress = opts.suppress || false;\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe((txStatus, error) => {\n          if ((error || txStatus.statusCode) && !suppress) {\n            reject(error || txStatus.errorMessage);\n            unsub();\n          } else if (predicate(txStatus)) {\n            resolve(txStatus);\n            unsub();\n          }\n        });\n      });\n    };\n  }\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed)\n  };\n}\ntransaction.isUnknown = isUnknown;\ntransaction.isPending = isPending;\ntransaction.isFinalized = isFinalized;\ntransaction.isExecuted = isExecuted;\ntransaction.isSealed = isSealed;\ntransaction.isExpired = isExpired;\n\nconst RATE = 10000;\nconst UPDATED$1 = \"UPDATED\";\nconst TICK = \"TICK\";\nconst HIGH_WATER_MARK = \"hwm\";\nconst scheduleTick = async ctx => {\n  return setTimeout(() => ctx.sendSelf(TICK), await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(\"fcl.eventPollRate\", RATE));\n};\nconst HANDLERS$2 = {\n  [TICK]: async ctx => {\n    if (!ctx.hasSubs()) return;\n    let hwm = ctx.get(HIGH_WATER_MARK);\n    if (hwm == null) {\n      ctx.put(HIGH_WATER_MARK, await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)());\n      ctx.put(TICK, await scheduleTick(ctx));\n    } else {\n      let next = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)();\n      ctx.put(HIGH_WATER_MARK, next);\n      if (hwm.height < next.height) {\n        const data = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockHeightRange)(ctx.self(), hwm.height + 1, next.height)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n        for (let d of data) ctx.broadcast(UPDATED$1, d.data);\n      }\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: async (ctx, letter) => {\n    if (!ctx.hasSubs()) {\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n    ctx.subscribe(letter.from);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n    if (!ctx.hasSubs()) {\n      clearTimeout(ctx.get(TICK));\n      ctx.delete(TICK);\n      ctx.delete(HIGH_WATER_MARK);\n    }\n  }\n};\nconst spawnEvents = key => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$2, key);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Event} Event\n */\n\n/**\n * @typedef {object} SubscribeObject\n * @property {Function} subscribe - The subscribe function.\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Event}\n */\n\n/**\n * @description - Subscribe to events\n * @param {string} key - A valid event name\n * @returns {SubscribeObject}\n * \n * @example\n * import * as fcl from \"@onflow/fcl\"\n * fcl.events(eventName).subscribe((event) => console.log(event))\n */\nfunction events(key) {\n  return {\n    /**\n     * @description - Subscribe to events\n     * @param {Function} callback - The callback function\n     * @returns {SubscriptionCallback}\n     */\n    subscribe: callback => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(key, spawnEvents, callback)\n  };\n}\n\nconst stub = () => {\n  throw new Error(`Platform specific Core Strategies are not initialized`);\n};\nconst stubCoreStrategies = {\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: stub,\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub\n};\nconst supportedPlugins = [\"ServicePlugin\"];\nconst supportedServicePlugins = [\"discovery-service\"];\nconst validateDiscoveryPlugin = servicePlugin => {\n  const {\n    services,\n    serviceStrategy\n  } = servicePlugin;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(services) && services.length, \"Array of Discovery Services is required\");\n  for (const ds of services) {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(ds.f_type) && ds.f_type === \"Service\", \"Service is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(ds.type) && ds.type === \"authn\", `Service must be type authn. Received ${ds.type}`);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);\n  }\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy), \"Service strategy is required\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), \"Service strategy method is required\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), \"Service strategy exec function is required\");\n  return {\n    discoveryServices: services,\n    serviceStrategy\n  };\n};\nconst ServiceRegistry = _ref => {\n  let {\n    coreStrategies\n  } = _ref;\n  let services = new Set();\n  let strategies = new Map(Object.entries(coreStrategies));\n  const add = servicePlugin => {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);\n    if (servicePlugin.type === \"discovery-service\") {\n      const {\n        discoveryServices,\n        serviceStrategy\n      } = validateDiscoveryPlugin(servicePlugin);\n      setServices(discoveryServices);\n      if (!strategies.has(serviceStrategy.method)) {\n        strategies.set(serviceStrategy.method, serviceStrategy.exec);\n      } else {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `Add Service Plugin`,\n          message: `Service strategy for ${serviceStrategy.method} already exists`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.warn\n        });\n      }\n    }\n  };\n  const setServices = discoveryServices => services = new Set([...discoveryServices]);\n  const getServices = () => [...services];\n  const getStrategy = method => strategies.get(method);\n  const getStrategies = () => [...strategies.keys()];\n  return Object.freeze({\n    add,\n    getServices,\n    getStrategy,\n    getStrategies\n  });\n};\nconst validatePlugins = plugins => {\n  let pluginsArray;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(plugins, \"No plugins supplied\");\n  if (!Array.isArray(plugins)) {\n    pluginsArray = [plugins];\n  } else {\n    pluginsArray = [...plugins];\n  }\n  for (const p of pluginsArray) {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(p.name), \"Plugin name is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(p.f_type), \"Plugin f_type is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);\n  }\n  return pluginsArray;\n};\nconst PluginRegistry = () => {\n  const pluginsMap = new Map();\n  const getPlugins = () => pluginsMap;\n  const add = plugins => {\n    const pluginsArray = validatePlugins(plugins);\n    for (const p of pluginsArray) {\n      pluginsMap.set(p.name, p);\n      if (p.f_type === \"ServicePlugin\") {\n        serviceRegistry.add(p);\n      }\n    }\n  };\n  return Object.freeze({\n    add,\n    getPlugins\n  });\n};\nlet serviceRegistry;\nconst getIsServiceRegistryInitialized = () => typeof serviceRegistry !== 'undefined';\nconst initServiceRegistry = _ref2 => {\n  let {\n    coreStrategies\n  } = _ref2;\n  if (getIsServiceRegistryInitialized()) {\n    return serviceRegistry;\n  }\n  const _serviceRegistry = ServiceRegistry({\n    coreStrategies\n  });\n  serviceRegistry = _serviceRegistry;\n  return _serviceRegistry;\n};\nconst getServiceRegistry = () => {\n  if (!getIsServiceRegistryInitialized()) {\n    console.warn(\"Registry is not initalized, it will be initialized with stub core strategies\");\n    return initServiceRegistry({\n      coreStrategies: stubCoreStrategies\n    });\n  }\n  return serviceRegistry;\n};\nconst pluginRegistry = PluginRegistry();\n\nconst makeDiscoveryServices = async () => {\n  const extensionServices = window?.fcl_extensions || [];\n  return [...extensionServices, ...getServiceRegistry().getServices()];\n};\nasync function getDiscoveryService(service) {\n  const discoveryAuthnInclude = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.include\", []);\n  const discoveryWalletMethod = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"discovery.wallet.method\", \"discovery.wallet.method.default\"]);\n  const method = service?.method ? service.method : discoveryWalletMethod;\n  const endpoint = service?.endpoint ?? (await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"discovery.wallet\", \"challenge.handshake\"]));\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(endpoint, `\n    If no service is passed to \"authenticate,\" then \"discovery.wallet\" must be defined in fcl config.\n    See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n    `);\n  return {\n    ...service,\n    type: \"authn\",\n    endpoint,\n    method,\n    discoveryAuthnInclude\n  };\n}\n\nasync function getServices(_ref) {\n  let {\n    types\n  } = _ref;\n  const endpoint = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.endpoint\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Boolean(endpoint), `\"discovery.authn.endpoint\" in config must be defined.`);\n  const include = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.include\", []);\n  const url = new URL(endpoint);\n  return fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      type: types,\n      fclVersion: VERSION,\n      include,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n      userAgent: window?.navigator?.userAgent,\n      network: await getChainId()\n    })\n  }).then(d => d.json());\n}\n\nconst SERVICE_ACTOR_KEYS = {\n  AUTHN: \"authn\",\n  RESULTS: \"results\",\n  SNAPSHOT: \"SNAPSHOT\",\n  UPDATED: \"UPDATED\",\n  UPDATE_RESULTS: \"UPDATE_RESULTS\"\n};\nconst warn = (fact, msg) => {\n  if (fact) {\n    console.warn(`\n      %cFCL Warning\n      ============================\n      ${msg}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `, \"font-weight:bold;font-family:monospace;\");\n  }\n};\nconst fetchServicesFromDiscovery = async () => {\n  try {\n    const services = await getServices({\n      types: [SERVICE_ACTOR_KEYS.AUTHN]\n    });\n    (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {\n      results: services\n    });\n  } catch (error) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: `${error.name} Error fetching Discovery API services.`,\n      message: error.message,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n    });\n  }\n};\nconst HANDLERS$1 = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    warn(typeof window === \"undefined\", '\"fcl.discovery\" is only available in the browser.');\n    // If you call this before the window is loaded extensions will not be set yet\n    if (document.readyState === 'complete') {\n      fetchServicesFromDiscovery();\n    } else {\n      window.onload = async () => {\n        fetchServicesFromDiscovery();\n      };\n    }\n  },\n  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {\n    ctx.merge(data);\n    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),\n  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({\n    ...ctx.all()\n  })\n};\nconst spawnProviders = () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$1, SERVICE_ACTOR_KEYS.AUTHN);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Service} Service\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Service[]}\n */\n\n/**\n * @description\n * Discovery methods for interacting with Authn.\n * \n * @typedef {object} Authn\n * @property {Function} subscribe - Subscribe to Discovery authn services\n * @property {Function} snapshot - Get the current Discovery authn services spanshot\n * @property {Function} update - Trigger an update of authn services\n */\nconst authn = {\n  /**\n   * @description - Subscribe to Discovery authn services\n   * @param {Function} cb\n   * @returns {SubscriptionCallback}\n   */\n  subscribe: cb => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb),\n  /**\n   * @description - Get the current Discovery authn services spanshot\n   * @returns {Service[]}\n   */\n  snapshot: () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.snapshoter)(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders),\n  /**\n   * @description - Trigger an update of authn services\n   * @returns {void}\n   */\n  update: () => fetchServicesFromDiscovery()\n};\n\nconst discovery = {\n  authn\n};\n\nvar sha3 = {};\n\nvar sponge = {};\n\nvar permute = {};\n\nvar chi = {};\n\nvar copy = function copy(I, i) {\n  return function (O, o) {\n    var oi = o * 2;\n    var ii = i * 2;\n    O[oi] = I[ii];\n    O[oi + 1] = I[ii + 1];\n  };\n};\nvar copy_1 = copy;\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var chi = function chi(_ref) {\n    var A = _ref.A,\n      C = _ref.C;\n    for (var y = 0; y < 25; y += 5) {\n      for (var x = 0; x < 5; x++) {\n        (0, _copy[\"default\"])(A, y + x)(C, x);\n      }\n      for (var _x = 0; _x < 5; _x++) {\n        var xy = (y + _x) * 2;\n        var x1 = (_x + 1) % 5 * 2;\n        var x2 = (_x + 2) % 5 * 2;\n        A[xy] ^= ~C[x1] & C[x2];\n        A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];\n      }\n    }\n  };\n  var _default = chi;\n  exports[\"default\"] = _default;\n})(chi);\n\nvar iota = {};\n\nvar roundConstants = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);\n  var _default = ROUND_CONSTANTS;\n  exports[\"default\"] = _default;\n})(roundConstants);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _roundConstants = _interopRequireDefault(roundConstants);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var iota = function iota(_ref) {\n    var A = _ref.A,\n      roundIndex = _ref.roundIndex;\n    var i = roundIndex * 2;\n    A[0] ^= _roundConstants[\"default\"][i];\n    A[1] ^= _roundConstants[\"default\"][i + 1];\n  };\n  var _default = iota;\n  exports[\"default\"] = _default;\n})(iota);\n\nvar rhoPi = {};\n\nvar piShuffles = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];\n  var _default = PI_SHUFFLES;\n  exports[\"default\"] = _default;\n})(piShuffles);\n\nvar rhoOffsets = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];\n  var _default = RHO_OFFSETS;\n  exports[\"default\"] = _default;\n})(rhoOffsets);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _piShuffles = _interopRequireDefault(piShuffles);\n  var _rhoOffsets = _interopRequireDefault(rhoOffsets);\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var rhoPi = function rhoPi(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      W = _ref.W;\n    (0, _copy[\"default\"])(A, 1)(W, 0);\n    var H = 0;\n    var L = 0;\n    var Wi = 0;\n    var ri = 32;\n    for (var i = 0; i < 24; i++) {\n      var j = _piShuffles[\"default\"][i];\n      var r = _rhoOffsets[\"default\"][i];\n      (0, _copy[\"default\"])(A, j)(C, 0);\n      H = W[0];\n      L = W[1];\n      ri = 32 - r;\n      Wi = r < 32 ? 0 : 1;\n      W[Wi] = H << r | L >>> ri;\n      W[(Wi + 1) % 2] = L << r | H >>> ri;\n      (0, _copy[\"default\"])(W, 0)(A, j);\n      (0, _copy[\"default\"])(C, 0)(W, 0);\n    }\n  };\n  var _default = rhoPi;\n  exports[\"default\"] = _default;\n})(rhoPi);\n\nvar theta = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var theta = function theta(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      D = _ref.D,\n      W = _ref.W;\n    var H = 0;\n    var L = 0;\n    for (var x = 0; x < 5; x++) {\n      var x20 = x * 2;\n      var x21 = (x + 5) * 2;\n      var x22 = (x + 10) * 2;\n      var x23 = (x + 15) * 2;\n      var x24 = (x + 20) * 2;\n      C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];\n      C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];\n    }\n    for (var _x = 0; _x < 5; _x++) {\n      (0, _copy[\"default\"])(C, (_x + 1) % 5)(W, 0);\n      H = W[0];\n      L = W[1];\n      W[0] = H << 1 | L >>> 31;\n      W[1] = L << 1 | H >>> 31;\n      D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];\n      D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];\n      for (var y = 0; y < 25; y += 5) {\n        A[(y + _x) * 2] ^= D[_x * 2];\n        A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];\n      }\n    }\n  };\n  var _default = theta;\n  exports[\"default\"] = _default;\n})(theta);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _chi = _interopRequireDefault(chi);\n  var _iota = _interopRequireDefault(iota);\n  var _rhoPi = _interopRequireDefault(rhoPi);\n  var _theta = _interopRequireDefault(theta);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var permute = function permute() {\n    var C = new Uint32Array(10);\n    var D = new Uint32Array(10);\n    var W = new Uint32Array(2);\n    return function (A) {\n      for (var roundIndex = 0; roundIndex < 24; roundIndex++) {\n        (0, _theta[\"default\"])({\n          A: A,\n          C: C,\n          D: D,\n          W: W\n        });\n        (0, _rhoPi[\"default\"])({\n          A: A,\n          C: C,\n          W: W\n        });\n        (0, _chi[\"default\"])({\n          A: A,\n          C: C\n        });\n        (0, _iota[\"default\"])({\n          A: A,\n          roundIndex: roundIndex\n        });\n      }\n      C.fill(0);\n      D.fill(0);\n      W.fill(0);\n    };\n  };\n  var _default = permute;\n  exports[\"default\"] = _default;\n})(permute);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _buffer = buffer__WEBPACK_IMPORTED_MODULE_9__;\n  var _permute = _interopRequireDefault(permute);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var xorWords = function xorWords(I, O) {\n    for (var i = 0; i < I.length; i += 8) {\n      var o = i / 4;\n      O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];\n      O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];\n    }\n    return O;\n  };\n  var readWords = function readWords(I, O) {\n    for (var o = 0; o < O.length; o += 8) {\n      var i = o / 4;\n      O[o] = I[i + 1];\n      O[o + 1] = I[i + 1] >>> 8;\n      O[o + 2] = I[i + 1] >>> 16;\n      O[o + 3] = I[i + 1] >>> 24;\n      O[o + 4] = I[i];\n      O[o + 5] = I[i] >>> 8;\n      O[o + 6] = I[i] >>> 16;\n      O[o + 7] = I[i] >>> 24;\n    }\n    return O;\n  };\n  var Sponge = function Sponge(_ref) {\n    var _this = this;\n    var capacity = _ref.capacity,\n      padding = _ref.padding;\n    var keccak = (0, _permute[\"default\"])();\n    var stateSize = 200;\n    var blockSize = capacity / 8;\n    var queueSize = stateSize - capacity / 4;\n    var queueOffset = 0;\n    var state = new Uint32Array(stateSize / 4);\n    var queue = _buffer.Buffer.allocUnsafe(queueSize);\n    this.absorb = function (buffer) {\n      for (var i = 0; i < buffer.length; i++) {\n        queue[queueOffset] = buffer[i];\n        queueOffset += 1;\n        if (queueOffset >= queueSize) {\n          xorWords(queue, state);\n          keccak(state);\n          queueOffset = 0;\n        }\n      }\n      return _this;\n    };\n    this.squeeze = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var output = {\n        buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),\n        padding: options.padding || padding,\n        queue: _buffer.Buffer.allocUnsafe(queue.length),\n        state: new Uint32Array(state.length)\n      };\n      queue.copy(output.queue);\n      for (var i = 0; i < state.length; i++) {\n        output.state[i] = state[i];\n      }\n      output.queue.fill(0, queueOffset);\n      output.queue[queueOffset] |= output.padding;\n      output.queue[queueSize - 1] |= 128;\n      xorWords(output.queue, output.state);\n      for (var offset = 0; offset < output.buffer.length; offset += queueSize) {\n        keccak(output.state);\n        readWords(output.state, output.buffer.slice(offset, offset + queueSize));\n      }\n      return output.buffer;\n    };\n    this.reset = function () {\n      queue.fill(0);\n      state.fill(0);\n      queueOffset = 0;\n      return _this;\n    };\n    return this;\n  };\n  var _default = Sponge;\n  exports[\"default\"] = _default;\n})(sponge);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;\n  var _buffer = buffer__WEBPACK_IMPORTED_MODULE_9__;\n  var _sponge = _interopRequireDefault(sponge);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var createHash = function createHash(_ref) {\n    var allowedSizes = _ref.allowedSizes,\n      defaultSize = _ref.defaultSize,\n      padding = _ref.padding;\n    return function Hash() {\n      var _this = this;\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;\n      if (!this || this.constructor !== Hash) {\n        return new Hash(size);\n      }\n      if (allowedSizes && !allowedSizes.includes(size)) {\n        throw new Error(\"Unsupported hash length\");\n      }\n      var sponge = new _sponge[\"default\"]({\n        capacity: size\n      });\n      this.update = function (input) {\n        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n        if (_buffer.Buffer.isBuffer(input)) {\n          sponge.absorb(input);\n          return _this;\n        }\n        if (typeof input === \"string\") {\n          return _this.update(_buffer.Buffer.from(input, encoding));\n        }\n        throw new TypeError(\"Not a string or buffer\");\n      };\n      this.digest = function () {\n        var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"binary\";\n        var options = typeof formatOrOptions === \"string\" ? {\n          format: formatOrOptions\n        } : formatOrOptions;\n        var buffer = sponge.squeeze({\n          buffer: options.buffer,\n          padding: options.padding || padding\n        });\n        if (options.format && options.format !== \"binary\") {\n          return buffer.toString(options.format);\n        }\n        return buffer;\n      };\n      this.reset = function () {\n        sponge.reset();\n        return _this;\n      };\n      return this;\n    };\n  };\n  var Keccak = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 1\n  });\n  exports.Keccak = Keccak;\n  var SHA3 = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 6\n  });\n  exports.SHA3 = SHA3;\n  var SHAKE = createHash({\n    allowedSizes: [128, 256],\n    defaultSize: 256,\n    padding: 31\n  });\n  exports.SHAKE = SHAKE;\n  var SHA3Hash = Keccak;\n  exports.SHA3Hash = SHA3Hash;\n  SHA3.SHA3Hash = SHA3Hash;\n  var _default = SHA3;\n  exports[\"default\"] = _default;\n})(sha3);\n\nasync function genHash(utf8String) {\n  const sha = new sha3.SHA3(256);\n  sha.update(_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(utf8String, \"utf8\"));\n  return sha.digest(\"hex\");\n}\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *  \n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nasync function generateTemplateId(_ref) {\n  let {\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateTemplateId({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateTemplateId({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const templateData = template.data;\n      const messages = await Promise.all(Object.keys(templateData.messages).map(async messageKey => [await genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));\n      const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async dependencyAddressPlaceholder => [await genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async dependencyContract => [await genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async dependencyContractNetwork => [await genHash(dependencyContractNetwork), [await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), await genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));\n      const _arguments = await Promise.all(Object.keys(templateData?.[\"arguments\"]).map(async argumentLabel => [await genHash(argumentLabel), [await genHash(String(templateData?.[\"arguments\"]?.[argumentLabel].index)), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].type), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].balance || \"\"), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages).map(async argumentMessageKey => [await genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));\n      const encodedHex = (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([await genHash(\"InteractionTemplate\"), await genHash(\"1.0.0\"), await genHash(templateData?.type), await genHash(templateData?.interface), messages, await genHash(templateData?.cadence), dependencies, _arguments]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateId Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Returns whether a set of auditors have audited a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @param {Array<string>} params.auditors - Array of auditors\n * @param {object} opts\n * @param {string} opts.flowInteractionAuditContract - Flow Interaction Template Audit contract address\n * @returns {Promise<object>} - Object of auditor addresses and audit status\n */\nasync function getInteractionTemplateAudits(_ref) {\n  let {\n    template,\n    auditors\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getInteractionTemplateAudits({ template }) -- template must be defined\");\n  template = normalizeInteractionTemplate(template);\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate\");\n\n  // Recompute ID to be sure it matches\n  let recomputedTemplateID = await generateTemplateId({\n    template\n  });\n  if (recomputedTemplateID !== template.id) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: \"getInteractionTemplateAudits Debug Error\",\n      message: `Could not recompute and match template ID\n                computed: ${recomputedTemplateID}\n                template: ${template.id}\n            `,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.debug\n    });\n    throw new Error(\"getInteractionTemplateAudits Error: Could not recompute and match template ID\");\n  }\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const _auditors = auditors || (await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(\"flow.auditors\"));\n      (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(_auditors, \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set\");\n      (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(Array.isArray(_auditors), \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array\");\n      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;\n      if (!FlowInteractionAuditContract) {\n        const fclNetwork = await getChainId(opts);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(fclNetwork === \"mainnet\" || fclNetwork === \"testnet\", \"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'\");\n        if (fclNetwork === \"mainnet\") {\n          FlowInteractionAuditContract = \"0xfd100e39d50a13e6\";\n        } else {\n          FlowInteractionAuditContract = \"0xf78bfc12d0a786dc\";\n        }\n      }\n      const audits = await query({\n        cadence: `\n        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}\n        pub fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,\n        args: (arg, t) => [arg(recomputedTemplateID, t.String), arg(_auditors, t.Array(t.Address))]\n      });\n      return audits;\n    default:\n      throw new Error(\"getInteractionTemplateAudits Error: Unsupported template version\");\n  }\n}\n\nfunction generateImport(_ref) {\n  let {\n    contractName,\n    address\n  } = _ref;\n  return {\n    contractName,\n    address,\n    contract: \"\"\n  };\n}\n\nfunction findImports(cadence) {\n  let imports = [];\n  let importsReg = /import ((\\w|,| )+)* from 0x\\w+/g;\n  let fileImports = cadence.match(importsReg) || [];\n  for (const fileImport of fileImports) {\n    const importLineReg = /import ((\\w+|, |)*) from (0x\\w+)/g;\n    const importLine = importLineReg.exec(fileImport);\n    const contractsReg = /((?:\\w+)+),?/g;\n    const contracts = importLine[1].match(contractsReg) || [];\n    for (const contract of contracts) {\n      imports.push(generateImport({\n        address: importLine[3],\n        contractName: contract.replace(/,/g, \"\")\n      }));\n    }\n  }\n  return imports;\n}\n\n/**\n * @description Produces a dependency pin for a contract at a given block height\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {number} params.blockHeight - The block height to produce the dependency pin for\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPin(_ref) {\n  let {\n    address,\n    contractName,\n    blockHeight\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(address != undefined, \"generateDependencyPin({ address }) -- address must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(contractName != undefined, \"generateDependencyPin({ contractName }) -- contractName must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) -- blockHeight must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof address === \"string\", \"generateDependencyPin({ address }) -- address must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof contractName === \"string\", \"generateDependencyPin({ contractName }) -- contractName must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) -- blockHeight must be a number\");\n  let horizon = [generateImport({\n    contractName,\n    address\n  })];\n  for (const horizonImport of horizon) {\n    let account = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getAccount)(await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(horizonImport.address, horizonImport.address)), (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockHeight)(blockHeight)], opts).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n    horizonImport.contract = account.contracts?.[horizonImport.contractName];\n    if (!horizonImport.contract) {\n      console.error(\"Did not find expected contract\", horizonImport, account);\n      throw new Error(\"Did not find expected contract\");\n    }\n    let contractImports = findImports(horizonImport.contract);\n    horizon.push(...contractImports);\n  }\n  let contractHashes = horizon.map(iport => genHash(iport.contract));\n  let contractHashesJoined = contractHashes.join(\"\");\n  return genHash(contractHashesJoined);\n}\n\n/**\n * @description Produces a dependency pin for a contract at latest sealed block\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPinAtLatestSealedBlock(_ref2) {\n  let {\n    address,\n    contractName\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)({\n    sealed: true\n  }, opts);\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return generateDependencyPin({\n    address,\n    contractName,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\nfunction normalizeInteractionTemplateInterface(templateInterface) {\n  if (templateInterface == null) return null;\n  switch (templateInterface[\"f_version\"]) {\n    case \"1.0.0\":\n      return templateInterface;\n    default:\n      throw new Error(\"normalizeInteractionTemplateInterface Error: Invalid InteractionTemplateInterface\");\n  }\n}\n\n/**\n * @description Generates Interaction Template Interface ID for a given Interaction Template Interface\n * \n * @param {object} params\n * @param {object} params.templateInterface - Interaction Template Interface\n * @returns {Promise<string>} - Interaction Template Interface ID\n */\nasync function generateTemplateInterfaceId(_ref) {\n  let {\n    templateInterface\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(templateInterface != undefined, \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof templateInterface === \"object\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof templateInterface.f_type === \"InteractionTemplateInterface\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface object must be an InteractionTemplate\");\n  templateInterface = normalizeInteractionTemplateInterface(templateInterface);\n  switch (templateInterface.f_version) {\n    case \"1.0.0\":\n      const interfaceData = templateInterface.data;\n      const encodedHex = (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([await genHash(\"InteractionTemplateInterface\"), await genHash(\"1.0.0\"), await genHash(interfaceData.flip), await Promise.all(Object.keys(interfaceData.arguments).map(async argumentLabel => [await genHash(argumentLabel), await genHash(String(interfaceData.arguments[argumentLabel].index)), await genHash(interfaceData.arguments[argumentLabel].type)]))]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateInterfaceId Error: Unsupported templateInterface version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at a block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {number} params.blockHeight - Block height to check pins at\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSame(_ref) {\n  let {\n    template,\n    blockHeight,\n    network\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(network != undefined, \"generateDependencyPin({ network }) network must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) blockHeight must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) blockHeight must be a number\");\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let templateDependenciesPlaceholderKeys = Object.keys(template.data.dependencies);\n      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {\n        let templateDependencyPlaceholder = template.data.dependencies[templateDependencyPlaceholderKey];\n        let templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);\n        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {\n          let templateDependencyPlaceholderContractNetworks = template.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];\n          let templateDependency = templateDependencyPlaceholderContractNetworks[network];\n          if (typeof templateDependency === \"undefined\") continue;\n          let pin = await generateDependencyPin({\n            address: templateDependency.address,\n            contractName: templateDependency.contract,\n            blockHeight\n          }, opts);\n          if (pin !== templateDependency.pin) {\n            (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n              title: \"verifyDependencyPinsSame Debug Error\",\n              message: `Could not recompute and match dependency pin.\n                                address: ${templateDependency.address} | contract: ${templateDependency.contract}\n                                computed: ${pin}\n                                template: ${templateDependency.pin}\n                            `,\n              level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.debug\n            });\n            return false;\n          }\n        }\n      }\n      return true;\n    default:\n      throw new Error(\"verifyDependencyPinsSame Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at the latest block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {\n  let {\n    template,\n    network\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)({\n    sealed: true\n  });\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return verifyDependencyPinsSame({\n    template,\n    network,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\n/**\n * @description Get Interaction Template argument message\n * \n * @param {object} params\n * @param {string} params.localization [localization=\"en-US\"] - Localization code\n * @param {string} params.messageKey - Message key\n * @param {object} params.template - Interaction Template\n * @returns {string} - Message\n */\nfunction getTemplateMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    messageKey,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(messageKey, \"getTemplateMessage({ messageKey }) -- messageKey must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateMessage({ messageKey }) -- messageKey must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(localization, \"getTemplateMessage({ localization }) -- localization must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof localization === \"string\", \"getTemplateMessage({ localization }) -- localization must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getTemplateMessage({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"getTemplateMessage({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"getTemplateMessage({ template }) -- template object must be an InteractionTemplate\");\n  const messages = template?.data?.messages;\n  return messages?.[messageKey]?.i18n?.[localization];\n}\n\n/**\n * @description Gets Interaction Template argument message by message key, argument label, and localization\n * \n * @param {object} opts\n * @param {string} opts.localization [localization=\"en-US\"] - Localization to get message for\n * @param {string} opts.argumentLabel - Argument label to get message for\n * @param {string} opts.messageKey - Message key to get message for\n * @param {object} opts.template - Interaction Template to get message from\n * @returns {string} - Message\n */\nfunction getTemplateArgumentMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    argumentLabel,\n    messageKey,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(messageKey, \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(argumentLabel, \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(localization, \"getTemplateArgumentMessage({ localization }) -- localization must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof localization === \"string\", \"getTemplateArgumentMessage({ localization }) -- localization must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getTemplateArgumentMessage({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"getTemplateArgumentMessage({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate\");\n  const args = template?.data?.arguments;\n  return args?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getInteractionTemplateAudits: getInteractionTemplateAudits,\n  generateDependencyPin: generateDependencyPin,\n  generateDependencyPinAtLatestSealedBlock: generateDependencyPinAtLatestSealedBlock,\n  generateTemplateId: generateTemplateId,\n  generateTemplateInterfaceId: generateTemplateInterfaceId,\n  verifyDependencyPinsSame: verifyDependencyPinsSame,\n  verifyDependencyPinsSameAtLatestSealedBlock: verifyDependencyPinsSameAtLatestSealedBlock,\n  deriveCadenceByNetwork: deriveCadenceByNetwork,\n  getTemplateMessage: getTemplateMessage,\n  getTemplateArgumentMessage: getTemplateArgumentMessage\n});\n\n/**\n * @type {Types}\n */\nconst t = _onflow_types__WEBPACK_IMPORTED_MODULE_1__;\n\n// Set chain id default on access node change\nwatchForChainIdChanges();\n\nasync function fetchServices(servicesURL, code) {\n  if (servicesURL == null || code == null) return [];\n  const url = new URL(servicesURL);\n  url.searchParams.append(\"code\", code);\n  const resp = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).then(d => d.json());\n  if (Array.isArray(resp)) return resp;\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services = [];\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service\n      });\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider\n    });\n  }\n  return services;\n}\n\nfunction mergeServices() {\n  let sx1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let sx2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // TODO: Make this smarter\n  return [...sx1, ...sx2];\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"identity\": {\n//     \"address\": \"0x____\"\n//   },\n//   \"provider\": {\n//     \"address\": \"0x____\",\n//     \"name\": \"Best Wallet\",\n//     \"description\": \"The Best Wallet\"\n//     \"icon\": \"https://\",\n//   }\n// }\nfunction normalizeAuthn(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.authn,\n        id: service.pid,\n        provider: {\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          name: service.name,\n          icon: service.icon\n        }\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"pre-authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of pre-authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizePreAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"frame\",\n//    \"endpoint\": \"https://rawr\",\n//    \"data\": {},   // Sent to frame when ready\n//    \"params\": {}, // include in query params on frame\n// }\nfunction normalizeFrame(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        old: service,\n        ...SERVICE_PRAGMA,\n        type: \"frame\",\n        endpoint: service.endpoint,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"back-channel-rpc\",\n//    \"endpoint\": \"https://rawr\",\n//    \"method\": \"HTTP/GET\", // HTTP/GET | HTTP/POST\n//    \"data\": {},           // included in body of rpc\n//    \"params\": {},         // included as query params on endpoint url\n// }\nfunction normalizeBackChannelRpc(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: \"back-channel-rpc\",\n        endpoint: service.endpoint,\n        method: service.method,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"open-id\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"method: \"data\",\n//   \"data\": {\n//      \"profile\": {\n//        \"name\": \"Bob\",\n//        \"family_name\": \"Builder\",\n//        \"given_name\": \"Robert\",\n//        \"middle_name\": \"the\",\n//        \"nickname\": \"Bob the Builder\",\n//        \"perferred_username\": \"bob\",\n//        \"profile\": \"https://www.bobthebuilder.com/\",\n//        \"picture\": \"https://avatars.onflow.org/avatar/bob\",\n//        \"gender\": \"...\",\n//        \"birthday\": \"2001-01-18\",\n//        \"zoneinfo\": \"America/Vancouver\",\n//        \"locale\": \"en-us\",\n//        \"updated_at\": \"1614970797388\"\n//      },\n//      \"email\": {\n//        \"email\": \"bob@bob.bob\",\n//        \"email_verified\": true\n//      },\n//      \"address\": {\n//        \"address\": \"One Apple Park Way, Cupertino, CA 95014, USA\"\n//      },\n//      \"phone\": {\n//        \"phone_number\": \"+1 (xxx) yyy-zzzz\",\n//        \"phone_number_verified\": true\n//      },\n//      \"social\": {\n//        \"twitter\": \"@_qvvg\",\n//        \"twitter_verified\": true\n//      },\n//   }\n// }\nfunction normalizeOpenId(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return null;\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"user-signature\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"IFRAME/RPC\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of user-signature request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeUserSignature(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid user-signature service\");\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    type: \"local-view\",\n//    method: \"VIEW/IFRAME\",\n//    endpoint: \"https://woot.org/authz/local\",\n//    data: {},\n//    params: {},\n// }\nfunction normalizeLocalView(resp) {\n  if (resp == null) return null;\n  if (resp.method == null) {\n    resp = {\n      ...resp,\n      type: \"local-view\",\n      method: \"VIEW/IFRAME\"\n    };\n  }\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: resp.type || \"local-view\",\n        method: resp.method,\n        endpoint: resp.endpoint,\n        data: resp.data || {},\n        params: resp.params || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",                    // Its a service!\n//   \"f_vsn\": \"1.0.0\",                       // Follows the v1.0.0 spec for the service\n//   \"type\": \"account-proof\",                // the type of service it is\n//   \"method\": \"DATA\",                       // Its data!\n//   \"uid\": \"awesome-wallet#account-proof\",  // A unique identifier for the service\n//   \"data\": {\n//     \"f_type\": \"account-proof\",\n//     \"f_vsn\": \"1.0.0\",\n//     \"nonce\": \"0A1BC2FF\",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)\n//     \"address\": \"0xUSER\",                  // The user's address (8 bytes, i.e 16 hex characters)\n//     \"signature\": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)\n// }\n\nfunction normalizeAccountProof(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(`FCL Normalizer Error: Invalid account-proof service`);\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn-refresh\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\",  // \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthnRefresh(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid authn-refresh service\");\n  }\n}\n\nconst serviceNormalizers = {\n  \"back-channel-rpc\": normalizeBackChannelRpc,\n  \"pre-authz\": normalizePreAuthz,\n  authz: normalizeAuthz,\n  authn: normalizeAuthn,\n  frame: normalizeFrame,\n  \"open-id\": normalizeOpenId,\n  \"user-signature\": normalizeUserSignature,\n  \"local-view\": normalizeLocalView,\n  \"account-proof\": normalizeAccountProof,\n  \"authn-refresh\": normalizeAuthnRefresh\n};\nfunction normalizeService(service, data) {\n  try {\n    var normalized = serviceNormalizers[service.type](service, data);\n    return normalized;\n  } catch (error) {\n    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);\n    return service;\n  }\n}\n\nfunction deriveCompositeId(authn) {\n  return _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode([authn.provider.address || authn.provider.name || \"UNSPECIFIED\", authn.id]).toString(\"hex\");\n}\nfunction normalizeData(data) {\n  data.addr = data.addr ? (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.addr) : null;\n  data.paddr = data.paddr ? (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.paddr) : null;\n  return data;\n}\nfunction findService(type, services) {\n  return services.find(d => d.type === type);\n}\nasync function buildUser(data) {\n  data = normalizeData(data);\n  var services = mergeServices(data.services || [], await fetchServices(data.hks, data.code)).map(service => normalizeService(service, data));\n  const authn = findService(\"authn\", services);\n  return {\n    ...USER_PRAGMA,\n    addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.addr),\n    cid: deriveCompositeId(authn),\n    loggedIn: true,\n    services: services,\n    expiresAt: data.expires\n  };\n}\n\nfunction serviceOfType() {\n  let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let type = arguments.length > 1 ? arguments[1] : undefined;\n  return services.find(service => service.type === type);\n}\n\nconst execStrategy = async _ref => {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const strategy = getServiceRegistry().getStrategy(service.method);\n  return strategy({\n    service,\n    body,\n    config,\n    opts\n  });\n};\nasync function execService(_ref2) {\n  let {\n    service,\n    msg = {},\n    config = {},\n    opts = {},\n    platform\n  } = _ref2;\n  msg.data = service.data;\n  const execConfig = {\n    services: await configLens(/^service\\./),\n    app: await configLens(/^app\\.detail\\./),\n    client: {\n      ...config.client,\n      platform,\n      fclVersion: VERSION,\n      fclLibrary: \"https://github.com/onflow/fcl-js\",\n      hostname: window?.location?.hostname ?? null,\n      network: await getChainId(opts)\n    }\n  };\n  try {\n    const res = await execStrategy({\n      service,\n      body: msg,\n      config: execConfig,\n      opts\n    });\n    if (res.status === \"REDIRECT\") {\n      (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(service.type === res.data.type, \"Cannot shift recursive service type in execService\");\n      return await execService({\n        service: res.data,\n        msg,\n        config: execConfig,\n        opts\n      });\n    } else {\n      return res;\n    }\n  } catch (error) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: `Error on execService ${service?.type}`,\n      message: error,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n    });\n    throw error;\n  }\n}\n\n// {\n//    \"f_type\": \"CompositeSignature\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"addr\": \"_____\",         // sans-prefix\n//    \"signature\": \"adfe1234\", // hex\n//    \"keyId\": 3,\n// }\nfunction normalizeCompositeSignature(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...COMPOSITE_SIGNATURE_PRAGMA,\n        addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(resp.addr || resp.address),\n        signature: resp.signature || resp.sig,\n        keyId: resp.keyId\n      };\n  }\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").CurrentUser} CurrentUser\n * @typedef {import(\"@onflow/typedefs\").CompositeSignature} CompositeSignature\n */\n\nconst isFn = d => typeof d === \"function\";\nconst NAME = \"CURRENT_USER\";\nconst UPDATED = \"CURRENT_USER/UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\";\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\";\nconst DATA = `{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}`;\nconst getStoredUser = async storage => {\n  const fallback = JSON.parse(DATA);\n  const stored = await storage.get(NAME);\n  if (stored != null && fallback[\"f_vsn\"] !== stored[\"f_vsn\"]) {\n    storage.removeItem(NAME);\n    return fallback;\n  }\n  return stored || fallback;\n};\nconst HANDLERS = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    if (typeof window === \"undefined\") {\n      console.warn(`\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        `, \"font-weight:bold;font-family:monospace;\");\n    }\n    ctx.merge(JSON.parse(DATA));\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) {\n      const user = await getStoredUser(storage);\n      if (notExpired(user)) ctx.merge(user);\n    }\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [SET_CURRENT_USER]: async (ctx, letter, data) => {\n    ctx.merge(data);\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DEL_CURRENT_USER]: async (ctx, letter) => {\n    ctx.merge(JSON.parse(DATA));\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  }\n};\nconst spawnCurrentUser = () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS, NAME);\nfunction notExpired(user) {\n  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();\n}\nasync function getAccountProofData() {\n  let accountProofDataResolver = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"fcl.accountProof.resolver\");\n  if (accountProofDataResolver == null) return;\n  if (!isFn(accountProofDataResolver)) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: \"Account Proof Data Resolver must be a function\",\n      message: `Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}\n                `,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.warn\n    });\n    return;\n  }\n  const accountProofData = await accountProofDataResolver();\n  if (accountProofData == null) return;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof accountProofData.appIdentifier === \"string\", \"appIdentifier must be a string\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(accountProofData.nonce), \"Nonce must be a hex string\");\n  return accountProofData;\n}\nconst makeConfig = async _ref => {\n  let {\n    discoveryAuthnInclude\n  } = _ref;\n  return {\n    client: {\n      discoveryAuthnInclude,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies()\n    }\n  };\n};\n\n/**\n * @description - Authenticate a user\n * @param {object} [opts] - Options\n * @param {object} [opts.platform] - platform that runs the function\n * @param {object} [opts.service] - Optional service to use for authentication\n * @param {boolean} [opts.redir=false] - Optional flag to allow window to stay open after authentication\n * @returns {Promise<CurrentUser>} - User object\n */\nconst getAuthenticate = _ref2 => {\n  let {\n    platform\n  } = _ref2;\n  return async function () {\n    let {\n      service,\n      redir = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {\n      window.location.href = service?.provider?.install_link;\n      return;\n    }\n    return new Promise(async (resolve, reject) => {\n      spawnCurrentUser();\n      const opts = {\n        redir\n      };\n      const user = await snapshot();\n      const discoveryService = await getDiscoveryService(service);\n      const refreshService = serviceOfType(user.services, \"authn-refresh\");\n      let accountProofData;\n      if (user.loggedIn) {\n        if (refreshService) {\n          try {\n            const response = await execService({\n              service: refreshService,\n              msg: accountProofData,\n              opts,\n              platform\n            });\n            (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SET_CURRENT_USER, await buildUser(response));\n          } catch (error) {\n            (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n              title: `${error.name} Could not refresh wallet authentication.`,\n              message: error.message,\n              level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n            });\n          } finally {\n            return resolve(await snapshot());\n          }\n        } else {\n          return resolve(user);\n        }\n      }\n      try {\n        accountProofData = await getAccountProofData();\n      } catch (error) {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `${error.name} On Authentication: Could not resolve account proof data.`,\n          message: error.message,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n        });\n        return reject(error);\n      }\n      try {\n        const response = await execService({\n          service: discoveryService,\n          msg: accountProofData,\n          config: await makeConfig(discoveryService),\n          opts,\n          platform\n        });\n        (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SET_CURRENT_USER, await buildUser(response));\n      } catch (error) {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `${error} On Authentication`,\n          message: error,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n        });\n      } finally {\n        resolve(await snapshot());\n      }\n    });\n  };\n};\n\n/**\n * @description - Unauthenticate a user\n * @returns {void}\n */\nfunction unauthenticate$1() {\n  spawnCurrentUser();\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, DEL_CURRENT_USER);\n}\nconst normalizePreAuthzResponse = authz => ({\n  f_type: \"PreAuthzResponse\",\n  f_vsn: \"1.0.0\",\n  proposer: (authz || {}).proposer,\n  payer: (authz || {}).payer || [],\n  authorization: (authz || {}).authorization || []\n});\nconst getResolvePreAuthz = _ref3 => {\n  let {\n    platform\n  } = _ref3;\n  return authz => {\n    const resp = normalizePreAuthzResponse(authz);\n    const axs = [];\n    if (resp.proposer != null) axs.push([\"PROPOSER\", resp.proposer]);\n    for (let az of resp.payer || []) axs.push([\"PAYER\", az]);\n    for (let az of resp.authorization || []) axs.push([\"AUTHORIZER\", az]);\n    var result = axs.map(_ref4 => {\n      let [role, az] = _ref4;\n      return {\n        tempId: [az.identity.address, az.identity.keyId].join(\"|\"),\n        addr: az.identity.address,\n        keyId: az.identity.keyId,\n        signingFunction(signable) {\n          return execService({\n            service: az,\n            msg: signable,\n            platform\n          });\n        },\n        role: {\n          proposer: role === \"PROPOSER\",\n          payer: role === \"PAYER\",\n          authorizer: role === \"AUTHORIZER\"\n        }\n      };\n    });\n    return result;\n  };\n};\n\n/**\n * @description\n * Produces the needed authorization details for the current user to submit transactions to Flow\n * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.\n * \n * @param {object} ops - running options\n * @param {string} ops.platform - platform that runs the function\n * @param {object} account - Account object\n * @returns {Promise<object>} - Account object with signing function\n */\nconst getAuthorization = _ref5 => {\n  let {\n    platform\n  } = _ref5;\n  return async account => {\n    spawnCurrentUser();\n    return {\n      ...account,\n      tempId: \"CURRENT_USER\",\n      async resolve(account, preSignable) {\n        const user = await getAuthenticate({\n          platform\n        })({\n          redir: true\n        });\n        const authz = serviceOfType(user.services, \"authz\");\n        const preAuthz = serviceOfType(user.services, \"pre-authz\");\n        if (preAuthz) return getResolvePreAuthz({\n          platform\n        })(await execService({\n          service: preAuthz,\n          msg: preSignable,\n          platform\n        }));\n        if (authz) {\n          let windowRef;\n          if (isMobile() && authz.method === \"WC/RPC\") {\n            windowRef = window.open(\"\", \"_blank\");\n          }\n          return {\n            ...account,\n            tempId: \"CURRENT_USER\",\n            resolve: null,\n            addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authz.identity.address),\n            keyId: authz.identity.keyId,\n            sequenceNum: null,\n            signature: null,\n            async signingFunction(signable) {\n              return normalizeCompositeSignature(await execService({\n                service: authz,\n                msg: signable,\n                opts: {\n                  includeOlderJsonRpcCall: true,\n                  windowRef\n                },\n                platform\n              }));\n            }\n          };\n        }\n        throw new Error(\"No Authz or PreAuthz Service configured for CURRENT_USER\");\n      }\n    };\n  };\n};\n\n/**\n * @description\n * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.\n * \n * @param {Function} callback - Callback function\n * @returns {Function} - Unsubscribe function\n */\nfunction subscribe(callback) {\n  spawnCurrentUser();\n  const EXIT = \"@EXIT\";\n  const self = (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(async ctx => {\n    ctx.send(NAME, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      if (letter.tag === EXIT) {\n        ctx.send(NAME, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data);\n    }\n  });\n  return () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(self, EXIT);\n}\n\n/**\n * @description - Gets the current user\n * @returns {Promise<CurrentUser>} - User object\n */\nfunction snapshot() {\n  spawnCurrentUser();\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\n\n/**\n * @description - Resolves the current user as an argument\n * \n * @param {object} ops - running options\n * @param {string} ops.platform - platform that runs the function\n * @returns {Promise<Function>}\n */\nconst getResolveArgument = _ref6 => {\n  let {\n    platform\n  } = _ref6;\n  return async () => {\n    const {\n      addr\n    } = await getAuthenticate({\n      platform\n    })();\n    return (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg)((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(addr), _onflow_types__WEBPACK_IMPORTED_MODULE_1__.Address);\n  };\n};\nconst makeSignable = msg => {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(msg), \"Message must be a hex string\");\n  return {\n    message: msg\n  };\n};\n\n/**\n * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.\n * @param {string} msg - Message to sign\n * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures\n */\nconst getSignUserMessage = _ref7 => {\n  let {\n    platform\n  } = _ref7;\n  return async msg => {\n    spawnCurrentUser();\n    const user = await getAuthenticate({\n      platform\n    })({\n      redir: true\n    });\n    const signingService = serviceOfType(user.services, \"user-signature\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(signingService, \"Current user must have authorized a signing service.\");\n    try {\n      const response = await execService({\n        service: signingService,\n        msg: makeSignable(msg),\n        platform\n      });\n      if (Array.isArray(response)) {\n        return response.map(compSigs => normalizeCompositeSignature(compSigs));\n      } else {\n        return [normalizeCompositeSignature(response)];\n      }\n    } catch (error) {\n      return error;\n    }\n  };\n};\nconst getCurrentUser = _ref8 => {\n  let {\n    platform\n  } = _ref8;\n  let currentUser = () => {\n    return {\n      authenticate: getAuthenticate({\n        platform\n      }),\n      unauthenticate: unauthenticate$1,\n      authorization: getAuthorization({\n        platform\n      }),\n      signUserMessage: getSignUserMessage({\n        platform\n      }),\n      subscribe,\n      snapshot,\n      resolveArgument: getResolveArgument({\n        platform\n      })\n    };\n  };\n  currentUser.authenticate = getAuthenticate({\n    platform\n  });\n  currentUser.unauthenticate = unauthenticate$1;\n  currentUser.authorization = getAuthorization({\n    platform\n  });\n  currentUser.signUserMessage = getSignUserMessage({\n    platform\n  });\n  currentUser.subscribe = subscribe;\n  currentUser.snapshot = snapshot;\n  currentUser.resolveArgument = getResolveArgument({\n    platform\n  });\n  return currentUser;\n};\n\nconst getMutate = _ref => {\n  let {\n    platform\n  } = _ref;\n  /**\n   * @description\n   * Allows you to submit transactions to the blockchain to potentially mutate the state.\n   *\n   * @param {object} [opts] - Mutation Options and configuration\n   * @param {string} [opts.cadence] - Cadence Transaction used to mutate Flow\n   * @param {import(\"../shared-exports\").ArgsFn} [opts.args] - Arguments passed to cadence transaction\n   * @param {object | string} [opts.template] - Interaction Template for a transaction\n   * @param {number} [opts.limit] - Compute Limit for transaction\n   * @param {Function} [opts.authz] - Authorization function for transaction\n   * @param {Function} [opts.proposer] - Proposer Authorization function for transaction\n   * @param {Function} [opts.payer] - Payer Authorization function for transaction\n   * @param {Array<Function>} [opts.authorizations] - Authorizations function for transaction\n   * @returns {Promise<string>} Transaction Id\n   *\n   * @example\n   * fcl.mutate({\n   *   cadence: `\n   *     transaction(a: Int, b: Int, c: Address) {\n   *       prepare(acct: AuthAccount) {\n   *         log(acct)\n   *         log(a)\n   *         log(b)\n   *         log(c)\n   *       }\n   *     }\n   *   `,\n   *   args: (arg, t) => [\n   *     arg(6, t.Int),\n   *     arg(7, t.Int),\n   *     arg(\"0xba1132bc08f82fe2\", t.Address),\n   *   ],\n   * })\n   *\n   *\n   * Options:\n   * type Options = {\n   *   template: InteractionTemplate | String // InteractionTemplate or url to one\n   *   cadence: String!,\n   *   args: (arg, t) => Array<Arg>,\n   *   limit: Number,\n   *   authz: AuthzFn, // will overload the trinity of signatory roles\n   *   proposer: AuthzFn, // will overload the proposer signatory role\n   *   payer: AuthzFn, // will overload the payer signatory role\n   *   authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles\n   * }\n   */\n  const mutate = async function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var txid;\n    try {\n      await preMutate(opts);\n      opts = await prepTemplateOpts(opts);\n      const currentUser = getCurrentUser({\n        platform\n      });\n      // Allow for a config to overwrite the authorization function.\n      // prettier-ignore\n      const authz = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().get(\"fcl.authz\", currentUser().authorization);\n      txid = _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().overload(opts.dependencies || {}, async () =>\n      // prettier-ignore\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.transaction(opts.cadence), _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit(opts.limit),\n      // opts.proposer > opts.authz > authz\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.proposer(opts.proposer || opts.authz || authz),\n      // opts.payer > opts.authz > authz\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.payer(opts.payer || opts.authz || authz),\n      // opts.authorizations > [opts.authz > authz]\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorizations(opts.authorizations || [opts.authz || authz])]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode));\n      return txid;\n    } catch (error) {\n      throw error;\n    }\n  };\n  return mutate;\n};\n\nconst FRAME = \"FCL_IFRAME\";\nconst FRAME_STYLES = `\n  position:fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  height: 100%;\n  width: 100vw;\n  display:block;\n  background:rgba(0,0,0,0.25);\n  z-index: 2147483647;\n  box-sizing: border-box;\n  color-scheme: light;\n`;\nfunction renderFrame(src) {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(!document.getElementById(FRAME), \"Attempt at triggering multiple Frames\", {\n    src\n  });\n  const $frame = document.createElement(\"iframe\");\n  $frame.src = src;\n  $frame.id = FRAME;\n  $frame.allow = \"usb *; hid *\";\n  $frame.frameBorder = \"0\";\n  $frame.style.cssText = FRAME_STYLES;\n  document.body.append($frame);\n  const unmount = () => {\n    if (document.getElementById(FRAME)) {\n      document.getElementById(FRAME).remove();\n    }\n  };\n  return [$frame.contentWindow, unmount];\n}\n\nconst POP = \"FCL_POP\";\nlet popup = null;\nlet previousUrl$1 = null;\nfunction popupWindow(url, windowName, win, w, h) {\n  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;\n  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;\n  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);\n  if (!popup) throw new Error(\"Popup failed to open (was it blocked by a popup blocker?)\");\n  return popup;\n}\nfunction renderPop(src) {\n  if (popup == null || popup?.closed) {\n    popup = popupWindow(src, POP, window, 640, 770);\n  } else if (previousUrl$1 !== src) {\n    popup.location.replace(src);\n    popup.focus();\n  } else {\n    popup.focus();\n  }\n  previousUrl$1 = src;\n  const unmount = () => {\n    if (popup && !popup.closed) {\n      popup.close();\n    }\n    popup = null;\n  };\n  return [popup, unmount];\n}\n\nlet tab$1 = null;\nlet previousUrl = null;\nfunction renderTab(src) {\n  if (tab$1 == null || tab$1?.closed) {\n    tab$1 = window.open(src, \"_blank\");\n    if (!tab$1) throw new Error(\"Tab failed to open (was it blocked by the browser?)\");\n  } else if (previousUrl !== src) {\n    tab$1.location.replace(src);\n    tab$1.focus();\n  } else {\n    tab$1.focus();\n  }\n  previousUrl = src;\n  const unmount = () => {\n    if (tab$1 && !tab$1.closed) {\n      tab$1.close();\n    }\n    tab$1 = null;\n  };\n  return [tab$1, unmount];\n}\n\nconst isServerSide = () => typeof window === \"undefined\";\nconst getSessionStorage = () => {\n  try {\n    const SESSION_STORAGE = {\n      can: !isServerSide(),\n      get: async key => JSON.parse(sessionStorage.getItem(key)),\n      put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))\n    };\n    return SESSION_STORAGE;\n  } catch (error) {\n    return null;\n  }\n};\nconst getDefaultConfig = () => {\n  return {\n    \"discovery.wallet.method.default\": \"IFRAME/RPC\",\n    \"fcl.storage.default\": getSessionStorage()\n  };\n};\n\nfunction serviceEndpoint(service) {\n  const url = new URL(service.endpoint);\n  if (window?.location?.origin) {\n    url.searchParams.append(\"l6n\", window.location.origin);\n  }\n  if (service.params != null) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value);\n    }\n  }\n  return url;\n}\n\nfunction fetchService(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const method = opts.method || \"POST\";\n  const body = method === \"GET\" ? undefined : JSON.stringify(opts.data || service.data || {});\n  return fetch(serviceEndpoint(service), {\n    method: method,\n    headers: {\n      ...(service.headers || {}),\n      ...(opts.headers || {}),\n      \"Content-Type\": \"application/json\"\n    },\n    body: body\n  }).then(d => d.json());\n}\n\n// {\n//    \"f_type\": \"PollingResponse\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"status\": \"PENDING\", // PENDING | APPROVED | DECLINED | REDIRECT\n//    \"reason\": null,      // Reason for Declining Transaction\n//    \"data\": null,        // Return value for APPROVED\n//    \"updates\": BackChannelRpc,\n//    \"local\": Frame,\n// }\nfunction normalizePollingResponse(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...POLLING_RESPONSE_PRAGMA,\n        status: resp.status ?? \"APPROVED\",\n        reason: resp.reason ?? null,\n        data: resp.compositeSignature || resp.data || {\n          ...resp\n        } || {},\n        updates: normalizeBackChannelRpc(resp.authorizationUpdates),\n        local: normalizeFrame((resp.local || [])[0])\n      };\n  }\n}\n\nconst OPTIONS = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\"\n};\nconst serviceMethod = service => {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(OPTIONS[service.method], \"Invalid Service Method for type back-channel-rpc\", {\n    service\n  });\n  return OPTIONS[service.method];\n};\nasync function poll(service) {\n  let checkCanContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => true;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(service, \"Missing Polling Service\", {\n    service\n  });\n  const canContinue = checkCanContinue();\n  if (!canContinue) throw new Error(\"Externally Halted\");\n  let resp;\n  try {\n    if (typeof document !== \"undefined\" && document.visibilityState === \"hidden\") {\n      await new Promise(r => setTimeout(r, 500));\n      return poll(service, checkCanContinue);\n    }\n    resp = await fetchService(service, {\n      method: serviceMethod(service)\n    }).then(normalizePollingResponse);\n  } catch (error) {\n    throw error;\n  }\n  switch (resp.status) {\n    case \"APPROVED\":\n      return resp.data;\n    case \"DECLINED\":\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n    default:\n      await new Promise(r => setTimeout(r, 500));\n      return poll(resp.updates, checkCanContinue);\n  }\n}\n\nconst getExecHttpPost = execLocal => async _ref => {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const resp = await fetchService(service, {\n    data: {\n      fclVersion: VERSION,\n      service: {\n        params: service.params,\n        data: service.data,\n        type: service.type\n      },\n      config,\n      ...body\n    }\n  }).then(normalizePollingResponse);\n  if (resp.status === \"APPROVED\") {\n    return resp.data;\n  } else if (resp.status === \"DECLINED\") {\n    throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n  } else if (resp.status === \"REDIRECT\") {\n    return resp;\n  } else if (resp.status === \"PENDING\") {\n    // these two flags are required to run polling one more time before it stops\n    var canContinue = true;\n    var shouldContinue = true;\n    const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {\n      serviceEndpoint,\n      onClose: () => shouldContinue = false\n    });\n    const close = () => {\n      try {\n        unmount();\n        shouldContinue = false;\n      } catch (error) {\n        console.error(\"Frame Close Error\", error);\n      }\n    };\n    /**\n     * this function is run once per poll call.\n     * Offsetting canContinue flag to make sure that\n     * the polling is performed one extra time after canContinue flag is set to false\n     * to prevent halting on Android when a browser calls window.close\n     * before FCL receives a successful result from polling\n     *\n     * @returns {boolean} \n     */\n    const checkCanContinue = () => {\n      const offsetCanContinue = canContinue;\n      canContinue = shouldContinue;\n      return offsetCanContinue;\n    };\n    return poll(resp.updates, checkCanContinue).then(serviceResponse => {\n      close();\n      return serviceResponse;\n    }).catch(error => {\n      console.error(error);\n      close();\n      throw error;\n    });\n  } else {\n    console.error(`Auto Decline: Invalid Response`, {\n      service,\n      resp\n    });\n    throw new Error(`Auto Decline: Invalid Response`);\n  }\n};\n\nconst CLOSE_EVENT = \"FCL:VIEW:CLOSE\";\nconst READY_EVENT = \"FCL:VIEW:READY\";\nconst RESPONSE_EVENT = \"FCL:VIEW:RESPONSE\";\nconst _ = e => typeof e === \"string\" && e.toLowerCase();\nconst IGNORE = new Set([\"monetizationstart\", \"monetizationpending\", \"monetizationprogress\", \"monetizationstop\"]);\nconst deprecate = (was, want) => console.warn(\"DEPRECATION NOTICE\", `Received ${was}, please use ${want} for this and future versions of FCL`);\nconst buildMessageHandler = _ref => {\n  let {\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  } = _ref;\n  return e => {\n    try {\n      if (typeof e.data !== \"object\") return;\n      if (IGNORE.has(e.data.type)) return;\n      if (_(e.data.type) === _(CLOSE_EVENT)) close();\n      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {\n        send,\n        close\n      });\n      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {\n        send,\n        close\n      });\n      onMessage(e, {\n        send,\n        close\n      });\n\n      // Backwards Compatible\n      if (_(e.data.type) === _(\"FCL:FRAME:READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:CLOSE\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      //\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::AUTHZ_READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      if (_(e.data.type) === _(\"FCL::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n    } catch (error) {\n      console.error(\"Frame Callback Error\", error);\n      close();\n    }\n  };\n};\n\nconst noop$3 = () => {};\nfunction frame(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$3,\n    close: noop$3\n  };\n  const onClose = opts.onClose || noop$3;\n  const onMessage = opts.onMessage || noop$3;\n  const onReady = opts.onReady || noop$3;\n  const onResponse = opts.onResponse || noop$3;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$frame, unmount] = renderFrame(serviceEndpoint(service));\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Frame Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Frame Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execIframeRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;\n    frame(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            fclVersion: VERSION,\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params],\n              deprecated: {\n                message: \"jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n              }\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$2 = () => {};\nfunction pop(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$2,\n    close: noop$2\n  };\n  const onClose = opts.onClose || noop$2;\n  const onMessage = opts.onMessage || noop$2;\n  const onReady = opts.onReady || noop$2;\n  const onResponse = opts.onResponse || noop$2;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$pop, unmount] = renderPop(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($pop && $pop.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Popup Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Popup Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execPopRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    pop(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$1 = () => {};\nfunction tab(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$1,\n    close: noop$1\n  };\n  const onClose = opts.onClose || noop$1;\n  const onMessage = opts.onMessage || noop$1;\n  const onReady = opts.onReady || noop$1;\n  const onResponse = opts.onResponse || noop$1;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$tab, unmount] = renderTab(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($tab && $tab.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Tab Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Tab Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execTabRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    tab(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop = () => {};\nfunction extension(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop,\n    close: noop\n  };\n  const onClose = opts.onClose || noop;\n  const onMessage = opts.onMessage || noop;\n  const onReady = opts.onReady || noop;\n  const onResponse = opts.onResponse || noop;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  send({\n    service\n  });\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      onClose();\n    } catch (error) {\n      console.error(\"Ext Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Ext Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execExtRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    extension(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execExtRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst NOT_IMPLEMENTED = () => {\n  throw new Error(\"Strategy util has not been implemented on this platform\");\n};\nconst VIEWS = {\n  \"VIEW/IFRAME\": renderFrame,\n  \"VIEW/POP\": renderPop,\n  \"VIEW/TAB\": renderTab,\n  \"VIEW/MOBILE_BROWSER\": NOT_IMPLEMENTED,\n  \"VIEW/DEEPLINK\": NOT_IMPLEMENTED\n};\nasync function execLocal(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    serviceEndpoint: () => {}\n  };\n  const {\n    serviceEndpoint\n  } = opts;\n  try {\n    return VIEWS[service.method](serviceEndpoint(service), opts);\n  } catch (error) {\n    console.error(\"execLocal({service, opts = {}})\", error, {\n      service,\n      opts\n    });\n    throw error;\n  }\n}\n\nconst coreStrategies = {\n  [CORE_STRATEGIES[\"HTTP/RPC\"]]: getExecHttpPost(execLocal),\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: getExecHttpPost(execLocal),\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: execIframeRPC,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: execPopRPC,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: execTabRPC,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: execExtRPC\n};\n\nconst mutate = getMutate({\n  platform: \"web\"\n});\nconst currentUser = getCurrentUser({\n  platform: \"web\"\n});\nconst authenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst unauthenticate = () => currentUser().unauthenticate();\nconst reauthenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  currentUser().unauthenticate();\n  return currentUser().authenticate(opts);\n};\nconst signUp = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst logIn = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst authz = currentUser().authorization;\n(0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)(getDefaultConfig());\ninitServiceRegistry({\n  coreStrategies\n});\n\n\n//# sourceMappingURL=fcl.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9mY2wvZGlzdC9mY2wubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQzhOO0FBQzJPO0FBQ3ZjO0FBQ2M7QUFDVjtBQUNEO0FBQ0E7QUFDc0I7QUFDUztBQUNyQjtBQUNmO0FBQ1U7QUFDa0g7QUFDL0g7QUFDNkM7QUFDdEM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw0Q0FBTyxFQUFFLDBDQUFHO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsaUVBQVMseUNBQXlDLEtBQUs7QUFDekQ7QUFDQTtBQUNBLGdCQUFnQixrREFBYztBQUM5QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsaUVBQVMseUNBQXlDLEtBQUs7QUFDekQsRUFBRSxpRUFBUyxzQ0FBc0MsS0FBSztBQUN0RCw0Q0FBNEMsc0RBQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLGlFQUFTO0FBQ1g7QUFDQSxFQUFFLGlFQUFTO0FBQ1g7QUFDQSxFQUFFLGlFQUFTLDRDQUE0QyxTQUFTO0FBQ2hFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRSxzREFBVyxpREFBaUQsU0FBUztBQUN2RSxF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O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZUFBZSxzREFBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsc0RBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsc0RBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSiw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQzs7QUFFd1M7QUFDelMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvZmNsL2Rpc3QvZmNsLm1vZHVsZS5qcz82ODM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNkayBmcm9tICdAb25mbG93L3Nkayc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgYXMgaW52YXJpYW50JDEsIGVuY29kZU1lc3NhZ2VGcm9tU2lnbmFibGUsIGNvbmZpZyBhcyBjb25maWckMSwgcmVzb2x2ZSwgcGlwZSwgaW50ZXJhY3Rpb24sIGNyZWF0ZVNpZ25hYmxlVm91Y2hlciwgc2VuZCwgZ2V0VHJhbnNhY3Rpb25TdGF0dXMsIGRlY29kZSwgYmxvY2ssIGdldEV2ZW50c0F0QmxvY2tIZWlnaHRSYW5nZSwgZ2V0QWNjb3VudCwgYXRCbG9ja0hlaWdodCwgYXJnIH0gZnJvbSAnQG9uZmxvdy9zZGsnO1xuZXhwb3J0IHsgVGVzdFV0aWxzLCBhY2NvdW50LCBhcmcsIGFyZ3MsIGF0QmxvY2tIZWlnaHQsIGF0QmxvY2tJZCwgYXV0aG9yaXphdGlvbiwgYXV0aG9yaXphdGlvbnMsIGJsb2NrLCBidWlsZCwgY3JlYXRlU2lnbmFibGVWb3VjaGVyLCBkZWNvZGUsIGdldEFjY291bnQsIGdldEJsb2NrLCBnZXRCbG9ja0hlYWRlciwgZ2V0Q29sbGVjdGlvbiwgZ2V0RXZlbnRzLCBnZXRFdmVudHNBdEJsb2NrSGVpZ2h0UmFuZ2UsIGdldEV2ZW50c0F0QmxvY2tJZHMsIGdldE5ldHdvcmtQYXJhbWV0ZXJzLCBnZXRUcmFuc2FjdGlvbiwgZ2V0VHJhbnNhY3Rpb25TdGF0dXMsIGludmFyaWFudCwgaXNCYWQsIGlzT2ssIGxpbWl0LCBwYXJhbSwgcGFyYW1zLCBwYXllciwgcGluZywgcGlwZSwgcHJvcG9zZXIsIHJlZiwgc2NyaXB0LCBzZW5kLCB0cmFuc2FjdGlvbiwgdmFsaWRhdG9yLCB2b3VjaGVySW50ZXJjZXB0LCB2b3VjaGVyVG9UeElkLCB3aHkgfSBmcm9tICdAb25mbG93L3Nkayc7XG5pbXBvcnQgKiBhcyB0JDEgZnJvbSAnQG9uZmxvdy90eXBlcyc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdAb25mbG93L3V0aWwtaW52YXJpYW50JztcbmltcG9ydCBmZXRjaFRyYW5zcG9ydCBmcm9tICdjcm9zcy1mZXRjaCc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAb25mbG93L2NvbmZpZyc7XG5leHBvcnQgeyBjb25maWcgfSBmcm9tICdAb25mbG93L2NvbmZpZyc7XG5pbXBvcnQgeyB3aXRoUHJlZml4LCBzYW5zUHJlZml4IH0gZnJvbSAnQG9uZmxvdy91dGlsLWFkZHJlc3MnO1xuZXhwb3J0IHsgZGlzcGxheSwgc2Fuc1ByZWZpeCwgd2l0aFByZWZpeCB9IGZyb20gJ0BvbmZsb3cvdXRpbC1hZGRyZXNzJztcbmltcG9ydCB7IGxvZywgTEVWRUxTIH0gZnJvbSAnQG9uZmxvdy91dGlsLWxvZ2dlcic7XG5pbXBvcnQgKiBhcyBybHAgZnJvbSAnQG9uZmxvdy9ybHAnO1xuaW1wb3J0IHsgQnVmZmVyLCBlbmNvZGUgfSBmcm9tICdAb25mbG93L3JscCc7XG5pbXBvcnQgeyBzbmFwc2hvdGVyLCBzdWJzY3JpYmVyLCBzcGF3biwgSU5JVCwgU1VCU0NSSUJFLCBVUERBVEVEIGFzIFVQREFURUQkMiwgVU5TVUJTQ1JJQkUsIFNOQVBTSE9UIGFzIFNOQVBTSE9UJDEsIHNlbmQgYXMgc2VuZCQxIH0gZnJvbSAnQG9uZmxvdy91dGlsLWFjdG9yJztcbmltcG9ydCByZXF1aXJlJCQwIGZyb20gJ2J1ZmZlcic7XG5leHBvcnQgeyB0ZW1wbGF0ZSBhcyBjYWRlbmNlLCB0ZW1wbGF0ZSBhcyBjZGMgfSBmcm9tICdAb25mbG93L3V0aWwtdGVtcGxhdGUnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnQG9uZmxvdy91dGlsLXVpZCc7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjEuNi4wXCIgO1xuXG5jb25zdCBpcyA9IHR5cGUgPT4gZCA9PiB0eXBlb2YgZCA9PT0gdHlwZTtcbmNvbnN0IGlzUmVxdWlyZWQgPSBkID0+IGQgIT0gbnVsbDtcbmNvbnN0IGlzT2JqZWN0ID0gaXMoXCJvYmplY3RcIik7XG5jb25zdCBpc1N0cmluZyA9IGlzKFwic3RyaW5nXCIpO1xuY29uc3QgaXNGdW5jID0gaXMoXCJmdW5jdGlvblwiKTtcbmNvbnN0IGlzTnVtYmVyID0gaXMoXCJudW1iZXJcIik7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3MoYXgpIHtcbiAgaWYgKGlzRnVuYyhheCkpIHJldHVybiBheChzZGsuYXJnLCB0JDEpO1xuICByZXR1cm4gW107XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGh0dHBEb2N1bWVudFJlc29sdmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB1cmxcbiAgfSA9IF9yZWY7XG4gIGludmFyaWFudCh0eXBlb2YgdXJsICE9PSBcInVuZGVmaW5lZFwiLCBcInJldHJpZXZlKHsgdXJsIH0pIC0tIHVybCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGxldCByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXdhaXQgZmV0Y2hUcmFuc3BvcnQodXJsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImh0dHBEb2N1bWVudFJlc29sdmVyIEVycm9yOiBGYWlsZWQgdG8gcmV0cmlldmUgZG9jdW1lbnQuXCIpO1xuICB9XG4gIGxldCBkb2N1bWVudCA9IHJlcy5vayA/IGF3YWl0IHJlcy5qc29uKCkgOiBudWxsO1xuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5jb25zdCBET0NVTUVOVF9SRVNPTFZFUlMgPSBuZXcgTWFwKFtbXCJodHRwXCIsIGh0dHBEb2N1bWVudFJlc29sdmVyXSwgW1wiaHR0cHNcIiwgaHR0cERvY3VtZW50UmVzb2x2ZXJdXSk7XG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZShfcmVmMikge1xuICBsZXQge1xuICAgIHVybFxuICB9ID0gX3JlZjI7XG4gIGludmFyaWFudCh0eXBlb2YgdXJsICE9PSBcInVuZGVmaW5lZFwiLCBcInJldHJpZXZlKHsgdXJsIH0pIC0tIHVybCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiLCBcInJldHJpZXZlKHsgdXJsIH0pIC0tIHVybCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBjb25zdCBkb2N1bWVudFJlc29sdmVyc0Zyb21Db25maWcgPSBhd2FpdCBjb25maWcoKS53aGVyZSgvXmRvY3VtZW50XFwucmVzb2x2ZXJcXC4vKTtcbiAgT2JqZWN0LmtleXMoZG9jdW1lbnRSZXNvbHZlcnNGcm9tQ29uZmlnKS5tYXAoa2V5ID0+IHtcbiAgICBjb25zdCByZXNvbHZlckZyb21Db25maWcgPSBkb2N1bWVudFJlc29sdmVyc0Zyb21Db25maWdba2V5XTtcbiAgICBjb25zdCByZXNvbHZlclByb3RvY29sID0ga2V5LnJlcGxhY2UoL15kb2N1bWVudFxcLnJlc29sdmVyXFwuLywgXCJcIik7XG4gICAgRE9DVU1FTlRfUkVTT0xWRVJTLnNldChyZXNvbHZlclByb3RvY29sLCByZXNvbHZlckZyb21Db25maWcpO1xuICB9KTtcbiAgY29uc3QgdXJsUGFydHMgPSAvXiguKik6XFwvXFwvKFtBLVphLXowLTlcXC1cXC5dKykoOlswLTldKyk/KC4qKSQvLmV4ZWModXJsKTtcbiAgaW52YXJpYW50KHVybFBhcnRzLCBcIkZhaWxlZCB0byBwYXJzZSBVUkxcIik7XG4gIGNvbnN0IHByb3RvY29sID0gdXJsUGFydHNbMV07XG4gIGludmFyaWFudCh1cmxQYXJ0cywgXCJGYWlsZWQgdG8gcGFyc2UgVVJMIHByb3RvY29sXCIpO1xuICBjb25zdCByZXNvbHZlciA9IERPQ1VNRU5UX1JFU09MVkVSUy5nZXQocHJvdG9jb2wpO1xuICBpbnZhcmlhbnQocmVzb2x2ZXIsIGBObyByZXNvbHZlciBmb3VuZCBmb3IgcHJvdGNvbD0ke3Byb3RvY29sfWApO1xuICBsZXQgZG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlcih7XG4gICAgdXJsXG4gIH0pO1xuICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgaWYgKHRlbXBsYXRlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHRlbXBsYXRlW1wiZl92ZXJzaW9uXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUgRXJyb3I6IEludmFsaWQgSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGaWxscyBpbXBvcnQgYWRkcmVzc2VzIGluIENhZGVuY2UgZm9yIG5ldHdvcmtcbiAqIFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uZXR3b3JrIC0gTmV0d29yayB0byBkZXJpdmUgQ2FkZW5jZSBmb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGVtcGxhdGUgLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSB0byBkZXJpdmUgQ2FkZW5jZSBmcm9tXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIENhZGVuY2VcbiAqL1xuZnVuY3Rpb24gZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayhfcmVmKSB7XG4gIGxldCB7XG4gICAgbmV0d29yayxcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjtcbiAgaW52YXJpYW50JDEobmV0d29yayAhPSB1bmRlZmluZWQsIFwiZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayh7IG5ldHdvcmsgfSkgLS0gbmV0d29yayBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBuZXR3b3JrID09PSBcInN0cmluZ1wiLCBcImRlcml2ZUNhZGVuY2VCeU5ldHdvcmsoeyBuZXR3b3JrIH0pIC0tIG5ldHdvcmsgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlID09PSBcIm9iamVjdFwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZS5mX3R5cGUgPT09IFwiSW50ZXJhY3Rpb25UZW1wbGF0ZVwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUgPSBub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgc3dpdGNoICh0ZW1wbGF0ZS5mX3ZlcnNpb24pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIGxldCBuZXR3b3JrRGVwZW5kZW5jaWVzID0gT2JqZWN0LmtleXModGVtcGxhdGU/LmRhdGE/LmRlcGVuZGVuY2llcykubWFwKGRlcGVuZGVuY3lQbGFjZWhvbGRlciA9PiB7XG4gICAgICAgIGxldCBkZXBlbmRlbmN5TmV0d29ya0NvbnRyYWN0cyA9IE9iamVjdC52YWx1ZXModGVtcGxhdGU/LmRhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lQbGFjZWhvbGRlcl0pO1xuICAgICAgICBpbnZhcmlhbnQkMShkZXBlbmRlbmN5TmV0d29ya0NvbnRyYWN0cywgYGRlcml2ZUNhZGVuY2VCeU5ldHdvcmsgLS0gQ291bGQgbm90IGZpbmQgY29udHJhY3RzIGZvciBkZXBlbmRlbmN5IHBsYWNlaG9sZGVyOiAke2RlcGVuZGVuY3lQbGFjZWhvbGRlcn1gKTtcbiAgICAgICAgaW52YXJpYW50JDEoZGVwZW5kZW5jeU5ldHdvcmtDb250cmFjdHMubGVuZ3RoID09PSAwLCBgZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayAtLSBDb3VsZCBub3QgZmluZCBjb250cmFjdHMgZm9yIGRlcGVuZGVuY3kgcGxhY2Vob2xkZXI6ICR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyfWApO1xuICAgICAgICBsZXQgZGVwZW5kZW5jeUNvbnRyYWN0ID0gZGVwZW5kZW5jeU5ldHdvcmtDb250cmFjdHNbMF07XG4gICAgICAgIGxldCBkZXBlbmRlbmN5Q29udHJhY3RGb3JOZXR3b3JrID0gZGVwZW5kZW5jeUNvbnRyYWN0Py5bbmV0d29ya107XG4gICAgICAgIGludmFyaWFudCQxKGRlcGVuZGVuY3lDb250cmFjdEZvck5ldHdvcmssIGBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrIC0tIENvdWxkIG5vdCBmaW5kICR7bmV0d29ya30gbmV0d29yayBpbmZvcm1hdGlvbiBmb3IgZGVwZW5kZW5jeTogJHtkZXBlbmRlbmN5UGxhY2Vob2xkZXJ9YCk7XG4gICAgICAgIHJldHVybiBbZGVwZW5kZW5jeVBsYWNlaG9sZGVyLCBkZXBlbmRlbmN5Q29udHJhY3RGb3JOZXR3b3JrLmFkZHJlc3NdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV0d29ya0RlcGVuZGVuY2llcy5yZWR1Y2UoKGNhZGVuY2UsIF9yZWYyKSA9PiB7XG4gICAgICAgIGxldCBbcGxhY2Vob2xkZXIsIGFkZHJlc3NdID0gX3JlZjI7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcIihcXFxcYlwiICsgcGxhY2Vob2xkZXIgKyBcIlxcXFxiKVwiLCBcImdcIik7XG4gICAgICAgIHJldHVybiBjYWRlbmNlLnJlcGxhY2UocmVnZXgsIGFkZHJlc3MpO1xuICAgICAgfSwgdGVtcGxhdGUuZGF0YS5jYWRlbmNlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayBFcnJvcjogVW5zdXBwb3J0ZWQgdGVtcGxhdGUgdmVyc2lvblwiKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaENoYWluSWQoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZGsuc2VuZChbc2RrLmdldE5ldHdvcmtQYXJhbWV0ZXJzKCldLCBvcHRzKS50aGVuKHNkay5kZWNvZGUpO1xuICByZXR1cm4gcmVzcG9uc2UuY2hhaW5JZDtcbn1cblxuLy8gQ2FjaGUgb2YgY2hhaW5JZCBwcm9taXNlcyBmb3IgZWFjaCBhY2Nlc3Mgbm9kZSB2YWx1ZVxuLy8ga2V5OiBhY2Nlc3Mgbm9kZSwgdmFsdWU6IGNoYWluSWQgcHJvbWlzZVxubGV0IGNoYWluSWRDYWNoZSA9IHt9O1xubGV0IGhhc1dhcm5lZEVudiA9IGZhbHNlO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0cyB0aGUgY2hhaW4gSUQgaWYgaXRzIHNldCwgb3RoZXJ3aXNlIGdldHMgdGhlIGNoYWluIElEIGZyb20gdGhlIGFjY2VzcyBub2RlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgY2hhaW4gSUQgb2YgdGhlIGFjY2VzcyBub2RlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNoYWluIElEIGlzIG5vdCBmb3VuZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zIFwidGVzdG5ldFwiXG4gKiBnZXRDaGFpbklkKClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q2hhaW5JZCgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgZmxvd05ldHdvcmtDZmcgPSBhd2FpdCBjb25maWcuZ2V0KFwiZmxvdy5uZXR3b3JrXCIpO1xuICBsZXQgZW52Q2ZnID0gYXdhaXQgY29uZmlnLmdldChcImVudlwiKTtcbiAgaWYgKGVudkNmZyAmJiAhaGFzV2FybmVkRW52KSB7XG4gICAgbG9nLmRlcHJlY2F0ZSh7XG4gICAgICBwa2c6IFwiRkNMXCIsXG4gICAgICBzdWJqZWN0OiAnVXNpbmcgdGhlIFwiZW52XCIgY29uZmlndXJhdGlvbiBrZXkgZm9yIHNwZWNpZnlpbmcgdGhlIGZsb3cgbmV0d29yaycsXG4gICAgICBtZXNzYWdlOiBcIkNvbmZpZ3VyaW5nIHRvIHNwZWNpZnkgZmxvdyBuZXR3b3JrIGlzIG5vIGxvbmdlciByZXF1aXJlZFwiLFxuICAgICAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZjbC9UUkFOU0lUSU9OUy5tZCMwMDAxLWRlcHJlY2F0ZS1lbnYtY29uZmlnLWtleVwiXG4gICAgfSk7XG4gICAgaGFzV2FybmVkRW52ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBhY2Nlc3NOb2RlID0gb3B0cy5ub2RlIHx8IChhd2FpdCBjb25maWcuZ2V0KFwiYWNjZXNzTm9kZS5hcGlcIikpO1xuICBpZiAoIWFjY2Vzc05vZGUpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gZGVwcmVjYXRlZCBmbG93Lm5ldHdvcmsgYW5kIGVudiBjb25maWcga2V5c1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkIGhhdmUgYmVlbiBkb25lIGJlZm9yZSB0cnlpbmcgdG8gZmV0Y2ggdGhlIGNoYWluSWQgZnJvbSB0aGUgYWNjZXNzIG5vZGVcbiAgICAvLyBIb3dldmVyLCB0aGlzIHdhcyB0aGUgYmVoYXZpb3VyIHdpdGggdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24gb2YgZ2V0Q2hhaW5JZCgpXG4gICAgaWYgKGZsb3dOZXR3b3JrQ2ZnKSB7XG4gICAgICByZXR1cm4gZmxvd05ldHdvcmtDZmc7XG4gICAgfSBlbHNlIGlmIChlbnZDZmcpIHtcbiAgICAgIHJldHVybiBlbnZDZmc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgRWl0aGVyIHRoZSBcImFjY2Vzc05vZGUuYXBpXCIgY29uZmlnIGtleSBvciBvcHRzLm5vZGUgbXVzdCBiZSBzZXRgKTtcbiAgfVxuXG4gIC8vIFRyeSB1c2luZyBjYWNoZWQgY2hhaW5JZCBmaXJzdCBpZiBpdCBleGlzdHMgYW5kIGFjY2VzcyBub2RlIGlzIHRoZSBzYW1lXG4gIGlmIChjaGFpbklkQ2FjaGVbYWNjZXNzTm9kZV0pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGNoYWluSWRDYWNoZVthY2Nlc3NOb2RlXTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cblxuICAvLyBJZiBubyBjYWNoZWQgY2hhaW5JZCwgdmFsdWUgaXMgc3RhbGUsIG9yIGxhc3QgYXR0ZW1wdCBmYWlsZWQsIHRyeSBnZXR0aW5nIGNoYWluSWQgZnJvbSBhY2Nlc3Mgbm9kZVxuICAvLyBDaGVjayBpZiBhbm90aGVyIGdldENoYWluSWQoKSBjYWxsIGhhcyBhbHJlYWR5IHN0YXJ0ZWQgYSBuZXcgcHJvbWlzZSwgaWYgbm90LCBzdGFydCBhIG5ldyBvbmVcbiAgLy8gVGhlcmUgbWF5IGhhdmUgYmVlbiBjb25jdXJyZW50IGNhbGxzIHRvIGdldENoYWluSWQoKSB3aGlsZSB0aGUgZmlyc3QgY2FsbCB3YXMgd2FpdGluZyBmb3IgdGhlIHJlc3BvbnNlXG4gIGlmICghY2hhaW5JZENhY2hlW2FjY2Vzc05vZGVdKSB7XG4gICAgY2hhaW5JZENhY2hlW2FjY2Vzc05vZGVdID0gZmV0Y2hDaGFpbklkKG9wdHMpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgcmVzZXQgdGhlIHByb21pc2Ugc28gdGhhdCB0aGUgbmV4dCBjYWxsIHdpbGwgdHJ5IGFnYWluXG4gICAgICBjaGFpbklkQ2FjaGVbYWNjZXNzTm9kZV0gPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICAvLyBVc2UgbmV3bHkgY3JlYXRlZCBwcm9taXNlXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGNoYWluSWRDYWNoZVthY2Nlc3NOb2RlXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZhbGwgYmFjayB0byBkZXByZWNhdGVkIGZsb3cubmV0d29yayBhbmQgZW52IGNvbmZpZyBrZXlzXG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGQgaGF2ZSBiZWVuIGRvbmUgYmVmb3JlIHRyeWluZyB0byBmZXRjaCB0aGUgY2hhaW5JZCBmcm9tIHRoZSBhY2Nlc3Mgbm9kZVxuICAgIC8vIEhvd2V2ZXIsIHRoaXMgd2FzIHRoZSBiZWhhdmlvdXIgd2l0aCB0aGUgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBnZXRDaGFpbklkKClcbiAgICBpZiAoZmxvd05ldHdvcmtDZmcpIHtcbiAgICAgIHJldHVybiBmbG93TmV0d29ya0NmZztcbiAgICB9IGVsc2UgaWYgKGVudkNmZykge1xuICAgICAgcmV0dXJuIGVudkNmZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGNoYWluSWQgZnJvbSBhY2Nlc3Mgbm9kZSAtIGFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgYWNjZXNzIG5vZGUgZW5kcG9pbnQuICBJZiBydW5uaW5nIGxvY2FsbHksIGlzIHlvdXIgZW11bGF0b3IgdXAtdG8tZGF0ZT8gJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdhdGNoZXMgdGhlIGNvbmZpZyBmb3IgY2hhbmdlcyB0byBhY2Nlc3Mgbm9kZSBhbmQgdXBkYXRlcyB0aGUgY2hhaW4gaWQgYWNjb3JkaW5nbHlcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB1bnN1YnNjcmliZXMgdGhlIGxpc3RlbmVyXG4gKlxuICovXG5mdW5jdGlvbiB3YXRjaEZvckNoYWluSWRDaGFuZ2VzKCkge1xuICByZXR1cm4gY29uZmlnLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgLy8gQ2FsbCBnZXRDaGFpbklkIHRvIHVwZGF0ZSB0aGUgY2hhaW5JZCBjYWNoZSBpZiBhY2Nlc3Mgbm9kZSBoYXMgY2hhbmdlZFxuICAgIGdldENoYWluSWQoe1xuICAgICAgZW5hYmxlUmVxdWVzdExvZ2dpbmc6IGZhbHNlXG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiBpc1NtYWxsSU9TKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvaVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiBpc0xhcmdlSU9TKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvaVBhZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzSU9TKCkge1xuICByZXR1cm4gaXNTbWFsbElPUygpIHx8IGlzTGFyZ2VJT1MoKTtcbn1cbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICByZXR1cm4gaXNBbmRyb2lkKCkgfHwgaXNJT1MoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVyaXZlRGVwZW5kZW5jaWVzKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbnN0IHRlbXBsYXRlID0gb3B0cy50ZW1wbGF0ZTtcbiAgY29uc3QgbmV0d29yayA9IGF3YWl0IGdldENoYWluSWQob3B0cyk7XG4gIGNvbnN0IGRlcml2ZWREZXBlbmRlbmNpZXMgPSB7fTtcbiAgc3dpdGNoICh0ZW1wbGF0ZVtcImZfdmVyc2lvblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgY29uc3QgZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5cyA9IE9iamVjdC5rZXlzKHRlbXBsYXRlPy5kYXRhPy5kZXBlbmRlbmNpZXMpO1xuICAgICAgZm9yIChsZXQgZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5IG9mIGRlcGVuZGVuY3lQbGFjZWhvbGRlcktleXMpIHtcbiAgICAgICAgbGV0IGRlcGVuZGVuY3lQbGFjZWhvbGRlciA9IHRlbXBsYXRlPy5kYXRhPy5kZXBlbmRlbmNpZXNbZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5XTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3RzS2V5cyA9IE9iamVjdC5rZXlzKGRlcGVuZGVuY3lQbGFjZWhvbGRlcik7XG4gICAgICAgIGludmFyaWFudChkZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdHNLZXlzLmxlbmd0aCA+IDAsIGBGQ0wgY29uZmlndXJlRGVwZW5kZW5jaWVzIEVycm9yOiBObyBjb250cmFjdHMgZm91bmQgaW4gdGVtcGxhdGUgZm9yIHBsYWNlaG9sZGVyPSR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5fWApO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdCA9IGRlcGVuZGVuY3lQbGFjZWhvbGRlcltkZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdHNLZXlzWzBdXTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0W25ldHdvcmtdO1xuICAgICAgICBpbnZhcmlhbnQoZGVwZW5kZW5jeSwgYEZDTCBjb25maWd1cmVEZXBlbmRlbmNpZXMgRXJyb3I6IE5vIGRlcGVuZGVuY3kgaW5mb3JtYXRpb24gZm9yIHBsYWNlaG9sZGVyPSR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5fSBjb250cmFjdD0ke2RlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0c0tleXNbMF19IG5ldHdvcms9JHtuZXR3b3JrfWApO1xuICAgICAgICBpbnZhcmlhbnQoZGVwZW5kZW5jeT8uYWRkcmVzcywgYEZDTCBjb25maWd1cmVEZXBlbmRlbmNpZXMgRXJyb3I6IE5vIGFkZHJlc3MgaW5mb3JtYXRpb24gZm9yIHBsYWNlaG9sZGVyPSR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5fSBjb250cmFjdD0ke2RlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0c0tleXNbMF19IG5ldHdvcms9JHtuZXR3b3JrfWApO1xuICAgICAgICBkZXJpdmVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lQbGFjZWhvbGRlcktleV0gPSB3aXRoUHJlZml4KGRlcGVuZGVuY3k/LmFkZHJlc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcml2ZWREZXBlbmRlbmNpZXM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZDTCBjb25maWd1cmVEZXBlbmRlbmNpZXMgRXJyb3I6IFVuc3VwcG9ydGVkIHRlbXBsYXRlIHZlcnNpb25cIik7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcFRlbXBsYXRlT3B0cyhvcHRzKSB7XG4gIGlmIChpc1N0cmluZyhvcHRzPy50ZW1wbGF0ZSkpIHtcbiAgICBvcHRzLnRlbXBsYXRlID0gYXdhaXQgcmV0cmlldmUoe1xuICAgICAgdXJsOiBvcHRzPy50ZW1wbGF0ZVxuICAgIH0pO1xuICB9XG4gIGxldCBkZXBlbmRlbmNpZXMgPSB7fTtcbiAgaWYgKG9wdHM/LnRlbXBsYXRlKSB7XG4gICAgb3B0cy50ZW1wbGF0ZSA9IG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUob3B0cz8udGVtcGxhdGUpO1xuICAgIGRlcGVuZGVuY2llcyA9IGF3YWl0IGRlcml2ZURlcGVuZGVuY2llcyh7XG4gICAgICB0ZW1wbGF0ZTogb3B0cy50ZW1wbGF0ZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNhZGVuY2UgPSBvcHRzLmNhZGVuY2UgfHwgZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayh7XG4gICAgdGVtcGxhdGU6IG9wdHMudGVtcGxhdGUsXG4gICAgbmV0d29yazogYXdhaXQgZ2V0Q2hhaW5JZChvcHRzKVxuICB9KTtcbiAgb3B0cy5jYWRlbmNlID0gY2FkZW5jZTtcbiAgb3B0cy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gIHJldHVybiBvcHRzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmUodHlwZSwgb3B0cykge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50KGlzUmVxdWlyZWQob3B0cyksIGAke3R5cGV9KG9wdHMpIC0tIG9wdHMgaXMgcmVxdWlyZWRgKTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGludmFyaWFudChpc09iamVjdChvcHRzKSwgYCR7dHlwZX0ob3B0cykgLS0gb3B0cyBtdXN0IGJlIGFuIG9iamVjdGApO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50KCEob3B0cy5jYWRlbmNlICYmIG9wdHMudGVtcGxhdGUpLCBgJHt0eXBlfSh7IHRlbXBsYXRlLCBjYWRlbmNlIH0pIC0tIGNhbm5vdCBwYXNzIGJvdGggY2FkZW5jZSBhbmQgdGVtcGxhdGVgKTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGludmFyaWFudChpc1JlcXVpcmVkKG9wdHMuY2FkZW5jZSB8fCBvcHRzPy50ZW1wbGF0ZSksIGAke3R5cGV9KHsgY2FkZW5jZSB9KSAtLSBjYWRlbmNlIGlzIHJlcXVpcmVkYCk7XG4gIC8vIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQoaXNTdHJpbmcob3B0cy5jYWRlbmNlKSB8fCBvcHRzPy50ZW1wbGF0ZSwgYCR7dHlwZX0oeyBjYWRlbmNlIH0pIC0tIGNhZGVuY2UgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50KGF3YWl0IHNkay5jb25maWcoKS5nZXQoXCJhY2Nlc3NOb2RlLmFwaVwiKSwgYCR7dHlwZX0ob3B0cykgLS0gUmVxdWlyZWQgdmFsdWUgZm9yIFwiYWNjZXNzTm9kZS5hcGlcIiBub3QgZGVmaW5lZCBpbiBjb25maWcuIFNlZTogJHtcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmNsL3NyYy9leGVjL3F1ZXJ5Lm1kI2NvbmZpZ3VyYXRpb25cIn1gKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZU11dGF0ZShvcHRzKSB7XG4gIHJldHVybiBwcmUoXCJtdXRhdGVcIiwgb3B0cyk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVRdWVyeShvcHRzKSB7XG4gIHJldHVybiBwcmUoXCJxdWVyeVwiLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFsbG93cyB5b3UgdG8gc3VibWl0IHNjcmlwdHMgdG8gcXVlcnkgdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gUXVlcnkgT3B0aW9ucyBhbmQgY29uZmlndXJhdGlvblxuICogIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmNhZGVuY2UgLSBDYWRlbmNlIFNjcmlwdCB1c2VkIHRvIHF1ZXJ5IEZsb3dcbiAqICBAcGFyYW0ge2ltcG9ydChcIi4uL2ZjbFwiKS5BcmdzRm59IFtvcHRzLmFyZ3NdIC0gQXJndW1lbnRzIHBhc3NlZCB0byBjYWRlbmNlIHNjcmlwdFxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0cy50ZW1wbGF0ZV0gLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBmb3IgYSBzY3JpcHRcbiAqICBAcGFyYW0ge251bWJlcn0gW29wdHMubGltaXRdICAgLSBDb21wdXRlIExpbWl0IGZvciBRdWVyeVxuICogIEByZXR1cm5zIHtQcm9taXNlfVxuICpcbiAqICBAZXhhbXBsZVxuICogICAgY29uc3QgY2FkZW5jZSA9IGBcbiAqICAgICAgY2FkZW5jZTogYFxuICogICAgICAgIHB1YiBmdW4gbWFpbihhOiBJbnQsIGI6IEludCwgYzogQWRkcmVzcyk6IEludCB7XG4gKiAgICAgICAgICBsb2coYylcbiAqICAgICAgICAgIHJldHVybiBhICsgYlxuICogICAgICAgIH1cbiAqICAgIGAudHJpbSgpXG4gKlxuICogICAgY29uc3QgYXJncyA9IChhcmcsIHQpID0+IFtcbiAqICAgICAgYXJnKDUsIHQuSW50KSxcbiAqICAgICAgYXJnKDcsIHQuSW50KSxcbiAqICAgICAgYXJnKFwiMHhiMmRiNDNhZDZiYzM0NWZlYzlcIiwgdC5BZGRyZXNzKSxcbiAqICAgIF1cbiAqXG4gKiAgICBhd2FpdCBxdWVyeSh7IGNhZGVuY2UsIGFyZ3MgfSlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcXVlcnkoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgYXdhaXQgcHJlUXVlcnkob3B0cyk7XG4gIG9wdHMgPSBhd2FpdCBwcmVwVGVtcGxhdGVPcHRzKG9wdHMpO1xuICByZXR1cm4gc2RrLmNvbmZpZygpLm92ZXJsb2FkKG9wdHMuZGVwZW5kZW5jaWVzIHx8IHt9LCBhc3luYyAoKSA9PlxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc2RrLnNlbmQoW3Nkay5zY3JpcHQob3B0cy5jYWRlbmNlKSwgc2RrLmFyZ3Mobm9ybWFsaXplQXJncyhvcHRzLmFyZ3MgfHwgW10pKSwgb3B0cy5saW1pdCAmJiB0eXBlb2Ygb3B0cy5saW1pdCA9PT0gXCJudW1iZXJcIiAmJiBzZGsubGltaXQob3B0cy5saW1pdCldKS50aGVuKHNkay5kZWNvZGUpKTtcbn1cblxuY29uc3QgRkNMX1JFRElSRUNUX1VSTF9QQVJBTV9OQU1FID0gJ2ZjbF9yZWRpcmVjdF91cmwnO1xuY29uc3QgRkNMX1JFU1BPTlNFX1BBUkFNX05BTUUgPSAnZmNsUmVzcG9uc2VKc29uJztcbmNvbnN0IENPUkVfU1RSQVRFR0lFUyA9IHtcbiAgXCJIVFRQL1JQQ1wiOiBcIkhUVFAvUlBDXCIsXG4gIFwiSFRUUC9QT1NUXCI6IFwiSFRUUC9QT1NUXCIsXG4gIFwiSUZSQU1FL1JQQ1wiOiBcIklGUkFNRS9SUENcIixcbiAgXCJQT1AvUlBDXCI6IFwiUE9QL1JQQ1wiLFxuICBcIlRBQi9SUENcIjogXCJUQUIvUlBDXCIsXG4gIFwiRVhUL1JQQ1wiOiBcIkVYVC9SUENcIixcbiAgXCJERUVQTElOSy9SUENcIjogXCJERUVQTElOSy9SUENcIlxufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIExpc3RlbnMgZm9yIG1lc3NhZ2VzIGZyb20gRkNMXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZSAtIE1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lclxuICovXG5jb25zdCBvbk1lc3NhZ2VGcm9tRkNMID0gZnVuY3Rpb24gKG1lc3NhZ2VUeXBlKSB7XG4gIGxldCBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogKCkgPT4ge307XG4gIGNvbnN0IGJ1aWxkRGF0YSA9IGRhdGEgPT4ge1xuICAgIGlmIChkYXRhLmRlcHJlY2F0ZWQpIGNvbnNvbGUud2FybihcIkRFUFJFQ0FUSU9OIE5PVElDRVwiLCBkYXRhLmRlcHJlY2F0ZWQubWVzc2FnZSk7XG4gICAgZGVsZXRlIGRhdGE/LmJvZHk/LmludGVyYWN0aW9uO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICBjb25zdCBpbnRlcm5hbCA9IGUgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gZTtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChkYXRhLnR5cGUgIT09IG1lc3NhZ2VUeXBlKSByZXR1cm47XG4gICAgY2IoYnVpbGREYXRhKGRhdGEpKTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGludGVybmFsKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBpbnRlcm5hbCk7XG59O1xuXG4vLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYW4gb25nb2luZyBpc3N1ZSB3aXRoIFVSTCBpbiBSZWFjdCBOYXRpdmVcbmNvbnN0IF9VUkwgPSBnbG9iYWxUaGlzLlVSTDtcbmNsYXNzIFVSTCBleHRlbmRzIF9VUkwge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGJhc2UpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgc3VwZXIodXJsLCBiYXNlLCAuLi5hcmdzKTtcblxuICAgIC8vIEV4dHJhIGNoZWNrIGlmIGluIFJlYWN0IE5hdGl2ZVxuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlbmRzIG1lc3NhZ2UgdG8gRkNMIHdpbmRvd1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gTWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbXNnIC0gTWVzc2FnZSBvYmplY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICpcbiAqIEBleGFtcGxlXG4gKiBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpSRVNQT05TRVwiLCB7XG4gKiAgICBmX3R5cGU6IFwiUG9sbGluZ1Jlc3BvbnNlXCIsXG4gKiAgICBmX3ZzbjogXCIxLjAuMFwiLFxuICogICAgc3RhdHVzOiBcIkFQUFJPVkVEXCIsXG4gKiAgICByZWFzb246IG51bGwsXG4gKiAgICBkYXRhOiBkYXRhLFxuICogIH0pXG4gKi9cbmNvbnN0IHNlbmRNc2dUb0ZDTCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGxldCBtc2cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCBkYXRhID0ge1xuICAgIC4uLm1zZyxcbiAgICB0eXBlXG4gIH07XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gIGNvbnN0IHJlZGlyZWN0VXJsID0gdXJsUGFyYW1zLmdldChGQ0xfUkVESVJFQ1RfVVJMX1BBUkFNX05BTUUpO1xuICBpZiAocmVkaXJlY3RVcmwpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlZGlyZWN0VXJsKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChGQ0xfUkVTUE9OU0VfUEFSQU1fTkFNRSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsLmhyZWY7XG4gIH0gZWxzZSBpZiAod2luZG93LmxvY2F0aW9uICE9PSB3aW5kb3cucGFyZW50LmxvY2F0aW9uKSB7XG4gICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAuLi5tc2csXG4gICAgICB0eXBlXG4gICAgfSwgXCIqXCIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5vcGVuZXIpIHtcbiAgICB3aW5kb3cub3BlbmVyLnBvc3RNZXNzYWdlKHtcbiAgICAgIC4uLm1zZyxcbiAgICAgIHR5cGVcbiAgICB9LCBcIipcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbW11bmljYXRlIHdpdGggcGFyZW50IEZDTCBpbnN0YW5jZVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIExpc3RlbnMgZm9yIFwiRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIiBhbmQgc2VuZHMgXCJGQ0w6VklFVzpSRUFEWVwiXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG1zZyAtIE1lc3NhZ2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgcmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgb25NZXNzYWdlRnJvbUZDTChcIkZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCIsIGNiKTtcbiAgc2VuZE1zZ1RvRkNMKFwiRkNMOlZJRVc6UkVBRFlcIik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU2VuZHMgXCJGQ0w6VklFVzpDTE9TRVwiXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpDTE9TRVwiKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZW5kcyBcIkZDTDpWSUVXOlJFU1BPTlNFXCIgd2l0aCBzdGF0dXMgXCJBUFBST1ZFRFwiXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBEYXRhIG9iamVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGFwcHJvdmUgPSBkYXRhID0+IHtcbiAgc2VuZE1zZ1RvRkNMKFwiRkNMOlZJRVc6UkVTUE9OU0VcIiwge1xuICAgIGZfdHlwZTogXCJQb2xsaW5nUmVzcG9uc2VcIixcbiAgICBmX3ZzbjogXCIxLjAuMFwiLFxuICAgIHN0YXR1czogXCJBUFBST1ZFRFwiLFxuICAgIHJlYXNvbjogbnVsbCxcbiAgICBkYXRhOiBkYXRhXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlbmRzIFwiRkNMOlZJRVc6UkVTUE9OU0VcIiB3aXRoIHN0YXR1cyBcIkRFQ0xJTkVEXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gUmVhc29uIGZvciBkZWNsaW5pbmdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBkZWNsaW5lID0gcmVhc29uID0+IHtcbiAgc2VuZE1zZ1RvRkNMKFwiRkNMOlZJRVc6UkVTUE9OU0VcIiwge1xuICAgIGZfdHlwZTogXCJQb2xsaW5nUmVzcG9uc2VcIixcbiAgICBmX3ZzbjogXCIxLjAuMFwiLFxuICAgIHN0YXR1czogXCJERUNMSU5FRFwiLFxuICAgIHJlYXNvbjogcmVhc29uLFxuICAgIGRhdGE6IG51bGxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU2VuZHMgXCJGQ0w6VklFVzpSRVNQT05TRVwiIHdpdGggc3RhdHVzIFwiUkVESVJFQ1RcIlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gRGF0YSBvYmplY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCByZWRpcmVjdCA9IGRhdGEgPT4ge1xuICBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpSRVNQT05TRVwiLCB7XG4gICAgZl90eXBlOiBcIlBvbGxpbmdSZXNwb25zZVwiLFxuICAgIGZfdnNuOiBcIjEuMC4wXCIsXG4gICAgc3RhdHVzOiBcIlJFRElSRUNUXCIsXG4gICAgcmVhc29uOiBudWxsLFxuICAgIGRhdGE6IGRhdGFcbiAgfSk7XG59O1xuXG5jb25zdCBTRVJWSUNFX1BSQUdNQSA9IHtcbiAgZl90eXBlOiBcIlNlcnZpY2VcIixcbiAgZl92c246IFwiMS4wLjBcIlxufTtcbmNvbnN0IElERU5USVRZX1BSQUdNQSA9IHtcbiAgZl90eXBlOiBcIklkZW50aXR5XCIsXG4gIGZfdnNuOiBcIjEuMC4wXCJcbn07XG5jb25zdCBVU0VSX1BSQUdNQSA9IHtcbiAgZl90eXBlOiBcIlVTRVJcIixcbiAgZl92c246IFwiMS4wLjBcIlxufTtcbmNvbnN0IFBPTExJTkdfUkVTUE9OU0VfUFJBR01BID0ge1xuICBmX3R5cGU6IFwiUG9sbGluZ1Jlc3BvbnNlXCIsXG4gIGZfdnNuOiBcIjEuMC4wXCJcbn07XG5jb25zdCBDT01QT1NJVEVfU0lHTkFUVVJFX1BSQUdNQSA9IHtcbiAgZl90eXBlOiBcIkNvbXBvc2l0ZVNpZ25hdHVyZVwiLFxuICBmX3ZzbjogXCIxLjAuMFwiXG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ29uc3RydWN0cyBhIG5ldyBDb21wb3NpdGVTaWduYXR1cmUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBGbG93IEFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlJZCAtIEtleSBJRFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIFNpZ25hdHVyZSBhcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gQ29tcG9zaXRlU2lnbmF0dXJlKGFkZHIsIGtleUlkLCBzaWduYXR1cmUpIHtcbiAgdGhpcy5mX3R5cGUgPSBDT01QT1NJVEVfU0lHTkFUVVJFX1BSQUdNQS5mX3R5cGU7XG4gIHRoaXMuZl92c24gPSBDT01QT1NJVEVfU0lHTkFUVVJFX1BSQUdNQS5mX3ZzbjtcbiAgdGhpcy5hZGRyID0gd2l0aFByZWZpeChhZGRyKTtcbiAgdGhpcy5rZXlJZCA9IE51bWJlcihrZXlJZCk7XG4gIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xufVxuXG5jb25zdCByaWdodFBhZGRlZEhleEJ1ZmZlciA9ICh2YWx1ZSwgcGFkKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZS5wYWRFbmQocGFkICogMiwgXCIwXCIpLCBcImhleFwiKTtcbmNvbnN0IGxlZnRQYWRkZWRIZXhCdWZmZXIgPSAodmFsdWUsIHBhZCkgPT4gQnVmZmVyLmZyb20odmFsdWUucGFkU3RhcnQocGFkICogMiwgXCIwXCIpLCBcImhleFwiKTtcbmNvbnN0IGFkZHJlc3NCdWZmZXIgPSBhZGRyID0+IGxlZnRQYWRkZWRIZXhCdWZmZXIoYWRkciwgOCk7XG5jb25zdCBub25jZUJ1ZmZlciA9IG5vbmNlID0+IEJ1ZmZlci5mcm9tKG5vbmNlLCBcImhleFwiKTtcbmNvbnN0IGVuY29kZUFjY291bnRQcm9vZiA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIGxldCB7XG4gICAgYWRkcmVzcyxcbiAgICBub25jZSxcbiAgICBhcHBJZGVudGlmaWVyXG4gIH0gPSBfcmVmO1xuICBsZXQgaW5jbHVkZURvbWFpblRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgaW52YXJpYW50KGFkZHJlc3MsIFwiRW5jb2RlIE1lc3NhZ2UgRm9yIFByb3ZhYmxlIEF1dGhuIEVycm9yOiBhZGRyZXNzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50KG5vbmNlLCBcIkVuY29kZSBNZXNzYWdlIEZvciBQcm92YWJsZSBBdXRobiBFcnJvcjogbm9uY2UgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQoYXBwSWRlbnRpZmllciwgXCJFbmNvZGUgTWVzc2FnZSBGb3IgUHJvdmFibGUgQXV0aG4gRXJyb3I6IGFwcElkZW50aWZpZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQobm9uY2UubGVuZ3RoID49IDY0LCBcIkVuY29kZSBNZXNzYWdlIEZvciBQcm92YWJsZSBBdXRobiBFcnJvcjogbm9uY2UgbXVzdCBiZSBtaW5pbXVtIG9mIDMyIGJ5dGVzXCIpO1xuICBjb25zdCBBQ0NPVU5UX1BST09GX0RPTUFJTl9UQUcgPSByaWdodFBhZGRlZEhleEJ1ZmZlcihCdWZmZXIuZnJvbShcIkZDTC1BQ0NPVU5ULVBST09GLVYwLjBcIikudG9TdHJpbmcoXCJoZXhcIiksIDMyKTtcbiAgaWYgKGluY2x1ZGVEb21haW5UYWcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbQUNDT1VOVF9QUk9PRl9ET01BSU5fVEFHLCBlbmNvZGUoW2FwcElkZW50aWZpZXIsIGFkZHJlc3NCdWZmZXIoc2Fuc1ByZWZpeChhZGRyZXNzKSksIG5vbmNlQnVmZmVyKG5vbmNlKV0pXSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgcmV0dXJuIGVuY29kZShbYXBwSWRlbnRpZmllciwgYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KGFkZHJlc3MpKSwgbm9uY2VCdWZmZXIobm9uY2UpXSkudG9TdHJpbmcoXCJoZXhcIik7XG59O1xuXG5mdW5jdGlvbiBpbmplY3RFeHRTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UudHlwZSA9PT0gXCJhdXRoblwiICYmIHNlcnZpY2UuZW5kcG9pbnQgIT0gbnVsbCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh3aW5kb3cuZmNsX2V4dGVuc2lvbnMpKSB7XG4gICAgICB3aW5kb3cuZmNsX2V4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG4gICAgd2luZG93LmZjbF9leHRlbnNpb25zLnB1c2goc2VydmljZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKFwiQXV0aG4gc2VydmljZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxufVxuXG52YXIgaW5kZXgkMiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzZW5kTXNnVG9GQ0w6IHNlbmRNc2dUb0ZDTCxcbiAgcmVhZHk6IHJlYWR5LFxuICBjbG9zZTogY2xvc2UsXG4gIGFwcHJvdmU6IGFwcHJvdmUsXG4gIGRlY2xpbmU6IGRlY2xpbmUsXG4gIHJlZGlyZWN0OiByZWRpcmVjdCxcbiAgb25NZXNzYWdlRnJvbUZDTDogb25NZXNzYWdlRnJvbUZDTCxcbiAgZW5jb2RlTWVzc2FnZUZyb21TaWduYWJsZTogZW5jb2RlTWVzc2FnZUZyb21TaWduYWJsZSxcbiAgQ29tcG9zaXRlU2lnbmF0dXJlOiBDb21wb3NpdGVTaWduYXR1cmUsXG4gIGVuY29kZUFjY291bnRQcm9vZjogZW5jb2RlQWNjb3VudFByb29mLFxuICBpbmplY3RFeHRTZXJ2aWNlOiBpbmplY3RFeHRTZXJ2aWNlXG59KTtcblxuY29uc3QgQUNDT1VOVF9QUk9PRiA9IFwiQUNDT1VOVF9QUk9PRlwiO1xuY29uc3QgVVNFUl9TSUdOQVRVUkUgPSBcIlVTRVJfU0lHTkFUVVJFXCI7XG5jb25zdCB2YWxpZGF0ZUFyZ3MgPSBhcmdzID0+IHtcbiAgaWYgKGFyZ3MuYXBwSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcElkZW50aWZpZXIsXG4gICAgICBhZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBzaWduYXR1cmVzXG4gICAgfSA9IGFyZ3M7XG4gICAgaW52YXJpYW50KGlzU3RyaW5nKGFwcElkZW50aWZpZXIpLCBcInZlcmlmeUFjY291bnRQcm9vZih7IGFwcElkZW50aWZpZXIgfSkgLS0gYXBwSWRlbnRpZmllciBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIGludmFyaWFudChpc1N0cmluZyhhZGRyZXNzKSAmJiBzYW5zUHJlZml4KGFkZHJlc3MpLmxlbmd0aCA9PT0gMTYsIFwidmVyaWZ5QWNjb3VudFByb29mKHsgYWRkcmVzcyB9KSAtLSBhZGRyZXNzIG11c3QgYmUgYSB2YWxpZCBhZGRyZXNzXCIpO1xuICAgIGludmFyaWFudCgvXlswLTlhLWZdKyQvaS50ZXN0KG5vbmNlKSwgXCJub25jZSBtdXN0IGJlIGEgaGV4IHN0cmluZ1wiKTtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzaWduYXR1cmVzKSAmJiBzaWduYXR1cmVzLmV2ZXJ5KChzaWcsIGksIGFycikgPT4gc2lnLmZfdHlwZSA9PT0gXCJDb21wb3NpdGVTaWduYXR1cmVcIiksIFwiTXVzdCBpbmNsdWRlIGFuIEFycmF5IG9mIENvbXBvc2l0ZVNpZ25hdHVyZXMgdG8gdmVyaWZ5XCIpO1xuICAgIGludmFyaWFudChzaWduYXR1cmVzLm1hcChjcyA9PiBjcy5hZGRyKS5ldmVyeSgoYWRkciwgaSwgYXJyKSA9PiBhZGRyID09PSBhcnJbMF0pLCBcIlVzZXIgc2lnbmF0dXJlcyB0byBiZSB2ZXJpZmllZCBtdXN0IGJlIGZyb20gYSBzaW5nbGUgYWNjb3VudCBhZGRyZXNzXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBhZGRyZXNzLFxuICAgICAgY29tcFNpZ3NcbiAgICB9ID0gYXJncztcbiAgICBpbnZhcmlhbnQoL15bMC05YS1mXSskL2kudGVzdChtZXNzYWdlKSwgXCJTaWduZWQgbWVzc2FnZSBtdXN0IGJlIGEgaGV4IHN0cmluZ1wiKTtcbiAgICBpbnZhcmlhbnQoaXNTdHJpbmcoYWRkcmVzcykgJiYgc2Fuc1ByZWZpeChhZGRyZXNzKS5sZW5ndGggPT09IDE2LCBcInZlcmlmeVVzZXJTaWduYXR1cmVzKHsgYWRkcmVzcyB9KSAtLSBhZGRyZXNzIG11c3QgYmUgYSB2YWxpZCBhZGRyZXNzXCIpO1xuICAgIGludmFyaWFudChBcnJheS5pc0FycmF5KGNvbXBTaWdzKSAmJiBjb21wU2lncy5ldmVyeSgoc2lnLCBpLCBhcnIpID0+IHNpZy5mX3R5cGUgPT09IFwiQ29tcG9zaXRlU2lnbmF0dXJlXCIpLCBcIk11c3QgaW5jbHVkZSBhbiBBcnJheSBvZiBDb21wb3NpdGVTaWduYXR1cmVzIHRvIHZlcmlmeVwiKTtcbiAgICBpbnZhcmlhbnQoY29tcFNpZ3MubWFwKGNzID0+IGNzLmFkZHIpLmV2ZXJ5KChhZGRyLCBpLCBhcnIpID0+IGFkZHIgPT09IGFyclswXSksIFwiVXNlciBzaWduYXR1cmVzIHRvIGJlIHZlcmlmaWVkIG11c3QgYmUgZnJvbSBhIHNpbmdsZSBhY2NvdW50IGFkZHJlc3NcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIFRPRE86IHBhc3MgaW4gb3B0aW9uIGZvciBjb250cmFjdCBidXQgd2UncmUgY29ubmVjdGVkIHRvIHRlc3RuZXRcbi8vIGxvZyBhZGRyZXNzICsgbmV0d29yayAtPiBpbiBzeW5jP1xuY29uc3QgZ2V0VmVyaWZ5U2lnbmF0dXJlc1NjcmlwdCA9IGFzeW5jIChzaWcsIG9wdHMpID0+IHtcbiAgY29uc3QgdmVyaWZ5RnVuY3Rpb24gPSBzaWcgPT09IFwiQUNDT1VOVF9QUk9PRlwiID8gXCJ2ZXJpZnlBY2NvdW50UHJvb2ZTaWduYXR1cmVzXCIgOiBcInZlcmlmeVVzZXJTaWduYXR1cmVzXCI7XG4gIGxldCBuZXR3b3JrID0gYXdhaXQgZ2V0Q2hhaW5JZChvcHRzKTtcbiAgbGV0IGZjbENyeXB0b0NvbnRyYWN0O1xuICBpbnZhcmlhbnQob3B0cy5mY2xDcnlwdG9Db250cmFjdCB8fCBuZXR3b3JrID09PSBcInRlc3RuZXRcIiB8fCBuZXR3b3JrID09PSBcIm1haW5uZXRcIiwgXCIke3ZlcmlmeUZ1bmN0aW9ufSh7IGZjbENyeXB0b0NvbnRyYWN0IH0pIC0tIGZjbENyeXB0byBjb250cmFjdCBhZGRyZXNzIG11c3QgYmUgc2V0IGZvciBub24tbWFpbm5ldC90ZXN0bmV0IG5ldHdvcmtzXCIpO1xuICBpZiAob3B0cy5mY2xDcnlwdG9Db250cmFjdCkge1xuICAgIGZjbENyeXB0b0NvbnRyYWN0ID0gb3B0cy5mY2xDcnlwdG9Db250cmFjdDtcbiAgfSBlbHNlIHtcbiAgICBmY2xDcnlwdG9Db250cmFjdCA9IG5ldHdvcmsgPT09IFwidGVzdG5ldFwiID8gXCIweDc0ZGFhNmY5YzdlZjI0YjFcIiA6IFwiMHhiNGI4MmExYzlkMjFkMjg0XCI7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGltcG9ydCBGQ0xDcnlwdG8gZnJvbSAke2ZjbENyeXB0b0NvbnRyYWN0fVxuXG4gICAgICBwdWIgZnVuIG1haW4oXG4gICAgICAgICAgYWRkcmVzczogQWRkcmVzcywgXG4gICAgICAgICAgbWVzc2FnZTogU3RyaW5nLCBcbiAgICAgICAgICBrZXlJbmRpY2VzOiBbSW50XSwgXG4gICAgICAgICAgc2lnbmF0dXJlczogW1N0cmluZ11cbiAgICAgICk6IEJvb2wge1xuICAgICAgICByZXR1cm4gRkNMQ3J5cHRvLiR7dmVyaWZ5RnVuY3Rpb259KGFkZHJlc3M6IGFkZHJlc3MsIG1lc3NhZ2U6IG1lc3NhZ2UsIGtleUluZGljZXM6IGtleUluZGljZXMsIHNpZ25hdHVyZXM6IHNpZ25hdHVyZXMpXG4gICAgICB9XG4gICAgYDtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBWZXJpZnkgYSB2YWxpZCBhY2NvdW50IHByb29mIHNpZ25hdHVyZSBvciBzaWduYXR1cmVzIGZvciBhbiBhY2NvdW50IG9uIEZsb3cuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcElkZW50aWZpZXIgLSBBIG1lc3NhZ2Ugc3RyaW5nIGluIGhleGFkZWNpbWFsIGZvcm1hdFxuICogQHBhcmFtIHtvYmplY3R9IGFjY291bnRQcm9vZkRhdGEgLSBBbiBvYmplY3QgY29uc2lzdGluZyBvZiBhZGRyZXNzLCBub25jZSwgYW5kIHNpZ25hdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50UHJvb2ZEYXRhLmFkZHJlc3MgLSBBIEZsb3cgYWNjb3VudCBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudFByb29mRGF0YS5ub25jZSAtIEEgcmFuZG9tIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQgKG1pbmltdW0gMzIgYnl0ZXMgaW4gdG90YWwsIGkuZSA2NCBoZXggY2hhcmFjdGVycylcbiAqIEBwYXJhbSB7b2JqZWN0W119IGFjY291bnRQcm9vZkRhdGEuc2lnbmF0dXJlcyAtIEFuIGFycmF5IG9mIGNvbXBvc2l0ZSBzaWduYXR1cmVzIHRvIHZlcmlmeVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mY2xDcnlwdG9Db250cmFjdCAtIEFuIG9wdGlvbmFsIG92ZXJyaWRlIEZsb3cgYWNjb3VudCBhZGRyZXNzIHdoZXJlIHRoZSBGQ0xDcnlwdG8gY29udHJhY3QgaXMgZGVwbG95ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICBjb25zdCBhY2NvdW50UHJvb2ZEYXRhID0ge1xuICogICBhZGRyZXNzOiBcIjB4MTIzXCIsXG4gKiAgIG5vbmNlOiBcIkYwMTIzXCJcbiAqICAgc2lnbmF0dXJlczogW3tmX3R5cGU6IFwiQ29tcG9zaXRlU2lnbmF0dXJlXCIsIGZfdnNuOiBcIjEuMC4wXCIsIGFkZHI6IFwiMHgxMjNcIiwga2V5SWQ6IDAsIHNpZ25hdHVyZTogXCJhYmMxMjNcIn1dLFxuICogIH1cbiAqXG4gKiAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGZjbC5BcHBVdGlscy52ZXJpZnlBY2NvdW50UHJvb2YoXG4gKiAgICBcIkF3ZXNvbWVBcHBJZFwiLFxuICogICAgYWNjb3VudFByb29mRGF0YSxcbiAqICAgIHtmY2xDcnlwdG9Db250cmFjdH1cbiAqICApXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUFjY291bnRQcm9vZihhcHBJZGVudGlmaWVyLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgYWRkcmVzcyxcbiAgICBub25jZSxcbiAgICBzaWduYXR1cmVzXG4gIH0gPSBfcmVmO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhbGlkYXRlQXJncyh7XG4gICAgYXBwSWRlbnRpZmllcixcbiAgICBhZGRyZXNzLFxuICAgIG5vbmNlLFxuICAgIHNpZ25hdHVyZXNcbiAgfSk7XG4gIGNvbnN0IG1lc3NhZ2UgPSBlbmNvZGVBY2NvdW50UHJvb2Yoe1xuICAgIGFkZHJlc3MsXG4gICAgbm9uY2UsXG4gICAgYXBwSWRlbnRpZmllclxuICB9LCBmYWxzZSk7XG4gIGxldCBzaWduYXR1cmVzQXJyID0gW107XG4gIGxldCBrZXlJbmRpY2VzID0gW107XG4gIGZvciAoY29uc3QgZWwgb2Ygc2lnbmF0dXJlcykge1xuICAgIHNpZ25hdHVyZXNBcnIucHVzaChlbC5zaWduYXR1cmUpO1xuICAgIGtleUluZGljZXMucHVzaChlbC5rZXlJZC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gcXVlcnkoe1xuICAgIGNhZGVuY2U6IGF3YWl0IGdldFZlcmlmeVNpZ25hdHVyZXNTY3JpcHQoQUNDT1VOVF9QUk9PRiwgb3B0cyksXG4gICAgYXJnczogKGFyZywgdCkgPT4gW2FyZyh3aXRoUHJlZml4KGFkZHJlc3MpLCB0LkFkZHJlc3MpLCBhcmcobWVzc2FnZSwgdC5TdHJpbmcpLCBhcmcoa2V5SW5kaWNlcywgdC5BcnJheSh0LkludCkpLCBhcmcoc2lnbmF0dXJlc0FyciwgdC5BcnJheSh0LlN0cmluZykpXVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFZlcmlmeSBhIHZhbGlkIHNpZ25hdHVyZS9zIGZvciBhbiBhY2NvdW50IG9uIEZsb3cuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBBIG1lc3NhZ2Ugc3RyaW5nIGluIGhleGFkZWNpbWFsIGZvcm1hdFxuICogQHBhcmFtIHtBcnJheX0gY29tcFNpZ3MgLSBBbiBhcnJheSBvZiBDb21wb3NpdGUgU2lnbmF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBTaWdzW10uYWRkciAtIFRoZSBhY2NvdW50IGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wU2lnc1tdLmtleUlkIC0gVGhlIGFjY291bnQga2V5SWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wU2lnc1tdLnNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdHM9e31dIC0gT3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZjbENyeXB0b0NvbnRyYWN0IC0gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgb2YgRmxvdyBhY2NvdW50IGFkZHJlc3Mgd2hlcmUgdGhlIEZDTENyeXB0byBjb250cmFjdCBpcyBkZXBsb3llZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBmY2wuQXBwVXRpbHMudmVyaWZ5VXNlclNpZ25hdHVyZXMoXG4gKiAgICBCdWZmZXIuZnJvbSgnRk9PJykudG9TdHJpbmcoXCJoZXhcIiksXG4gKiAgICBbe2ZfdHlwZTogXCJDb21wb3NpdGVTaWduYXR1cmVcIiwgZl92c246IFwiMS4wLjBcIiwgYWRkcjogXCIweDEyM1wiLCBrZXlJZDogMCwgc2lnbmF0dXJlOiBcImFiYzEyM1wifV0sXG4gKiAgICB7ZmNsQ3J5cHRvQ29udHJhY3R9XG4gKiAgKVxuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlVc2VyU2lnbmF0dXJlcyQxKG1lc3NhZ2UsIGNvbXBTaWdzKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgYWRkcmVzcyA9IHdpdGhQcmVmaXgoY29tcFNpZ3NbMF0uYWRkcik7XG4gIHZhbGlkYXRlQXJncyh7XG4gICAgbWVzc2FnZSxcbiAgICBhZGRyZXNzLFxuICAgIGNvbXBTaWdzXG4gIH0pO1xuICBsZXQgc2lnbmF0dXJlc0FyciA9IFtdO1xuICBsZXQga2V5SW5kaWNlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGVsIG9mIGNvbXBTaWdzKSB7XG4gICAgc2lnbmF0dXJlc0Fyci5wdXNoKGVsLnNpZ25hdHVyZSk7XG4gICAga2V5SW5kaWNlcy5wdXNoKGVsLmtleUlkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBxdWVyeSh7XG4gICAgY2FkZW5jZTogYXdhaXQgZ2V0VmVyaWZ5U2lnbmF0dXJlc1NjcmlwdChVU0VSX1NJR05BVFVSRSwgb3B0cyksXG4gICAgYXJnczogKGFyZywgdCkgPT4gW2FyZyhhZGRyZXNzLCB0LkFkZHJlc3MpLCBhcmcobWVzc2FnZSwgdC5TdHJpbmcpLCBhcmcoa2V5SW5kaWNlcywgdC5BcnJheSh0LkludCkpLCBhcmcoc2lnbmF0dXJlc0FyciwgdC5BcnJheSh0LlN0cmluZykpXVxuICB9KTtcbn1cblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdmVyaWZ5QWNjb3VudFByb29mOiB2ZXJpZnlBY2NvdW50UHJvb2YsXG4gIHZlcmlmeVVzZXJTaWduYXR1cmVzOiB2ZXJpZnlVc2VyU2lnbmF0dXJlcyQxXG59KTtcblxuLyoqXG4gKiBWZXJpZnkgYSB2YWxpZCBzaWduYXR1cmUvcyBmb3IgYW4gYWNjb3VudCBvbiBGbG93LlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gJzEuMC4wLWFscGhhLjAnLCB1c2UgQXBwVXRpbHMudmVyaWZ5VXNlclNpZ25hdHVyZXMgaW5zdGVhZFxuICpcbiAqL1xuY29uc3QgdmVyaWZ5VXNlclNpZ25hdHVyZXMgPSBsb2cuZGVwcmVjYXRlKHtcbiAgcGtnOiBcIkZDTFwiLFxuICBzdWJqZWN0OiBcImZjbC52ZXJpZnlVc2VyU2lnbmF0dXJlcygpXCIsXG4gIG1lc3NhZ2U6IFwiUGxlYXNlIHVzZSBmY2wuQXBwVXRpbHMudmVyaWZ5VXNlclNpZ25hdHVyZXMoKVwiLFxuICBjYWxsYmFjazogZnVuY3Rpb24gdmVyaWZ5VXNlclNpZ25hdHVyZXMobWVzc2FnZSwgY29tcFNpZ3MpIHtcbiAgICByZXR1cm4gdmVyaWZ5VXNlclNpZ25hdHVyZXMkMShtZXNzYWdlLCBjb21wU2lncyk7XG4gIH1cbn0pO1xuXG5jb25zdCBzZXJpYWxpemUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCByZXNvbHZlRnVuY3Rpb24gPSBhd2FpdCBjb25maWckMS5maXJzdChbXCJzZGsucmVzb2x2ZVwiXSwgb3B0cy5yZXNvbHZlIHx8IHJlc29sdmUpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkgYXJncyA9IGF3YWl0IHBpcGUoaW50ZXJhY3Rpb24oKSwgYXJncyk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjcmVhdGVTaWduYWJsZVZvdWNoZXIoYXdhaXQgcmVzb2x2ZUZ1bmN0aW9uKGFyZ3MpKSwgbnVsbCwgMik7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBjb25maWdMZW5zKHJlZ2V4KSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYXdhaXQgY29uZmlnKCkud2hlcmUocmVnZXgpKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgcmV0dXJuIFtrZXkucmVwbGFjZShyZWdleCwgXCJcIiksIHZhbHVlXTtcbiAgfSkpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJAb25mbG93L3R5cGVkZWZzXCIpLlRyYW5zYWN0aW9ufSBUcmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuVHJhbnNhY3Rpb25TdGF0dXN9IFRyYW5zYWN0aW9uU3RhdHVzXG4gKi9cblxuY29uc3QgUkFURSQxID0gMjUwMDtcbmNvbnN0IFBPTEwgPSBcIlBPTExcIjtcbmNvbnN0IGZldGNoVHhTdGF0dXMgPSBhc3luYyB0cmFuc2FjdGlvbklkID0+IHtcbiAgcmV0dXJuIHNlbmQoW2dldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSWQpXSkudGhlbihkZWNvZGUpO1xufTtcbmNvbnN0IGlzRXhwaXJlZCA9IHR4ID0+IHR4LnN0YXR1cyA9PT0gNTtcbmNvbnN0IGlzU2VhbGVkID0gdHggPT4gdHguc3RhdHVzID49IDQ7XG5jb25zdCBpc0V4ZWN1dGVkID0gdHggPT4gdHguc3RhdHVzID49IDM7XG5jb25zdCBpc0ZpbmFsaXplZCA9IHR4ID0+IHR4LnN0YXR1cyA+PSAyO1xuY29uc3QgaXNQZW5kaW5nID0gdHggPT4gdHguc3RhdHVzID49IDE7XG5jb25zdCBpc1Vua25vd24gPSB0eCA9PiB0eC5zdGF0dXMgPj0gMDtcbmNvbnN0IGlzRGlmZiA9IChjdXIsIG5leHQpID0+IHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGN1cikgIT09IEpTT04uc3RyaW5naWZ5KG5leHQpO1xufTtcbmNvbnN0IEhBTkRMRVJTJDMgPSB7XG4gIFtJTklUXTogYXN5bmMgY3R4ID0+IHtcbiAgICBjdHguc2VuZFNlbGYoUE9MTCk7XG4gIH0sXG4gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCQyLCBjdHguYWxsKCkpO1xuICB9LFxuICBbVU5TVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICB9LFxuICBbU05BUFNIT1QkMV06IGFzeW5jIChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldHRlci5yZXBseShjdHguYWxsKCkpO1xuICB9LFxuICBbUE9MTF06IGFzeW5jIGN0eCA9PiB7XG4gICAgbGV0IHR4O1xuICAgIHRyeSB7XG4gICAgICB0eCA9IGF3YWl0IGZldGNoVHhTdGF0dXMoY3R4LnNlbGYoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGN0eC5mYXRhbEVycm9yKGUpO1xuICAgIH1cbiAgICBpZiAoIWlzU2VhbGVkKHR4KSkgc2V0VGltZW91dCgoKSA9PiBjdHguc2VuZFNlbGYoUE9MTCksIFJBVEUkMSk7XG4gICAgaWYgKGlzRGlmZihjdHguYWxsKCksIHR4KSkgY3R4LmJyb2FkY2FzdChVUERBVEVEJDIsIHR4KTtcbiAgICBjdHgubWVyZ2UodHgpO1xuICB9XG59O1xuY29uc3Qgc2NvcGVkID0gdHJhbnNhY3Rpb25JZCA9PiB7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gXCJvYmplY3RcIikgdHJhbnNhY3Rpb25JZCA9IHRyYW5zYWN0aW9uSWQudHJhbnNhY3Rpb25JZDtcbiAgaWYgKHRyYW5zYWN0aW9uSWQgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb25JZCByZXF1aXJlZFwiKTtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uSWQ7XG59O1xuY29uc3Qgc3Bhd25UcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uSWQgPT4ge1xuICByZXR1cm4gc3Bhd24oSEFORExFUlMkMywgc2NvcGVkKHRyYW5zYWN0aW9uSWQpKTtcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIFN1YnNjcmlwdGlvbkNhbGxiYWNrXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uU3RhdHVzfSB0eFN0YXR1c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIGEgdHJhbnNhY3Rpb25cbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgLSBUaGUgdHJhbnNhY3Rpb24gSURcbiAqIEByZXR1cm5zIHt7XG4gKiAgICBzbmFwc2hvdDogZnVuY3Rpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvblN0YXR1cz4sXG4gKiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKFN1YnNjcmlwdGlvbkNhbGxiYWNrKTogZnVuY3Rpb24oKTogdm9pZCxcbiAqICAgIG9uY2VGaW5hbGl6ZWQ6IGZ1bmN0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb25TdGF0dXM+LFxuICogICAgb25jZUV4ZWN1dGVkOiBmdW5jdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uU3RhdHVzPixcbiAqICAgIG9uY2VTZWFsZWQ6IGZ1bmN0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb25TdGF0dXM+XG4gKiB9fVxuICovXG5mdW5jdGlvbiB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbklkKSB7XG4gIGZ1bmN0aW9uIHNuYXBzaG90KCkge1xuICAgIHJldHVybiBzbmFwc2hvdGVyKHRyYW5zYWN0aW9uSWQsIHNwYXduVHJhbnNhY3Rpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIHJldHVybiBzdWJzY3JpYmVyKHNjb3BlZCh0cmFuc2FjdGlvbklkKSwgc3Bhd25UcmFuc2FjdGlvbiwgY2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIG9uY2UocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlubmVyT25jZSgpIHtcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGNvbnN0IHN1cHByZXNzID0gb3B0cy5zdXBwcmVzcyB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3ViID0gc3Vic2NyaWJlKCh0eFN0YXR1cywgZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoKGVycm9yIHx8IHR4U3RhdHVzLnN0YXR1c0NvZGUpICYmICFzdXBwcmVzcykge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yIHx8IHR4U3RhdHVzLmVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlKHR4U3RhdHVzKSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0eFN0YXR1cyk7XG4gICAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc25hcHNob3QsXG4gICAgc3Vic2NyaWJlLFxuICAgIG9uY2VGaW5hbGl6ZWQ6IG9uY2UoaXNGaW5hbGl6ZWQpLFxuICAgIG9uY2VFeGVjdXRlZDogb25jZShpc0V4ZWN1dGVkKSxcbiAgICBvbmNlU2VhbGVkOiBvbmNlKGlzU2VhbGVkKVxuICB9O1xufVxudHJhbnNhY3Rpb24uaXNVbmtub3duID0gaXNVbmtub3duO1xudHJhbnNhY3Rpb24uaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xudHJhbnNhY3Rpb24uaXNGaW5hbGl6ZWQgPSBpc0ZpbmFsaXplZDtcbnRyYW5zYWN0aW9uLmlzRXhlY3V0ZWQgPSBpc0V4ZWN1dGVkO1xudHJhbnNhY3Rpb24uaXNTZWFsZWQgPSBpc1NlYWxlZDtcbnRyYW5zYWN0aW9uLmlzRXhwaXJlZCA9IGlzRXhwaXJlZDtcblxuY29uc3QgUkFURSA9IDEwMDAwO1xuY29uc3QgVVBEQVRFRCQxID0gXCJVUERBVEVEXCI7XG5jb25zdCBUSUNLID0gXCJUSUNLXCI7XG5jb25zdCBISUdIX1dBVEVSX01BUksgPSBcImh3bVwiO1xuY29uc3Qgc2NoZWR1bGVUaWNrID0gYXN5bmMgY3R4ID0+IHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gY3R4LnNlbmRTZWxmKFRJQ0spLCBhd2FpdCBjb25maWckMSgpLmdldChcImZjbC5ldmVudFBvbGxSYXRlXCIsIFJBVEUpKTtcbn07XG5jb25zdCBIQU5ETEVSUyQyID0ge1xuICBbVElDS106IGFzeW5jIGN0eCA9PiB7XG4gICAgaWYgKCFjdHguaGFzU3VicygpKSByZXR1cm47XG4gICAgbGV0IGh3bSA9IGN0eC5nZXQoSElHSF9XQVRFUl9NQVJLKTtcbiAgICBpZiAoaHdtID09IG51bGwpIHtcbiAgICAgIGN0eC5wdXQoSElHSF9XQVRFUl9NQVJLLCBhd2FpdCBibG9jaygpKTtcbiAgICAgIGN0eC5wdXQoVElDSywgYXdhaXQgc2NoZWR1bGVUaWNrKGN0eCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV4dCA9IGF3YWl0IGJsb2NrKCk7XG4gICAgICBjdHgucHV0KEhJR0hfV0FURVJfTUFSSywgbmV4dCk7XG4gICAgICBpZiAoaHdtLmhlaWdodCA8IG5leHQuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzZW5kKFtnZXRFdmVudHNBdEJsb2NrSGVpZ2h0UmFuZ2UoY3R4LnNlbGYoKSwgaHdtLmhlaWdodCArIDEsIG5leHQuaGVpZ2h0KV0pLnRoZW4oZGVjb2RlKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkYXRhKSBjdHguYnJvYWRjYXN0KFVQREFURUQkMSwgZC5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXQoVElDSywgYXdhaXQgc2NoZWR1bGVUaWNrKGN0eCkpO1xuICAgIH1cbiAgfSxcbiAgW1NVQlNDUklCRV06IGFzeW5jIChjdHgsIGxldHRlcikgPT4ge1xuICAgIGlmICghY3R4Lmhhc1N1YnMoKSkge1xuICAgICAgY3R4LnB1dChUSUNLLCBhd2FpdCBzY2hlZHVsZVRpY2soY3R4KSk7XG4gICAgfVxuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICB9LFxuICBbVU5TVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGlmICghY3R4Lmhhc1N1YnMoKSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGN0eC5nZXQoVElDSykpO1xuICAgICAgY3R4LmRlbGV0ZShUSUNLKTtcbiAgICAgIGN0eC5kZWxldGUoSElHSF9XQVRFUl9NQVJLKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBzcGF3bkV2ZW50cyA9IGtleSA9PiBzcGF3bihIQU5ETEVSUyQyLCBrZXkpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJAb25mbG93L3R5cGVkZWZzXCIpLkV2ZW50fSBFdmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU3Vic2NyaWJlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzdWJzY3JpYmUgLSBUaGUgc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN1YnNjcmlwdGlvbkNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBTdWJzY3JpYmUgdG8gZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSB2YWxpZCBldmVudCBuYW1lXG4gKiBAcmV0dXJucyB7U3Vic2NyaWJlT2JqZWN0fVxuICogXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgZmNsIGZyb20gXCJAb25mbG93L2ZjbFwiXG4gKiBmY2wuZXZlbnRzKGV2ZW50TmFtZSkuc3Vic2NyaWJlKChldmVudCkgPT4gY29uc29sZS5sb2coZXZlbnQpKVxuICovXG5mdW5jdGlvbiBldmVudHMoa2V5KSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIC0gU3Vic2NyaWJlIHRvIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbkNhbGxiYWNrfVxuICAgICAqL1xuICAgIHN1YnNjcmliZTogY2FsbGJhY2sgPT4gc3Vic2NyaWJlcihrZXksIHNwYXduRXZlbnRzLCBjYWxsYmFjaylcbiAgfTtcbn1cblxuY29uc3Qgc3R1YiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQbGF0Zm9ybSBzcGVjaWZpYyBDb3JlIFN0cmF0ZWdpZXMgYXJlIG5vdCBpbml0aWFsaXplZGApO1xufTtcbmNvbnN0IHN0dWJDb3JlU3RyYXRlZ2llcyA9IHtcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIkVYVC9SUENcIl1dOiBzdHViLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiSFRUUC9QT1NUXCJdXTogc3R1YixcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIklGUkFNRS9SUENcIl1dOiBzdHViLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiUE9QL1JQQ1wiXV06IHN0dWIsXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJUQUIvUlBDXCJdXTogc3R1YixcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIkVYVC9SUENcIl1dOiBzdHViXG59O1xuY29uc3Qgc3VwcG9ydGVkUGx1Z2lucyA9IFtcIlNlcnZpY2VQbHVnaW5cIl07XG5jb25zdCBzdXBwb3J0ZWRTZXJ2aWNlUGx1Z2lucyA9IFtcImRpc2NvdmVyeS1zZXJ2aWNlXCJdO1xuY29uc3QgdmFsaWRhdGVEaXNjb3ZlcnlQbHVnaW4gPSBzZXJ2aWNlUGx1Z2luID0+IHtcbiAgY29uc3Qge1xuICAgIHNlcnZpY2VzLFxuICAgIHNlcnZpY2VTdHJhdGVneVxuICB9ID0gc2VydmljZVBsdWdpbjtcbiAgaW52YXJpYW50KEFycmF5LmlzQXJyYXkoc2VydmljZXMpICYmIHNlcnZpY2VzLmxlbmd0aCwgXCJBcnJheSBvZiBEaXNjb3ZlcnkgU2VydmljZXMgaXMgcmVxdWlyZWRcIik7XG4gIGZvciAoY29uc3QgZHMgb2Ygc2VydmljZXMpIHtcbiAgICBpbnZhcmlhbnQoaXNSZXF1aXJlZChkcy5mX3R5cGUpICYmIGRzLmZfdHlwZSA9PT0gXCJTZXJ2aWNlXCIsIFwiU2VydmljZSBpcyByZXF1aXJlZFwiKTtcbiAgICBpbnZhcmlhbnQoaXNSZXF1aXJlZChkcy50eXBlKSAmJiBkcy50eXBlID09PSBcImF1dGhuXCIsIGBTZXJ2aWNlIG11c3QgYmUgdHlwZSBhdXRobi4gUmVjZWl2ZWQgJHtkcy50eXBlfWApO1xuICAgIGludmFyaWFudChkcy5tZXRob2QgaW4gQ09SRV9TVFJBVEVHSUVTIHx8IHNlcnZpY2VTdHJhdGVneS5tZXRob2QgPT09IGRzLm1ldGhvZCwgYFNlcnZpY2UgbWV0aG9kICR7ZHMubWV0aG9kfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbiAgaW52YXJpYW50KGlzUmVxdWlyZWQoc2VydmljZVN0cmF0ZWd5KSwgXCJTZXJ2aWNlIHN0cmF0ZWd5IGlzIHJlcXVpcmVkXCIpO1xuICBpbnZhcmlhbnQoaXNSZXF1aXJlZChzZXJ2aWNlU3RyYXRlZ3kubWV0aG9kKSAmJiBpc1N0cmluZyhzZXJ2aWNlU3RyYXRlZ3kubWV0aG9kKSwgXCJTZXJ2aWNlIHN0cmF0ZWd5IG1ldGhvZCBpcyByZXF1aXJlZFwiKTtcbiAgaW52YXJpYW50KGlzUmVxdWlyZWQoc2VydmljZVN0cmF0ZWd5LmV4ZWMpICYmIGlzRnVuYyhzZXJ2aWNlU3RyYXRlZ3kuZXhlYyksIFwiU2VydmljZSBzdHJhdGVneSBleGVjIGZ1bmN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICByZXR1cm4ge1xuICAgIGRpc2NvdmVyeVNlcnZpY2VzOiBzZXJ2aWNlcyxcbiAgICBzZXJ2aWNlU3RyYXRlZ3lcbiAgfTtcbn07XG5jb25zdCBTZXJ2aWNlUmVnaXN0cnkgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb3JlU3RyYXRlZ2llc1xuICB9ID0gX3JlZjtcbiAgbGV0IHNlcnZpY2VzID0gbmV3IFNldCgpO1xuICBsZXQgc3RyYXRlZ2llcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoY29yZVN0cmF0ZWdpZXMpKTtcbiAgY29uc3QgYWRkID0gc2VydmljZVBsdWdpbiA9PiB7XG4gICAgaW52YXJpYW50KHN1cHBvcnRlZFNlcnZpY2VQbHVnaW5zLmluY2x1ZGVzKHNlcnZpY2VQbHVnaW4udHlwZSksIGBTZXJ2aWNlIFBsdWdpbiB0eXBlICR7c2VydmljZVBsdWdpbi50eXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgaWYgKHNlcnZpY2VQbHVnaW4udHlwZSA9PT0gXCJkaXNjb3Zlcnktc2VydmljZVwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpc2NvdmVyeVNlcnZpY2VzLFxuICAgICAgICBzZXJ2aWNlU3RyYXRlZ3lcbiAgICAgIH0gPSB2YWxpZGF0ZURpc2NvdmVyeVBsdWdpbihzZXJ2aWNlUGx1Z2luKTtcbiAgICAgIHNldFNlcnZpY2VzKGRpc2NvdmVyeVNlcnZpY2VzKTtcbiAgICAgIGlmICghc3RyYXRlZ2llcy5oYXMoc2VydmljZVN0cmF0ZWd5Lm1ldGhvZCkpIHtcbiAgICAgICAgc3RyYXRlZ2llcy5zZXQoc2VydmljZVN0cmF0ZWd5Lm1ldGhvZCwgc2VydmljZVN0cmF0ZWd5LmV4ZWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKHtcbiAgICAgICAgICB0aXRsZTogYEFkZCBTZXJ2aWNlIFBsdWdpbmAsXG4gICAgICAgICAgbWVzc2FnZTogYFNlcnZpY2Ugc3RyYXRlZ3kgZm9yICR7c2VydmljZVN0cmF0ZWd5Lm1ldGhvZH0gYWxyZWFkeSBleGlzdHNgLFxuICAgICAgICAgIGxldmVsOiBMRVZFTFMud2FyblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldFNlcnZpY2VzID0gZGlzY292ZXJ5U2VydmljZXMgPT4gc2VydmljZXMgPSBuZXcgU2V0KFsuLi5kaXNjb3ZlcnlTZXJ2aWNlc10pO1xuICBjb25zdCBnZXRTZXJ2aWNlcyA9ICgpID0+IFsuLi5zZXJ2aWNlc107XG4gIGNvbnN0IGdldFN0cmF0ZWd5ID0gbWV0aG9kID0+IHN0cmF0ZWdpZXMuZ2V0KG1ldGhvZCk7XG4gIGNvbnN0IGdldFN0cmF0ZWdpZXMgPSAoKSA9PiBbLi4uc3RyYXRlZ2llcy5rZXlzKCldO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYWRkLFxuICAgIGdldFNlcnZpY2VzLFxuICAgIGdldFN0cmF0ZWd5LFxuICAgIGdldFN0cmF0ZWdpZXNcbiAgfSk7XG59O1xuY29uc3QgdmFsaWRhdGVQbHVnaW5zID0gcGx1Z2lucyA9PiB7XG4gIGxldCBwbHVnaW5zQXJyYXk7XG4gIGludmFyaWFudChwbHVnaW5zLCBcIk5vIHBsdWdpbnMgc3VwcGxpZWRcIik7XG4gIGlmICghQXJyYXkuaXNBcnJheShwbHVnaW5zKSkge1xuICAgIHBsdWdpbnNBcnJheSA9IFtwbHVnaW5zXTtcbiAgfSBlbHNlIHtcbiAgICBwbHVnaW5zQXJyYXkgPSBbLi4ucGx1Z2luc107XG4gIH1cbiAgZm9yIChjb25zdCBwIG9mIHBsdWdpbnNBcnJheSkge1xuICAgIGludmFyaWFudChpc1JlcXVpcmVkKHAubmFtZSksIFwiUGx1Z2luIG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgaW52YXJpYW50KGlzUmVxdWlyZWQocC5mX3R5cGUpLCBcIlBsdWdpbiBmX3R5cGUgaXMgcmVxdWlyZWRcIik7XG4gICAgaW52YXJpYW50KHN1cHBvcnRlZFBsdWdpbnMuaW5jbHVkZXMocC5mX3R5cGUpLCBgUGx1Z2luIHR5cGUgJHtwLmZfdHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiBwbHVnaW5zQXJyYXk7XG59O1xuY29uc3QgUGx1Z2luUmVnaXN0cnkgPSAoKSA9PiB7XG4gIGNvbnN0IHBsdWdpbnNNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGdldFBsdWdpbnMgPSAoKSA9PiBwbHVnaW5zTWFwO1xuICBjb25zdCBhZGQgPSBwbHVnaW5zID0+IHtcbiAgICBjb25zdCBwbHVnaW5zQXJyYXkgPSB2YWxpZGF0ZVBsdWdpbnMocGx1Z2lucyk7XG4gICAgZm9yIChjb25zdCBwIG9mIHBsdWdpbnNBcnJheSkge1xuICAgICAgcGx1Z2luc01hcC5zZXQocC5uYW1lLCBwKTtcbiAgICAgIGlmIChwLmZfdHlwZSA9PT0gXCJTZXJ2aWNlUGx1Z2luXCIpIHtcbiAgICAgICAgc2VydmljZVJlZ2lzdHJ5LmFkZChwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBhZGQsXG4gICAgZ2V0UGx1Z2luc1xuICB9KTtcbn07XG5sZXQgc2VydmljZVJlZ2lzdHJ5O1xuY29uc3QgZ2V0SXNTZXJ2aWNlUmVnaXN0cnlJbml0aWFsaXplZCA9ICgpID0+IHR5cGVvZiBzZXJ2aWNlUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaW5pdFNlcnZpY2VSZWdpc3RyeSA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBjb3JlU3RyYXRlZ2llc1xuICB9ID0gX3JlZjI7XG4gIGlmIChnZXRJc1NlcnZpY2VSZWdpc3RyeUluaXRpYWxpemVkKCkpIHtcbiAgICByZXR1cm4gc2VydmljZVJlZ2lzdHJ5O1xuICB9XG4gIGNvbnN0IF9zZXJ2aWNlUmVnaXN0cnkgPSBTZXJ2aWNlUmVnaXN0cnkoe1xuICAgIGNvcmVTdHJhdGVnaWVzXG4gIH0pO1xuICBzZXJ2aWNlUmVnaXN0cnkgPSBfc2VydmljZVJlZ2lzdHJ5O1xuICByZXR1cm4gX3NlcnZpY2VSZWdpc3RyeTtcbn07XG5jb25zdCBnZXRTZXJ2aWNlUmVnaXN0cnkgPSAoKSA9PiB7XG4gIGlmICghZ2V0SXNTZXJ2aWNlUmVnaXN0cnlJbml0aWFsaXplZCgpKSB7XG4gICAgY29uc29sZS53YXJuKFwiUmVnaXN0cnkgaXMgbm90IGluaXRhbGl6ZWQsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzdHViIGNvcmUgc3RyYXRlZ2llc1wiKTtcbiAgICByZXR1cm4gaW5pdFNlcnZpY2VSZWdpc3RyeSh7XG4gICAgICBjb3JlU3RyYXRlZ2llczogc3R1YkNvcmVTdHJhdGVnaWVzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlcnZpY2VSZWdpc3RyeTtcbn07XG5jb25zdCBwbHVnaW5SZWdpc3RyeSA9IFBsdWdpblJlZ2lzdHJ5KCk7XG5cbmNvbnN0IG1ha2VEaXNjb3ZlcnlTZXJ2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uU2VydmljZXMgPSB3aW5kb3c/LmZjbF9leHRlbnNpb25zIHx8IFtdO1xuICByZXR1cm4gWy4uLmV4dGVuc2lvblNlcnZpY2VzLCAuLi5nZXRTZXJ2aWNlUmVnaXN0cnkoKS5nZXRTZXJ2aWNlcygpXTtcbn07XG5hc3luYyBmdW5jdGlvbiBnZXREaXNjb3ZlcnlTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgY29uc3QgZGlzY292ZXJ5QXV0aG5JbmNsdWRlID0gYXdhaXQgY29uZmlnLmdldChcImRpc2NvdmVyeS5hdXRobi5pbmNsdWRlXCIsIFtdKTtcbiAgY29uc3QgZGlzY292ZXJ5V2FsbGV0TWV0aG9kID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcImRpc2NvdmVyeS53YWxsZXQubWV0aG9kXCIsIFwiZGlzY292ZXJ5LndhbGxldC5tZXRob2QuZGVmYXVsdFwiXSk7XG4gIGNvbnN0IG1ldGhvZCA9IHNlcnZpY2U/Lm1ldGhvZCA/IHNlcnZpY2UubWV0aG9kIDogZGlzY292ZXJ5V2FsbGV0TWV0aG9kO1xuICBjb25zdCBlbmRwb2ludCA9IHNlcnZpY2U/LmVuZHBvaW50ID8/IChhd2FpdCBjb25maWcuZmlyc3QoW1wiZGlzY292ZXJ5LndhbGxldFwiLCBcImNoYWxsZW5nZS5oYW5kc2hha2VcIl0pKTtcbiAgaW52YXJpYW50KGVuZHBvaW50LCBgXG4gICAgSWYgbm8gc2VydmljZSBpcyBwYXNzZWQgdG8gXCJhdXRoZW50aWNhdGUsXCIgdGhlbiBcImRpc2NvdmVyeS53YWxsZXRcIiBtdXN0IGJlIGRlZmluZWQgaW4gZmNsIGNvbmZpZy5cbiAgICBTZWU6IFwiaHR0cHM6Ly9kb2NzLm9uZmxvdy5vcmcvZmNsL3JlZmVyZW5jZS9hcGkvI3NldHRpbmctY29uZmlndXJhdGlvbi12YWx1ZXNcIlxuICAgIGApO1xuICByZXR1cm4ge1xuICAgIC4uLnNlcnZpY2UsXG4gICAgdHlwZTogXCJhdXRoblwiLFxuICAgIGVuZHBvaW50LFxuICAgIG1ldGhvZCxcbiAgICBkaXNjb3ZlcnlBdXRobkluY2x1ZGVcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmljZXMoX3JlZikge1xuICBsZXQge1xuICAgIHR5cGVzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbmRwb2ludCA9IGF3YWl0IGNvbmZpZy5nZXQoXCJkaXNjb3ZlcnkuYXV0aG4uZW5kcG9pbnRcIik7XG4gIGludmFyaWFudChCb29sZWFuKGVuZHBvaW50KSwgYFwiZGlzY292ZXJ5LmF1dGhuLmVuZHBvaW50XCIgaW4gY29uZmlnIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgY29uc3QgaW5jbHVkZSA9IGF3YWl0IGNvbmZpZy5nZXQoXCJkaXNjb3ZlcnkuYXV0aG4uaW5jbHVkZVwiLCBbXSk7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoZW5kcG9pbnQpO1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdHlwZXMsXG4gICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgaW5jbHVkZSxcbiAgICAgIGNsaWVudFNlcnZpY2VzOiBhd2FpdCBtYWtlRGlzY292ZXJ5U2VydmljZXMoKSxcbiAgICAgIHN1cHBvcnRlZFN0cmF0ZWdpZXM6IGdldFNlcnZpY2VSZWdpc3RyeSgpLmdldFN0cmF0ZWdpZXMoKSxcbiAgICAgIHVzZXJBZ2VudDogd2luZG93Py5uYXZpZ2F0b3I/LnVzZXJBZ2VudCxcbiAgICAgIG5ldHdvcms6IGF3YWl0IGdldENoYWluSWQoKVxuICAgIH0pXG4gIH0pLnRoZW4oZCA9PiBkLmpzb24oKSk7XG59XG5cbmNvbnN0IFNFUlZJQ0VfQUNUT1JfS0VZUyA9IHtcbiAgQVVUSE46IFwiYXV0aG5cIixcbiAgUkVTVUxUUzogXCJyZXN1bHRzXCIsXG4gIFNOQVBTSE9UOiBcIlNOQVBTSE9UXCIsXG4gIFVQREFURUQ6IFwiVVBEQVRFRFwiLFxuICBVUERBVEVfUkVTVUxUUzogXCJVUERBVEVfUkVTVUxUU1wiXG59O1xuY29uc3Qgd2FybiA9IChmYWN0LCBtc2cpID0+IHtcbiAgaWYgKGZhY3QpIHtcbiAgICBjb25zb2xlLndhcm4oYFxuICAgICAgJWNGQ0wgV2FybmluZ1xuICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgJHttc2d9XG4gICAgICBGb3IgbW9yZSBpbmZvLCBwbGVhc2Ugc2VlIHRoZSBkb2NzOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9mY2wvXG4gICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICBgLCBcImZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO1wiKTtcbiAgfVxufTtcbmNvbnN0IGZldGNoU2VydmljZXNGcm9tRGlzY292ZXJ5ID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcnZpY2VzID0gYXdhaXQgZ2V0U2VydmljZXMoe1xuICAgICAgdHlwZXM6IFtTRVJWSUNFX0FDVE9SX0tFWVMuQVVUSE5dXG4gICAgfSk7XG4gICAgc2VuZCQxKFNFUlZJQ0VfQUNUT1JfS0VZUy5BVVRITiwgU0VSVklDRV9BQ1RPUl9LRVlTLlVQREFURV9SRVNVTFRTLCB7XG4gICAgICByZXN1bHRzOiBzZXJ2aWNlc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogYCR7ZXJyb3IubmFtZX0gRXJyb3IgZmV0Y2hpbmcgRGlzY292ZXJ5IEFQSSBzZXJ2aWNlcy5gLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGxldmVsOiBMRVZFTFMuZXJyb3JcbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IEhBTkRMRVJTJDEgPSB7XG4gIFtJTklUXTogYXN5bmMgY3R4ID0+IHtcbiAgICB3YXJuKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIsICdcImZjbC5kaXNjb3ZlcnlcIiBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4nKTtcbiAgICAvLyBJZiB5b3UgY2FsbCB0aGlzIGJlZm9yZSB0aGUgd2luZG93IGlzIGxvYWRlZCBleHRlbnNpb25zIHdpbGwgbm90IGJlIHNldCB5ZXRcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgZmV0Y2hTZXJ2aWNlc0Zyb21EaXNjb3ZlcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgZmV0Y2hTZXJ2aWNlc0Zyb21EaXNjb3ZlcnkoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBbU0VSVklDRV9BQ1RPUl9LRVlTLlVQREFURV9SRVNVTFRTXTogKGN0eCwgX2xldHRlciwgZGF0YSkgPT4ge1xuICAgIGN0eC5tZXJnZShkYXRhKTtcbiAgICBjdHguYnJvYWRjYXN0KFNFUlZJQ0VfQUNUT1JfS0VZUy5VUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBTRVJWSUNFX0FDVE9SX0tFWVMuVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4gY3R4LnVuc3Vic2NyaWJlKGxldHRlci5mcm9tKSxcbiAgW1NFUlZJQ0VfQUNUT1JfS0VZUy5TTkFQU0hPVF06IGFzeW5jIChjdHgsIGxldHRlcikgPT4gbGV0dGVyLnJlcGx5KHtcbiAgICAuLi5jdHguYWxsKClcbiAgfSlcbn07XG5jb25zdCBzcGF3blByb3ZpZGVycyA9ICgpID0+IHNwYXduKEhBTkRMRVJTJDEsIFNFUlZJQ0VfQUNUT1JfS0VZUy5BVVRITik7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuU2VydmljZX0gU2VydmljZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN1YnNjcmlwdGlvbkNhbGxiYWNrXG4gKiBAcmV0dXJucyB7U2VydmljZVtdfVxuICovXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXNjb3ZlcnkgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBBdXRobi5cbiAqIFxuICogQHR5cGVkZWYge29iamVjdH0gQXV0aG5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHN1YnNjcmliZSAtIFN1YnNjcmliZSB0byBEaXNjb3ZlcnkgYXV0aG4gc2VydmljZXNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNuYXBzaG90IC0gR2V0IHRoZSBjdXJyZW50IERpc2NvdmVyeSBhdXRobiBzZXJ2aWNlcyBzcGFuc2hvdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlIC0gVHJpZ2dlciBhbiB1cGRhdGUgb2YgYXV0aG4gc2VydmljZXNcbiAqL1xuY29uc3QgYXV0aG4gPSB7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gLSBTdWJzY3JpYmUgdG8gRGlzY292ZXJ5IGF1dGhuIHNlcnZpY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm5zIHtTdWJzY3JpcHRpb25DYWxsYmFja31cbiAgICovXG4gIHN1YnNjcmliZTogY2IgPT4gc3Vic2NyaWJlcihTRVJWSUNFX0FDVE9SX0tFWVMuQVVUSE4sIHNwYXduUHJvdmlkZXJzLCBjYiksXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gLSBHZXQgdGhlIGN1cnJlbnQgRGlzY292ZXJ5IGF1dGhuIHNlcnZpY2VzIHNwYW5zaG90XG4gICAqIEByZXR1cm5zIHtTZXJ2aWNlW119XG4gICAqL1xuICBzbmFwc2hvdDogKCkgPT4gc25hcHNob3RlcihTRVJWSUNFX0FDVE9SX0tFWVMuQVVUSE4sIHNwYXduUHJvdmlkZXJzKSxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiAtIFRyaWdnZXIgYW4gdXBkYXRlIG9mIGF1dGhuIHNlcnZpY2VzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgdXBkYXRlOiAoKSA9PiBmZXRjaFNlcnZpY2VzRnJvbURpc2NvdmVyeSgpXG59O1xuXG5jb25zdCBkaXNjb3ZlcnkgPSB7XG4gIGF1dGhuXG59O1xuXG52YXIgc2hhMyA9IHt9O1xuXG52YXIgc3BvbmdlID0ge307XG5cbnZhciBwZXJtdXRlID0ge307XG5cbnZhciBjaGkgPSB7fTtcblxudmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KEksIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChPLCBvKSB7XG4gICAgdmFyIG9pID0gbyAqIDI7XG4gICAgdmFyIGlpID0gaSAqIDI7XG4gICAgT1tvaV0gPSBJW2lpXTtcbiAgICBPW29pICsgMV0gPSBJW2lpICsgMV07XG4gIH07XG59O1xudmFyIGNvcHlfMSA9IGNvcHk7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9jb3B5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb3B5XzEpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgY2hpID0gZnVuY3Rpb24gY2hpKF9yZWYpIHtcbiAgICB2YXIgQSA9IF9yZWYuQSxcbiAgICAgIEMgPSBfcmVmLkM7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCAyNTsgeSArPSA1KSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuICAgICAgICAoMCwgX2NvcHlbXCJkZWZhdWx0XCJdKShBLCB5ICsgeCkoQywgeCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgNTsgX3grKykge1xuICAgICAgICB2YXIgeHkgPSAoeSArIF94KSAqIDI7XG4gICAgICAgIHZhciB4MSA9IChfeCArIDEpICUgNSAqIDI7XG4gICAgICAgIHZhciB4MiA9IChfeCArIDIpICUgNSAqIDI7XG4gICAgICAgIEFbeHldIF49IH5DW3gxXSAmIENbeDJdO1xuICAgICAgICBBW3h5ICsgMV0gXj0gfkNbeDEgKyAxXSAmIENbeDIgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBfZGVmYXVsdCA9IGNoaTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKGNoaSk7XG5cbnZhciBpb3RhID0ge307XG5cbnZhciByb3VuZENvbnN0YW50cyA9IHt9O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gIHZhciBST1VORF9DT05TVEFOVFMgPSBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDAsIDMyODk4LCAyMTQ3NDgzNjQ4LCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksIDIxNDc0ODM2NDgsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAwLCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMjE0NzQ4MzY0OCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDAsIDMyNzc4LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMCwgMjE0NzQ4MzY0OSwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQyNF0pO1xuICB2YXIgX2RlZmF1bHQgPSBST1VORF9DT05TVEFOVFM7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShyb3VuZENvbnN0YW50cyk7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9yb3VuZENvbnN0YW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocm91bmRDb25zdGFudHMpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgaW90YSA9IGZ1bmN0aW9uIGlvdGEoX3JlZikge1xuICAgIHZhciBBID0gX3JlZi5BLFxuICAgICAgcm91bmRJbmRleCA9IF9yZWYucm91bmRJbmRleDtcbiAgICB2YXIgaSA9IHJvdW5kSW5kZXggKiAyO1xuICAgIEFbMF0gXj0gX3JvdW5kQ29uc3RhbnRzW1wiZGVmYXVsdFwiXVtpXTtcbiAgICBBWzFdIF49IF9yb3VuZENvbnN0YW50c1tcImRlZmF1bHRcIl1baSArIDFdO1xuICB9O1xuICB2YXIgX2RlZmF1bHQgPSBpb3RhO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkoaW90YSk7XG5cbnZhciByaG9QaSA9IHt9O1xuXG52YXIgcGlTaHVmZmxlcyA9IHt9O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gIHZhciBQSV9TSFVGRkxFUyA9IFsxMCwgNywgMTEsIDE3LCAxOCwgMywgNSwgMTYsIDgsIDIxLCAyNCwgNCwgMTUsIDIzLCAxOSwgMTMsIDEyLCAyLCAyMCwgMTQsIDIyLCA5LCA2LCAxXTtcbiAgdmFyIF9kZWZhdWx0ID0gUElfU0hVRkZMRVM7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShwaVNodWZmbGVzKTtcblxudmFyIHJob09mZnNldHMgPSB7fTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgUkhPX09GRlNFVFMgPSBbMSwgMywgNiwgMTAsIDE1LCAyMSwgMjgsIDM2LCA0NSwgNTUsIDIsIDE0LCAyNywgNDEsIDU2LCA4LCAyNSwgNDMsIDYyLCAxOCwgMzksIDYxLCAyMCwgNDRdO1xuICB2YXIgX2RlZmF1bHQgPSBSSE9fT0ZGU0VUUztcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKHJob09mZnNldHMpO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gIHZhciBfcGlTaHVmZmxlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocGlTaHVmZmxlcyk7XG4gIHZhciBfcmhvT2Zmc2V0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmhvT2Zmc2V0cyk7XG4gIHZhciBfY29weSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29weV8xKTtcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cbiAgdmFyIHJob1BpID0gZnVuY3Rpb24gcmhvUGkoX3JlZikge1xuICAgIHZhciBBID0gX3JlZi5BLFxuICAgICAgQyA9IF9yZWYuQyxcbiAgICAgIFcgPSBfcmVmLlc7XG4gICAgKDAsIF9jb3B5W1wiZGVmYXVsdFwiXSkoQSwgMSkoVywgMCk7XG4gICAgdmFyIEggPSAwO1xuICAgIHZhciBMID0gMDtcbiAgICB2YXIgV2kgPSAwO1xuICAgIHZhciByaSA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgdmFyIGogPSBfcGlTaHVmZmxlc1tcImRlZmF1bHRcIl1baV07XG4gICAgICB2YXIgciA9IF9yaG9PZmZzZXRzW1wiZGVmYXVsdFwiXVtpXTtcbiAgICAgICgwLCBfY29weVtcImRlZmF1bHRcIl0pKEEsIGopKEMsIDApO1xuICAgICAgSCA9IFdbMF07XG4gICAgICBMID0gV1sxXTtcbiAgICAgIHJpID0gMzIgLSByO1xuICAgICAgV2kgPSByIDwgMzIgPyAwIDogMTtcbiAgICAgIFdbV2ldID0gSCA8PCByIHwgTCA+Pj4gcmk7XG4gICAgICBXWyhXaSArIDEpICUgMl0gPSBMIDw8IHIgfCBIID4+PiByaTtcbiAgICAgICgwLCBfY29weVtcImRlZmF1bHRcIl0pKFcsIDApKEEsIGopO1xuICAgICAgKDAsIF9jb3B5W1wiZGVmYXVsdFwiXSkoQywgMCkoVywgMCk7XG4gICAgfVxuICB9O1xuICB2YXIgX2RlZmF1bHQgPSByaG9QaTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKHJob1BpKTtcblxudmFyIHRoZXRhID0ge307XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9jb3B5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb3B5XzEpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgdGhldGEgPSBmdW5jdGlvbiB0aGV0YShfcmVmKSB7XG4gICAgdmFyIEEgPSBfcmVmLkEsXG4gICAgICBDID0gX3JlZi5DLFxuICAgICAgRCA9IF9yZWYuRCxcbiAgICAgIFcgPSBfcmVmLlc7XG4gICAgdmFyIEggPSAwO1xuICAgIHZhciBMID0gMDtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuICAgICAgdmFyIHgyMCA9IHggKiAyO1xuICAgICAgdmFyIHgyMSA9ICh4ICsgNSkgKiAyO1xuICAgICAgdmFyIHgyMiA9ICh4ICsgMTApICogMjtcbiAgICAgIHZhciB4MjMgPSAoeCArIDE1KSAqIDI7XG4gICAgICB2YXIgeDI0ID0gKHggKyAyMCkgKiAyO1xuICAgICAgQ1t4MjBdID0gQVt4MjBdIF4gQVt4MjFdIF4gQVt4MjJdIF4gQVt4MjNdIF4gQVt4MjRdO1xuICAgICAgQ1t4MjAgKyAxXSA9IEFbeDIwICsgMV0gXiBBW3gyMSArIDFdIF4gQVt4MjIgKyAxXSBeIEFbeDIzICsgMV0gXiBBW3gyNCArIDFdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgNTsgX3grKykge1xuICAgICAgKDAsIF9jb3B5W1wiZGVmYXVsdFwiXSkoQywgKF94ICsgMSkgJSA1KShXLCAwKTtcbiAgICAgIEggPSBXWzBdO1xuICAgICAgTCA9IFdbMV07XG4gICAgICBXWzBdID0gSCA8PCAxIHwgTCA+Pj4gMzE7XG4gICAgICBXWzFdID0gTCA8PCAxIHwgSCA+Pj4gMzE7XG4gICAgICBEW194ICogMl0gPSBDWyhfeCArIDQpICUgNSAqIDJdIF4gV1swXTtcbiAgICAgIERbX3ggKiAyICsgMV0gPSBDWyhfeCArIDQpICUgNSAqIDIgKyAxXSBeIFdbMV07XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDI1OyB5ICs9IDUpIHtcbiAgICAgICAgQVsoeSArIF94KSAqIDJdIF49IERbX3ggKiAyXTtcbiAgICAgICAgQVsoeSArIF94KSAqIDIgKyAxXSBePSBEW194ICogMiArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIF9kZWZhdWx0ID0gdGhldGE7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KSh0aGV0YSk7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9jaGkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNoaSk7XG4gIHZhciBfaW90YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaW90YSk7XG4gIHZhciBfcmhvUGkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJob1BpKTtcbiAgdmFyIF90aGV0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQodGhldGEpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgcGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUoKSB7XG4gICAgdmFyIEMgPSBuZXcgVWludDMyQXJyYXkoMTApO1xuICAgIHZhciBEID0gbmV3IFVpbnQzMkFycmF5KDEwKTtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSgyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKEEpIHtcbiAgICAgIGZvciAodmFyIHJvdW5kSW5kZXggPSAwOyByb3VuZEluZGV4IDwgMjQ7IHJvdW5kSW5kZXgrKykge1xuICAgICAgICAoMCwgX3RoZXRhW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgIEE6IEEsXG4gICAgICAgICAgQzogQyxcbiAgICAgICAgICBEOiBELFxuICAgICAgICAgIFc6IFdcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfcmhvUGlbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgQTogQSxcbiAgICAgICAgICBDOiBDLFxuICAgICAgICAgIFc6IFdcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfY2hpW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgIEE6IEEsXG4gICAgICAgICAgQzogQ1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9pb3RhW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgIEE6IEEsXG4gICAgICAgICAgcm91bmRJbmRleDogcm91bmRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIEMuZmlsbCgwKTtcbiAgICAgIEQuZmlsbCgwKTtcbiAgICAgIFcuZmlsbCgwKTtcbiAgICB9O1xuICB9O1xuICB2YXIgX2RlZmF1bHQgPSBwZXJtdXRlO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkocGVybXV0ZSk7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9idWZmZXIgPSByZXF1aXJlJCQwO1xuICB2YXIgX3Blcm11dGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHBlcm11dGUpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgeG9yV29yZHMgPSBmdW5jdGlvbiB4b3JXb3JkcyhJLCBPKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBJLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICB2YXIgbyA9IGkgLyA0O1xuICAgICAgT1tvXSBePSBJW2kgKyA3XSA8PCAyNCB8IElbaSArIDZdIDw8IDE2IHwgSVtpICsgNV0gPDwgOCB8IElbaSArIDRdO1xuICAgICAgT1tvICsgMV0gXj0gSVtpICsgM10gPDwgMjQgfCBJW2kgKyAyXSA8PCAxNiB8IElbaSArIDFdIDw8IDggfCBJW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTztcbiAgfTtcbiAgdmFyIHJlYWRXb3JkcyA9IGZ1bmN0aW9uIHJlYWRXb3JkcyhJLCBPKSB7XG4gICAgZm9yICh2YXIgbyA9IDA7IG8gPCBPLmxlbmd0aDsgbyArPSA4KSB7XG4gICAgICB2YXIgaSA9IG8gLyA0O1xuICAgICAgT1tvXSA9IElbaSArIDFdO1xuICAgICAgT1tvICsgMV0gPSBJW2kgKyAxXSA+Pj4gODtcbiAgICAgIE9bbyArIDJdID0gSVtpICsgMV0gPj4+IDE2O1xuICAgICAgT1tvICsgM10gPSBJW2kgKyAxXSA+Pj4gMjQ7XG4gICAgICBPW28gKyA0XSA9IElbaV07XG4gICAgICBPW28gKyA1XSA9IElbaV0gPj4+IDg7XG4gICAgICBPW28gKyA2XSA9IElbaV0gPj4+IDE2O1xuICAgICAgT1tvICsgN10gPSBJW2ldID4+PiAyNDtcbiAgICB9XG4gICAgcmV0dXJuIE87XG4gIH07XG4gIHZhciBTcG9uZ2UgPSBmdW5jdGlvbiBTcG9uZ2UoX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNhcGFjaXR5ID0gX3JlZi5jYXBhY2l0eSxcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmc7XG4gICAgdmFyIGtlY2NhayA9ICgwLCBfcGVybXV0ZVtcImRlZmF1bHRcIl0pKCk7XG4gICAgdmFyIHN0YXRlU2l6ZSA9IDIwMDtcbiAgICB2YXIgYmxvY2tTaXplID0gY2FwYWNpdHkgLyA4O1xuICAgIHZhciBxdWV1ZVNpemUgPSBzdGF0ZVNpemUgLSBjYXBhY2l0eSAvIDQ7XG4gICAgdmFyIHF1ZXVlT2Zmc2V0ID0gMDtcbiAgICB2YXIgc3RhdGUgPSBuZXcgVWludDMyQXJyYXkoc3RhdGVTaXplIC8gNCk7XG4gICAgdmFyIHF1ZXVlID0gX2J1ZmZlci5CdWZmZXIuYWxsb2NVbnNhZmUocXVldWVTaXplKTtcbiAgICB0aGlzLmFic29yYiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW3F1ZXVlT2Zmc2V0XSA9IGJ1ZmZlcltpXTtcbiAgICAgICAgcXVldWVPZmZzZXQgKz0gMTtcbiAgICAgICAgaWYgKHF1ZXVlT2Zmc2V0ID49IHF1ZXVlU2l6ZSkge1xuICAgICAgICAgIHhvcldvcmRzKHF1ZXVlLCBzdGF0ZSk7XG4gICAgICAgICAga2VjY2FrKHN0YXRlKTtcbiAgICAgICAgICBxdWV1ZU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuICAgIHRoaXMuc3F1ZWV6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgIGJ1ZmZlcjogb3B0aW9ucy5idWZmZXIgfHwgX2J1ZmZlci5CdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tTaXplKSxcbiAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nIHx8IHBhZGRpbmcsXG4gICAgICAgIHF1ZXVlOiBfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShxdWV1ZS5sZW5ndGgpLFxuICAgICAgICBzdGF0ZTogbmV3IFVpbnQzMkFycmF5KHN0YXRlLmxlbmd0aClcbiAgICAgIH07XG4gICAgICBxdWV1ZS5jb3B5KG91dHB1dC5xdWV1ZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dC5zdGF0ZVtpXSA9IHN0YXRlW2ldO1xuICAgICAgfVxuICAgICAgb3V0cHV0LnF1ZXVlLmZpbGwoMCwgcXVldWVPZmZzZXQpO1xuICAgICAgb3V0cHV0LnF1ZXVlW3F1ZXVlT2Zmc2V0XSB8PSBvdXRwdXQucGFkZGluZztcbiAgICAgIG91dHB1dC5xdWV1ZVtxdWV1ZVNpemUgLSAxXSB8PSAxMjg7XG4gICAgICB4b3JXb3JkcyhvdXRwdXQucXVldWUsIG91dHB1dC5zdGF0ZSk7XG4gICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBvdXRwdXQuYnVmZmVyLmxlbmd0aDsgb2Zmc2V0ICs9IHF1ZXVlU2l6ZSkge1xuICAgICAgICBrZWNjYWsob3V0cHV0LnN0YXRlKTtcbiAgICAgICAgcmVhZFdvcmRzKG91dHB1dC5zdGF0ZSwgb3V0cHV0LmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHF1ZXVlU2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5idWZmZXI7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcXVldWUuZmlsbCgwKTtcbiAgICAgIHN0YXRlLmZpbGwoMCk7XG4gICAgICBxdWV1ZU9mZnNldCA9IDA7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgdmFyIF9kZWZhdWx0ID0gU3BvbmdlO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkoc3BvbmdlKTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5TSEFLRSA9IGV4cG9ydHMuU0hBM0hhc2ggPSBleHBvcnRzLlNIQTMgPSBleHBvcnRzLktlY2NhayA9IHZvaWQgMDtcbiAgdmFyIF9idWZmZXIgPSByZXF1aXJlJCQwO1xuICB2YXIgX3Nwb25nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoc3BvbmdlKTtcbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cbiAgdmFyIGNyZWF0ZUhhc2ggPSBmdW5jdGlvbiBjcmVhdGVIYXNoKF9yZWYpIHtcbiAgICB2YXIgYWxsb3dlZFNpemVzID0gX3JlZi5hbGxvd2VkU2l6ZXMsXG4gICAgICBkZWZhdWx0U2l6ZSA9IF9yZWYuZGVmYXVsdFNpemUsXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nO1xuICAgIHJldHVybiBmdW5jdGlvbiBIYXNoKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkZWZhdWx0U2l6ZTtcbiAgICAgIGlmICghdGhpcyB8fCB0aGlzLmNvbnN0cnVjdG9yICE9PSBIYXNoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGFzaChzaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd2VkU2l6ZXMgJiYgIWFsbG93ZWRTaXplcy5pbmNsdWRlcyhzaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBoYXNoIGxlbmd0aFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBzcG9uZ2UgPSBuZXcgX3Nwb25nZVtcImRlZmF1bHRcIl0oe1xuICAgICAgICBjYXBhY2l0eTogc2l6ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwidXRmOFwiO1xuICAgICAgICBpZiAoX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgICAgc3BvbmdlLmFic29yYihpbnB1dCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKF9idWZmZXIuQnVmZmVyLmZyb20oaW5wdXQsIGVuY29kaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHN0cmluZyBvciBidWZmZXJcIik7XG4gICAgICB9O1xuICAgICAgdGhpcy5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb3JtYXRPck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiYmluYXJ5XCI7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIGZvcm1hdE9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgICBmb3JtYXQ6IGZvcm1hdE9yT3B0aW9uc1xuICAgICAgICB9IDogZm9ybWF0T3JPcHRpb25zO1xuICAgICAgICB2YXIgYnVmZmVyID0gc3BvbmdlLnNxdWVlemUoe1xuICAgICAgICAgIGJ1ZmZlcjogb3B0aW9ucy5idWZmZXIsXG4gICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nIHx8IHBhZGRpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcob3B0aW9ucy5mb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3BvbmdlLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9O1xuICB2YXIgS2VjY2FrID0gY3JlYXRlSGFzaCh7XG4gICAgYWxsb3dlZFNpemVzOiBbMjI0LCAyNTYsIDM4NCwgNTEyXSxcbiAgICBkZWZhdWx0U2l6ZTogNTEyLFxuICAgIHBhZGRpbmc6IDFcbiAgfSk7XG4gIGV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuICB2YXIgU0hBMyA9IGNyZWF0ZUhhc2goe1xuICAgIGFsbG93ZWRTaXplczogWzIyNCwgMjU2LCAzODQsIDUxMl0sXG4gICAgZGVmYXVsdFNpemU6IDUxMixcbiAgICBwYWRkaW5nOiA2XG4gIH0pO1xuICBleHBvcnRzLlNIQTMgPSBTSEEzO1xuICB2YXIgU0hBS0UgPSBjcmVhdGVIYXNoKHtcbiAgICBhbGxvd2VkU2l6ZXM6IFsxMjgsIDI1Nl0sXG4gICAgZGVmYXVsdFNpemU6IDI1NixcbiAgICBwYWRkaW5nOiAzMVxuICB9KTtcbiAgZXhwb3J0cy5TSEFLRSA9IFNIQUtFO1xuICB2YXIgU0hBM0hhc2ggPSBLZWNjYWs7XG4gIGV4cG9ydHMuU0hBM0hhc2ggPSBTSEEzSGFzaDtcbiAgU0hBMy5TSEEzSGFzaCA9IFNIQTNIYXNoO1xuICB2YXIgX2RlZmF1bHQgPSBTSEEzO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkoc2hhMyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbkhhc2godXRmOFN0cmluZykge1xuICBjb25zdCBzaGEgPSBuZXcgc2hhMy5TSEEzKDI1Nik7XG4gIHNoYS51cGRhdGUoQnVmZmVyLmZyb20odXRmOFN0cmluZywgXCJ1dGY4XCIpKTtcbiAgcmV0dXJuIHNoYS5kaWdlc3QoXCJoZXhcIik7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdlbmVyYXRlcyBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBJRCBmb3IgYSBnaXZlbiBJbnRlcmFjdGlvbiBUZW1wbGF0ZVxuICogIFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIElEXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGVtcGxhdGVJZChfcmVmKSB7XG4gIGxldCB7XG4gICAgdGVtcGxhdGVcbiAgfSA9IF9yZWY7XG4gIGludmFyaWFudCQxKHRlbXBsYXRlICE9IHVuZGVmaW5lZCwgXCJnZW5lcmF0ZVRlbXBsYXRlSWQoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJvYmplY3RcIiwgXCJnZW5lcmF0ZVRlbXBsYXRlSWQoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlLmZfdHlwZSA9PT0gXCJJbnRlcmFjdGlvblRlbXBsYXRlXCIsIFwiZ2VuZXJhdGVUZW1wbGF0ZUlkKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgb2JqZWN0IG11c3QgYmUgYW4gSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUgPSBub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgc3dpdGNoICh0ZW1wbGF0ZS5mX3ZlcnNpb24pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IHRlbXBsYXRlLmRhdGE7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YS5tZXNzYWdlcykubWFwKGFzeW5jIG1lc3NhZ2VLZXkgPT4gW2F3YWl0IGdlbkhhc2gobWVzc2FnZUtleSksIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YS5tZXNzYWdlcz8uW21lc3NhZ2VLZXldPy5pMThuKS5tYXAoYXN5bmMgaTE4bmtleWxhbmd1YWdlID0+IFthd2FpdCBnZW5IYXNoKGkxOG5rZXlsYW5ndWFnZSksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhLm1lc3NhZ2VzPy5bbWVzc2FnZUtleV0/LmkxOG4/LltpMThua2V5bGFuZ3VhZ2VdKV0pKV0pKTtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YT8uZGVwZW5kZW5jaWVzKS5tYXAoYXN5bmMgZGVwZW5kZW5jeUFkZHJlc3NQbGFjZWhvbGRlciA9PiBbYXdhaXQgZ2VuSGFzaChkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyKSwgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXM/LltkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyXSkubWFwKGFzeW5jIGRlcGVuZGVuY3lDb250cmFjdCA9PiBbYXdhaXQgZ2VuSGFzaChkZXBlbmRlbmN5Q29udHJhY3QpLCBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0ZW1wbGF0ZURhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXJdPy5bZGVwZW5kZW5jeUNvbnRyYWN0XSkubWFwKGFzeW5jIGRlcGVuZGVuY3lDb250cmFjdE5ldHdvcmsgPT4gW2F3YWl0IGdlbkhhc2goZGVwZW5kZW5jeUNvbnRyYWN0TmV0d29yayksIFthd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8uZGVwZW5kZW5jaWVzPy5bZGVwZW5kZW5jeUFkZHJlc3NQbGFjZWhvbGRlcl0/LltkZXBlbmRlbmN5Q29udHJhY3RdPy5bZGVwZW5kZW5jeUNvbnRyYWN0TmV0d29ya10uYWRkcmVzcyksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXM/LltkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyXT8uW2RlcGVuZGVuY3lDb250cmFjdF0/LltkZXBlbmRlbmN5Q29udHJhY3ROZXR3b3JrXS5jb250cmFjdCksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXM/LltkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyXT8uW2RlcGVuZGVuY3lDb250cmFjdF0/LltkZXBlbmRlbmN5Q29udHJhY3ROZXR3b3JrXS5mcV9hZGRyZXNzKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXJdPy5bZGVwZW5kZW5jeUNvbnRyYWN0XT8uW2RlcGVuZGVuY3lDb250cmFjdE5ldHdvcmtdLnBpbiksIGF3YWl0IGdlbkhhc2goU3RyaW5nKHRlbXBsYXRlRGF0YT8uZGVwZW5kZW5jaWVzPy5bZGVwZW5kZW5jeUFkZHJlc3NQbGFjZWhvbGRlcl0/LltkZXBlbmRlbmN5Q29udHJhY3RdPy5bZGVwZW5kZW5jeUNvbnRyYWN0TmV0d29ya10ucGluX2Jsb2NrX2hlaWdodCkpXV0pKV0pKV0pKTtcbiAgICAgIGNvbnN0IF9hcmd1bWVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0ZW1wbGF0ZURhdGE/LltcImFyZ3VtZW50c1wiXSkubWFwKGFzeW5jIGFyZ3VtZW50TGFiZWwgPT4gW2F3YWl0IGdlbkhhc2goYXJndW1lbnRMYWJlbCksIFthd2FpdCBnZW5IYXNoKFN0cmluZyh0ZW1wbGF0ZURhdGE/LltcImFyZ3VtZW50c1wiXT8uW2FyZ3VtZW50TGFiZWxdLmluZGV4KSksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5bXCJhcmd1bWVudHNcIl0/Llthcmd1bWVudExhYmVsXS50eXBlKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LltcImFyZ3VtZW50c1wiXT8uW2FyZ3VtZW50TGFiZWxdLmJhbGFuY2UgfHwgXCJcIiksIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YT8uW1wiYXJndW1lbnRzXCJdPy5bYXJndW1lbnRMYWJlbF0ubWVzc2FnZXMpLm1hcChhc3luYyBhcmd1bWVudE1lc3NhZ2VLZXkgPT4gW2F3YWl0IGdlbkhhc2goYXJndW1lbnRNZXNzYWdlS2V5KSwgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhPy5bXCJhcmd1bWVudHNcIl0/Llthcmd1bWVudExhYmVsXS5tZXNzYWdlcz8uW2FyZ3VtZW50TWVzc2FnZUtleV0uaTE4bikubWFwKGFzeW5jIGkxOG5rZXlsYW5ndWFnZSA9PiBbYXdhaXQgZ2VuSGFzaChpMThua2V5bGFuZ3VhZ2UpLCBhd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8uW1wiYXJndW1lbnRzXCJdPy5bYXJndW1lbnRMYWJlbF0ubWVzc2FnZXM/Llthcmd1bWVudE1lc3NhZ2VLZXldLmkxOG4/LltpMThua2V5bGFuZ3VhZ2VdKV0pKV0pKV1dKSk7XG4gICAgICBjb25zdCBlbmNvZGVkSGV4ID0gZW5jb2RlKFthd2FpdCBnZW5IYXNoKFwiSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKSwgYXdhaXQgZ2VuSGFzaChcIjEuMC4wXCIpLCBhd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8udHlwZSksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5pbnRlcmZhY2UpLCBtZXNzYWdlcywgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LmNhZGVuY2UpLCBkZXBlbmRlbmNpZXMsIF9hcmd1bWVudHNdKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHJldHVybiBnZW5IYXNoKGVuY29kZWRIZXgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW5lcmF0ZVRlbXBsYXRlSWQgRXJyb3I6IFVuc3VwcG9ydGVkIHRlbXBsYXRlIHZlcnNpb25cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB3aGV0aGVyIGEgc2V0IG9mIGF1ZGl0b3JzIGhhdmUgYXVkaXRlZCBhIGdpdmVuIEludGVyYWN0aW9uIFRlbXBsYXRlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHBhcmFtcy5hdWRpdG9ycyAtIEFycmF5IG9mIGF1ZGl0b3JzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdCAtIEZsb3cgSW50ZXJhY3Rpb24gVGVtcGxhdGUgQXVkaXQgY29udHJhY3QgYWRkcmVzc1xuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBPYmplY3Qgb2YgYXVkaXRvciBhZGRyZXNzZXMgYW5kIGF1ZGl0IHN0YXR1c1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0ZW1wbGF0ZSxcbiAgICBhdWRpdG9yc1xuICB9ID0gX3JlZjtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZSAhPSB1bmRlZmluZWQsIFwiZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgdGVtcGxhdGUgPSBub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVcIiwgXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBhbiBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuXG4gIC8vIFJlY29tcHV0ZSBJRCB0byBiZSBzdXJlIGl0IG1hdGNoZXNcbiAgbGV0IHJlY29tcHV0ZWRUZW1wbGF0ZUlEID0gYXdhaXQgZ2VuZXJhdGVUZW1wbGF0ZUlkKHtcbiAgICB0ZW1wbGF0ZVxuICB9KTtcbiAgaWYgKHJlY29tcHV0ZWRUZW1wbGF0ZUlEICE9PSB0ZW1wbGF0ZS5pZCkge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzIERlYnVnIEVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBgQ291bGQgbm90IHJlY29tcHV0ZSBhbmQgbWF0Y2ggdGVtcGxhdGUgSURcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogJHtyZWNvbXB1dGVkVGVtcGxhdGVJRH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJHt0ZW1wbGF0ZS5pZH1cbiAgICAgICAgICAgIGAsXG4gICAgICBsZXZlbDogTEVWRUxTLmRlYnVnXG4gICAgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyBFcnJvcjogQ291bGQgbm90IHJlY29tcHV0ZSBhbmQgbWF0Y2ggdGVtcGxhdGUgSURcIik7XG4gIH1cbiAgc3dpdGNoICh0ZW1wbGF0ZS5mX3ZlcnNpb24pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIGNvbnN0IF9hdWRpdG9ycyA9IGF1ZGl0b3JzIHx8IChhd2FpdCBjb25maWckMSgpLmdldChcImZsb3cuYXVkaXRvcnNcIikpO1xuICAgICAgaW52YXJpYW50JDEoX2F1ZGl0b3JzLCBcImdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMgRXJyb3I6IFJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gZm9yICdmY2wuYXVkaXRvcnMnIGlzIG5vdCBzZXRcIik7XG4gICAgICBpbnZhcmlhbnQkMShBcnJheS5pc0FycmF5KF9hdWRpdG9ycyksIFwiZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyBFcnJvcjogUmVxdWlyZWQgY29uZmlndXJhdGlvbiBmb3IgJ2ZjbC5hdWRpdG9ycycgaXMgbm90IGFuIGFycmF5XCIpO1xuICAgICAgbGV0IEZsb3dJbnRlcmFjdGlvbkF1ZGl0Q29udHJhY3QgPSBvcHRzLmZsb3dJbnRlcmFjdGlvbkF1ZGl0Q29udHJhY3Q7XG4gICAgICBpZiAoIUZsb3dJbnRlcmFjdGlvbkF1ZGl0Q29udHJhY3QpIHtcbiAgICAgICAgY29uc3QgZmNsTmV0d29yayA9IGF3YWl0IGdldENoYWluSWQob3B0cyk7XG4gICAgICAgIGludmFyaWFudCQxKGZjbE5ldHdvcmsgPT09IFwibWFpbm5ldFwiIHx8IGZjbE5ldHdvcmsgPT09IFwidGVzdG5ldFwiLCBcImdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMgRXJyb3I6IFVuYWJsZSB0byBkZXRlcm1pbmUgYWRkcmVzcyBmb3IgRmxvd0ludGVyYWN0aW9uVGVtcGxhdGVBdWRpdCBjb250cmFjdC4gU2V0IGNvbmZpZ3VyYXRpb24gZm9yICdmY2wubmV0d29yaycgdG8gJ21haW5uZXQnIG9yICd0ZXN0bmV0J1wiKTtcbiAgICAgICAgaWYgKGZjbE5ldHdvcmsgPT09IFwibWFpbm5ldFwiKSB7XG4gICAgICAgICAgRmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdCA9IFwiMHhmZDEwMGUzOWQ1MGExM2U2XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdCA9IFwiMHhmNzhiZmMxMmQwYTc4NmRjXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1ZGl0cyA9IGF3YWl0IHF1ZXJ5KHtcbiAgICAgICAgY2FkZW5jZTogYFxuICAgICAgICBpbXBvcnQgRmxvd0ludGVyYWN0aW9uVGVtcGxhdGVBdWRpdCBmcm9tICR7Rmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdH1cbiAgICAgICAgcHViIGZ1biBtYWluKHRlbXBsYXRlSWQ6IFN0cmluZywgYXVkaXRvcnM6IFtBZGRyZXNzXSk6IHtBZGRyZXNzOkJvb2x9IHtcbiAgICAgICAgICByZXR1cm4gRmxvd0ludGVyYWN0aW9uVGVtcGxhdGVBdWRpdC5nZXRIYXNUZW1wbGF0ZUJlZW5BdWRpdGVkQnlBdWRpdG9ycyh0ZW1wbGF0ZUlkOiB0ZW1wbGF0ZUlkLCBhdWRpdG9yczogYXVkaXRvcnMpXG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgYXJnczogKGFyZywgdCkgPT4gW2FyZyhyZWNvbXB1dGVkVGVtcGxhdGVJRCwgdC5TdHJpbmcpLCBhcmcoX2F1ZGl0b3JzLCB0LkFycmF5KHQuQWRkcmVzcykpXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXVkaXRzO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzIEVycm9yOiBVbnN1cHBvcnRlZCB0ZW1wbGF0ZSB2ZXJzaW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1wb3J0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjb250cmFjdE5hbWUsXG4gICAgYWRkcmVzc1xuICB9ID0gX3JlZjtcbiAgcmV0dXJuIHtcbiAgICBjb250cmFjdE5hbWUsXG4gICAgYWRkcmVzcyxcbiAgICBjb250cmFjdDogXCJcIlxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSW1wb3J0cyhjYWRlbmNlKSB7XG4gIGxldCBpbXBvcnRzID0gW107XG4gIGxldCBpbXBvcnRzUmVnID0gL2ltcG9ydCAoKFxcd3wsfCApKykqIGZyb20gMHhcXHcrL2c7XG4gIGxldCBmaWxlSW1wb3J0cyA9IGNhZGVuY2UubWF0Y2goaW1wb3J0c1JlZykgfHwgW107XG4gIGZvciAoY29uc3QgZmlsZUltcG9ydCBvZiBmaWxlSW1wb3J0cykge1xuICAgIGNvbnN0IGltcG9ydExpbmVSZWcgPSAvaW1wb3J0ICgoXFx3K3wsIHwpKikgZnJvbSAoMHhcXHcrKS9nO1xuICAgIGNvbnN0IGltcG9ydExpbmUgPSBpbXBvcnRMaW5lUmVnLmV4ZWMoZmlsZUltcG9ydCk7XG4gICAgY29uc3QgY29udHJhY3RzUmVnID0gLygoPzpcXHcrKSspLD8vZztcbiAgICBjb25zdCBjb250cmFjdHMgPSBpbXBvcnRMaW5lWzFdLm1hdGNoKGNvbnRyYWN0c1JlZykgfHwgW107XG4gICAgZm9yIChjb25zdCBjb250cmFjdCBvZiBjb250cmFjdHMpIHtcbiAgICAgIGltcG9ydHMucHVzaChnZW5lcmF0ZUltcG9ydCh7XG4gICAgICAgIGFkZHJlc3M6IGltcG9ydExpbmVbM10sXG4gICAgICAgIGNvbnRyYWN0TmFtZTogY29udHJhY3QucmVwbGFjZSgvLC9nLCBcIlwiKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW1wb3J0cztcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUHJvZHVjZXMgYSBkZXBlbmRlbmN5IHBpbiBmb3IgYSBjb250cmFjdCBhdCBhIGdpdmVuIGJsb2NrIGhlaWdodFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgY29udGFpbmluZyB0aGUgY29udHJhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY29udHJhY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmJsb2NrSGVpZ2h0IC0gVGhlIGJsb2NrIGhlaWdodCB0byBwcm9kdWNlIHRoZSBkZXBlbmRlbmN5IHBpbiBmb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBpbnRlcmFjdGlvblxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBUaGUgZGVwZW5kZW5jeSBwaW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEZXBlbmRlbmN5UGluKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhZGRyZXNzLFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBibG9ja0hlaWdodFxuICB9ID0gX3JlZjtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpbnZhcmlhbnQkMShhZGRyZXNzICE9IHVuZGVmaW5lZCwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBhZGRyZXNzIH0pIC0tIGFkZHJlc3MgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMShjb250cmFjdE5hbWUgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGNvbnRyYWN0TmFtZSB9KSAtLSBjb250cmFjdE5hbWUgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMShibG9ja0hlaWdodCAhPSB1bmRlZmluZWQsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgYmxvY2tIZWlnaHQgfSkgLS0gYmxvY2tIZWlnaHQgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgYWRkcmVzcyA9PT0gXCJzdHJpbmdcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBhZGRyZXNzIH0pIC0tIGFkZHJlc3MgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIGNvbnRyYWN0TmFtZSA9PT0gXCJzdHJpbmdcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBjb250cmFjdE5hbWUgfSkgLS0gY29udHJhY3ROYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBibG9ja0hlaWdodCA9PT0gXCJudW1iZXJcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBibG9ja0hlaWdodCB9KSAtLSBibG9ja0hlaWdodCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICBsZXQgaG9yaXpvbiA9IFtnZW5lcmF0ZUltcG9ydCh7XG4gICAgY29udHJhY3ROYW1lLFxuICAgIGFkZHJlc3NcbiAgfSldO1xuICBmb3IgKGNvbnN0IGhvcml6b25JbXBvcnQgb2YgaG9yaXpvbikge1xuICAgIGxldCBhY2NvdW50ID0gYXdhaXQgc2VuZChbZ2V0QWNjb3VudChhd2FpdCBjb25maWckMSgpLmdldChob3Jpem9uSW1wb3J0LmFkZHJlc3MsIGhvcml6b25JbXBvcnQuYWRkcmVzcykpLCBhdEJsb2NrSGVpZ2h0KGJsb2NrSGVpZ2h0KV0sIG9wdHMpLnRoZW4oZGVjb2RlKTtcbiAgICBob3Jpem9uSW1wb3J0LmNvbnRyYWN0ID0gYWNjb3VudC5jb250cmFjdHM/Lltob3Jpem9uSW1wb3J0LmNvbnRyYWN0TmFtZV07XG4gICAgaWYgKCFob3Jpem9uSW1wb3J0LmNvbnRyYWN0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRGlkIG5vdCBmaW5kIGV4cGVjdGVkIGNvbnRyYWN0XCIsIGhvcml6b25JbXBvcnQsIGFjY291bnQpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIGV4cGVjdGVkIGNvbnRyYWN0XCIpO1xuICAgIH1cbiAgICBsZXQgY29udHJhY3RJbXBvcnRzID0gZmluZEltcG9ydHMoaG9yaXpvbkltcG9ydC5jb250cmFjdCk7XG4gICAgaG9yaXpvbi5wdXNoKC4uLmNvbnRyYWN0SW1wb3J0cyk7XG4gIH1cbiAgbGV0IGNvbnRyYWN0SGFzaGVzID0gaG9yaXpvbi5tYXAoaXBvcnQgPT4gZ2VuSGFzaChpcG9ydC5jb250cmFjdCkpO1xuICBsZXQgY29udHJhY3RIYXNoZXNKb2luZWQgPSBjb250cmFjdEhhc2hlcy5qb2luKFwiXCIpO1xuICByZXR1cm4gZ2VuSGFzaChjb250cmFjdEhhc2hlc0pvaW5lZCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFByb2R1Y2VzIGEgZGVwZW5kZW5jeSBwaW4gZm9yIGEgY29udHJhY3QgYXQgbGF0ZXN0IHNlYWxlZCBibG9ja1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgY29udGFpbmluZyB0aGUgY29udHJhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY29udHJhY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgaW50ZXJhY3Rpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIGRlcGVuZGVuY3kgcGluXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlRGVwZW5kZW5jeVBpbkF0TGF0ZXN0U2VhbGVkQmxvY2soX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBhZGRyZXNzLFxuICAgIGNvbnRyYWN0TmFtZVxuICB9ID0gX3JlZjI7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IGxhdGVzdFNlYWxlZEJsb2NrID0gYXdhaXQgYmxvY2soe1xuICAgIHNlYWxlZDogdHJ1ZVxuICB9LCBvcHRzKTtcbiAgbGV0IGxhdGVzdFNlYWxlZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0U2VhbGVkQmxvY2s/LmhlaWdodDtcbiAgcmV0dXJuIGdlbmVyYXRlRGVwZW5kZW5jeVBpbih7XG4gICAgYWRkcmVzcyxcbiAgICBjb250cmFjdE5hbWUsXG4gICAgYmxvY2tIZWlnaHQ6IGxhdGVzdFNlYWxlZEJsb2NrSGVpZ2h0XG4gIH0sIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlSW50ZXJmYWNlKHRlbXBsYXRlSW50ZXJmYWNlKSB7XG4gIGlmICh0ZW1wbGF0ZUludGVyZmFjZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoICh0ZW1wbGF0ZUludGVyZmFjZVtcImZfdmVyc2lvblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHRlbXBsYXRlSW50ZXJmYWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlSW50ZXJmYWNlIEVycm9yOiBJbnZhbGlkIEludGVyYWN0aW9uVGVtcGxhdGVJbnRlcmZhY2VcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2VuZXJhdGVzIEludGVyYWN0aW9uIFRlbXBsYXRlIEludGVyZmFjZSBJRCBmb3IgYSBnaXZlbiBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBJbnRlcmZhY2VcbiAqIFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZUludGVyZmFjZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIEludGVyZmFjZVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBJbnRlcmZhY2UgSURcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZW1wbGF0ZUludGVyZmFjZUlkKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0ZW1wbGF0ZUludGVyZmFjZVxuICB9ID0gX3JlZjtcbiAgaW52YXJpYW50JDEodGVtcGxhdGVJbnRlcmZhY2UgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlVGVtcGxhdGVJbnRlcmZhY2VJZCh7IHRlbXBsYXRlSW50ZXJmYWNlIH0pIC0tIHRlbXBsYXRlSW50ZXJmYWNlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlSW50ZXJmYWNlID09PSBcIm9iamVjdFwiLCBcImdlbmVyYXRlVGVtcGxhdGVJbnRlcmZhY2VJZCh7IHRlbXBsYXRlSW50ZXJmYWNlIH0pIC0tIHRlbXBsYXRlSW50ZXJmYWNlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGVJbnRlcmZhY2UuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVJbnRlcmZhY2VcIiwgXCJnZW5lcmF0ZVRlbXBsYXRlSW50ZXJmYWNlSWQoeyB0ZW1wbGF0ZUludGVyZmFjZSB9KSAtLSB0ZW1wbGF0ZUludGVyZmFjZSBvYmplY3QgbXVzdCBiZSBhbiBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuICB0ZW1wbGF0ZUludGVyZmFjZSA9IG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGVJbnRlcmZhY2UodGVtcGxhdGVJbnRlcmZhY2UpO1xuICBzd2l0Y2ggKHRlbXBsYXRlSW50ZXJmYWNlLmZfdmVyc2lvbikge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgY29uc3QgaW50ZXJmYWNlRGF0YSA9IHRlbXBsYXRlSW50ZXJmYWNlLmRhdGE7XG4gICAgICBjb25zdCBlbmNvZGVkSGV4ID0gZW5jb2RlKFthd2FpdCBnZW5IYXNoKFwiSW50ZXJhY3Rpb25UZW1wbGF0ZUludGVyZmFjZVwiKSwgYXdhaXQgZ2VuSGFzaChcIjEuMC4wXCIpLCBhd2FpdCBnZW5IYXNoKGludGVyZmFjZURhdGEuZmxpcCksIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKGludGVyZmFjZURhdGEuYXJndW1lbnRzKS5tYXAoYXN5bmMgYXJndW1lbnRMYWJlbCA9PiBbYXdhaXQgZ2VuSGFzaChhcmd1bWVudExhYmVsKSwgYXdhaXQgZ2VuSGFzaChTdHJpbmcoaW50ZXJmYWNlRGF0YS5hcmd1bWVudHNbYXJndW1lbnRMYWJlbF0uaW5kZXgpKSwgYXdhaXQgZ2VuSGFzaChpbnRlcmZhY2VEYXRhLmFyZ3VtZW50c1thcmd1bWVudExhYmVsXS50eXBlKV0pKV0pLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIGdlbkhhc2goZW5jb2RlZEhleCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdlbmVyYXRlVGVtcGxhdGVJbnRlcmZhY2VJZCBFcnJvcjogVW5zdXBwb3J0ZWQgdGVtcGxhdGVJbnRlcmZhY2UgdmVyc2lvblwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgYW4gSW50ZXJhY3Rpb24gVGVtcGxhdGUncyBwaW5zIG1hdGNoIHRob3NlIGdlbmVyYXRlZCBhdCBhIGJsb2NrIGhlaWdodFxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRlbXBsYXRlIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGUgdG8gY2hlY2sgcGlucyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYmxvY2tIZWlnaHQgLSBCbG9jayBoZWlnaHQgdG8gY2hlY2sgcGlucyBhdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uZXR3b3JrIC0gTmV0d29yayB0byBjaGVjayBwaW5zIG9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciBvciBub3QgdGhlIHBpbnMgbWF0Y2hcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0ZW1wbGF0ZSxcbiAgICBibG9ja0hlaWdodCxcbiAgICBuZXR3b3JrXG4gIH0gPSBfcmVmO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGludmFyaWFudCQxKHRlbXBsYXRlICE9IHVuZGVmaW5lZCwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJvYmplY3RcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGFuIEludGVyYWN0aW9uVGVtcGxhdGVcIik7XG4gIHRlbXBsYXRlID0gbm9ybWFsaXplSW50ZXJhY3Rpb25UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIGludmFyaWFudCQxKG5ldHdvcmsgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IG5ldHdvcmsgfSkgbmV0d29yayBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKGJsb2NrSGVpZ2h0ICE9IHVuZGVmaW5lZCwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBibG9ja0hlaWdodCB9KSBibG9ja0hlaWdodCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBibG9ja0hlaWdodCA9PT0gXCJudW1iZXJcIiwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBibG9ja0hlaWdodCB9KSBibG9ja0hlaWdodCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICBzd2l0Y2ggKHRlbXBsYXRlLmZfdmVyc2lvbikge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgbGV0IHRlbXBsYXRlRGVwZW5kZW5jaWVzUGxhY2Vob2xkZXJLZXlzID0gT2JqZWN0LmtleXModGVtcGxhdGUuZGF0YS5kZXBlbmRlbmNpZXMpO1xuICAgICAgZm9yIChsZXQgdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXkgb2YgdGVtcGxhdGVEZXBlbmRlbmNpZXNQbGFjZWhvbGRlcktleXMpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlRGVwZW5kZW5jeVBsYWNlaG9sZGVyID0gdGVtcGxhdGUuZGF0YS5kZXBlbmRlbmNpZXNbdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXldO1xuICAgICAgICBsZXQgdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdE5hbWVzID0gT2JqZWN0LmtleXModGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXIpO1xuICAgICAgICBmb3IgKGxldCB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0TmFtZSBvZiB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0TmFtZXMpIHtcbiAgICAgICAgICBsZXQgdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdE5ldHdvcmtzID0gdGVtcGxhdGUuZGF0YS5kZXBlbmRlbmNpZXNbdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXldW3RlbXBsYXRlRGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3ROYW1lXTtcbiAgICAgICAgICBsZXQgdGVtcGxhdGVEZXBlbmRlbmN5ID0gdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdE5ldHdvcmtzW25ldHdvcmtdO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVEZXBlbmRlbmN5ID09PSBcInVuZGVmaW5lZFwiKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgcGluID0gYXdhaXQgZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRlbXBsYXRlRGVwZW5kZW5jeS5hZGRyZXNzLFxuICAgICAgICAgICAgY29udHJhY3ROYW1lOiB0ZW1wbGF0ZURlcGVuZGVuY3kuY29udHJhY3QsXG4gICAgICAgICAgICBibG9ja0hlaWdodFxuICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgIGlmIChwaW4gIT09IHRlbXBsYXRlRGVwZW5kZW5jeS5waW4pIHtcbiAgICAgICAgICAgIGxvZyh7XG4gICAgICAgICAgICAgIHRpdGxlOiBcInZlcmlmeURlcGVuZGVuY3lQaW5zU2FtZSBEZWJ1ZyBFcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IHJlY29tcHV0ZSBhbmQgbWF0Y2ggZGVwZW5kZW5jeSBwaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6ICR7dGVtcGxhdGVEZXBlbmRlbmN5LmFkZHJlc3N9IHwgY29udHJhY3Q6ICR7dGVtcGxhdGVEZXBlbmRlbmN5LmNvbnRyYWN0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogJHtwaW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAke3RlbXBsYXRlRGVwZW5kZW5jeS5waW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgbGV2ZWw6IExFVkVMUy5kZWJ1Z1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lIEVycm9yOiBVbnN1cHBvcnRlZCB0ZW1wbGF0ZSB2ZXJzaW9uXCIpO1xuICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiBhbiBJbnRlcmFjdGlvbiBUZW1wbGF0ZSdzIHBpbnMgbWF0Y2ggdGhvc2UgZ2VuZXJhdGVkIGF0IHRoZSBsYXRlc3QgYmxvY2sgaGVpZ2h0XG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGVtcGxhdGUgLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSB0byBjaGVjayBwaW5zIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uZXR3b3JrIC0gTmV0d29yayB0byBjaGVjayBwaW5zIG9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciBvciBub3QgdGhlIHBpbnMgbWF0Y2hcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lQXRMYXRlc3RTZWFsZWRCbG9jayhfcmVmMikge1xuICBsZXQge1xuICAgIHRlbXBsYXRlLFxuICAgIG5ldHdvcmtcbiAgfSA9IF9yZWYyO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBsYXRlc3RTZWFsZWRCbG9jayA9IGF3YWl0IGJsb2NrKHtcbiAgICBzZWFsZWQ6IHRydWVcbiAgfSk7XG4gIGxldCBsYXRlc3RTZWFsZWRCbG9ja0hlaWdodCA9IGxhdGVzdFNlYWxlZEJsb2NrPy5oZWlnaHQ7XG4gIHJldHVybiB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWUoe1xuICAgIHRlbXBsYXRlLFxuICAgIG5ldHdvcmssXG4gICAgYmxvY2tIZWlnaHQ6IGxhdGVzdFNlYWxlZEJsb2NrSGVpZ2h0XG4gIH0sIG9wdHMpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXQgSW50ZXJhY3Rpb24gVGVtcGxhdGUgYXJndW1lbnQgbWVzc2FnZVxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxvY2FsaXphdGlvbiBbbG9jYWxpemF0aW9uPVwiZW4tVVNcIl0gLSBMb2NhbGl6YXRpb24gY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlS2V5IC0gTWVzc2FnZSBrZXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGVtcGxhdGUgLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZVxuICogQHJldHVybnMge3N0cmluZ30gLSBNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGdldFRlbXBsYXRlTWVzc2FnZShfcmVmKSB7XG4gIGxldCB7XG4gICAgbG9jYWxpemF0aW9uID0gXCJlbi1VU1wiLFxuICAgIG1lc3NhZ2VLZXksXG4gICAgdGVtcGxhdGVcbiAgfSA9IF9yZWY7XG4gIGludmFyaWFudCQxKG1lc3NhZ2VLZXksIFwiZ2V0VGVtcGxhdGVNZXNzYWdlKHsgbWVzc2FnZUtleSB9KSAtLSBtZXNzYWdlS2V5IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIG1lc3NhZ2VLZXkgPT09IFwic3RyaW5nXCIsIFwiZ2V0VGVtcGxhdGVNZXNzYWdlKHsgbWVzc2FnZUtleSB9KSAtLSBtZXNzYWdlS2V5IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCQxKGxvY2FsaXphdGlvbiwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyBsb2NhbGl6YXRpb24gfSkgLS0gbG9jYWxpemF0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIGxvY2FsaXphdGlvbiA9PT0gXCJzdHJpbmdcIiwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyBsb2NhbGl6YXRpb24gfSkgLS0gbG9jYWxpemF0aW9uIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCQxKHRlbXBsYXRlICE9IHVuZGVmaW5lZCwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJvYmplY3RcIiwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlLmZfdHlwZSA9PT0gXCJJbnRlcmFjdGlvblRlbXBsYXRlXCIsIFwiZ2V0VGVtcGxhdGVNZXNzYWdlKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgb2JqZWN0IG11c3QgYmUgYW4gSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgY29uc3QgbWVzc2FnZXMgPSB0ZW1wbGF0ZT8uZGF0YT8ubWVzc2FnZXM7XG4gIHJldHVybiBtZXNzYWdlcz8uW21lc3NhZ2VLZXldPy5pMThuPy5bbG9jYWxpemF0aW9uXTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBhcmd1bWVudCBtZXNzYWdlIGJ5IG1lc3NhZ2Uga2V5LCBhcmd1bWVudCBsYWJlbCwgYW5kIGxvY2FsaXphdGlvblxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxpemF0aW9uIFtsb2NhbGl6YXRpb249XCJlbi1VU1wiXSAtIExvY2FsaXphdGlvbiB0byBnZXQgbWVzc2FnZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmFyZ3VtZW50TGFiZWwgLSBBcmd1bWVudCBsYWJlbCB0byBnZXQgbWVzc2FnZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm1lc3NhZ2VLZXkgLSBNZXNzYWdlIGtleSB0byBnZXQgbWVzc2FnZSBmb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzLnRlbXBsYXRlIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGUgdG8gZ2V0IG1lc3NhZ2UgZnJvbVxuICogQHJldHVybnMge3N0cmluZ30gLSBNZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBsb2NhbGl6YXRpb24gPSBcImVuLVVTXCIsXG4gICAgYXJndW1lbnRMYWJlbCxcbiAgICBtZXNzYWdlS2V5LFxuICAgIHRlbXBsYXRlXG4gIH0gPSBfcmVmO1xuICBpbnZhcmlhbnQkMShtZXNzYWdlS2V5LCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgbWVzc2FnZUtleSB9KSAtLSBtZXNzYWdlS2V5IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIG1lc3NhZ2VLZXkgPT09IFwic3RyaW5nXCIsIFwiZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoeyBtZXNzYWdlS2V5IH0pIC0tIG1lc3NhZ2VLZXkgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEoYXJndW1lbnRMYWJlbCwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IGFyZ3VtZW50TGFiZWwgfSkgLS0gYXJndW1lbnRMYWJlbCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBtZXNzYWdlS2V5ID09PSBcInN0cmluZ1wiLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgYXJndW1lbnRMYWJlbCB9KSAtLSBhcmd1bWVudExhYmVsIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCQxKGxvY2FsaXphdGlvbiwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IGxvY2FsaXphdGlvbiB9KSAtLSBsb2NhbGl6YXRpb24gbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgbG9jYWxpemF0aW9uID09PSBcInN0cmluZ1wiLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgbG9jYWxpemF0aW9uIH0pIC0tIGxvY2FsaXphdGlvbiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZSAhPSB1bmRlZmluZWQsIFwiZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJvYmplY3RcIiwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGUuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVcIiwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG9iamVjdCBtdXN0IGJlIGFuIEludGVyYWN0aW9uVGVtcGxhdGVcIik7XG4gIGNvbnN0IGFyZ3MgPSB0ZW1wbGF0ZT8uZGF0YT8uYXJndW1lbnRzO1xuICByZXR1cm4gYXJncz8uW2FyZ3VtZW50TGFiZWxdPy5tZXNzYWdlcz8uW21lc3NhZ2VLZXldPy5pMThuPy5bbG9jYWxpemF0aW9uXTtcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHM6IGdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMsXG4gIGdlbmVyYXRlRGVwZW5kZW5jeVBpbjogZ2VuZXJhdGVEZXBlbmRlbmN5UGluLFxuICBnZW5lcmF0ZURlcGVuZGVuY3lQaW5BdExhdGVzdFNlYWxlZEJsb2NrOiBnZW5lcmF0ZURlcGVuZGVuY3lQaW5BdExhdGVzdFNlYWxlZEJsb2NrLFxuICBnZW5lcmF0ZVRlbXBsYXRlSWQ6IGdlbmVyYXRlVGVtcGxhdGVJZCxcbiAgZ2VuZXJhdGVUZW1wbGF0ZUludGVyZmFjZUlkOiBnZW5lcmF0ZVRlbXBsYXRlSW50ZXJmYWNlSWQsXG4gIHZlcmlmeURlcGVuZGVuY3lQaW5zU2FtZTogdmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lLFxuICB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWVBdExhdGVzdFNlYWxlZEJsb2NrOiB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWVBdExhdGVzdFNlYWxlZEJsb2NrLFxuICBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrOiBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrLFxuICBnZXRUZW1wbGF0ZU1lc3NhZ2U6IGdldFRlbXBsYXRlTWVzc2FnZSxcbiAgZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2U6IGdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlXG59KTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXN9XG4gKi9cbmNvbnN0IHQgPSB0JDE7XG5cbi8vIFNldCBjaGFpbiBpZCBkZWZhdWx0IG9uIGFjY2VzcyBub2RlIGNoYW5nZVxud2F0Y2hGb3JDaGFpbklkQ2hhbmdlcygpO1xuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNlcnZpY2VzKHNlcnZpY2VzVVJMLCBjb2RlKSB7XG4gIGlmIChzZXJ2aWNlc1VSTCA9PSBudWxsIHx8IGNvZGUgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHNlcnZpY2VzVVJMKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjb2RlXCIsIGNvZGUpO1xuICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfVxuICB9KS50aGVuKGQgPT4gZC5qc29uKCkpO1xuICBpZiAoQXJyYXkuaXNBcnJheShyZXNwKSkgcmV0dXJuIHJlc3A7XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIEZpcnN0LUdlbiBXYWxsZXQgUHJvdmlkZXJzXG4gIGNvbnN0IHNlcnZpY2VzID0gW107XG5cbiAgLy8gQ29udmVydCBhdXRob3JpemF0aW9ucyBpbnRvIGF1dGh6IHNlcnZpY2VzXG4gIGlmIChBcnJheS5pc0FycmF5KHJlc3AuYXV0aG9yaXphdGlvbnMpKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiByZXNwLmF1dGhvcml6YXRpb25zKSB7XG4gICAgICBzZXJ2aWNlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJhdXRoelwiLFxuICAgICAgICBrZXlJZDogcmVzcC5rZXlJZCxcbiAgICAgICAgLi4uc2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBQcm92aWRlciBpbmZvIGludG8gYW4gYXV0aG4gc2VydmljZVxuICBpZiAocmVzcC5wcm92aWRlciAhPSBudWxsKSB7XG4gICAgc2VydmljZXMucHVzaCh7XG4gICAgICB0eXBlOiBcImF1dGhuXCIsXG4gICAgICBpZDogXCJ3YWxsZXQtcHJvdmlkZXIjYXV0aG5cIixcbiAgICAgIC4uLnJlc3AucHJvdmlkZXJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VydmljZXM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlU2VydmljZXMoKSB7XG4gIGxldCBzeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgc3gyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgLy8gVE9ETzogTWFrZSB0aGlzIHNtYXJ0ZXJcbiAgcmV0dXJuIFsuLi5zeDEsIC4uLnN4Ml07XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICBcInR5cGVcIjogXCJhdXRoblwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgIFwiaWRcIjogXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIiwgLy8gd2FsbGV0cyBpbnRlcm5hbCBpZCBmb3IgdGhlIHVzZXJcbi8vICAgXCJpZGVudGl0eVwiOiB7XG4vLyAgICAgXCJhZGRyZXNzXCI6IFwiMHhfX19fXCJcbi8vICAgfSxcbi8vICAgXCJwcm92aWRlclwiOiB7XG4vLyAgICAgXCJhZGRyZXNzXCI6IFwiMHhfX19fXCIsXG4vLyAgICAgXCJuYW1lXCI6IFwiQmVzdCBXYWxsZXRcIixcbi8vICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIEJlc3QgV2FsbGV0XCJcbi8vICAgICBcImljb25cIjogXCJodHRwczovL1wiLFxuLy8gICB9XG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVBdXRobihzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLlNFUlZJQ0VfUFJBR01BLFxuICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGUsXG4gICAgICAgIHVpZDogc2VydmljZS5pZCxcbiAgICAgICAgZW5kcG9pbnQ6IHNlcnZpY2UuYXV0aG4sXG4gICAgICAgIGlkOiBzZXJ2aWNlLnBpZCxcbiAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICBhZGRyZXNzOiB3aXRoUHJlZml4KHNlcnZpY2UuYWRkciksXG4gICAgICAgICAgbmFtZTogc2VydmljZS5uYW1lLFxuICAgICAgICAgIGljb246IHNlcnZpY2UuaWNvblxuICAgICAgICB9XG4gICAgICB9O1xuICB9XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJzZXJ2aWNlXCIsXG4vLyAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICBcInR5cGVcIjogXCJhdXRoelwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgIFwibWV0aG9kXCI6IFwiSFRUUC9QT1NUXCIsIC8vIEhUVFAvUE9TVCB8IElGUkFNRS9SUEMgfCBIVFRQL1JQQ1xuLy8gICBcImlkZW50aXR5XCI6IHtcbi8vICAgICAgXCJhZGRyZXNzXCI6IFwiMHhfX19fX19cIixcbi8vICAgICAgXCJrZXlJZFwiOiAwLFxuLy8gICB9LFxuLy8gICBcImRhdGFcIjoge30sIC8vIGluY2x1ZGVkIGluIGJvZHkgb2YgYXV0aHogcmVxdWVzdFxuLy8gICBcInBhcmFtc1wiOiB7fSwgLy8gaW5jbHVkZWQgYXMgcXVlcnkgcGFyYW1zIG9uIGVuZHBvaW50IHVybFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplQXV0aHooc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5TRVJWSUNFX1BSQUdNQSxcbiAgICAgICAgdHlwZTogc2VydmljZS50eXBlLFxuICAgICAgICB1aWQ6IHNlcnZpY2UuaWQsXG4gICAgICAgIGVuZHBvaW50OiBzZXJ2aWNlLmVuZHBvaW50LFxuICAgICAgICBtZXRob2Q6IHNlcnZpY2UubWV0aG9kLFxuICAgICAgICBpZGVudGl0eToge1xuICAgICAgICAgIC4uLklERU5USVRZX1BSQUdNQSxcbiAgICAgICAgICBhZGRyZXNzOiB3aXRoUHJlZml4KHNlcnZpY2UuYWRkciksXG4gICAgICAgICAga2V5SWQ6IHNlcnZpY2Uua2V5SWRcbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1zOiBzZXJ2aWNlLnBhcmFtcyxcbiAgICAgICAgZGF0YTogc2VydmljZS5kYXRhXG4gICAgICB9O1xuICB9XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJzZXJ2aWNlXCIsXG4vLyAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICBcInR5cGVcIjogXCJwcmUtYXV0aHpcIixcbi8vICAgXCJ1aWRcIjogXCJ1bmlxdWVEZWR1cGVLZXlcIixcbi8vICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vcmF3clwiLFxuLy8gICBcIm1ldGhvZFwiOiBcIkhUVFAvUE9TVFwiLCAvLyBIVFRQL1BPU1QgfCBJRlJBTUUvUlBDIHwgSFRUUC9SUENcbi8vICAgXCJpZGVudGl0eVwiOiB7XG4vLyAgICAgIFwiYWRkcmVzc1wiOiBcIjB4X19fX19fXCIsXG4vLyAgICAgIFwia2V5SWRcIjogMCxcbi8vICAgfSxcbi8vICAgXCJkYXRhXCI6IHt9LCAvLyBpbmNsdWRlZCBpbiBib2R5IG9mIHByZS1hdXRoeiByZXF1ZXN0XG4vLyAgIFwicGFyYW1zXCI6IHt9LCAvLyBpbmNsdWRlZCBhcyBxdWVyeSBwYXJhbXMgb24gZW5kcG9pbnQgdXJsXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVQcmVBdXRoeihzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLlNFUlZJQ0VfUFJBR01BLFxuICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGUsXG4gICAgICAgIHVpZDogc2VydmljZS5pZCxcbiAgICAgICAgZW5kcG9pbnQ6IHNlcnZpY2UuZW5kcG9pbnQsXG4gICAgICAgIG1ldGhvZDogc2VydmljZS5tZXRob2QsXG4gICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgLi4uSURFTlRJVFlfUFJBR01BLFxuICAgICAgICAgIGFkZHJlc3M6IHdpdGhQcmVmaXgoc2VydmljZS5hZGRyKSxcbiAgICAgICAgICBrZXlJZDogc2VydmljZS5rZXlJZFxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGFcbiAgICAgIH07XG4gIH1cbn1cblxuLy8ge1xuLy8gICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgIFwidHlwZVwiOiBcImZyYW1lXCIsXG4vLyAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgICBcImRhdGFcIjoge30sICAgLy8gU2VudCB0byBmcmFtZSB3aGVuIHJlYWR5XG4vLyAgICBcInBhcmFtc1wiOiB7fSwgLy8gaW5jbHVkZSBpbiBxdWVyeSBwYXJhbXMgb24gZnJhbWVcbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZyYW1lKHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoc2VydmljZVtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gc2VydmljZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2xkOiBzZXJ2aWNlLFxuICAgICAgICAuLi5TRVJWSUNFX1BSQUdNQSxcbiAgICAgICAgdHlwZTogXCJmcmFtZVwiLFxuICAgICAgICBlbmRwb2ludDogc2VydmljZS5lbmRwb2ludCxcbiAgICAgICAgcGFyYW1zOiBzZXJ2aWNlLnBhcmFtcyB8fCB7fSxcbiAgICAgICAgZGF0YTogc2VydmljZS5kYXRhIHx8IHt9XG4gICAgICB9O1xuICB9XG59XG5cbi8vIHtcbi8vICAgIFwiZl90eXBlXCI6IFwiU2VydmljZVwiLFxuLy8gICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgICBcInR5cGVcIjogXCJiYWNrLWNoYW5uZWwtcnBjXCIsXG4vLyAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgICBcIm1ldGhvZFwiOiBcIkhUVFAvR0VUXCIsIC8vIEhUVFAvR0VUIHwgSFRUUC9QT1NUXG4vLyAgICBcImRhdGFcIjoge30sICAgICAgICAgICAvLyBpbmNsdWRlZCBpbiBib2R5IG9mIHJwY1xuLy8gICAgXCJwYXJhbXNcIjoge30sICAgICAgICAgLy8gaW5jbHVkZWQgYXMgcXVlcnkgcGFyYW1zIG9uIGVuZHBvaW50IHVybFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplQmFja0NoYW5uZWxScGMoc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5TRVJWSUNFX1BSQUdNQSxcbiAgICAgICAgdHlwZTogXCJiYWNrLWNoYW5uZWwtcnBjXCIsXG4gICAgICAgIGVuZHBvaW50OiBzZXJ2aWNlLmVuZHBvaW50LFxuICAgICAgICBtZXRob2Q6IHNlcnZpY2UubWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zIHx8IHt9LFxuICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEgfHwge31cbiAgICAgIH07XG4gIH1cbn1cblxuLy8ge1xuLy8gICBcImZfdHlwZVwiOiBcIlNlcnZpY2VcIixcbi8vICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgIFwidHlwZVwiOiBcIm9wZW4taWRcIixcbi8vICAgXCJ1aWRcIjogXCJ1bmlxdWVEZWR1cGVLZXlcIixcbi8vICAgXCJtZXRob2Q6IFwiZGF0YVwiLFxuLy8gICBcImRhdGFcIjoge1xuLy8gICAgICBcInByb2ZpbGVcIjoge1xuLy8gICAgICAgIFwibmFtZVwiOiBcIkJvYlwiLFxuLy8gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCdWlsZGVyXCIsXG4vLyAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUm9iZXJ0XCIsXG4vLyAgICAgICAgXCJtaWRkbGVfbmFtZVwiOiBcInRoZVwiLFxuLy8gICAgICAgIFwibmlja25hbWVcIjogXCJCb2IgdGhlIEJ1aWxkZXJcIixcbi8vICAgICAgICBcInBlcmZlcnJlZF91c2VybmFtZVwiOiBcImJvYlwiLFxuLy8gICAgICAgIFwicHJvZmlsZVwiOiBcImh0dHBzOi8vd3d3LmJvYnRoZWJ1aWxkZXIuY29tL1wiLFxuLy8gICAgICAgIFwicGljdHVyZVwiOiBcImh0dHBzOi8vYXZhdGFycy5vbmZsb3cub3JnL2F2YXRhci9ib2JcIixcbi8vICAgICAgICBcImdlbmRlclwiOiBcIi4uLlwiLFxuLy8gICAgICAgIFwiYmlydGhkYXlcIjogXCIyMDAxLTAxLTE4XCIsXG4vLyAgICAgICAgXCJ6b25laW5mb1wiOiBcIkFtZXJpY2EvVmFuY291dmVyXCIsXG4vLyAgICAgICAgXCJsb2NhbGVcIjogXCJlbi11c1wiLFxuLy8gICAgICAgIFwidXBkYXRlZF9hdFwiOiBcIjE2MTQ5NzA3OTczODhcIlxuLy8gICAgICB9LFxuLy8gICAgICBcImVtYWlsXCI6IHtcbi8vICAgICAgICBcImVtYWlsXCI6IFwiYm9iQGJvYi5ib2JcIixcbi8vICAgICAgICBcImVtYWlsX3ZlcmlmaWVkXCI6IHRydWVcbi8vICAgICAgfSxcbi8vICAgICAgXCJhZGRyZXNzXCI6IHtcbi8vICAgICAgICBcImFkZHJlc3NcIjogXCJPbmUgQXBwbGUgUGFyayBXYXksIEN1cGVydGlubywgQ0EgOTUwMTQsIFVTQVwiXG4vLyAgICAgIH0sXG4vLyAgICAgIFwicGhvbmVcIjoge1xuLy8gICAgICAgIFwicGhvbmVfbnVtYmVyXCI6IFwiKzEgKHh4eCkgeXl5LXp6enpcIixcbi8vICAgICAgICBcInBob25lX251bWJlcl92ZXJpZmllZFwiOiB0cnVlXG4vLyAgICAgIH0sXG4vLyAgICAgIFwic29jaWFsXCI6IHtcbi8vICAgICAgICBcInR3aXR0ZXJcIjogXCJAX3F2dmdcIixcbi8vICAgICAgICBcInR3aXR0ZXJfdmVyaWZpZWRcIjogdHJ1ZVxuLy8gICAgICB9LFxuLy8gICB9XG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVPcGVuSWQoc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyB7XG4vLyAgIFwiZl90eXBlXCI6IFwiU2VydmljZVwiLFxuLy8gICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgXCJ0eXBlXCI6IFwidXNlci1zaWduYXR1cmVcIixcbi8vICAgXCJ1aWRcIjogXCJ1bmlxdWVEZWR1cGVLZXlcIixcbi8vICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vcmF3clwiLFxuLy8gICBcIm1ldGhvZFwiOiBcIklGUkFNRS9SUENcIiwgLy8gSFRUUC9QT1NUIHwgSUZSQU1FL1JQQyB8IEhUVFAvUlBDXG4vLyAgIFwiaWRcIjogXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIiwgLy8gd2FsbGV0cyBpbnRlcm5hbCBpZCBmb3IgdGhlIHVzZXJcbi8vICAgXCJkYXRhXCI6IHt9LCAvLyBpbmNsdWRlZCBpbiBib2R5IG9mIHVzZXItc2lnbmF0dXJlIHJlcXVlc3Rcbi8vICAgXCJwYXJhbXNcIjoge30sIC8vIGluY2x1ZGVkIGFzIHF1ZXJ5IHBhcmFtcyBvbiBlbmRwb2ludCB1cmxcbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVzZXJTaWduYXR1cmUoc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVzZXItc2lnbmF0dXJlIHNlcnZpY2VcIik7XG4gIH1cbn1cblxuLy8ge1xuLy8gICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgIHR5cGU6IFwibG9jYWwtdmlld1wiLFxuLy8gICAgbWV0aG9kOiBcIlZJRVcvSUZSQU1FXCIsXG4vLyAgICBlbmRwb2ludDogXCJodHRwczovL3dvb3Qub3JnL2F1dGh6L2xvY2FsXCIsXG4vLyAgICBkYXRhOiB7fSxcbi8vICAgIHBhcmFtczoge30sXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbFZpZXcocmVzcCkge1xuICBpZiAocmVzcCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKHJlc3AubWV0aG9kID09IG51bGwpIHtcbiAgICByZXNwID0ge1xuICAgICAgLi4ucmVzcCxcbiAgICAgIHR5cGU6IFwibG9jYWwtdmlld1wiLFxuICAgICAgbWV0aG9kOiBcIlZJRVcvSUZSQU1FXCJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmVzcFtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uU0VSVklDRV9QUkFHTUEsXG4gICAgICAgIHR5cGU6IHJlc3AudHlwZSB8fCBcImxvY2FsLXZpZXdcIixcbiAgICAgICAgbWV0aG9kOiByZXNwLm1ldGhvZCxcbiAgICAgICAgZW5kcG9pbnQ6IHJlc3AuZW5kcG9pbnQsXG4gICAgICAgIGRhdGE6IHJlc3AuZGF0YSB8fCB7fSxcbiAgICAgICAgcGFyYW1zOiByZXNwLnBhcmFtcyB8fCB7fVxuICAgICAgfTtcbiAgfVxufVxuXG4vLyB7XG4vLyAgIFwiZl90eXBlXCI6IFwiU2VydmljZVwiLCAgICAgICAgICAgICAgICAgICAgLy8gSXRzIGEgc2VydmljZSFcbi8vICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dzIHRoZSB2MS4wLjAgc3BlYyBmb3IgdGhlIHNlcnZpY2Vcbi8vICAgXCJ0eXBlXCI6IFwiYWNjb3VudC1wcm9vZlwiLCAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBvZiBzZXJ2aWNlIGl0IGlzXG4vLyAgIFwibWV0aG9kXCI6IFwiREFUQVwiLCAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRzIGRhdGEhXG4vLyAgIFwidWlkXCI6IFwiYXdlc29tZS13YWxsZXQjYWNjb3VudC1wcm9vZlwiLCAgLy8gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNlcnZpY2Vcbi8vICAgXCJkYXRhXCI6IHtcbi8vICAgICBcImZfdHlwZVwiOiBcImFjY291bnQtcHJvb2ZcIixcbi8vICAgICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgICBcIm5vbmNlXCI6IFwiMEExQkMyRkZcIiwgICAgICAgICAgICAgICAgICAvLyBOb25jZSBzaWduZWQgYnkgdGhlIGN1cnJlbnQgYWNjb3VudC1wcm9vZiAobWluaW11bSAzMiBieXRlcyBpbiB0b3RhbCwgaS5lIDY0IGhleCBjaGFyYWN0ZXJzKVxuLy8gICAgIFwiYWRkcmVzc1wiOiBcIjB4VVNFUlwiLCAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyJ3MgYWRkcmVzcyAoOCBieXRlcywgaS5lIDE2IGhleCBjaGFyYWN0ZXJzKVxuLy8gICAgIFwic2lnbmF0dXJlXCI6IENvbXBvc2l0ZVNpZ25hdHVyZSwgICAgICAvLyBhZGRyZXNzIChzYW5zLXByZWZpeCksIGtleUlkLCBzaWduYXR1cmUgKGhleClcbi8vIH1cblxuZnVuY3Rpb24gbm9ybWFsaXplQWNjb3VudFByb29mKHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoc2VydmljZVtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gc2VydmljZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGQ0wgTm9ybWFsaXplciBFcnJvcjogSW52YWxpZCBhY2NvdW50LXByb29mIHNlcnZpY2VgKTtcbiAgfVxufVxuXG4vLyB7XG4vLyAgIFwiZl90eXBlXCI6IFwiU2VydmljZVwiLFxuLy8gICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgXCJ0eXBlXCI6IFwiYXV0aG4tcmVmcmVzaFwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgIFwibWV0aG9kXCI6IFwiSFRUUC9QT1NUXCIsICAvLyBcIkhUVFAvUE9TVFwiLCAvLyBIVFRQL1BPU1QgfCBJRlJBTUUvUlBDIHwgSFRUUC9SUENcbi8vICAgXCJpZFwiOiBcInh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFwiLCAvLyB3YWxsZXRzIGludGVybmFsIGlkIGZvciB0aGUgdXNlclxuLy8gICBcImRhdGFcIjoge30sIC8vIGluY2x1ZGVkIGluIGJvZHkgb2YgcmVxdWVzdFxuLy8gICBcInBhcmFtc1wiOiB7fSwgLy8gaW5jbHVkZWQgYXMgcXVlcnkgcGFyYW1zIG9uIGVuZHBvaW50IHVybFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplQXV0aG5SZWZyZXNoKHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoc2VydmljZVtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gc2VydmljZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdXRobi1yZWZyZXNoIHNlcnZpY2VcIik7XG4gIH1cbn1cblxuY29uc3Qgc2VydmljZU5vcm1hbGl6ZXJzID0ge1xuICBcImJhY2stY2hhbm5lbC1ycGNcIjogbm9ybWFsaXplQmFja0NoYW5uZWxScGMsXG4gIFwicHJlLWF1dGh6XCI6IG5vcm1hbGl6ZVByZUF1dGh6LFxuICBhdXRoejogbm9ybWFsaXplQXV0aHosXG4gIGF1dGhuOiBub3JtYWxpemVBdXRobixcbiAgZnJhbWU6IG5vcm1hbGl6ZUZyYW1lLFxuICBcIm9wZW4taWRcIjogbm9ybWFsaXplT3BlbklkLFxuICBcInVzZXItc2lnbmF0dXJlXCI6IG5vcm1hbGl6ZVVzZXJTaWduYXR1cmUsXG4gIFwibG9jYWwtdmlld1wiOiBub3JtYWxpemVMb2NhbFZpZXcsXG4gIFwiYWNjb3VudC1wcm9vZlwiOiBub3JtYWxpemVBY2NvdW50UHJvb2YsXG4gIFwiYXV0aG4tcmVmcmVzaFwiOiBub3JtYWxpemVBdXRoblJlZnJlc2hcbn07XG5mdW5jdGlvbiBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UsIGRhdGEpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9ybWFsaXplZCA9IHNlcnZpY2VOb3JtYWxpemVyc1tzZXJ2aWNlLnR5cGVdKHNlcnZpY2UsIGRhdGEpO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFVucmVjb2duaXplZCBGQ0wgU2VydmljZSBUeXBlIFske3NlcnZpY2UudHlwZX1dYCwgc2VydmljZSwgZXJyb3IpO1xuICAgIHJldHVybiBzZXJ2aWNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlcml2ZUNvbXBvc2l0ZUlkKGF1dGhuKSB7XG4gIHJldHVybiBybHAuZW5jb2RlKFthdXRobi5wcm92aWRlci5hZGRyZXNzIHx8IGF1dGhuLnByb3ZpZGVyLm5hbWUgfHwgXCJVTlNQRUNJRklFRFwiLCBhdXRobi5pZF0pLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRGF0YShkYXRhKSB7XG4gIGRhdGEuYWRkciA9IGRhdGEuYWRkciA/IHdpdGhQcmVmaXgoZGF0YS5hZGRyKSA6IG51bGw7XG4gIGRhdGEucGFkZHIgPSBkYXRhLnBhZGRyID8gd2l0aFByZWZpeChkYXRhLnBhZGRyKSA6IG51bGw7XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gZmluZFNlcnZpY2UodHlwZSwgc2VydmljZXMpIHtcbiAgcmV0dXJuIHNlcnZpY2VzLmZpbmQoZCA9PiBkLnR5cGUgPT09IHR5cGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRVc2VyKGRhdGEpIHtcbiAgZGF0YSA9IG5vcm1hbGl6ZURhdGEoZGF0YSk7XG4gIHZhciBzZXJ2aWNlcyA9IG1lcmdlU2VydmljZXMoZGF0YS5zZXJ2aWNlcyB8fCBbXSwgYXdhaXQgZmV0Y2hTZXJ2aWNlcyhkYXRhLmhrcywgZGF0YS5jb2RlKSkubWFwKHNlcnZpY2UgPT4gbm9ybWFsaXplU2VydmljZShzZXJ2aWNlLCBkYXRhKSk7XG4gIGNvbnN0IGF1dGhuID0gZmluZFNlcnZpY2UoXCJhdXRoblwiLCBzZXJ2aWNlcyk7XG4gIHJldHVybiB7XG4gICAgLi4uVVNFUl9QUkFHTUEsXG4gICAgYWRkcjogd2l0aFByZWZpeChkYXRhLmFkZHIpLFxuICAgIGNpZDogZGVyaXZlQ29tcG9zaXRlSWQoYXV0aG4pLFxuICAgIGxvZ2dlZEluOiB0cnVlLFxuICAgIHNlcnZpY2VzOiBzZXJ2aWNlcyxcbiAgICBleHBpcmVzQXQ6IGRhdGEuZXhwaXJlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZXJ2aWNlT2ZUeXBlKCkge1xuICBsZXQgc2VydmljZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gc2VydmljZXMuZmluZChzZXJ2aWNlID0+IHNlcnZpY2UudHlwZSA9PT0gdHlwZSk7XG59XG5cbmNvbnN0IGV4ZWNTdHJhdGVneSA9IGFzeW5jIF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHNlcnZpY2UsXG4gICAgYm9keSxcbiAgICBjb25maWcsXG4gICAgb3B0c1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc3RyYXRlZ3kgPSBnZXRTZXJ2aWNlUmVnaXN0cnkoKS5nZXRTdHJhdGVneShzZXJ2aWNlLm1ldGhvZCk7XG4gIHJldHVybiBzdHJhdGVneSh7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGV4ZWNTZXJ2aWNlKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBtc2cgPSB7fSxcbiAgICBjb25maWcgPSB7fSxcbiAgICBvcHRzID0ge30sXG4gICAgcGxhdGZvcm1cbiAgfSA9IF9yZWYyO1xuICBtc2cuZGF0YSA9IHNlcnZpY2UuZGF0YTtcbiAgY29uc3QgZXhlY0NvbmZpZyA9IHtcbiAgICBzZXJ2aWNlczogYXdhaXQgY29uZmlnTGVucygvXnNlcnZpY2VcXC4vKSxcbiAgICBhcHA6IGF3YWl0IGNvbmZpZ0xlbnMoL15hcHBcXC5kZXRhaWxcXC4vKSxcbiAgICBjbGllbnQ6IHtcbiAgICAgIC4uLmNvbmZpZy5jbGllbnQsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICBmY2xMaWJyYXJ5OiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmNsLWpzXCIsXG4gICAgICBob3N0bmFtZTogd2luZG93Py5sb2NhdGlvbj8uaG9zdG5hbWUgPz8gbnVsbCxcbiAgICAgIG5ldHdvcms6IGF3YWl0IGdldENoYWluSWQob3B0cylcbiAgICB9XG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY1N0cmF0ZWd5KHtcbiAgICAgIHNlcnZpY2UsXG4gICAgICBib2R5OiBtc2csXG4gICAgICBjb25maWc6IGV4ZWNDb25maWcsXG4gICAgICBvcHRzXG4gICAgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IFwiUkVESVJFQ1RcIikge1xuICAgICAgaW52YXJpYW50KHNlcnZpY2UudHlwZSA9PT0gcmVzLmRhdGEudHlwZSwgXCJDYW5ub3Qgc2hpZnQgcmVjdXJzaXZlIHNlcnZpY2UgdHlwZSBpbiBleGVjU2VydmljZVwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBleGVjU2VydmljZSh7XG4gICAgICAgIHNlcnZpY2U6IHJlcy5kYXRhLFxuICAgICAgICBtc2csXG4gICAgICAgIGNvbmZpZzogZXhlY0NvbmZpZyxcbiAgICAgICAgb3B0c1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogYEVycm9yIG9uIGV4ZWNTZXJ2aWNlICR7c2VydmljZT8udHlwZX1gLFxuICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgICBsZXZlbDogTEVWRUxTLmVycm9yXG4gICAgfSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8ge1xuLy8gICAgXCJmX3R5cGVcIjogXCJDb21wb3NpdGVTaWduYXR1cmVcIixcbi8vICAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICAgXCJhZGRyXCI6IFwiX19fX19cIiwgICAgICAgICAvLyBzYW5zLXByZWZpeFxuLy8gICAgXCJzaWduYXR1cmVcIjogXCJhZGZlMTIzNFwiLCAvLyBoZXhcbi8vICAgIFwia2V5SWRcIjogMyxcbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvc2l0ZVNpZ25hdHVyZShyZXNwKSB7XG4gIGlmIChyZXNwID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHJlc3BbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLkNPTVBPU0lURV9TSUdOQVRVUkVfUFJBR01BLFxuICAgICAgICBhZGRyOiBzYW5zUHJlZml4KHJlc3AuYWRkciB8fCByZXNwLmFkZHJlc3MpLFxuICAgICAgICBzaWduYXR1cmU6IHJlc3Auc2lnbmF0dXJlIHx8IHJlc3Auc2lnLFxuICAgICAgICBrZXlJZDogcmVzcC5rZXlJZFxuICAgICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJAb25mbG93L3R5cGVkZWZzXCIpLkN1cnJlbnRVc2VyfSBDdXJyZW50VXNlclxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuQ29tcG9zaXRlU2lnbmF0dXJlfSBDb21wb3NpdGVTaWduYXR1cmVcbiAqL1xuXG5jb25zdCBpc0ZuID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgTkFNRSA9IFwiQ1VSUkVOVF9VU0VSXCI7XG5jb25zdCBVUERBVEVEID0gXCJDVVJSRU5UX1VTRVIvVVBEQVRFRFwiO1xuY29uc3QgU05BUFNIT1QgPSBcIlNOQVBTSE9UXCI7XG5jb25zdCBTRVRfQ1VSUkVOVF9VU0VSID0gXCJTRVRfQ1VSUkVOVF9VU0VSXCI7XG5jb25zdCBERUxfQ1VSUkVOVF9VU0VSID0gXCJERUxfQ1VSUkVOVF9VU0VSXCI7XG5jb25zdCBEQVRBID0gYHtcbiAgXCJmX3R5cGVcIjogXCJVc2VyXCIsXG4gIFwiZl92c25cIjogXCIxLjAuMFwiLFxuICBcImFkZHJcIjpudWxsLFxuICBcImNpZFwiOm51bGwsXG4gIFwibG9nZ2VkSW5cIjpudWxsLFxuICBcImV4cGlyZXNBdFwiOm51bGwsXG4gIFwic2VydmljZXNcIjpbXVxufWA7XG5jb25zdCBnZXRTdG9yZWRVc2VyID0gYXN5bmMgc3RvcmFnZSA9PiB7XG4gIGNvbnN0IGZhbGxiYWNrID0gSlNPTi5wYXJzZShEQVRBKTtcbiAgY29uc3Qgc3RvcmVkID0gYXdhaXQgc3RvcmFnZS5nZXQoTkFNRSk7XG4gIGlmIChzdG9yZWQgIT0gbnVsbCAmJiBmYWxsYmFja1tcImZfdnNuXCJdICE9PSBzdG9yZWRbXCJmX3ZzblwiXSkge1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShOQU1FKTtcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgcmV0dXJuIHN0b3JlZCB8fCBmYWxsYmFjaztcbn07XG5jb25zdCBIQU5ETEVSUyA9IHtcbiAgW0lOSVRdOiBhc3luYyBjdHggPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFxuICAgICAgICAlY0ZDTCBXYXJuaW5nXG4gICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgXCJjdXJyZW50VXNlclwiIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgICBGb3IgbW9yZSBpbmZvLCBwbGVhc2Ugc2VlIHRoZSBkb2NzOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9mY2wvXG4gICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgYCwgXCJmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcIik7XG4gICAgfVxuICAgIGN0eC5tZXJnZShKU09OLnBhcnNlKERBVEEpKTtcbiAgICBjb25zdCBzdG9yYWdlID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcImZjbC5zdG9yYWdlXCIsIFwiZmNsLnN0b3JhZ2UuZGVmYXVsdFwiXSk7XG4gICAgaWYgKHN0b3JhZ2UuY2FuKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0U3RvcmVkVXNlcihzdG9yYWdlKTtcbiAgICAgIGlmIChub3RFeHBpcmVkKHVzZXIpKSBjdHgubWVyZ2UodXNlcik7XG4gICAgfVxuICB9LFxuICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVU5TVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICB9LFxuICBbU05BUFNIT1RdOiBhc3luYyAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXR0ZXIucmVwbHkoe1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtTRVRfQ1VSUkVOVF9VU0VSXTogYXN5bmMgKGN0eCwgbGV0dGVyLCBkYXRhKSA9PiB7XG4gICAgY3R4Lm1lcmdlKGRhdGEpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBhd2FpdCBjb25maWcuZmlyc3QoW1wiZmNsLnN0b3JhZ2VcIiwgXCJmY2wuc3RvcmFnZS5kZWZhdWx0XCJdKTtcbiAgICBpZiAoc3RvcmFnZS5jYW4pIHN0b3JhZ2UucHV0KE5BTUUsIGN0eC5hbGwoKSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0RFTF9DVVJSRU5UX1VTRVJdOiBhc3luYyAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgubWVyZ2UoSlNPTi5wYXJzZShEQVRBKSk7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJmY2wuc3RvcmFnZVwiLCBcImZjbC5zdG9yYWdlLmRlZmF1bHRcIl0pO1xuICAgIGlmIChzdG9yYWdlLmNhbikgc3RvcmFnZS5wdXQoTkFNRSwgY3R4LmFsbCgpKTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9XG59O1xuY29uc3Qgc3Bhd25DdXJyZW50VXNlciA9ICgpID0+IHNwYXduKEhBTkRMRVJTLCBOQU1FKTtcbmZ1bmN0aW9uIG5vdEV4cGlyZWQodXNlcikge1xuICByZXR1cm4gdXNlci5leHBpcmVzQXQgPT0gbnVsbCB8fCB1c2VyLmV4cGlyZXNBdCA9PT0gMCB8fCB1c2VyLmV4cGlyZXNBdCA+IERhdGUubm93KCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50UHJvb2ZEYXRhKCkge1xuICBsZXQgYWNjb3VudFByb29mRGF0YVJlc29sdmVyID0gYXdhaXQgY29uZmlnLmdldChcImZjbC5hY2NvdW50UHJvb2YucmVzb2x2ZXJcIik7XG4gIGlmIChhY2NvdW50UHJvb2ZEYXRhUmVzb2x2ZXIgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoIWlzRm4oYWNjb3VudFByb29mRGF0YVJlc29sdmVyKSkge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogXCJBY2NvdW50IFByb29mIERhdGEgUmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gICAgICBtZXNzYWdlOiBgQ2hlY2sgZmNsLmFjY291bnRQcm9vZi5yZXNvbHZlciBjb25maWd1cmF0aW9uLlxuICAgICAgICAgICAgICAgIEV4cGVjdGVkOiBmY2wuYWNjb3VudFByb29mLnJlc29sdmVyOiBhc3luYyAoKSA9PiB7IC4uLiB9XG4gICAgICAgICAgICAgICAgUmVjZWl2ZWQ6IGZjbC5hY2NvdW50UHJvb2YucmVzb2x2ZXI6ICR7dHlwZW9mIGFjY291bnRQcm9vZkRhdGFSZXNvbHZlcn1cbiAgICAgICAgICAgICAgICBgLFxuICAgICAgbGV2ZWw6IExFVkVMUy53YXJuXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFjY291bnRQcm9vZkRhdGEgPSBhd2FpdCBhY2NvdW50UHJvb2ZEYXRhUmVzb2x2ZXIoKTtcbiAgaWYgKGFjY291bnRQcm9vZkRhdGEgPT0gbnVsbCkgcmV0dXJuO1xuICBpbnZhcmlhbnQodHlwZW9mIGFjY291bnRQcm9vZkRhdGEuYXBwSWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIiwgXCJhcHBJZGVudGlmaWVyIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCgvXlswLTlhLWZdKyQvaS50ZXN0KGFjY291bnRQcm9vZkRhdGEubm9uY2UpLCBcIk5vbmNlIG11c3QgYmUgYSBoZXggc3RyaW5nXCIpO1xuICByZXR1cm4gYWNjb3VudFByb29mRGF0YTtcbn1cbmNvbnN0IG1ha2VDb25maWcgPSBhc3luYyBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkaXNjb3ZlcnlBdXRobkluY2x1ZGVcbiAgfSA9IF9yZWY7XG4gIHJldHVybiB7XG4gICAgY2xpZW50OiB7XG4gICAgICBkaXNjb3ZlcnlBdXRobkluY2x1ZGUsXG4gICAgICBjbGllbnRTZXJ2aWNlczogYXdhaXQgbWFrZURpc2NvdmVyeVNlcnZpY2VzKCksXG4gICAgICBzdXBwb3J0ZWRTdHJhdGVnaWVzOiBnZXRTZXJ2aWNlUmVnaXN0cnkoKS5nZXRTdHJhdGVnaWVzKClcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEF1dGhlbnRpY2F0ZSBhIHVzZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gLSBPcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdHMucGxhdGZvcm1dIC0gcGxhdGZvcm0gdGhhdCBydW5zIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzLnNlcnZpY2VdIC0gT3B0aW9uYWwgc2VydmljZSB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJlZGlyPWZhbHNlXSAtIE9wdGlvbmFsIGZsYWcgdG8gYWxsb3cgd2luZG93IHRvIHN0YXkgb3BlbiBhZnRlciBhdXRoZW50aWNhdGlvblxuICogQHJldHVybnMge1Byb21pc2U8Q3VycmVudFVzZXI+fSAtIFVzZXIgb2JqZWN0XG4gKi9cbmNvbnN0IGdldEF1dGhlbnRpY2F0ZSA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHtcbiAgICAgIHNlcnZpY2UsXG4gICAgICByZWRpciA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHNlcnZpY2UgJiYgIXNlcnZpY2U/LnByb3ZpZGVyPy5pc19pbnN0YWxsZWQgJiYgc2VydmljZT8ucHJvdmlkZXI/LnJlcXVpcmVzX2luc3RhbGwpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gc2VydmljZT8ucHJvdmlkZXI/Lmluc3RhbGxfbGluaztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIHJlZGlyXG4gICAgICB9O1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHNuYXBzaG90KCk7XG4gICAgICBjb25zdCBkaXNjb3ZlcnlTZXJ2aWNlID0gYXdhaXQgZ2V0RGlzY292ZXJ5U2VydmljZShzZXJ2aWNlKTtcbiAgICAgIGNvbnN0IHJlZnJlc2hTZXJ2aWNlID0gc2VydmljZU9mVHlwZSh1c2VyLnNlcnZpY2VzLCBcImF1dGhuLXJlZnJlc2hcIik7XG4gICAgICBsZXQgYWNjb3VudFByb29mRGF0YTtcbiAgICAgIGlmICh1c2VyLmxvZ2dlZEluKSB7XG4gICAgICAgIGlmIChyZWZyZXNoU2VydmljZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGV4ZWNTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgc2VydmljZTogcmVmcmVzaFNlcnZpY2UsXG4gICAgICAgICAgICAgIG1zZzogYWNjb3VudFByb29mRGF0YSxcbiAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgcGxhdGZvcm1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZCQxKE5BTUUsIFNFVF9DVVJSRU5UX1VTRVIsIGF3YWl0IGJ1aWxkVXNlcihyZXNwb25zZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2coe1xuICAgICAgICAgICAgICB0aXRsZTogYCR7ZXJyb3IubmFtZX0gQ291bGQgbm90IHJlZnJlc2ggd2FsbGV0IGF1dGhlbnRpY2F0aW9uLmAsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGxldmVsOiBMRVZFTFMuZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhd2FpdCBzbmFwc2hvdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodXNlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjY291bnRQcm9vZkRhdGEgPSBhd2FpdCBnZXRBY2NvdW50UHJvb2ZEYXRhKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2coe1xuICAgICAgICAgIHRpdGxlOiBgJHtlcnJvci5uYW1lfSBPbiBBdXRoZW50aWNhdGlvbjogQ291bGQgbm90IHJlc29sdmUgYWNjb3VudCBwcm9vZiBkYXRhLmAsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBsZXZlbDogTEVWRUxTLmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXhlY1NlcnZpY2Uoe1xuICAgICAgICAgIHNlcnZpY2U6IGRpc2NvdmVyeVNlcnZpY2UsXG4gICAgICAgICAgbXNnOiBhY2NvdW50UHJvb2ZEYXRhLFxuICAgICAgICAgIGNvbmZpZzogYXdhaXQgbWFrZUNvbmZpZyhkaXNjb3ZlcnlTZXJ2aWNlKSxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgIH0pO1xuICAgICAgICBzZW5kJDEoTkFNRSwgU0VUX0NVUlJFTlRfVVNFUiwgYXdhaXQgYnVpbGRVc2VyKHJlc3BvbnNlKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2coe1xuICAgICAgICAgIHRpdGxlOiBgJHtlcnJvcn0gT24gQXV0aGVudGljYXRpb25gLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgIGxldmVsOiBMRVZFTFMuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNvbHZlKGF3YWl0IHNuYXBzaG90KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBVbmF1dGhlbnRpY2F0ZSBhIHVzZXJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1bmF1dGhlbnRpY2F0ZSQxKCkge1xuICBzcGF3bkN1cnJlbnRVc2VyKCk7XG4gIHNlbmQkMShOQU1FLCBERUxfQ1VSUkVOVF9VU0VSKTtcbn1cbmNvbnN0IG5vcm1hbGl6ZVByZUF1dGh6UmVzcG9uc2UgPSBhdXRoeiA9PiAoe1xuICBmX3R5cGU6IFwiUHJlQXV0aHpSZXNwb25zZVwiLFxuICBmX3ZzbjogXCIxLjAuMFwiLFxuICBwcm9wb3NlcjogKGF1dGh6IHx8IHt9KS5wcm9wb3NlcixcbiAgcGF5ZXI6IChhdXRoeiB8fCB7fSkucGF5ZXIgfHwgW10sXG4gIGF1dGhvcml6YXRpb246IChhdXRoeiB8fCB7fSkuYXV0aG9yaXphdGlvbiB8fCBbXVxufSk7XG5jb25zdCBnZXRSZXNvbHZlUHJlQXV0aHogPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgcGxhdGZvcm1cbiAgfSA9IF9yZWYzO1xuICByZXR1cm4gYXV0aHogPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBub3JtYWxpemVQcmVBdXRoelJlc3BvbnNlKGF1dGh6KTtcbiAgICBjb25zdCBheHMgPSBbXTtcbiAgICBpZiAocmVzcC5wcm9wb3NlciAhPSBudWxsKSBheHMucHVzaChbXCJQUk9QT1NFUlwiLCByZXNwLnByb3Bvc2VyXSk7XG4gICAgZm9yIChsZXQgYXogb2YgcmVzcC5wYXllciB8fCBbXSkgYXhzLnB1c2goW1wiUEFZRVJcIiwgYXpdKTtcbiAgICBmb3IgKGxldCBheiBvZiByZXNwLmF1dGhvcml6YXRpb24gfHwgW10pIGF4cy5wdXNoKFtcIkFVVEhPUklaRVJcIiwgYXpdKTtcbiAgICB2YXIgcmVzdWx0ID0gYXhzLm1hcChfcmVmNCA9PiB7XG4gICAgICBsZXQgW3JvbGUsIGF6XSA9IF9yZWY0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGVtcElkOiBbYXouaWRlbnRpdHkuYWRkcmVzcywgYXouaWRlbnRpdHkua2V5SWRdLmpvaW4oXCJ8XCIpLFxuICAgICAgICBhZGRyOiBhei5pZGVudGl0eS5hZGRyZXNzLFxuICAgICAgICBrZXlJZDogYXouaWRlbnRpdHkua2V5SWQsXG4gICAgICAgIHNpZ25pbmdGdW5jdGlvbihzaWduYWJsZSkge1xuICAgICAgICAgIHJldHVybiBleGVjU2VydmljZSh7XG4gICAgICAgICAgICBzZXJ2aWNlOiBheixcbiAgICAgICAgICAgIG1zZzogc2lnbmFibGUsXG4gICAgICAgICAgICBwbGF0Zm9ybVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgcHJvcG9zZXI6IHJvbGUgPT09IFwiUFJPUE9TRVJcIixcbiAgICAgICAgICBwYXllcjogcm9sZSA9PT0gXCJQQVlFUlwiLFxuICAgICAgICAgIGF1dGhvcml6ZXI6IHJvbGUgPT09IFwiQVVUSE9SSVpFUlwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm9kdWNlcyB0aGUgbmVlZGVkIGF1dGhvcml6YXRpb24gZGV0YWlscyBmb3IgdGhlIGN1cnJlbnQgdXNlciB0byBzdWJtaXQgdHJhbnNhY3Rpb25zIHRvIEZsb3dcbiAqIEl0IGRlZmluZXMgYSBzaWduaW5nIGZ1bmN0aW9uIHRoYXQgY29ubmVjdHMgdG8gYSB1c2VyJ3Mgd2FsbGV0IHByb3ZpZGVyIHRvIHByb2R1Y2Ugc2lnbmF0dXJlcyB0byBzdWJtaXQgdHJhbnNhY3Rpb25zLlxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gb3BzIC0gcnVubmluZyBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BzLnBsYXRmb3JtIC0gcGxhdGZvcm0gdGhhdCBydW5zIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGFjY291bnQgLSBBY2NvdW50IG9iamVjdFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBBY2NvdW50IG9iamVjdCB3aXRoIHNpZ25pbmcgZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0QXV0aG9yaXphdGlvbiA9IF9yZWY1ID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjU7XG4gIHJldHVybiBhc3luYyBhY2NvdW50ID0+IHtcbiAgICBzcGF3bkN1cnJlbnRVc2VyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjY291bnQsXG4gICAgICB0ZW1wSWQ6IFwiQ1VSUkVOVF9VU0VSXCIsXG4gICAgICBhc3luYyByZXNvbHZlKGFjY291bnQsIHByZVNpZ25hYmxlKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGUoe1xuICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgIH0pKHtcbiAgICAgICAgICByZWRpcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXV0aHogPSBzZXJ2aWNlT2ZUeXBlKHVzZXIuc2VydmljZXMsIFwiYXV0aHpcIik7XG4gICAgICAgIGNvbnN0IHByZUF1dGh6ID0gc2VydmljZU9mVHlwZSh1c2VyLnNlcnZpY2VzLCBcInByZS1hdXRoelwiKTtcbiAgICAgICAgaWYgKHByZUF1dGh6KSByZXR1cm4gZ2V0UmVzb2x2ZVByZUF1dGh6KHtcbiAgICAgICAgICBwbGF0Zm9ybVxuICAgICAgICB9KShhd2FpdCBleGVjU2VydmljZSh7XG4gICAgICAgICAgc2VydmljZTogcHJlQXV0aHosXG4gICAgICAgICAgbXNnOiBwcmVTaWduYWJsZSxcbiAgICAgICAgICBwbGF0Zm9ybVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChhdXRoeikge1xuICAgICAgICAgIGxldCB3aW5kb3dSZWY7XG4gICAgICAgICAgaWYgKGlzTW9iaWxlKCkgJiYgYXV0aHoubWV0aG9kID09PSBcIldDL1JQQ1wiKSB7XG4gICAgICAgICAgICB3aW5kb3dSZWYgPSB3aW5kb3cub3BlbihcIlwiLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFjY291bnQsXG4gICAgICAgICAgICB0ZW1wSWQ6IFwiQ1VSUkVOVF9VU0VSXCIsXG4gICAgICAgICAgICByZXNvbHZlOiBudWxsLFxuICAgICAgICAgICAgYWRkcjogc2Fuc1ByZWZpeChhdXRoei5pZGVudGl0eS5hZGRyZXNzKSxcbiAgICAgICAgICAgIGtleUlkOiBhdXRoei5pZGVudGl0eS5rZXlJZCxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtOiBudWxsLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgYXN5bmMgc2lnbmluZ0Z1bmN0aW9uKHNpZ25hYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVDb21wb3NpdGVTaWduYXR1cmUoYXdhaXQgZXhlY1NlcnZpY2Uoe1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IGF1dGh6LFxuICAgICAgICAgICAgICAgIG1zZzogc2lnbmFibGUsXG4gICAgICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgICAgaW5jbHVkZU9sZGVySnNvblJwY0NhbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICB3aW5kb3dSZWZcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIEF1dGh6IG9yIFByZUF1dGh6IFNlcnZpY2UgY29uZmlndXJlZCBmb3IgQ1VSUkVOVF9VU0VSXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGNhbGxiYWNrIHBhc3NlZCB0byBzdWJzY3JpYmUgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBhdXRoZW50aWNhdGVzIGFuZCB1bi1hdXRoZW50aWNhdGVzLCBtYWtpbmcgaXQgZWFzeSB0byB1cGRhdGUgdGhlIFVJIGFjY29yZGluZ2x5LlxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgY29uc3QgRVhJVCA9IFwiQEVYSVRcIjtcbiAgY29uc3Qgc2VsZiA9IHNwYXduKGFzeW5jIGN0eCA9PiB7XG4gICAgY3R4LnNlbmQoTkFNRSwgU1VCU0NSSUJFKTtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgY29uc3QgbGV0dGVyID0gYXdhaXQgY3R4LnJlY2VpdmUoKTtcbiAgICAgIGlmIChsZXR0ZXIudGFnID09PSBFWElUKSB7XG4gICAgICAgIGN0eC5zZW5kKE5BTUUsIFVOU1VCU0NSSUJFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobGV0dGVyLmRhdGEpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiBzZW5kJDEoc2VsZiwgRVhJVCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gR2V0cyB0aGUgY3VycmVudCB1c2VyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDdXJyZW50VXNlcj59IC0gVXNlciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc25hcHNob3QoKSB7XG4gIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgcmV0dXJuIHNlbmQkMShOQU1FLCBTTkFQU0hPVCwgbnVsbCwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gUmVzb2x2ZXMgdGhlIGN1cnJlbnQgdXNlciBhcyBhbiBhcmd1bWVudFxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gb3BzIC0gcnVubmluZyBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BzLnBsYXRmb3JtIC0gcGxhdGZvcm0gdGhhdCBydW5zIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb24+fVxuICovXG5jb25zdCBnZXRSZXNvbHZlQXJndW1lbnQgPSBfcmVmNiA9PiB7XG4gIGxldCB7XG4gICAgcGxhdGZvcm1cbiAgfSA9IF9yZWY2O1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJcbiAgICB9ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlKHtcbiAgICAgIHBsYXRmb3JtXG4gICAgfSkoKTtcbiAgICByZXR1cm4gYXJnKHdpdGhQcmVmaXgoYWRkciksIHQkMS5BZGRyZXNzKTtcbiAgfTtcbn07XG5jb25zdCBtYWtlU2lnbmFibGUgPSBtc2cgPT4ge1xuICBpbnZhcmlhbnQoL15bMC05YS1mXSskL2kudGVzdChtc2cpLCBcIk1lc3NhZ2UgbXVzdCBiZSBhIGhleCBzdHJpbmdcIik7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogbXNnXG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgbWV0aG9kIHRvIHVzZSBhbGxvd2luZyB0aGUgdXNlciB0byBwZXJzb25hbGx5IHNpZ24gZGF0YSB2aWEgRkNMIENvbXBhdGlibGUgV2FsbGV0cy9TZXJ2aWNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgLSBNZXNzYWdlIHRvIHNpZ25cbiAqIEByZXR1cm5zIHtQcm9taXNlPENvbXBvc2l0ZVNpZ25hdHVyZVtdPn0gLSBBcnJheSBvZiBDb21wb3NpdGVTaWduYXR1cmVzXG4gKi9cbmNvbnN0IGdldFNpZ25Vc2VyTWVzc2FnZSA9IF9yZWY3ID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjc7XG4gIHJldHVybiBhc3luYyBtc2cgPT4ge1xuICAgIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlKHtcbiAgICAgIHBsYXRmb3JtXG4gICAgfSkoe1xuICAgICAgcmVkaXI6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBzaWduaW5nU2VydmljZSA9IHNlcnZpY2VPZlR5cGUodXNlci5zZXJ2aWNlcywgXCJ1c2VyLXNpZ25hdHVyZVwiKTtcbiAgICBpbnZhcmlhbnQoc2lnbmluZ1NlcnZpY2UsIFwiQ3VycmVudCB1c2VyIG11c3QgaGF2ZSBhdXRob3JpemVkIGEgc2lnbmluZyBzZXJ2aWNlLlwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBleGVjU2VydmljZSh7XG4gICAgICAgIHNlcnZpY2U6IHNpZ25pbmdTZXJ2aWNlLFxuICAgICAgICBtc2c6IG1ha2VTaWduYWJsZShtc2cpLFxuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChjb21wU2lncyA9PiBub3JtYWxpemVDb21wb3NpdGVTaWduYXR1cmUoY29tcFNpZ3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbm9ybWFsaXplQ29tcG9zaXRlU2lnbmF0dXJlKHJlc3BvbnNlKV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBfcmVmOCA9PiB7XG4gIGxldCB7XG4gICAgcGxhdGZvcm1cbiAgfSA9IF9yZWY4O1xuICBsZXQgY3VycmVudFVzZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhlbnRpY2F0ZTogZ2V0QXV0aGVudGljYXRlKHtcbiAgICAgICAgcGxhdGZvcm1cbiAgICAgIH0pLFxuICAgICAgdW5hdXRoZW50aWNhdGU6IHVuYXV0aGVudGljYXRlJDEsXG4gICAgICBhdXRob3JpemF0aW9uOiBnZXRBdXRob3JpemF0aW9uKHtcbiAgICAgICAgcGxhdGZvcm1cbiAgICAgIH0pLFxuICAgICAgc2lnblVzZXJNZXNzYWdlOiBnZXRTaWduVXNlck1lc3NhZ2Uoe1xuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSksXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzbmFwc2hvdCxcbiAgICAgIHJlc29sdmVBcmd1bWVudDogZ2V0UmVzb2x2ZUFyZ3VtZW50KHtcbiAgICAgICAgcGxhdGZvcm1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcbiAgY3VycmVudFVzZXIuYXV0aGVudGljYXRlID0gZ2V0QXV0aGVudGljYXRlKHtcbiAgICBwbGF0Zm9ybVxuICB9KTtcbiAgY3VycmVudFVzZXIudW5hdXRoZW50aWNhdGUgPSB1bmF1dGhlbnRpY2F0ZSQxO1xuICBjdXJyZW50VXNlci5hdXRob3JpemF0aW9uID0gZ2V0QXV0aG9yaXphdGlvbih7XG4gICAgcGxhdGZvcm1cbiAgfSk7XG4gIGN1cnJlbnRVc2VyLnNpZ25Vc2VyTWVzc2FnZSA9IGdldFNpZ25Vc2VyTWVzc2FnZSh7XG4gICAgcGxhdGZvcm1cbiAgfSk7XG4gIGN1cnJlbnRVc2VyLnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgY3VycmVudFVzZXIuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgY3VycmVudFVzZXIucmVzb2x2ZUFyZ3VtZW50ID0gZ2V0UmVzb2x2ZUFyZ3VtZW50KHtcbiAgICBwbGF0Zm9ybVxuICB9KTtcbiAgcmV0dXJuIGN1cnJlbnRVc2VyO1xufTtcblxuY29uc3QgZ2V0TXV0YXRlID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgcGxhdGZvcm1cbiAgfSA9IF9yZWY7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQWxsb3dzIHlvdSB0byBzdWJtaXQgdHJhbnNhY3Rpb25zIHRvIHRoZSBibG9ja2NoYWluIHRvIHBvdGVudGlhbGx5IG11dGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gLSBNdXRhdGlvbiBPcHRpb25zIGFuZCBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jYWRlbmNlXSAtIENhZGVuY2UgVHJhbnNhY3Rpb24gdXNlZCB0byBtdXRhdGUgRmxvd1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NoYXJlZC1leHBvcnRzXCIpLkFyZ3NGbn0gW29wdHMuYXJnc10gLSBBcmd1bWVudHMgcGFzc2VkIHRvIGNhZGVuY2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmd9IFtvcHRzLnRlbXBsYXRlXSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIGZvciBhIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5saW1pdF0gLSBDb21wdXRlIExpbWl0IGZvciB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5hdXRoel0gLSBBdXRob3JpemF0aW9uIGZ1bmN0aW9uIGZvciB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5wcm9wb3Nlcl0gLSBQcm9wb3NlciBBdXRob3JpemF0aW9uIGZ1bmN0aW9uIGZvciB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5wYXllcl0gLSBQYXllciBBdXRob3JpemF0aW9uIGZ1bmN0aW9uIGZvciB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gW29wdHMuYXV0aG9yaXphdGlvbnNdIC0gQXV0aG9yaXphdGlvbnMgZnVuY3Rpb24gZm9yIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRyYW5zYWN0aW9uIElkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGZjbC5tdXRhdGUoe1xuICAgKiAgIGNhZGVuY2U6IGBcbiAgICogICAgIHRyYW5zYWN0aW9uKGE6IEludCwgYjogSW50LCBjOiBBZGRyZXNzKSB7XG4gICAqICAgICAgIHByZXBhcmUoYWNjdDogQXV0aEFjY291bnQpIHtcbiAgICogICAgICAgICBsb2coYWNjdClcbiAgICogICAgICAgICBsb2coYSlcbiAgICogICAgICAgICBsb2coYilcbiAgICogICAgICAgICBsb2coYylcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIGAsXG4gICAqICAgYXJnczogKGFyZywgdCkgPT4gW1xuICAgKiAgICAgYXJnKDYsIHQuSW50KSxcbiAgICogICAgIGFyZyg3LCB0LkludCksXG4gICAqICAgICBhcmcoXCIweGJhMTEzMmJjMDhmODJmZTJcIiwgdC5BZGRyZXNzKSxcbiAgICogICBdLFxuICAgKiB9KVxuICAgKlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKiB0eXBlIE9wdGlvbnMgPSB7XG4gICAqICAgdGVtcGxhdGU6IEludGVyYWN0aW9uVGVtcGxhdGUgfCBTdHJpbmcgLy8gSW50ZXJhY3Rpb25UZW1wbGF0ZSBvciB1cmwgdG8gb25lXG4gICAqICAgY2FkZW5jZTogU3RyaW5nISxcbiAgICogICBhcmdzOiAoYXJnLCB0KSA9PiBBcnJheTxBcmc+LFxuICAgKiAgIGxpbWl0OiBOdW1iZXIsXG4gICAqICAgYXV0aHo6IEF1dGh6Rm4sIC8vIHdpbGwgb3ZlcmxvYWQgdGhlIHRyaW5pdHkgb2Ygc2lnbmF0b3J5IHJvbGVzXG4gICAqICAgcHJvcG9zZXI6IEF1dGh6Rm4sIC8vIHdpbGwgb3ZlcmxvYWQgdGhlIHByb3Bvc2VyIHNpZ25hdG9yeSByb2xlXG4gICAqICAgcGF5ZXI6IEF1dGh6Rm4sIC8vIHdpbGwgb3ZlcmxvYWQgdGhlIHBheWVyIHNpZ25hdG9yeSByb2xlXG4gICAqICAgYXV0aG9yaXphdGlvbnM6IFtBdXRoekZuXSwgLy8gYW4gYXJyYXkgb2YgYXV0aG9yaXphdGlvbiBmdW5jdGlvbnMgdXNlZCBhcyBhdXRob3JpemF0aW9ucyBzaWduYXRvcnkgcm9sZXNcbiAgICogfVxuICAgKi9cbiAgY29uc3QgbXV0YXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgdHhpZDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlTXV0YXRlKG9wdHMpO1xuICAgICAgb3B0cyA9IGF3YWl0IHByZXBUZW1wbGF0ZU9wdHMob3B0cyk7XG4gICAgICBjb25zdCBjdXJyZW50VXNlciA9IGdldEN1cnJlbnRVc2VyKHtcbiAgICAgICAgcGxhdGZvcm1cbiAgICAgIH0pO1xuICAgICAgLy8gQWxsb3cgZm9yIGEgY29uZmlnIHRvIG92ZXJ3cml0ZSB0aGUgYXV0aG9yaXphdGlvbiBmdW5jdGlvbi5cbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgY29uc3QgYXV0aHogPSBhd2FpdCBzZGsuY29uZmlnKCkuZ2V0KFwiZmNsLmF1dGh6XCIsIGN1cnJlbnRVc2VyKCkuYXV0aG9yaXphdGlvbik7XG4gICAgICB0eGlkID0gc2RrLmNvbmZpZygpLm92ZXJsb2FkKG9wdHMuZGVwZW5kZW5jaWVzIHx8IHt9LCBhc3luYyAoKSA9PlxuICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICBzZGsuc2VuZChbc2RrLnRyYW5zYWN0aW9uKG9wdHMuY2FkZW5jZSksIHNkay5hcmdzKG5vcm1hbGl6ZUFyZ3Mob3B0cy5hcmdzIHx8IFtdKSksIG9wdHMubGltaXQgJiYgaXNOdW1iZXIob3B0cy5saW1pdCkgJiYgc2RrLmxpbWl0KG9wdHMubGltaXQpLFxuICAgICAgLy8gb3B0cy5wcm9wb3NlciA+IG9wdHMuYXV0aHogPiBhdXRoelxuICAgICAgc2RrLnByb3Bvc2VyKG9wdHMucHJvcG9zZXIgfHwgb3B0cy5hdXRoeiB8fCBhdXRoeiksXG4gICAgICAvLyBvcHRzLnBheWVyID4gb3B0cy5hdXRoeiA+IGF1dGh6XG4gICAgICBzZGsucGF5ZXIob3B0cy5wYXllciB8fCBvcHRzLmF1dGh6IHx8IGF1dGh6KSxcbiAgICAgIC8vIG9wdHMuYXV0aG9yaXphdGlvbnMgPiBbb3B0cy5hdXRoeiA+IGF1dGh6XVxuICAgICAgc2RrLmF1dGhvcml6YXRpb25zKG9wdHMuYXV0aG9yaXphdGlvbnMgfHwgW29wdHMuYXV0aHogfHwgYXV0aHpdKV0pLnRoZW4oc2RrLmRlY29kZSkpO1xuICAgICAgcmV0dXJuIHR4aWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG11dGF0ZTtcbn07XG5cbmNvbnN0IEZSQU1FID0gXCJGQ0xfSUZSQU1FXCI7XG5jb25zdCBGUkFNRV9TVFlMRVMgPSBgXG4gIHBvc2l0aW9uOmZpeGVkO1xuICB0b3A6IDBweDtcbiAgcmlnaHQ6IDBweDtcbiAgYm90dG9tOiAwcHg7XG4gIGxlZnQ6IDBweDtcbiAgaGVpZ2h0OiAxMDAlO1xuICB3aWR0aDogMTAwdnc7XG4gIGRpc3BsYXk6YmxvY2s7XG4gIGJhY2tncm91bmQ6cmdiYSgwLDAsMCwwLjI1KTtcbiAgei1pbmRleDogMjE0NzQ4MzY0NztcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgY29sb3Itc2NoZW1lOiBsaWdodDtcbmA7XG5mdW5jdGlvbiByZW5kZXJGcmFtZShzcmMpIHtcbiAgaW52YXJpYW50KCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChGUkFNRSksIFwiQXR0ZW1wdCBhdCB0cmlnZ2VyaW5nIG11bHRpcGxlIEZyYW1lc1wiLCB7XG4gICAgc3JjXG4gIH0pO1xuICBjb25zdCAkZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAkZnJhbWUuc3JjID0gc3JjO1xuICAkZnJhbWUuaWQgPSBGUkFNRTtcbiAgJGZyYW1lLmFsbG93ID0gXCJ1c2IgKjsgaGlkICpcIjtcbiAgJGZyYW1lLmZyYW1lQm9yZGVyID0gXCIwXCI7XG4gICRmcmFtZS5zdHlsZS5jc3NUZXh0ID0gRlJBTUVfU1RZTEVTO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZCgkZnJhbWUpO1xuICBjb25zdCB1bm1vdW50ID0gKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChGUkFNRSkpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEZSQU1FKS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBbJGZyYW1lLmNvbnRlbnRXaW5kb3csIHVubW91bnRdO1xufVxuXG5jb25zdCBQT1AgPSBcIkZDTF9QT1BcIjtcbmxldCBwb3B1cCA9IG51bGw7XG5sZXQgcHJldmlvdXNVcmwkMSA9IG51bGw7XG5mdW5jdGlvbiBwb3B1cFdpbmRvdyh1cmwsIHdpbmRvd05hbWUsIHdpbiwgdywgaCkge1xuICBjb25zdCB5ID0gd2luLnRvcC5vdXRlckhlaWdodCAvIDIgKyB3aW4udG9wLnNjcmVlblkgLSBoIC8gMjtcbiAgY29uc3QgeCA9IHdpbi50b3Aub3V0ZXJXaWR0aCAvIDIgKyB3aW4udG9wLnNjcmVlblggLSB3IC8gMjtcbiAgY29uc3QgcG9wdXAgPSB3aW4ub3Blbih1cmwsIHdpbmRvd05hbWUsIGB0b29sYmFyPW5vLCBsb2NhdGlvbj1ubywgZGlyZWN0b3JpZXM9bm8sIHN0YXR1cz1ubywgbWVudWJhcj1ubywgc2Nyb2xsYmFycz1ubywgcmVzaXphYmxlPW5vLCBjb3B5aGlzdG9yeT1ubywgd2lkdGg9JHt3fSwgaGVpZ2h0PSR7aH0sIHRvcD0ke3l9LCBsZWZ0PSR7eH1gKTtcbiAgaWYgKCFwb3B1cCkgdGhyb3cgbmV3IEVycm9yKFwiUG9wdXAgZmFpbGVkIHRvIG9wZW4gKHdhcyBpdCBibG9ja2VkIGJ5IGEgcG9wdXAgYmxvY2tlcj8pXCIpO1xuICByZXR1cm4gcG9wdXA7XG59XG5mdW5jdGlvbiByZW5kZXJQb3Aoc3JjKSB7XG4gIGlmIChwb3B1cCA9PSBudWxsIHx8IHBvcHVwPy5jbG9zZWQpIHtcbiAgICBwb3B1cCA9IHBvcHVwV2luZG93KHNyYywgUE9QLCB3aW5kb3csIDY0MCwgNzcwKTtcbiAgfSBlbHNlIGlmIChwcmV2aW91c1VybCQxICE9PSBzcmMpIHtcbiAgICBwb3B1cC5sb2NhdGlvbi5yZXBsYWNlKHNyYyk7XG4gICAgcG9wdXAuZm9jdXMoKTtcbiAgfSBlbHNlIHtcbiAgICBwb3B1cC5mb2N1cygpO1xuICB9XG4gIHByZXZpb3VzVXJsJDEgPSBzcmM7XG4gIGNvbnN0IHVubW91bnQgPSAoKSA9PiB7XG4gICAgaWYgKHBvcHVwICYmICFwb3B1cC5jbG9zZWQpIHtcbiAgICAgIHBvcHVwLmNsb3NlKCk7XG4gICAgfVxuICAgIHBvcHVwID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIFtwb3B1cCwgdW5tb3VudF07XG59XG5cbmxldCB0YWIkMSA9IG51bGw7XG5sZXQgcHJldmlvdXNVcmwgPSBudWxsO1xuZnVuY3Rpb24gcmVuZGVyVGFiKHNyYykge1xuICBpZiAodGFiJDEgPT0gbnVsbCB8fCB0YWIkMT8uY2xvc2VkKSB7XG4gICAgdGFiJDEgPSB3aW5kb3cub3BlbihzcmMsIFwiX2JsYW5rXCIpO1xuICAgIGlmICghdGFiJDEpIHRocm93IG5ldyBFcnJvcihcIlRhYiBmYWlsZWQgdG8gb3BlbiAod2FzIGl0IGJsb2NrZWQgYnkgdGhlIGJyb3dzZXI/KVwiKTtcbiAgfSBlbHNlIGlmIChwcmV2aW91c1VybCAhPT0gc3JjKSB7XG4gICAgdGFiJDEubG9jYXRpb24ucmVwbGFjZShzcmMpO1xuICAgIHRhYiQxLmZvY3VzKCk7XG4gIH0gZWxzZSB7XG4gICAgdGFiJDEuZm9jdXMoKTtcbiAgfVxuICBwcmV2aW91c1VybCA9IHNyYztcbiAgY29uc3QgdW5tb3VudCA9ICgpID0+IHtcbiAgICBpZiAodGFiJDEgJiYgIXRhYiQxLmNsb3NlZCkge1xuICAgICAgdGFiJDEuY2xvc2UoKTtcbiAgICB9XG4gICAgdGFiJDEgPSBudWxsO1xuICB9O1xuICByZXR1cm4gW3RhYiQxLCB1bm1vdW50XTtcbn1cblxuY29uc3QgaXNTZXJ2ZXJTaWRlID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGdldFNlc3Npb25TdG9yYWdlID0gKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IFNFU1NJT05fU1RPUkFHRSA9IHtcbiAgICAgIGNhbjogIWlzU2VydmVyU2lkZSgpLFxuICAgICAgZ2V0OiBhc3luYyBrZXkgPT4gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSkpLFxuICAgICAgcHV0OiBhc3luYyAoa2V5LCB2YWx1ZSkgPT4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICB9O1xuICAgIHJldHVybiBTRVNTSU9OX1NUT1JBR0U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5jb25zdCBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIFwiZGlzY292ZXJ5LndhbGxldC5tZXRob2QuZGVmYXVsdFwiOiBcIklGUkFNRS9SUENcIixcbiAgICBcImZjbC5zdG9yYWdlLmRlZmF1bHRcIjogZ2V0U2Vzc2lvblN0b3JhZ2UoKVxuICB9O1xufTtcblxuZnVuY3Rpb24gc2VydmljZUVuZHBvaW50KHNlcnZpY2UpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChzZXJ2aWNlLmVuZHBvaW50KTtcbiAgaWYgKHdpbmRvdz8ubG9jYXRpb24/Lm9yaWdpbikge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibDZuXCIsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICB9XG4gIGlmIChzZXJ2aWNlLnBhcmFtcyAhPSBudWxsKSB7XG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlcnZpY2UucGFyYW1zIHx8IHt9KSkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGZldGNoU2VydmljZShzZXJ2aWNlKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgbWV0aG9kID0gb3B0cy5tZXRob2QgfHwgXCJQT1NUXCI7XG4gIGNvbnN0IGJvZHkgPSBtZXRob2QgPT09IFwiR0VUXCIgPyB1bmRlZmluZWQgOiBKU09OLnN0cmluZ2lmeShvcHRzLmRhdGEgfHwgc2VydmljZS5kYXRhIHx8IHt9KTtcbiAgcmV0dXJuIGZldGNoKHNlcnZpY2VFbmRwb2ludChzZXJ2aWNlKSwge1xuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLihzZXJ2aWNlLmhlYWRlcnMgfHwge30pLFxuICAgICAgLi4uKG9wdHMuaGVhZGVycyB8fCB7fSksXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogYm9keVxuICB9KS50aGVuKGQgPT4gZC5qc29uKCkpO1xufVxuXG4vLyB7XG4vLyAgICBcImZfdHlwZVwiOiBcIlBvbGxpbmdSZXNwb25zZVwiLFxuLy8gICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgICBcInN0YXR1c1wiOiBcIlBFTkRJTkdcIiwgLy8gUEVORElORyB8IEFQUFJPVkVEIHwgREVDTElORUQgfCBSRURJUkVDVFxuLy8gICAgXCJyZWFzb25cIjogbnVsbCwgICAgICAvLyBSZWFzb24gZm9yIERlY2xpbmluZyBUcmFuc2FjdGlvblxuLy8gICAgXCJkYXRhXCI6IG51bGwsICAgICAgICAvLyBSZXR1cm4gdmFsdWUgZm9yIEFQUFJPVkVEXG4vLyAgICBcInVwZGF0ZXNcIjogQmFja0NoYW5uZWxScGMsXG4vLyAgICBcImxvY2FsXCI6IEZyYW1lLFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKHJlc3ApIHtcbiAgaWYgKHJlc3AgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAocmVzcFtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uUE9MTElOR19SRVNQT05TRV9QUkFHTUEsXG4gICAgICAgIHN0YXR1czogcmVzcC5zdGF0dXMgPz8gXCJBUFBST1ZFRFwiLFxuICAgICAgICByZWFzb246IHJlc3AucmVhc29uID8/IG51bGwsXG4gICAgICAgIGRhdGE6IHJlc3AuY29tcG9zaXRlU2lnbmF0dXJlIHx8IHJlc3AuZGF0YSB8fCB7XG4gICAgICAgICAgLi4ucmVzcFxuICAgICAgICB9IHx8IHt9LFxuICAgICAgICB1cGRhdGVzOiBub3JtYWxpemVCYWNrQ2hhbm5lbFJwYyhyZXNwLmF1dGhvcml6YXRpb25VcGRhdGVzKSxcbiAgICAgICAgbG9jYWw6IG5vcm1hbGl6ZUZyYW1lKChyZXNwLmxvY2FsIHx8IFtdKVswXSlcbiAgICAgIH07XG4gIH1cbn1cblxuY29uc3QgT1BUSU9OUyA9IHtcbiAgXCJIVFRQL0dFVFwiOiBcIkdFVFwiLFxuICBcIkhUVFAvUE9TVFwiOiBcIlBPU1RcIlxufTtcbmNvbnN0IHNlcnZpY2VNZXRob2QgPSBzZXJ2aWNlID0+IHtcbiAgaW52YXJpYW50KE9QVElPTlNbc2VydmljZS5tZXRob2RdLCBcIkludmFsaWQgU2VydmljZSBNZXRob2QgZm9yIHR5cGUgYmFjay1jaGFubmVsLXJwY1wiLCB7XG4gICAgc2VydmljZVxuICB9KTtcbiAgcmV0dXJuIE9QVElPTlNbc2VydmljZS5tZXRob2RdO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHBvbGwoc2VydmljZSkge1xuICBsZXQgY2hlY2tDYW5Db250aW51ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogKCkgPT4gdHJ1ZTtcbiAgaW52YXJpYW50KHNlcnZpY2UsIFwiTWlzc2luZyBQb2xsaW5nIFNlcnZpY2VcIiwge1xuICAgIHNlcnZpY2VcbiAgfSk7XG4gIGNvbnN0IGNhbkNvbnRpbnVlID0gY2hlY2tDYW5Db250aW51ZSgpO1xuICBpZiAoIWNhbkNvbnRpbnVlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbGx5IEhhbHRlZFwiKTtcbiAgbGV0IHJlc3A7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCA1MDApKTtcbiAgICAgIHJldHVybiBwb2xsKHNlcnZpY2UsIGNoZWNrQ2FuQ29udGludWUpO1xuICAgIH1cbiAgICByZXNwID0gYXdhaXQgZmV0Y2hTZXJ2aWNlKHNlcnZpY2UsIHtcbiAgICAgIG1ldGhvZDogc2VydmljZU1ldGhvZChzZXJ2aWNlKVxuICAgIH0pLnRoZW4obm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBzd2l0Y2ggKHJlc3Auc3RhdHVzKSB7XG4gICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICByZXR1cm4gcmVzcC5kYXRhO1xuICAgIGNhc2UgXCJERUNMSU5FRFwiOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZC5cIn1gKTtcbiAgICBkZWZhdWx0OlxuICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDUwMCkpO1xuICAgICAgcmV0dXJuIHBvbGwocmVzcC51cGRhdGVzLCBjaGVja0NhbkNvbnRpbnVlKTtcbiAgfVxufVxuXG5jb25zdCBnZXRFeGVjSHR0cFBvc3QgPSBleGVjTG9jYWwgPT4gYXN5bmMgX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0gPSBfcmVmO1xuICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2hTZXJ2aWNlKHNlcnZpY2UsIHtcbiAgICBkYXRhOiB7XG4gICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgc2VydmljZToge1xuICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgfSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIC4uLmJvZHlcbiAgICB9XG4gIH0pLnRoZW4obm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKTtcbiAgaWYgKHJlc3Auc3RhdHVzID09PSBcIkFQUFJPVkVEXCIpIHtcbiAgICByZXR1cm4gcmVzcC5kYXRhO1xuICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzID09PSBcIkRFQ0xJTkVEXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkLlwifWApO1xuICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzID09PSBcIlJFRElSRUNUXCIpIHtcbiAgICByZXR1cm4gcmVzcDtcbiAgfSBlbHNlIGlmIChyZXNwLnN0YXR1cyA9PT0gXCJQRU5ESU5HXCIpIHtcbiAgICAvLyB0aGVzZSB0d28gZmxhZ3MgYXJlIHJlcXVpcmVkIHRvIHJ1biBwb2xsaW5nIG9uZSBtb3JlIHRpbWUgYmVmb3JlIGl0IHN0b3BzXG4gICAgdmFyIGNhbkNvbnRpbnVlID0gdHJ1ZTtcbiAgICB2YXIgc2hvdWxkQ29udGludWUgPSB0cnVlO1xuICAgIGNvbnN0IFtfLCB1bm1vdW50XSA9IGF3YWl0IGV4ZWNMb2NhbChub3JtYWxpemVMb2NhbFZpZXcocmVzcC5sb2NhbCksIHtcbiAgICAgIHNlcnZpY2VFbmRwb2ludCxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHNob3VsZENvbnRpbnVlID0gZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgc2hvdWxkQ29udGludWUgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGcmFtZSBDbG9zZSBFcnJvclwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHJ1biBvbmNlIHBlciBwb2xsIGNhbGwuXG4gICAgICogT2Zmc2V0dGluZyBjYW5Db250aW51ZSBmbGFnIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICogdGhlIHBvbGxpbmcgaXMgcGVyZm9ybWVkIG9uZSBleHRyYSB0aW1lIGFmdGVyIGNhbkNvbnRpbnVlIGZsYWcgaXMgc2V0IHRvIGZhbHNlXG4gICAgICogdG8gcHJldmVudCBoYWx0aW5nIG9uIEFuZHJvaWQgd2hlbiBhIGJyb3dzZXIgY2FsbHMgd2luZG93LmNsb3NlXG4gICAgICogYmVmb3JlIEZDTCByZWNlaXZlcyBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gcG9sbGluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFxuICAgICAqL1xuICAgIGNvbnN0IGNoZWNrQ2FuQ29udGludWUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXRDYW5Db250aW51ZSA9IGNhbkNvbnRpbnVlO1xuICAgICAgY2FuQ29udGludWUgPSBzaG91bGRDb250aW51ZTtcbiAgICAgIHJldHVybiBvZmZzZXRDYW5Db250aW51ZTtcbiAgICB9O1xuICAgIHJldHVybiBwb2xsKHJlc3AudXBkYXRlcywgY2hlY2tDYW5Db250aW51ZSkudGhlbihzZXJ2aWNlUmVzcG9uc2UgPT4ge1xuICAgICAgY2xvc2UoKTtcbiAgICAgIHJldHVybiBzZXJ2aWNlUmVzcG9uc2U7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBjbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihgQXV0byBEZWNsaW5lOiBJbnZhbGlkIFJlc3BvbnNlYCwge1xuICAgICAgc2VydmljZSxcbiAgICAgIHJlc3BcbiAgICB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG8gRGVjbGluZTogSW52YWxpZCBSZXNwb25zZWApO1xuICB9XG59O1xuXG5jb25zdCBDTE9TRV9FVkVOVCA9IFwiRkNMOlZJRVc6Q0xPU0VcIjtcbmNvbnN0IFJFQURZX0VWRU5UID0gXCJGQ0w6VklFVzpSRUFEWVwiO1xuY29uc3QgUkVTUE9OU0VfRVZFTlQgPSBcIkZDTDpWSUVXOlJFU1BPTlNFXCI7XG5jb25zdCBfID0gZSA9PiB0eXBlb2YgZSA9PT0gXCJzdHJpbmdcIiAmJiBlLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBJR05PUkUgPSBuZXcgU2V0KFtcIm1vbmV0aXphdGlvbnN0YXJ0XCIsIFwibW9uZXRpemF0aW9ucGVuZGluZ1wiLCBcIm1vbmV0aXphdGlvbnByb2dyZXNzXCIsIFwibW9uZXRpemF0aW9uc3RvcFwiXSk7XG5jb25zdCBkZXByZWNhdGUgPSAod2FzLCB3YW50KSA9PiBjb25zb2xlLndhcm4oXCJERVBSRUNBVElPTiBOT1RJQ0VcIiwgYFJlY2VpdmVkICR7d2FzfSwgcGxlYXNlIHVzZSAke3dhbnR9IGZvciB0aGlzIGFuZCBmdXR1cmUgdmVyc2lvbnMgb2YgRkNMYCk7XG5jb25zdCBidWlsZE1lc3NhZ2VIYW5kbGVyID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvblJlYWR5LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25NZXNzYWdlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gZSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICBpZiAoSUdOT1JFLmhhcyhlLmRhdGEudHlwZSkpIHJldHVybjtcbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhDTE9TRV9FVkVOVCkpIGNsb3NlKCk7XG4gICAgICBpZiAoXyhlLmRhdGEudHlwZSkgPT09IF8oUkVBRFlfRVZFTlQpKSBvblJlYWR5KGUsIHtcbiAgICAgICAgc2VuZCxcbiAgICAgICAgY2xvc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFJFU1BPTlNFX0VWRU5UKSkgb25SZXNwb25zZShlLCB7XG4gICAgICAgIHNlbmQsXG4gICAgICAgIGNsb3NlXG4gICAgICB9KTtcbiAgICAgIG9uTWVzc2FnZShlLCB7XG4gICAgICAgIHNlbmQsXG4gICAgICAgIGNsb3NlXG4gICAgICB9KTtcblxuICAgICAgLy8gQmFja3dhcmRzIENvbXBhdGlibGVcbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDpGUkFNRTpSRUFEWVwiKSkge1xuICAgICAgICBkZXByZWNhdGUoZS5kYXRhLnR5cGUsIFJFQURZX0VWRU5UKTtcbiAgICAgICAgb25SZWFkeShlLCB7XG4gICAgICAgICAgc2VuZCxcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDpGUkFNRTpSRVNQT05TRVwiKSkge1xuICAgICAgICBkZXByZWNhdGUoZS5kYXRhLnR5cGUsIFJFU1BPTlNFX0VWRU5UKTtcbiAgICAgICAgb25SZXNwb25zZShlLCB7XG4gICAgICAgICAgc2VuZCxcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDpGUkFNRTpDTE9TRVwiKSkge1xuICAgICAgICBkZXByZWNhdGUoZS5kYXRhLnR5cGUsIENMT1NFX0VWRU5UKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vXG4gICAgICBpZiAoXyhlLmRhdGEudHlwZSkgPT09IF8oXCJGQ0w6OkNIQUxMRU5HRTo6UkVTUE9OU0VcIikpIHtcbiAgICAgICAgZGVwcmVjYXRlKGUuZGF0YS50eXBlLCBSRVNQT05TRV9FVkVOVCk7XG4gICAgICAgIG9uUmVzcG9uc2UoZSwge1xuICAgICAgICAgIHNlbmQsXG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoXyhlLmRhdGEudHlwZSkgPT09IF8oXCJGQ0w6OkFVVEhaX1JFQURZXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgUkVBRFlfRVZFTlQpO1xuICAgICAgICBvblJlYWR5KGUsIHtcbiAgICAgICAgICBzZW5kLFxuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFwiRkNMOjpDSEFMTEVOR0U6OkNBTkNFTFwiKSkge1xuICAgICAgICBkZXByZWNhdGUoZS5kYXRhLnR5cGUsIENMT1NFX0VWRU5UKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDo6Q0FOQ0VMXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgQ0xPU0VfRVZFTlQpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRnJhbWUgQ2FsbGJhY2sgRXJyb3JcIiwgZXJyb3IpO1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBub29wJDMgPSAoKSA9PiB7fTtcbmZ1bmN0aW9uIGZyYW1lKHNlcnZpY2UpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4ge1xuICAgIHNlbmQ6IG5vb3AkMyxcbiAgICBjbG9zZTogbm9vcCQzXG4gIH07XG4gIGNvbnN0IG9uQ2xvc2UgPSBvcHRzLm9uQ2xvc2UgfHwgbm9vcCQzO1xuICBjb25zdCBvbk1lc3NhZ2UgPSBvcHRzLm9uTWVzc2FnZSB8fCBub29wJDM7XG4gIGNvbnN0IG9uUmVhZHkgPSBvcHRzLm9uUmVhZHkgfHwgbm9vcCQzO1xuICBjb25zdCBvblJlc3BvbnNlID0gb3B0cy5vblJlc3BvbnNlIHx8IG5vb3AkMztcbiAgY29uc3QgaGFuZGxlciA9IGJ1aWxkTWVzc2FnZUhhbmRsZXIoe1xuICAgIGNsb3NlLFxuICAgIHNlbmQsXG4gICAgb25SZWFkeSxcbiAgICBvblJlc3BvbnNlLFxuICAgIG9uTWVzc2FnZVxuICB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICBjb25zdCBbJGZyYW1lLCB1bm1vdW50XSA9IHJlbmRlckZyYW1lKHNlcnZpY2VFbmRwb2ludChzZXJ2aWNlKSk7XG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBjbG9zZVxuICB9O1xuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgdW5tb3VudCgpO1xuICAgICAgb25DbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRnJhbWUgQ2xvc2UgRXJyb3JcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgIHRyeSB7XG4gICAgICAkZnJhbWUucG9zdE1lc3NhZ2UoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtc2cgfHwge30pKSwgXCIqXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRnJhbWUgU2VuZCBFcnJvclwiLCBtc2csIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY0lmcmFtZVJQQyhfcmVmKSB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGlkID0gdWlkKCk7XG4gICAgY29uc3QgaW5jbHVkZU9sZGVySnNvblJwY0NhbGwgPSBvcHRzLmluY2x1ZGVPbGRlckpzb25ScGNDYWxsO1xuICAgIGZyYW1lKHNlcnZpY2UsIHtcbiAgICAgIGFzeW5jIG9uUmVhZHkoXywgX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzZW5kXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIixcbiAgICAgICAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgICAgICAgIHR5cGU6IFwiRkNMOkZSQU1FOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJGQ0w6RlJBTUU6UkVBRFk6UkVTUE9OU0UgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgd2l0aCB0eXBlOiBGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGluY2x1ZGVPbGRlckpzb25ScGNDYWxsKSB7XG4gICAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBtZXRob2Q6IFwiZmNsOnNpZ25cIixcbiAgICAgICAgICAgICAgcGFyYW1zOiBbYm9keSwgc2VydmljZS5wYXJhbXNdLFxuICAgICAgICAgICAgICBkZXByZWNhdGVkOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJqc29ucnBjIGlzIGRlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIHdpdGggdHlwZTogRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblJlc3BvbnNlKGUsIF9yZWYzKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVBvbGxpbmdSZXNwb25zZShlLmRhdGEpO1xuICAgICAgICAgIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJBUFBST1ZFRFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AuZGF0YSk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRFQ0xJTkVEXCI6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6ICR7cmVzcC5yZWFzb24gfHwgXCJObyByZWFzb24gc3VwcGxpZWRcIn1gKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVESVJFQ1RcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiBObyByZWFzb24gc3VwcGxpZWRgKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJleGVjSWZyYW1lUlBDIG9uUmVzcG9uc2UgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25NZXNzYWdlKGUsIF9yZWY0KSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUuZGF0YS5qc29ucnBjICE9PSBcIjIuMFwiKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCAhPT0gaWQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwID0gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKGUuZGF0YS5yZXN1bHQpO1xuICAgICAgICAgIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJBUFBST1ZFRFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AuZGF0YSk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRFQ0xJTkVEXCI6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6ICR7cmVzcC5yZWFzb24gfHwgXCJObyByZWFzb24gc3VwcGxpZWRcIn1gKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVESVJFQ1RcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiBObyByZWFzb24gc3VwcGxpZWRgKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJleGVjSWZyYW1lUlBDIG9uTWVzc2FnZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsb3NlKCkge1xuICAgICAgICByZWplY3QoYERlY2xpbmVkOiBFeHRlcm5hbGx5IEhhbHRlZGApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3Qgbm9vcCQyID0gKCkgPT4ge307XG5mdW5jdGlvbiBwb3Aoc2VydmljZSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiB7XG4gICAgc2VuZDogbm9vcCQyLFxuICAgIGNsb3NlOiBub29wJDJcbiAgfTtcbiAgY29uc3Qgb25DbG9zZSA9IG9wdHMub25DbG9zZSB8fCBub29wJDI7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG9wdHMub25NZXNzYWdlIHx8IG5vb3AkMjtcbiAgY29uc3Qgb25SZWFkeSA9IG9wdHMub25SZWFkeSB8fCBub29wJDI7XG4gIGNvbnN0IG9uUmVzcG9uc2UgPSBvcHRzLm9uUmVzcG9uc2UgfHwgbm9vcCQyO1xuICBjb25zdCBoYW5kbGVyID0gYnVpbGRNZXNzYWdlSGFuZGxlcih7XG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvblJlYWR5LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25NZXNzYWdlXG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gIGNvbnN0IFskcG9wLCB1bm1vdW50XSA9IHJlbmRlclBvcChzZXJ2aWNlRW5kcG9pbnQoc2VydmljZSkpO1xuICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJHBvcCAmJiAkcG9wLmNsb3NlZCkge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH0sIDUwMCk7XG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBjbG9zZVxuICB9O1xuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICB1bm1vdW50KCk7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3B1cCBDbG9zZSBFcnJvclwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgdHJ5IHtcbiAgICAgICRwb3AucG9zdE1lc3NhZ2UoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtc2cgfHwge30pKSwgXCIqXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUG9wdXAgU2VuZCBFcnJvclwiLCBtc2csIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY1BvcFJQQyhfcmVmKSB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGlkID0gdWlkKCk7XG4gICAgY29uc3Qge1xuICAgICAgcmVkaXIsXG4gICAgICBpbmNsdWRlT2xkZXJKc29uUnBjQ2FsbFxuICAgIH0gPSBvcHRzO1xuICAgIHBvcChzZXJ2aWNlLCB7XG4gICAgICBhc3luYyBvblJlYWR5KF8sIF9yZWYyKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc2VuZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAgICAgdHlwZTogXCJGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHNlcnZpY2U6IHtcbiAgICAgICAgICAgICAgcGFyYW1zOiBzZXJ2aWNlLnBhcmFtcyxcbiAgICAgICAgICAgICAgZGF0YTogc2VydmljZS5kYXRhLFxuICAgICAgICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICAgICAgICB0eXBlOiBcIkZDTDpGUkFNRTpSRUFEWTpSRVNQT05TRVwiLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHNlcnZpY2U6IHtcbiAgICAgICAgICAgICAgcGFyYW1zOiBzZXJ2aWNlLnBhcmFtcyxcbiAgICAgICAgICAgICAgZGF0YTogc2VydmljZS5kYXRhLFxuICAgICAgICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBkZXByZWNhdGVkOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRkNMOkZSQU1FOlJFQURZOlJFU1BPTlNFIGlzIGRlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIHdpdGggdHlwZTogRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpbmNsdWRlT2xkZXJKc29uUnBjQ2FsbCkge1xuICAgICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgbWV0aG9kOiBcImZjbDpzaWduXCIsXG4gICAgICAgICAgICAgIHBhcmFtczogW2JvZHksIHNlcnZpY2UucGFyYW1zXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25SZXNwb25zZShlLCBfcmVmMykge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UoZS5kYXRhKTtcbiAgICAgICAgICBzd2l0Y2ggKHJlc3Auc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiQVBQUk9WRURcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLmRhdGEpO1xuICAgICAgICAgICAgICAhcmVkaXIgJiYgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNQb3BSUEMgb25SZXNwb25zZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1lc3NhZ2UoZSwgX3JlZjQpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoZS5kYXRhLmpzb25ycGMgIT09IFwiMi4wXCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkICE9PSBpZCkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UoZS5kYXRhLnJlc3VsdCk7XG4gICAgICAgICAgc3dpdGNoIChyZXNwLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5kYXRhKTtcbiAgICAgICAgICAgICAgIXJlZGlyICYmIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRFQ0xJTkVEXCI6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6ICR7cmVzcC5yZWFzb24gfHwgXCJObyByZWFzb24gc3VwcGxpZWRcIn1gKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVESVJFQ1RcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiBObyByZWFzb24gc3VwcGxpZWRgKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJleGVjUG9wUlBDIG9uTWVzc2FnZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsb3NlKCkge1xuICAgICAgICByZWplY3QoYERlY2xpbmVkOiBFeHRlcm5hbGx5IEhhbHRlZGApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3Qgbm9vcCQxID0gKCkgPT4ge307XG5mdW5jdGlvbiB0YWIoc2VydmljZSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiB7XG4gICAgc2VuZDogbm9vcCQxLFxuICAgIGNsb3NlOiBub29wJDFcbiAgfTtcbiAgY29uc3Qgb25DbG9zZSA9IG9wdHMub25DbG9zZSB8fCBub29wJDE7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG9wdHMub25NZXNzYWdlIHx8IG5vb3AkMTtcbiAgY29uc3Qgb25SZWFkeSA9IG9wdHMub25SZWFkeSB8fCBub29wJDE7XG4gIGNvbnN0IG9uUmVzcG9uc2UgPSBvcHRzLm9uUmVzcG9uc2UgfHwgbm9vcCQxO1xuICBjb25zdCBoYW5kbGVyID0gYnVpbGRNZXNzYWdlSGFuZGxlcih7XG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvblJlYWR5LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25NZXNzYWdlXG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gIGNvbnN0IFskdGFiLCB1bm1vdW50XSA9IHJlbmRlclRhYihzZXJ2aWNlRW5kcG9pbnQoc2VydmljZSkpO1xuICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJHRhYiAmJiAkdGFiLmNsb3NlZCkge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH0sIDUwMCk7XG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBjbG9zZVxuICB9O1xuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICB1bm1vdW50KCk7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYWIgQ2xvc2UgRXJyb3JcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgIHRyeSB7XG4gICAgICAkdGFiLnBvc3RNZXNzYWdlKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobXNnIHx8IHt9KSksIFwiKlwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRhYiBTZW5kIEVycm9yXCIsIG1zZywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjVGFiUlBDKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaWQgPSB1aWQoKTtcbiAgICBjb25zdCB7XG4gICAgICByZWRpcixcbiAgICAgIGluY2x1ZGVPbGRlckpzb25ScGNDYWxsXG4gICAgfSA9IG9wdHM7XG4gICAgdGFiKHNlcnZpY2UsIHtcbiAgICAgIGFzeW5jIG9uUmVhZHkoXywgX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzZW5kXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICAgICAgICB0eXBlOiBcIkZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgICAgICAgIHR5cGU6IFwiRkNMOkZSQU1FOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJGQ0w6RlJBTUU6UkVBRFk6UkVTUE9OU0UgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgd2l0aCB0eXBlOiBGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGluY2x1ZGVPbGRlckpzb25ScGNDYWxsKSB7XG4gICAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBtZXRob2Q6IFwiZmNsOnNpZ25cIixcbiAgICAgICAgICAgICAgcGFyYW1zOiBbYm9keSwgc2VydmljZS5wYXJhbXNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblJlc3BvbnNlKGUsIF9yZWYzKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVBvbGxpbmdSZXNwb25zZShlLmRhdGEpO1xuICAgICAgICAgIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJBUFBST1ZFRFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AuZGF0YSk7XG4gICAgICAgICAgICAgICFyZWRpciAmJiBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJERUNMSU5FRFwiOlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkXCJ9YCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFRElSRUNUXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogTm8gcmVhc29uIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXhlY1BvcFJQQyBvblJlc3BvbnNlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTWVzc2FnZShlLCBfcmVmNCkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLmRhdGEuanNvbnJwYyAhPT0gXCIyLjBcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLmRhdGEuaWQgIT09IGlkKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVBvbGxpbmdSZXNwb25zZShlLmRhdGEucmVzdWx0KTtcbiAgICAgICAgICBzd2l0Y2ggKHJlc3Auc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiQVBQUk9WRURcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLmRhdGEpO1xuICAgICAgICAgICAgICAhcmVkaXIgJiYgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNQb3BSUEMgb25NZXNzYWdlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHJlamVjdChgRGVjbGluZWQ6IEV4dGVybmFsbHkgSGFsdGVkYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5mdW5jdGlvbiBleHRlbnNpb24oc2VydmljZSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiB7XG4gICAgc2VuZDogbm9vcCxcbiAgICBjbG9zZTogbm9vcFxuICB9O1xuICBjb25zdCBvbkNsb3NlID0gb3B0cy5vbkNsb3NlIHx8IG5vb3A7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG9wdHMub25NZXNzYWdlIHx8IG5vb3A7XG4gIGNvbnN0IG9uUmVhZHkgPSBvcHRzLm9uUmVhZHkgfHwgbm9vcDtcbiAgY29uc3Qgb25SZXNwb25zZSA9IG9wdHMub25SZXNwb25zZSB8fCBub29wO1xuICBjb25zdCBoYW5kbGVyID0gYnVpbGRNZXNzYWdlSGFuZGxlcih7XG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvblJlYWR5LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25NZXNzYWdlXG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gIHNlbmQoe1xuICAgIHNlcnZpY2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBjbG9zZVxuICB9O1xuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgb25DbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXh0IENsb3NlIEVycm9yXCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICB0cnkge1xuICAgICAgd2luZG93ICYmIHdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1zZyB8fCB7fSkpLCBcIipcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeHQgU2VuZCBFcnJvclwiLCBtc2csIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY0V4dFJQQyhfcmVmKSB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGV4dGVuc2lvbihzZXJ2aWNlLCB7XG4gICAgICBhc3luYyBvblJlYWR5KF8sIF9yZWYyKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc2VuZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAgICAgdHlwZTogXCJGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHNlcnZpY2U6IHtcbiAgICAgICAgICAgICAgcGFyYW1zOiBzZXJ2aWNlLnBhcmFtcyxcbiAgICAgICAgICAgICAgZGF0YTogc2VydmljZS5kYXRhLFxuICAgICAgICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVzcG9uc2UoZSwgX3JlZjMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwID0gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKGUuZGF0YSk7XG4gICAgICAgICAgc3dpdGNoIChyZXNwLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5kYXRhKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNFeHRSUEMgb25SZXNwb25zZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsb3NlKCkge1xuICAgICAgICByZWplY3QoYERlY2xpbmVkOiBFeHRlcm5hbGx5IEhhbHRlZGApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgTk9UX0lNUExFTUVOVEVEID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJhdGVneSB1dGlsIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBvbiB0aGlzIHBsYXRmb3JtXCIpO1xufTtcbmNvbnN0IFZJRVdTID0ge1xuICBcIlZJRVcvSUZSQU1FXCI6IHJlbmRlckZyYW1lLFxuICBcIlZJRVcvUE9QXCI6IHJlbmRlclBvcCxcbiAgXCJWSUVXL1RBQlwiOiByZW5kZXJUYWIsXG4gIFwiVklFVy9NT0JJTEVfQlJPV1NFUlwiOiBOT1RfSU1QTEVNRU5URUQsXG4gIFwiVklFVy9ERUVQTElOS1wiOiBOT1RfSU1QTEVNRU5URURcbn07XG5hc3luYyBmdW5jdGlvbiBleGVjTG9jYWwoc2VydmljZSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgIHNlcnZpY2VFbmRwb2ludDogKCkgPT4ge31cbiAgfTtcbiAgY29uc3Qge1xuICAgIHNlcnZpY2VFbmRwb2ludFxuICB9ID0gb3B0cztcbiAgdHJ5IHtcbiAgICByZXR1cm4gVklFV1Nbc2VydmljZS5tZXRob2RdKHNlcnZpY2VFbmRwb2ludChzZXJ2aWNlKSwgb3B0cyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcImV4ZWNMb2NhbCh7c2VydmljZSwgb3B0cyA9IHt9fSlcIiwgZXJyb3IsIHtcbiAgICAgIHNlcnZpY2UsXG4gICAgICBvcHRzXG4gICAgfSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuY29uc3QgY29yZVN0cmF0ZWdpZXMgPSB7XG4gIFtDT1JFX1NUUkFURUdJRVNbXCJIVFRQL1JQQ1wiXV06IGdldEV4ZWNIdHRwUG9zdChleGVjTG9jYWwpLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiSFRUUC9QT1NUXCJdXTogZ2V0RXhlY0h0dHBQb3N0KGV4ZWNMb2NhbCksXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJJRlJBTUUvUlBDXCJdXTogZXhlY0lmcmFtZVJQQyxcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIlBPUC9SUENcIl1dOiBleGVjUG9wUlBDLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiVEFCL1JQQ1wiXV06IGV4ZWNUYWJSUEMsXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJFWFQvUlBDXCJdXTogZXhlY0V4dFJQQ1xufTtcblxuY29uc3QgbXV0YXRlID0gZ2V0TXV0YXRlKHtcbiAgcGxhdGZvcm06IFwid2ViXCJcbn0pO1xuY29uc3QgY3VycmVudFVzZXIgPSBnZXRDdXJyZW50VXNlcih7XG4gIHBsYXRmb3JtOiBcIndlYlwiXG59KTtcbmNvbnN0IGF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gY3VycmVudFVzZXIoKS5hdXRoZW50aWNhdGUob3B0cyk7XG59O1xuY29uc3QgdW5hdXRoZW50aWNhdGUgPSAoKSA9PiBjdXJyZW50VXNlcigpLnVuYXV0aGVudGljYXRlKCk7XG5jb25zdCByZWF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjdXJyZW50VXNlcigpLnVuYXV0aGVudGljYXRlKCk7XG4gIHJldHVybiBjdXJyZW50VXNlcigpLmF1dGhlbnRpY2F0ZShvcHRzKTtcbn07XG5jb25zdCBzaWduVXAgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGN1cnJlbnRVc2VyKCkuYXV0aGVudGljYXRlKG9wdHMpO1xufTtcbmNvbnN0IGxvZ0luID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBjdXJyZW50VXNlcigpLmF1dGhlbnRpY2F0ZShvcHRzKTtcbn07XG5jb25zdCBhdXRoeiA9IGN1cnJlbnRVc2VyKCkuYXV0aG9yaXphdGlvbjtcbmNvbmZpZyhnZXREZWZhdWx0Q29uZmlnKCkpO1xuaW5pdFNlcnZpY2VSZWdpc3RyeSh7XG4gIGNvcmVTdHJhdGVnaWVzXG59KTtcblxuZXhwb3J0IHsgaW5kZXgkMSBhcyBBcHBVdGlscywgaW5kZXggYXMgSW50ZXJhY3Rpb25UZW1wbGF0ZVV0aWxzLCBWRVJTSU9OLCBpbmRleCQyIGFzIFdhbGxldFV0aWxzLCBhdXRoZW50aWNhdGUsIGF1dGh6LCBjdXJyZW50VXNlciwgZGlzY292ZXJ5LCBldmVudHMsIGdldENoYWluSWQsIGxvZ0luLCBtdXRhdGUsIHBsdWdpblJlZ2lzdHJ5LCBxdWVyeSwgcmVhdXRoZW50aWNhdGUsIHNlcmlhbGl6ZSwgc2lnblVwLCB0LCB0cmFuc2FjdGlvbiBhcyB0eCwgdW5hdXRoZW50aWNhdGUsIHZlcmlmeVVzZXJTaWduYXR1cmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mY2wubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@onflow/fcl/dist/fcl.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/rlp/dist/rlp.module.js":
/*!*****************************************************!*\
  !*** ./node_modules/@onflow/rlp/dist/rlp.module.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buffer: function() { return /* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   getLength: function() { return /* binding */ getLength; },\n/* harmony export */   toBuffer: function() { return /* binding */ toBuffer; }\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\n\n\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n **/\n\n/**\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n **/\nfunction encode(input) {\n  if (Array.isArray(input)) {\n    var output = [];\n    for (var i = 0; i < input.length; i++) {\n      output.push(encode(input[i]));\n    }\n    var buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat(output);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(buf.length, 192), buf]);\n  } else {\n    var inputBuf = toBuffer(input);\n    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\n  }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v, base) {\n  if (v.slice(0, 2) === \"00\") {\n    throw new Error(\"invalid RLP: extra zeros\");\n  }\n  return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n  if (len < 56) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([len + offset]);\n  } else {\n    var hexLength = intToHex(len);\n    var lLength = hexLength.length / 2;\n    var firstByte = intToHex(offset + 55 + lLength);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(firstByte + hexLength, \"hex\");\n  }\n}\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n **/\n\n/**\n * @param input - will be converted to buffer\n * @param stream Is the input a stream (false by default)\n * @returns returns buffer of encoded data\n **/\nfunction decode(input, stream) {\n  if (stream === void 0) {\n    stream = false;\n  }\n  if (!input || input.length === 0) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n  }\n  var inputBuffer = toBuffer(input);\n  var decoded = _decode(inputBuffer);\n  if (stream) {\n    return decoded;\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error(\"invalid remainder\");\n  }\n  return decoded.data;\n}\n\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nfunction getLength(input) {\n  if (!input || input.length === 0) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n  }\n  var inputBuffer = toBuffer(input);\n  var firstByte = inputBuffer[0];\n  if (firstByte <= 0x7f) {\n    return inputBuffer.length;\n  } else if (firstByte <= 0xb7) {\n    return firstByte - 0x7f;\n  } else if (firstByte <= 0xbf) {\n    return firstByte - 0xb6;\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    return firstByte - 0xbf;\n  } else {\n    // a list  over 55 bytes long\n    var llength = firstByte - 0xf6;\n    var length = safeParseInt(inputBuffer.slice(1, llength).toString(\"hex\"), 16);\n    return llength + length;\n  }\n}\n\n/** Decode an input with RLP */\nfunction _decode(input) {\n  var length, llength, data, innerRemainder, d;\n  var decoded = [];\n  var firstByte = input[0];\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.slice(1)\n    };\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f;\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    } else {\n      data = input.slice(1, length);\n    }\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error(\"invalid rlp encoding: byte must be less 0x80\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length)\n    };\n  } else if (firstByte <= 0xbf) {\n    llength = firstByte - 0xb6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    data = input.slice(llength, length + llength);\n    if (data.length < length) {\n      throw new Error(\"invalid RLP\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length + llength)\n    };\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    length = firstByte - 0xbf;\n    innerRemainder = input.slice(1, length);\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(length)\n    };\n  } else {\n    // a list  over 55 bytes long\n    llength = firstByte - 0xf6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    var totalLength = llength + length;\n    if (totalLength > input.length) {\n      throw new Error(\"invalid rlp: total length is larger than the data\");\n    }\n    innerRemainder = input.slice(llength, totalLength);\n    if (innerRemainder.length === 0) {\n      throw new Error(\"invalid rlp, List has a invalid length\");\n    }\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(totalLength)\n    };\n  }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n  return str.slice(0, 2) === \"0x\";\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n  if (typeof str !== \"string\") {\n    return str;\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer) {\n  if (integer < 0) {\n    throw new Error(\"Invalid integer as argument, must be unsigned!\");\n  }\n  var hex = integer.toString(16);\n  return hex.length % 2 ? \"0\" + hex : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n  return a.length % 2 ? \"0\" + a : a;\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer) {\n  var hex = intToHex(integer);\n  return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n}\n\n/** Transform anything into a Buffer */\nfunction toBuffer(v) {\n  if (!buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(v)) {\n    if (typeof v === \"string\") {\n      if (isHexPrefixed(v)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(padToEven(stripHexPrefix(v)), \"hex\");\n      } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);\n      }\n    } else if (typeof v === \"number\") {\n      if (!v) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n      } else {\n        return intToBuffer(v);\n      }\n    } else if (v === null || v === undefined) {\n      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    } else if (v instanceof Uint8Array) {\n      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);\n    } else {\n      throw new Error(\"invalid type\");\n    }\n  }\n  return v;\n}\n\n\n//# sourceMappingURL=rlp.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9ybHAvZGlzdC9ybHAubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnQztBQUNBOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLDBDQUFNO0FBQ3BCLFdBQVcsMENBQU07QUFDakIsSUFBSTtBQUNKO0FBQ0EsbUVBQW1FLDBDQUFNO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQU07QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDBDQUFNO0FBQ2I7QUFDQTtBQUNBLGVBQWUsMENBQU07QUFDckIsUUFBUTtBQUNSLGVBQWUsMENBQU07QUFDckI7QUFDQSxNQUFNO0FBQ047QUFDQSxlQUFlLDBDQUFNO0FBQ3JCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsMENBQU07QUFDbkIsTUFBTTtBQUNOLGFBQWEsMENBQU07QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ab25mbG93L3JscC9kaXN0L3JscC5tb2R1bGUuanM/NWQ1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcblxuLyoqXG4gKiBCdWlsdCBvbiB0b3Agb2YgcmxwIGxpYnJhcnksIHJlbW92aW5nIHRoZSBCTiBkZXBlbmRlbmN5IGZvciB0aGUgZmxvdy5cbiAqIFBhY2thZ2UgOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHBcbiAqIFJMUCBMaWNlbnNlIDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBldGhlcmV1bWpzL3JscCBpcyBsaWNlbnNlZCB1bmRlciB0aGVcbiAqIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wXG4gKiBQZXJtaXNzaW9ucyBvZiB0aGlzIHdlYWsgY29weWxlZnQgbGljZW5zZSBhcmUgY29uZGl0aW9uZWQgb24gbWFraW5nIGF2YWlsYWJsZSBzb3VyY2UgY29kZSBvZiBsaWNlbnNlZCBmaWxlcyBhbmQgbW9kaWZpY2F0aW9ucyBvZiB0aG9zZSBmaWxlcyB1bmRlciB0aGUgc2FtZSBsaWNlbnNlIChvciBpbiBjZXJ0YWluIGNhc2VzLCBvbmUgb2YgdGhlIEdOVSBsaWNlbnNlcykuIENvcHlyaWdodCBhbmQgbGljZW5zZSBub3RpY2VzIG11c3QgYmUgcHJlc2VydmVkLiBDb250cmlidXRvcnMgcHJvdmlkZSBhbiBleHByZXNzIGdyYW50IG9mIHBhdGVudCByaWdodHMuIEhvd2V2ZXIsIGEgbGFyZ2VyIHdvcmsgdXNpbmcgdGhlIGxpY2Vuc2VkIHdvcmsgbWF5IGJlIGRpc3RyaWJ1dGVkIHVuZGVyIGRpZmZlcmVudCB0ZXJtcyBhbmQgd2l0aG91dCBzb3VyY2UgY29kZSBmb3IgZmlsZXMgYWRkZWQgaW4gdGhlIGxhcmdlciB3b3JrLlxuICoqL1xuXG4vKipcbiAqIEBwYXJhbSBpbnB1dCAtIHdpbGwgYmUgY29udmVydGVkIHRvIGJ1ZmZlclxuICogQHJldHVybnMgcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKGVuY29kZShpbnB1dFtpXSkpO1xuICAgIH1cbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChvdXRwdXQpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNvZGVMZW5ndGgoYnVmLmxlbmd0aCwgMTkyKSwgYnVmXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlucHV0QnVmID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjggPyBpbnB1dEJ1ZiA6IEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBpbnRlZ2Vycy4gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gbGVhZGluZyB6ZXJvc1xuICogQHBhcmFtIHYgVGhlIHZhbHVlIHRvIHBhcnNlXG4gKiBAcGFyYW0gYmFzZSBUaGUgYmFzZSB0byBwYXJzZSB0aGUgaW50ZWdlciBpbnRvXG4gKi9cbmZ1bmN0aW9uIHNhZmVQYXJzZUludCh2LCBiYXNlKSB7XG4gIGlmICh2LnNsaWNlKDAsIDIpID09PSBcIjAwXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJMUDogZXh0cmEgemVyb3NcIik7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHYsIGJhc2UpO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGxlbiwgb2Zmc2V0KSB7XG4gIGlmIChsZW4gPCA1Nikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShbbGVuICsgb2Zmc2V0XSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhleExlbmd0aCA9IGludFRvSGV4KGxlbik7XG4gICAgdmFyIGxMZW5ndGggPSBoZXhMZW5ndGgubGVuZ3RoIC8gMjtcbiAgICB2YXIgZmlyc3RCeXRlID0gaW50VG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlyc3RCeXRlICsgaGV4TGVuZ3RoLCBcImhleFwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWx0IG9uIHRvcCBvZiBybHAgbGlicmFyeSwgcmVtb3ZpbmcgdGhlIEJOIGRlcGVuZGVuY3kgZm9yIHRoZSBmbG93LlxuICogUGFja2FnZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscFxuICogUkxQIExpY2Vuc2UgOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHAvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIGV0aGVyZXVtanMvcmxwIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZVxuICogTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjBcbiAqIFBlcm1pc3Npb25zIG9mIHRoaXMgd2VhayBjb3B5bGVmdCBsaWNlbnNlIGFyZSBjb25kaXRpb25lZCBvbiBtYWtpbmcgYXZhaWxhYmxlIHNvdXJjZSBjb2RlIG9mIGxpY2Vuc2VkIGZpbGVzIGFuZCBtb2RpZmljYXRpb25zIG9mIHRob3NlIGZpbGVzIHVuZGVyIHRoZSBzYW1lIGxpY2Vuc2UgKG9yIGluIGNlcnRhaW4gY2FzZXMsIG9uZSBvZiB0aGUgR05VIGxpY2Vuc2VzKS4gQ29weXJpZ2h0IGFuZCBsaWNlbnNlIG5vdGljZXMgbXVzdCBiZSBwcmVzZXJ2ZWQuIENvbnRyaWJ1dG9ycyBwcm92aWRlIGFuIGV4cHJlc3MgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cy4gSG93ZXZlciwgYSBsYXJnZXIgd29yayB1c2luZyB0aGUgbGljZW5zZWQgd29yayBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZGlmZmVyZW50IHRlcm1zIGFuZCB3aXRob3V0IHNvdXJjZSBjb2RlIGZvciBmaWxlcyBhZGRlZCBpbiB0aGUgbGFyZ2VyIHdvcmsuXG4gKiovXG5cbi8qKlxuICogQHBhcmFtIGlucHV0IC0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYnVmZmVyXG4gKiBAcGFyYW0gc3RyZWFtIElzIHRoZSBpbnB1dCBhIHN0cmVhbSAoZmFsc2UgYnkgZGVmYXVsdClcbiAqIEByZXR1cm5zIHJldHVybnMgYnVmZmVyIG9mIGVuY29kZWQgZGF0YVxuICoqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbSA9PT0gdm9pZCAwKSB7XG4gICAgc3RyZWFtID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICB9XG4gIHZhciBpbnB1dEJ1ZmZlciA9IHRvQnVmZmVyKGlucHV0KTtcbiAgdmFyIGRlY29kZWQgPSBfZGVjb2RlKGlucHV0QnVmZmVyKTtcbiAgaWYgKHN0cmVhbSkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIGlmIChkZWNvZGVkLnJlbWFpbmRlci5sZW5ndGggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlbWFpbmRlclwiKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZC5kYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBSTFAgaW5wdXRcbiAqIEBwYXJhbSBpbnB1dFxuICogQHJldHVybnMgVGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgb3IgYW4gZW1wdHkgQnVmZmVyIGlmIG5vIGlucHV0XG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aChpbnB1dCkge1xuICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gIH1cbiAgdmFyIGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xuICB2YXIgZmlyc3RCeXRlID0gaW5wdXRCdWZmZXJbMF07XG4gIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgIHJldHVybiBpbnB1dEJ1ZmZlci5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICByZXR1cm4gZmlyc3RCeXRlIC0gMHg3ZjtcbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGI2O1xuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgLy8gYSBsaXN0IGJldHdlZW4gIDAtNTUgYnl0ZXMgbG9uZ1xuICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGJmO1xuICB9IGVsc2Uge1xuICAgIC8vIGEgbGlzdCAgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgdmFyIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgIHZhciBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXRCdWZmZXIuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoXCJoZXhcIiksIDE2KTtcbiAgICByZXR1cm4gbGxlbmd0aCArIGxlbmd0aDtcbiAgfVxufVxuXG4vKiogRGVjb2RlIGFuIGlucHV0IHdpdGggUkxQICovXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gIHZhciBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICB2YXIgZGVjb2RlZCA9IFtdO1xuICB2YXIgZmlyc3RCeXRlID0gaW5wdXRbMF07XG4gIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgIC8vIGEgc2luZ2xlIGJ5dGUgd2hvc2UgdmFsdWUgaXMgaW4gdGhlIFsweDAwLCAweDdmXSByYW5nZSwgdGhhdCBieXRlIGlzIGl0cyBvd24gUkxQIGVuY29kaW5nLlxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgLy8gc3RyaW5nIGlzIDAtNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHZhbHVlIDB4ODAgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgIC8vIFRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYnl0ZSBpcyBbMHg4MCwgMHhiN11cbiAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgIC8vIHNldCAweDgwIG51bGwgdG8gMFxuICAgIGlmIChmaXJzdEJ5dGUgPT09IDB4ODApIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBlbmNvZGluZzogYnl0ZSBtdXN0IGJlIGxlc3MgMHg4MFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKFwiaGV4XCIpLCAxNik7XG4gICAgZGF0YSA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBSTFBcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKDEsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBsaXN0ICBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXQuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoXCJoZXhcIiksIDE2KTtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBybHA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YVwiKTtcbiAgICB9XG4gICAgaW5uZXJSZW1haW5kZXIgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgaWYgKGlubmVyUmVtYWluZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBybHAsIExpc3QgaGFzIGEgaW52YWxpZCBsZW5ndGhcIik7XG4gICAgfVxuICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKVxuICAgIH07XG4gIH1cbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gXCIweFwiO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXG5mdW5jdGlvbiBpbnRUb0hleChpbnRlZ2VyKSB7XG4gIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCFcIik7XG4gIH1cbiAgdmFyIGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cbi8qKiBQYWQgYSBzdHJpbmcgdG8gYmUgZXZlbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKGEpIHtcbiAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IFwiMFwiICsgYSA6IGE7XG59XG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIEJ1ZmZlciAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaW50ZWdlcikge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaW50ZWdlcik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpO1xufVxuXG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBCdWZmZXIgKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChpc0hleFByZWZpeGVkKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpLCBcImhleFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoIXYpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnRUb0J1ZmZlcih2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0eXBlXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IHsgZGVjb2RlLCBlbmNvZGUsIGdldExlbmd0aCwgdG9CdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@onflow/rlp/dist/rlp.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/sdk/dist/sdk.module.js":
/*!*****************************************************!*\
  !*** ./node_modules/@onflow/sdk/dist/sdk.module.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TestUtils: function() { return /* binding */ index; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   account: function() { return /* binding */ account; },\n/* harmony export */   arg: function() { return /* binding */ arg; },\n/* harmony export */   args: function() { return /* binding */ args; },\n/* harmony export */   atBlockHeight: function() { return /* binding */ atBlockHeight; },\n/* harmony export */   atBlockId: function() { return /* binding */ atBlockId; },\n/* harmony export */   authorization: function() { return /* binding */ authorization; },\n/* harmony export */   authorizations: function() { return /* binding */ authorizations; },\n/* harmony export */   block: function() { return /* binding */ block; },\n/* harmony export */   build: function() { return /* binding */ build; },\n/* harmony export */   cadence: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template; },\n/* harmony export */   cdc: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template; },\n/* harmony export */   config: function() { return /* reexport safe */ _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config; },\n/* harmony export */   createSignableVoucher: function() { return /* binding */ createSignableVoucher; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   destroy: function() { return /* binding */ destroy; },\n/* harmony export */   encodeMessageFromSignable: function() { return /* binding */ encodeMessageFromSignable; },\n/* harmony export */   encodeTransactionEnvelope: function() { return /* binding */ encodeTransactionEnvelope; },\n/* harmony export */   encodeTransactionPayload: function() { return /* binding */ encodeTransactionPayload; },\n/* harmony export */   encodeTxIdFromVoucher: function() { return /* binding */ encodeTxIdFromVoucher; },\n/* harmony export */   get: function() { return /* binding */ get; },\n/* harmony export */   getAccount: function() { return /* binding */ getAccount; },\n/* harmony export */   getBlock: function() { return /* binding */ getBlock; },\n/* harmony export */   getBlockHeader: function() { return /* binding */ getBlockHeader; },\n/* harmony export */   getCollection: function() { return /* binding */ getCollection; },\n/* harmony export */   getEvents: function() { return /* binding */ getEvents; },\n/* harmony export */   getEventsAtBlockHeightRange: function() { return /* binding */ getEventsAtBlockHeightRange; },\n/* harmony export */   getEventsAtBlockIds: function() { return /* binding */ getEventsAtBlockIds; },\n/* harmony export */   getNetworkParameters: function() { return /* binding */ getNetworkParameters; },\n/* harmony export */   getTransaction: function() { return /* binding */ getTransaction; },\n/* harmony export */   getTransactionStatus: function() { return /* binding */ getTransactionStatus; },\n/* harmony export */   interaction: function() { return /* binding */ interaction; },\n/* harmony export */   invariant: function() { return /* binding */ invariant; },\n/* harmony export */   isBad: function() { return /* binding */ isBad; },\n/* harmony export */   isGetAccount: function() { return /* binding */ isGetAccount; },\n/* harmony export */   isGetBlock: function() { return /* binding */ isGetBlock; },\n/* harmony export */   isGetBlockHeader: function() { return /* binding */ isGetBlockHeader; },\n/* harmony export */   isGetCollection: function() { return /* binding */ isGetCollection; },\n/* harmony export */   isGetEvents: function() { return /* binding */ isGetEvents; },\n/* harmony export */   isGetNetworkParameters: function() { return /* binding */ isGetNetworkParameters; },\n/* harmony export */   isGetTransaction: function() { return /* binding */ isGetTransaction; },\n/* harmony export */   isGetTransactionStatus: function() { return /* binding */ isGetTransactionStatus; },\n/* harmony export */   isOk: function() { return /* binding */ isOk; },\n/* harmony export */   isPing: function() { return /* binding */ isPing; },\n/* harmony export */   isScript: function() { return /* binding */ isScript; },\n/* harmony export */   isTransaction: function() { return /* binding */ isTransaction; },\n/* harmony export */   isUnknown: function() { return /* binding */ isUnknown; },\n/* harmony export */   limit: function() { return /* binding */ limit; },\n/* harmony export */   param: function() { return /* binding */ param; },\n/* harmony export */   params: function() { return /* binding */ params; },\n/* harmony export */   payer: function() { return /* binding */ payer; },\n/* harmony export */   ping: function() { return /* binding */ ping; },\n/* harmony export */   pipe: function() { return /* binding */ pipe; },\n/* harmony export */   proposer: function() { return /* binding */ proposer; },\n/* harmony export */   put: function() { return /* binding */ put; },\n/* harmony export */   ref: function() { return /* binding */ ref; },\n/* harmony export */   resolve: function() { return /* binding */ resolve; },\n/* harmony export */   resolveAccounts: function() { return /* binding */ resolveAccounts; },\n/* harmony export */   resolveArguments: function() { return /* binding */ resolveArguments; },\n/* harmony export */   resolveCadence: function() { return /* binding */ resolveCadence; },\n/* harmony export */   resolveFinalNormalization: function() { return /* binding */ resolveFinalNormalization; },\n/* harmony export */   resolveProposerSequenceNumber: function() { return /* binding */ resolveProposerSequenceNumber; },\n/* harmony export */   resolveRefBlockId: function() { return /* binding */ resolveRefBlockId; },\n/* harmony export */   resolveSignatures: function() { return /* binding */ resolveSignatures; },\n/* harmony export */   resolveValidators: function() { return /* binding */ resolveValidators; },\n/* harmony export */   resolveVoucherIntercept: function() { return /* binding */ resolveVoucherIntercept; },\n/* harmony export */   response: function() { return /* binding */ response; },\n/* harmony export */   script: function() { return /* binding */ script; },\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   transaction: function() { return /* binding */ transaction; },\n/* harmony export */   update: function() { return /* binding */ update; },\n/* harmony export */   validator: function() { return /* binding */ validator; },\n/* harmony export */   voucherIntercept: function() { return /* binding */ voucherIntercept; },\n/* harmony export */   voucherToTxId: function() { return /* binding */ voucherToTxId; },\n/* harmony export */   why: function() { return /* binding */ why; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-logger */ \"./node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/util-invariant */ \"./node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var _onflow_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/config */ \"./node_modules/@onflow/config/dist/config.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @onflow/rlp */ \"./node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/transport-http */ \"./node_modules/@onflow/transport-http/dist/sdk-send-http.module.js\");\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @onflow/util-address */ \"./node_modules/@onflow/util-address/dist/util-address.module.js\");\n/* harmony import */ var sha3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! sha3 */ \"./node_modules/sha3/index.js\");\n/* harmony import */ var _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @onflow/util-template */ \"./node_modules/@onflow/util-template/dist/template.module.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst UNKNOWN /*                       */ = \"UNKNOWN\";\nconst SCRIPT /*                        */ = \"SCRIPT\";\nconst TRANSACTION /*                   */ = \"TRANSACTION\";\nconst GET_TRANSACTION_STATUS /*        */ = \"GET_TRANSACTION_STATUS\";\nconst GET_ACCOUNT /*                   */ = \"GET_ACCOUNT\";\nconst GET_EVENTS /*                    */ = \"GET_EVENTS\";\nconst PING /*                          */ = \"PING\";\nconst GET_TRANSACTION /*               */ = \"GET_TRANSACTION\";\nconst GET_BLOCK /*                     */ = \"GET_BLOCK\";\nconst GET_BLOCK_HEADER /*              */ = \"GET_BLOCK_HEADER\";\nconst GET_COLLECTION /*                */ = \"GET_COLLECTION\";\nconst GET_NETWORK_PARAMETERS /*        */ = \"GET_NETWORK_PARAMETERS\";\nconst BAD /* */ = \"BAD\";\nconst OK /*  */ = \"OK\";\nconst ACCOUNT /*  */ = \"ACCOUNT\";\nconst PARAM /*    */ = \"PARAM\";\nconst ARGUMENT /* */ = \"ARGUMENT\";\nconst AUTHORIZER /* */ = \"authorizer\";\nconst PAYER /*      */ = \"payer\";\nconst PROPOSER /*   */ = \"proposer\";\nconst ACCT = `{\n  \"kind\":\"${ACCOUNT}\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}`;\nconst ARG = `{\n  \"kind\":\"${ARGUMENT}\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}`;\nconst IX = `{\n  \"tag\":\"${UNKNOWN}\",\n  \"assigns\":{},\n  \"status\":\"${OK}\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}`;\nconst KEYS = new Set(Object.keys(JSON.parse(IX)));\nconst interaction = () => JSON.parse(IX);\nconst CHARS = \"abcdefghijklmnopqrstuvwxyz0123456789\".split(\"\");\nconst randChar = () => CHARS[~~(Math.random() * CHARS.length)];\nconst uuid = () => Array.from({\n  length: 10\n}, randChar).join(\"\");\nconst isNumber$1 = d => typeof d === \"number\";\nconst isArray$1 = d => Array.isArray(d);\nconst isObj = d => d !== null && typeof d === \"object\";\nconst isNull = d => d == null;\nconst isFn$3 = d => typeof d === \"function\";\nconst isInteraction = ix => {\n  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;\n  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;\n  return true;\n};\nconst Ok = ix => {\n  ix.status = OK;\n  return ix;\n};\nconst Bad = (ix, reason) => {\n  ix.status = BAD;\n  ix.reason = reason;\n  return ix;\n};\nconst makeIx = wat => ix => {\n  ix.tag = wat;\n  return Ok(ix);\n};\nconst prepAccountKeyId = acct => {\n  if (acct.keyId == null) return acct;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!isNaN(parseInt(acct.keyId)), \"account.keyId must be an integer\");\n  return {\n    ...acct,\n    keyId: parseInt(acct.keyId)\n  };\n};\nconst prepAccount = function (acct) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return ix => {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(typeof acct === \"function\" || typeof acct === \"object\", \"prepAccount must be passed an authorization function or an account object\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(opts.role != null, \"Account must have a role\");\n    const ACCOUNT = JSON.parse(ACCT);\n    const role = opts.role;\n    const tempId = uuid();\n    if (acct.authorization && isFn$3(acct.authorization)) acct = {\n      resolve: acct.authorization\n    };\n    if (!acct.authorization && isFn$3(acct)) acct = {\n      resolve: acct\n    };\n    const resolve = acct.resolve;\n    if (resolve) acct.resolve = function (acct) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      return [resolve, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct);\n    };\n    acct = prepAccountKeyId(acct);\n    ix.accounts[tempId] = {\n      ...ACCOUNT,\n      tempId,\n      ...acct,\n      role: {\n        ...ACCOUNT.role,\n        ...(typeof acct.role === \"object\" ? acct.role : {}),\n        [role]: true\n      }\n    };\n    if (role === AUTHORIZER) {\n      ix.authorizations.push(tempId);\n    } else if (role === PAYER) {\n      ix.payer.push(tempId);\n    } else {\n      ix[role] = tempId;\n    }\n    return ix;\n  };\n};\nconst makeArgument = arg => ix => {\n  let tempId = uuid();\n  ix.message.arguments.push(tempId);\n  ix.arguments[tempId] = JSON.parse(ARG);\n  ix.arguments[tempId].tempId = tempId;\n  ix.arguments[tempId].value = arg.value;\n  ix.arguments[tempId].asArgument = arg.asArgument;\n  ix.arguments[tempId].xform = arg.xform;\n  ix.arguments[tempId].resolve = arg.resolve;\n  ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;\n  return Ok(ix);\n};\nconst makeUnknown /*                 */ = makeIx(UNKNOWN);\nconst makeScript /*                  */ = makeIx(SCRIPT);\nconst makeTransaction /*             */ = makeIx(TRANSACTION);\nconst makeGetTransactionStatus /*    */ = makeIx(GET_TRANSACTION_STATUS);\nconst makeGetTransaction /*          */ = makeIx(GET_TRANSACTION);\nconst makeGetAccount /*              */ = makeIx(GET_ACCOUNT);\nconst makeGetEvents /*               */ = makeIx(GET_EVENTS);\nconst makePing /*                    */ = makeIx(PING);\nconst makeGetBlock /*                */ = makeIx(GET_BLOCK);\nconst makeGetBlockHeader /*          */ = makeIx(GET_BLOCK_HEADER);\nconst makeGetCollection /*           */ = makeIx(GET_COLLECTION);\nconst makeGetNetworkParameters /*    */ = makeIx(GET_NETWORK_PARAMETERS);\nconst is = wat => ix => ix.tag === wat;\nconst isUnknown /*                 */ = is(UNKNOWN);\nconst isScript /*                  */ = is(SCRIPT);\nconst isTransaction /*             */ = is(TRANSACTION);\nconst isGetTransactionStatus /*    */ = is(GET_TRANSACTION_STATUS);\nconst isGetTransaction /*          */ = is(GET_TRANSACTION);\nconst isGetAccount /*              */ = is(GET_ACCOUNT);\nconst isGetEvents /*               */ = is(GET_EVENTS);\nconst isPing /*                    */ = is(PING);\nconst isGetBlock /*                */ = is(GET_BLOCK);\nconst isGetBlockHeader /*          */ = is(GET_BLOCK_HEADER);\nconst isGetCollection /*           */ = is(GET_COLLECTION);\nconst isGetNetworkParameters /*    */ = is(GET_NETWORK_PARAMETERS);\nconst isOk /*  */ = ix => ix.status === OK;\nconst isBad /* */ = ix => ix.status === BAD;\nconst why /*   */ = ix => ix.reason;\nconst isAccount /*  */ = account => account.kind === ACCOUNT;\nconst isParam /*    */ = param => param.kind === PARAM;\nconst isArgument /* */ = argument => argument.kind === ARGUMENT;\nconst hardMode = ix => {\n  for (let key of Object.keys(ix)) {\n    if (!KEYS.has(key)) throw new Error(`\"${key}\" is an invalid root level Interaction property.`);\n  }\n  return ix;\n};\nconst recPipe = async function (ix) {\n  let fns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  try {\n    ix = hardMode(await ix);\n    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);\n    if (!fns.length) return ix;\n    const [hd, ...rest] = fns;\n    const cur = await hd;\n    if (isFn$3(cur)) return recPipe(cur(ix), rest);\n    if (isNull(cur) || !cur) return recPipe(ix, rest);\n    if (isInteraction(cur)) return recPipe(cur, rest);\n    throw new Error(\"Invalid Interaction Composition\");\n  } catch (e) {\n    throw e;\n  }\n};\nconst pipe = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  const [arg1, arg2] = args;\n  if (isArray$1(arg1) && arg2 == null) return d => pipe(d, arg1);\n  return recPipe(arg1, arg2);\n};\nconst identity$1 = v => v;\nconst get = (ix, key, fallback) => {\n  return ix.assigns[key] == null ? fallback : ix.assigns[key];\n};\nconst put = (key, value) => ix => {\n  ix.assigns[key] = value;\n  return Ok(ix);\n};\nconst update = function (key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  return ix => {\n    ix.assigns[key] = fn(ix.assigns[key], ix);\n    return Ok(ix);\n  };\n};\nconst destroy = key => ix => {\n  delete ix.assigns[key];\n  return Ok(ix);\n};\n\nvar ixModule = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  UNKNOWN: UNKNOWN,\n  SCRIPT: SCRIPT,\n  TRANSACTION: TRANSACTION,\n  GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,\n  GET_ACCOUNT: GET_ACCOUNT,\n  GET_EVENTS: GET_EVENTS,\n  PING: PING,\n  GET_TRANSACTION: GET_TRANSACTION,\n  GET_BLOCK: GET_BLOCK,\n  GET_BLOCK_HEADER: GET_BLOCK_HEADER,\n  GET_COLLECTION: GET_COLLECTION,\n  GET_NETWORK_PARAMETERS: GET_NETWORK_PARAMETERS,\n  BAD: BAD,\n  OK: OK,\n  ACCOUNT: ACCOUNT,\n  PARAM: PARAM,\n  ARGUMENT: ARGUMENT,\n  AUTHORIZER: AUTHORIZER,\n  PAYER: PAYER,\n  PROPOSER: PROPOSER,\n  interaction: interaction,\n  uuid: uuid,\n  isNumber: isNumber$1,\n  isArray: isArray$1,\n  isObj: isObj,\n  isNull: isNull,\n  isFn: isFn$3,\n  isInteraction: isInteraction,\n  Ok: Ok,\n  Bad: Bad,\n  prepAccount: prepAccount,\n  makeArgument: makeArgument,\n  makeUnknown: makeUnknown,\n  makeScript: makeScript,\n  makeTransaction: makeTransaction,\n  makeGetTransactionStatus: makeGetTransactionStatus,\n  makeGetTransaction: makeGetTransaction,\n  makeGetAccount: makeGetAccount,\n  makeGetEvents: makeGetEvents,\n  makePing: makePing,\n  makeGetBlock: makeGetBlock,\n  makeGetBlockHeader: makeGetBlockHeader,\n  makeGetCollection: makeGetCollection,\n  makeGetNetworkParameters: makeGetNetworkParameters,\n  isUnknown: isUnknown,\n  isScript: isScript,\n  isTransaction: isTransaction,\n  isGetTransactionStatus: isGetTransactionStatus,\n  isGetTransaction: isGetTransaction,\n  isGetAccount: isGetAccount,\n  isGetEvents: isGetEvents,\n  isPing: isPing,\n  isGetBlock: isGetBlock,\n  isGetBlockHeader: isGetBlockHeader,\n  isGetCollection: isGetCollection,\n  isGetNetworkParameters: isGetNetworkParameters,\n  isOk: isOk,\n  isBad: isBad,\n  why: why,\n  isAccount: isAccount,\n  isParam: isParam,\n  isArgument: isArgument,\n  pipe: pipe,\n  get: get,\n  put: put,\n  update: update,\n  destroy: destroy\n});\n\nfunction build() {\n  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(interaction(), fns);\n}\n\nconst DEFAULT_RESPONSE = `{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null,\n    \"networkParameters\":null\n}`;\nconst response = () => JSON.parse(DEFAULT_RESPONSE);\n\n/**\n * @description - A builder function that returns the interaction to get the latest block\n * @param {boolean} [isSealed] - Whether or not the block should be sealed\n * @returns {Function} - An interaction object\n */\nfunction getBlock() {\n  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetBlock, ix => {\n    ix.block.isSealed = isSealed;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns the interaction to get an account by address\n * @param {string} addr - The address of the account to getq\n * @returns {Function} - An interaction object\n */\nfunction getAccount(addr) {\n  return pipe([makeGetAccount, ix => {\n    ix.account.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(addr);\n    return Ok(ix);\n  }]);\n}\n\nconst latestBlockDeprecationNotice = () => {\n  _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n    pkg: \"@onflow/decode\",\n    subject: \"Operating upon data of the latestBlock field of the response object\",\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\"\n  });\n};\nconst decodeImplicit = async i => i;\nconst decodeVoid = async () => null;\nconst decodeType = async type => {\n  return type.staticType;\n};\nconst decodePath = async path => {\n  return {\n    domain: path.domain,\n    identifier: path.identifier\n  };\n};\nconst decodeCapability = async cap => {\n  return {\n    path: cap.path,\n    address: cap.address,\n    borrowType: cap.borrowType\n  };\n};\nconst decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;\nconst decodeReference = async v => ({\n  address: v.address,\n  type: v.type\n});\nconst decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));\nconst decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {\n  acc = await acc;\n  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);\n  return acc;\n}, Promise.resolve({}));\nconst decodeComposite = async (composite, decoders, stack) => {\n  const decoded = await composite.fields.reduce(async (acc, v) => {\n    acc = await acc;\n    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);\n    return acc;\n  }, Promise.resolve({}));\n  const decoder = composite.id && decoderLookup(decoders, composite.id);\n  return decoder ? await decoder(decoded) : decoded;\n};\nconst defaultDecoders = {\n  UInt: decodeImplicit,\n  Int: decodeImplicit,\n  UInt8: decodeImplicit,\n  Int8: decodeImplicit,\n  UInt16: decodeImplicit,\n  Int16: decodeImplicit,\n  UInt32: decodeImplicit,\n  Int32: decodeImplicit,\n  UInt64: decodeImplicit,\n  Int64: decodeImplicit,\n  UInt128: decodeImplicit,\n  Int128: decodeImplicit,\n  UInt256: decodeImplicit,\n  Int256: decodeImplicit,\n  Word8: decodeImplicit,\n  Word16: decodeImplicit,\n  Word32: decodeImplicit,\n  Word64: decodeImplicit,\n  UFix64: decodeImplicit,\n  Fix64: decodeImplicit,\n  String: decodeImplicit,\n  Character: decodeImplicit,\n  Bool: decodeImplicit,\n  Address: decodeImplicit,\n  Void: decodeVoid,\n  Optional: decodeOptional,\n  Reference: decodeReference,\n  Array: decodeArray,\n  Dictionary: decodeDictionary,\n  Event: decodeComposite,\n  Resource: decodeComposite,\n  Struct: decodeComposite,\n  Enum: decodeComposite,\n  Type: decodeType,\n  Path: decodePath,\n  Capability: decodeCapability\n};\nconst decoderLookup = (decoders, lookup) => {\n  const found = Object.keys(decoders).find(decoder => {\n    if (/^\\/.*\\/$/.test(decoder)) {\n      const reg = new RegExp(decoder.substring(1, decoder.length - 1));\n      return reg.test(lookup);\n    }\n    return decoder === lookup;\n  });\n  return lookup && found && decoders[found];\n};\nconst recurseDecode = async (decodeInstructions, decoders, stack) => {\n  let decoder = decoderLookup(decoders, decodeInstructions.type);\n  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(\".\")}`);\n  return await decoder(decodeInstructions.value, decoders, stack);\n};\n\n/**\n * @description - Decodes a response from Flow into JSON\n * @param {*} decodeInstructions - The response object from Flow\n * @param {object} customDecoders - An object of custom decoders\n * @param {Array<*>} stack - The stack of the current decoding\n * @returns {Promise<*>} - The decoded response\n */\nconst decode$1 = async function (decodeInstructions) {\n  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  // Filter out all default decoders which are overridden by a custom decoder regex\n  const filteredDecoders = Object.keys(defaultDecoders).filter(decoder => !Object.keys(customDecoders).find(customDecoder => new RegExp(customDecoder).test(decoder))).reduce((decoders, decoderKey) => {\n    decoders[decoderKey] = defaultDecoders[decoderKey];\n    return decoders;\n  }, customDecoders);\n  const decoders = {\n    ...filteredDecoders,\n    ...customDecoders\n  };\n  return recurseDecode(decodeInstructions, decoders, stack);\n};\nconst decodeResponse = async function (response) {\n  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (response.encodedData) {\n    return decode$1(response.encodedData, customDecoders);\n  } else if (response.transactionStatus) {\n    return {\n      ...response.transactionStatus,\n      events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {\n        return {\n          type: e.type,\n          transactionId: e.transactionId,\n          transactionIndex: e.transactionIndex,\n          eventIndex: e.eventIndex,\n          data: await decode$1(e.payload, customDecoders)\n        };\n      }))\n    };\n  } else if (response.transaction) {\n    return response.transaction;\n  } else if (response.events) {\n    return await Promise.all(response.events.map(async function decodeEvents(e) {\n      return {\n        blockId: e.blockId,\n        blockHeight: e.blockHeight,\n        blockTimestamp: e.blockTimestamp,\n        type: e.type,\n        transactionId: e.transactionId,\n        transactionIndex: e.transactionIndex,\n        eventIndex: e.eventIndex,\n        data: await decode$1(e.payload, customDecoders)\n      };\n    }));\n  } else if (response.account) {\n    return response.account;\n  } else if (response.block) {\n    return response.block;\n  } else if (response.blockHeader) {\n    return response.blockHeader;\n  } else if (response.latestBlock) {\n    latestBlockDeprecationNotice();\n    return response.latestBlock;\n  } else if (response.transactionId) {\n    return response.transactionId;\n  } else if (response.collection) {\n    return response.collection;\n  } else if (response.networkParameters) {\n    const chainIdMap = {\n      \"flow-testnet\": \"testnet\",\n      \"flow-mainnet\": \"mainnet\",\n      \"flow-emulator\": \"local\"\n    };\n    return {\n      chainId: chainIdMap[response.networkParameters.chainId]\n    };\n  }\n  return null;\n};\n\nconst isFn$2 = v => typeof v === \"function\";\nconst isString$1 = v => typeof v === \"string\";\nconst oldIdentifierPatternFn = () => /\\b(0x\\w+)\\b/g;\nfunction isOldIdentifierSyntax(cadence) {\n  return oldIdentifierPatternFn().test(cadence);\n}\nconst newIdentifierPatternFn = () => /import\\s+\"(\\w+)\"/g;\nfunction isNewIdentifierSyntax(cadence) {\n  return newIdentifierPatternFn().test(cadence);\n}\nfunction getContractIdentifierSyntaxMatches(cadence) {\n  return cadence.matchAll(newIdentifierPatternFn());\n}\nasync function resolveCadence(ix) {\n  if (!isTransaction(ix) && !isScript(ix)) return ix;\n  var cadence = get(ix, \"ix.cadence\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(isFn$2(cadence) || isString$1(cadence), \"Cadence needs to be a function or a string.\");\n  if (isFn$2(cadence)) cadence = await cadence({});\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(isString$1(cadence), \"Cadence needs to be a string at this point.\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), \"Both account identifier and contract identifier syntax not simultaneously supported.\");\n  if (isOldIdentifierSyntax(cadence)) {\n    cadence = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().where(/^0x/).then(d => Object.entries(d).reduce((cadence, _ref) => {\n      let [key, value] = _ref;\n      const regex = new RegExp(\"(\\\\b\" + key + \"\\\\b)\", \"g\");\n      return cadence.replace(regex, value);\n    }, cadence));\n  }\n  if (isNewIdentifierSyntax(cadence)) {\n    for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {\n      const address = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(`system.contracts.${contractName}`);\n      if (address) {\n        cadence = cadence.replace(fullMatch, `import ${contractName} from ${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(address)}`);\n      } else {\n        _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log({\n          title: \"Contract Placeholder not found\",\n          message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.warn\n        });\n      }\n    }\n  }\n\n  // We need to move this over in any case.\n  ix.message.cadence = cadence;\n  return ix;\n}\n\nconst isFn$1 = v => typeof v === \"function\";\nfunction cast(arg) {\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);\n  if (isFn$1(arg.xform)) return arg.xform(arg.value);\n  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value);\n\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, `Invalid Argument`, arg);\n}\nasync function handleArgResolution(arg) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);\n  if (isFn$1(arg.resolveArgument)) {\n    const resolvedArg = await arg.resolveArgument();\n    return handleArgResolution(resolvedArg, depth - 1);\n  } else {\n    return arg;\n  }\n}\nasync function resolveArguments(ix) {\n  if (isTransaction(ix) || isScript(ix)) {\n    for (let [id, arg] of Object.entries(ix.arguments)) {\n      const res = await handleArgResolution(arg);\n      ix.arguments[id].asArgument = cast(res);\n    }\n  }\n  return ix;\n}\n\nconst encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));\nconst encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));\nconst encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));\nconst rightPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(value.padEnd(pad * 2, 0), \"hex\");\nconst leftPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(value.padStart(pad * 2, 0), \"hex\");\nconst TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(\"FLOW-V0.0-transaction\").toString(\"hex\"), 32).toString(\"hex\");\nconst prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8);\nconst blockBuffer = block => leftPaddedHexBuffer(block, 32);\nconst argumentToString = arg => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(JSON.stringify(arg), \"utf8\");\nconst scriptBuffer = script => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(script, \"utf8\");\nconst signatureBuffer = signature => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(signature, \"hex\");\nconst rlpEncode = v => {\n  return (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.encode)(v).toString(\"hex\");\n};\nconst sha3_256 = msg => {\n  const sha = new sha3__WEBPACK_IMPORTED_MODULE_6__.SHA3(256);\n  sha.update(_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(msg, \"hex\"));\n  return sha.digest().toString(\"hex\");\n};\nconst preparePayload = tx => {\n  validatePayload(tx);\n  return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(tx.payer)), tx.authorizers.map(authorizer => addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authorizer)))];\n};\nconst prepareEnvelope = tx => {\n  validateEnvelope(tx);\n  return [preparePayload(tx), preparePayloadSignatures(tx)];\n};\nconst preparePayloadSignatures = tx => {\n  const signers = collectSigners(tx);\n  return tx.payloadSigs.map(sig => {\n    return {\n      signerIndex: signers.get(sig.address),\n      keyId: sig.keyId,\n      sig: sig.sig\n    };\n  }).sort((a, b) => {\n    if (a.signerIndex > b.signerIndex) return 1;\n    if (a.signerIndex < b.signerIndex) return -1;\n    if (a.keyId > b.keyId) return 1;\n    if (a.keyId < b.keyId) return -1;\n  }).map(sig => {\n    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];\n  });\n};\nconst collectSigners = tx => {\n  const signers = new Map();\n  let i = 0;\n  const addSigner = addr => {\n    if (!signers.has(addr)) {\n      signers.set(addr, i);\n      i++;\n    }\n  };\n  addSigner(tx.proposalKey.address);\n  addSigner(tx.payer);\n  tx.authorizers.forEach(addSigner);\n  return signers;\n};\nconst prepareVoucher = voucher => {\n  validateVoucher(voucher);\n  const signers = collectSigners(voucher);\n  const prepareSigs = sigs => {\n    return sigs.map(_ref => {\n      let {\n        address,\n        keyId,\n        sig\n      } = _ref;\n      return {\n        signerIndex: signers.get(address),\n        keyId,\n        sig\n      };\n    }).sort((a, b) => {\n      if (a.signerIndex > b.signerIndex) return 1;\n      if (a.signerIndex < b.signerIndex) return -1;\n      if (a.keyId > b.keyId) return 1;\n      if (a.keyId < b.keyId) return -1;\n    }).map(sig => {\n      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];\n    });\n  };\n  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];\n};\nconst validatePayload = tx => {\n  payloadFields.forEach(field => checkField(tx, field));\n  proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, \"proposalKey\"));\n};\nconst validateEnvelope = tx => {\n  payloadSigsFields.forEach(field => checkField(tx, field));\n  tx.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field => checkField(sig, field, \"payloadSigs\", index));\n  });\n};\nconst validateVoucher = voucher => {\n  payloadFields.forEach(field => checkField(voucher, field));\n  proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, \"proposalKey\"));\n  payloadSigsFields.forEach(field => checkField(voucher, field));\n  voucher.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field => checkField(sig, field, \"payloadSigs\", index));\n  });\n  envelopeSigsFields.forEach(field => checkField(voucher, field));\n  voucher.envelopeSigs.forEach((sig, index) => {\n    envelopeSigFields.forEach(field => checkField(sig, field, \"envelopeSigs\", index));\n  });\n};\nconst isNumber = v => typeof v === \"number\";\nconst isString = v => typeof v === \"string\";\nconst isObject = v => v !== null && typeof v === \"object\";\nconst isArray = v => isObject(v) && v instanceof Array;\nconst payloadFields = [{\n  name: \"cadence\",\n  check: isString\n}, {\n  name: \"arguments\",\n  check: isArray\n}, {\n  name: \"refBlock\",\n  check: isString,\n  defaultVal: \"0\"\n}, {\n  name: \"computeLimit\",\n  check: isNumber\n}, {\n  name: \"proposalKey\",\n  check: isObject\n}, {\n  name: \"payer\",\n  check: isString\n}, {\n  name: \"authorizers\",\n  check: isArray\n}];\nconst proposalKeyFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sequenceNum\",\n  check: isNumber\n}];\nconst payloadSigsFields = [{\n  name: \"payloadSigs\",\n  check: isArray\n}];\nconst payloadSigFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sig\",\n  check: isString\n}];\nconst envelopeSigsFields = [{\n  name: \"envelopeSigs\",\n  check: isArray\n}];\nconst envelopeSigFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sig\",\n  check: isString\n}];\nconst checkField = (obj, field, base, index) => {\n  const {\n    name,\n    check,\n    defaultVal\n  } = field;\n  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;\n  if (obj[name] == null) throw missingFieldError(name, base, index);\n  if (!check(obj[name])) throw invalidFieldError(name, base, index);\n};\nconst printFieldName = (field, base, index) => {\n  if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;\n  return field;\n};\nconst missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);\nconst invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);\n\nfunction findInsideSigners(ix) {\n  // Inside Signers Are: (authorizers + proposer) - payer\n  let inside = new Set(ix.authorizations);\n  inside.add(ix.proposer);\n  if (Array.isArray(ix.payer)) {\n    ix.payer.forEach(p => inside.delete(p));\n  } else {\n    inside.delete(ix.payer);\n  }\n  return Array.from(inside);\n}\nfunction findOutsideSigners(ix) {\n  // Outside Signers Are: (payer)\n  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);\n  return Array.from(outside);\n}\nconst createSignableVoucher = ix => {\n  const buildAuthorizers = () => {\n    const authorizations = ix.authorizations.map(cid => (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[cid].addr)).reduce((prev, current) => {\n      return prev.find(item => item === current) ? prev : [...prev, current];\n    }, []);\n    return authorizations[0] ? authorizations : [];\n  };\n  const buildInsideSigners = () => findInsideSigners(ix).map(id => ({\n    address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[id].addr),\n    keyId: ix.accounts[id].keyId,\n    sig: ix.accounts[id].signature\n  }));\n  const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({\n    address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[id].addr),\n    keyId: ix.accounts[id].keyId,\n    sig: ix.accounts[id].signature\n  }));\n  return {\n    cadence: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    computeLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),\n    proposalKey: {\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum\n    },\n    payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),\n    authorizers: buildAuthorizers(),\n    payloadSigs: buildInsideSigners(),\n    envelopeSigs: buildOutsideSigners()\n  };\n};\nconst voucherToTxId = voucher => {\n  return encodeTxIdFromVoucher(voucher);\n};\n\nconst idof$1 = acct => `${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(acct.addr)}-${acct.keyId}`;\nconst isFn = v => typeof v === \"function\";\nfunction buildPreSignable(acct, ix) {\n  try {\n    return {\n      f_type: \"PreSignable\",\n      f_vsn: \"1.0.1\",\n      roles: acct.role,\n      cadence: ix.message.cadence,\n      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),\n      data: {},\n      interaction: ix,\n      voucher: createSignableVoucher(ix)\n    };\n  } catch (error) {\n    console.error(\"buildPreSignable\", error);\n    throw error;\n  }\n}\nasync function collectAccounts(ix, accounts, last) {\n  let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(depth, \"Account Resolve Recursion Limit Exceeded\", {\n    ix,\n    accounts\n  });\n  let authorizations = [];\n  for (let ax of accounts) {\n    let resolve = ax.resolve;\n    ax.resolve = null;\n    var old = last || ax;\n    if (isFn(resolve)) ax = await resolve(ax, buildPreSignable(ax, ix));\n    if (Array.isArray(ax)) {\n      await collectAccounts(ix, ax, old, depth - 1);\n    } else {\n      if (ax.addr) {\n        ax.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ax.addr);\n      }\n      if (ax.addr != null && ax.keyId != null) {\n        ax.tempId = idof$1(ax);\n      }\n      ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;\n      ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;\n      ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;\n      ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;\n      if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {\n        ix.proposer = ax.tempId;\n      }\n      if (ix.accounts[ax.tempId].role.payer) {\n        if (Array.isArray(ix.payer)) {\n          ix.payer = Array.from(new Set([...ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));\n        } else {\n          ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));\n        }\n        if (ix.payer.length > 1) {\n          // remove payer dups based on addr and keyId\n          const dupList = [];\n          const payerAccts = [];\n          ix.payer = ix.payer.reduce((g, tempId) => {\n            const {\n              addr\n            } = ix.accounts[tempId];\n            const key = idof$1(ix.accounts[tempId]);\n            payerAccts.push(addr);\n            if (dupList.includes(key)) return g;\n            dupList.push(key);\n            return [...g, tempId];\n          }, []);\n          const multiAccts = Array.from(new Set(payerAccts));\n          if (multiAccts.length > 1) {\n            throw new Error(\"Payer can not be different accounts\");\n          }\n        }\n      }\n      if (ix.accounts[ax.tempId].role.authorizer) {\n        if (last) {\n          // do group replacement\n          authorizations = Array.from(new Set([...authorizations, ax.tempId]));\n        } else {\n          // do 1-1 replacement\n          ix.authorizations = ix.authorizations.map(d => d === old.tempId ? ax.tempId : d);\n        }\n      }\n    }\n    if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];\n  }\n  if (last) {\n    // complete (flatmap) group replacement\n    ix.authorizations = ix.authorizations.map(d => d === last.tempId ? authorizations : d).reduce((prev, curr) => Array.isArray(curr) ? [...prev, ...curr] : [...prev, curr], []);\n  }\n}\nasync function resolveAccounts(ix) {\n  if (isTransaction(ix)) {\n    if (!Array.isArray(ix.payer)) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n        pkg: \"FCL\",\n        subject: '\"ix.payer\" must be an array. Support for ix.payer as a singular',\n        message: \"See changelog for more info.\"\n      });\n    }\n    try {\n      await collectAccounts(ix, Object.values(ix.accounts));\n      await collectAccounts(ix, Object.values(ix.accounts));\n    } catch (error) {\n      console.error(\"=== SAD PANDA ===\\n\\n\", error, \"\\n\\n=== SAD PANDA ===\");\n      throw error;\n    }\n  }\n  return ix;\n}\n\nasync function resolveSignatures(ix) {\n  if (isTransaction(ix)) {\n    try {\n      let insideSigners = findInsideSigners(ix);\n      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));\n      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));\n      let outsideSigners = findOutsideSigners(ix);\n      const outsidePayload = encodeTransactionEnvelope({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSigners.map(id => ({\n          address: ix.accounts[id].addr,\n          keyId: ix.accounts[id].keyId,\n          sig: ix.accounts[id].signature\n        }))\n      });\n      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));\n    } catch (error) {\n      console.error(\"Signatures\", error, {\n        ix\n      });\n      throw error;\n    }\n  }\n  return ix;\n}\nfunction fetchSignature(ix, payload) {\n  return async function innerFetchSignature(id) {\n    const acct = ix.accounts[id];\n    if (acct.signature != null) return;\n    const {\n      signature\n    } = await acct.signingFunction(buildSignable(acct, payload, ix));\n    ix.accounts[id].signature = signature;\n  };\n}\nfunction buildSignable(acct, message, ix) {\n  try {\n    return {\n      f_type: \"Signable\",\n      f_vsn: \"1.0.1\",\n      message,\n      addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(acct.addr),\n      keyId: acct.keyId,\n      roles: acct.role,\n      cadence: ix.message.cadence,\n      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),\n      data: {},\n      interaction: ix,\n      voucher: createSignableVoucher(ix)\n    };\n  } catch (error) {\n    console.error(\"buildSignable\", error);\n    throw error;\n  }\n}\nfunction prepForEncoding(ix) {\n  const payerAddress = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);\n  return {\n    cadence: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    computeLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),\n    proposalKey: {\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum\n    },\n    payer: payerAddress,\n    authorizers: ix.authorizations.map(cid => (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[cid].addr)).reduce((prev, current) => {\n      return prev.find(item => item === current) ? prev : [...prev, current];\n    }, [])\n  };\n}\n\nasync function resolveValidators(ix) {\n  const validators = get(ix, \"ix.validators\", []);\n  return pipe(ix, validators.map(cb => ix => cb(ix, {\n    Ok,\n    Bad\n  })));\n}\n\nasync function resolveFinalNormalization(ix) {\n  for (let key of Object.keys(ix.accounts)) {\n    ix.accounts[key].addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[key].addr);\n  }\n  return ix;\n}\n\nasync function resolveVoucherIntercept(ix) {\n  const fn = get(ix, \"ix.voucher-intercept\");\n  if (isFn$3(fn)) {\n    await fn(createSignableVoucher(ix));\n  }\n  return ix;\n}\n\nconst DEFAULT_COMPUTE_LIMIT = 100;\nasync function resolveComputeLimit(ix) {\n  if (isTransaction(ix)) {\n    ix.message.computeLimit = ix.message.computeLimit || (await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.get(\"fcl.limit\"));\n    if (!ix.message.computeLimit) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit\"\n      });\n      ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;\n    }\n  }\n  return ix;\n}\n\nconst noop = v => v;\nconst debug = function (key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return async ix => {\n    const accts = ix => [\"\\nAccounts:\", {\n      proposer: ix.proposer,\n      authorizations: ix.authorizations,\n      payer: ix.payer\n    }, \"\\n\\nDetails:\", ix.accounts].filter(Boolean);\n    const log = function () {\n      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {\n        msg[_key] = arguments[_key];\n      }\n      console.log(`debug[${key}] ---\\n`, ...msg, \"\\n\\n\\n---\");\n    };\n    if (await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.get(`debug.${key}`)) await fn(ix, log, accts);\n    return ix;\n  };\n};\nconst resolve = pipe([resolveCadence, debug(\"cadence\", (ix, log) => log(ix.message.cadence)), resolveComputeLimit, debug(\"compute limit\", (ix, log) => log(ix.message.computeLimit)), resolveArguments, debug(\"arguments\", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug(\"accounts\", (ix, log, accts) => log(...accts(ix))), /* special */execFetchRef, /* special */execFetchSequenceNumber, resolveSignatures, debug(\"signatures\", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug(\"resolved\", (ix, log) => log(ix))]);\nasync function execFetchRef(ix) {\n  if (isTransaction(ix) && ix.message.refBlock == null) {\n    const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n    const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n    ix.message.refBlock = (await sendFn(build([getBlock()]), {\n      config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n      response,\n      Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n      ix: ixModule\n    }, {\n      node\n    }).then(decodeResponse)).id;\n  }\n  return ix;\n}\nasync function execFetchSequenceNumber(ix) {\n  if (isTransaction(ix)) {\n    var acct = Object.values(ix.accounts).find(a => a.role.proposer);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(acct, `Transactions require a proposer`);\n    if (acct.sequenceNum == null) {\n      const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n      const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n      (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n      ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {\n        config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n        response,\n        Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n        ix: ixModule\n      }, {\n        node\n      }).then(decodeResponse).then(acct => acct.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);\n    }\n  }\n  return ix;\n}\n\nfunction invariant() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length > 1) {\n    const [predicate, message] = args;\n    return invariant((ix, _ref) => {\n      let {\n        Ok,\n        Bad\n      } = _ref;\n      return predicate ? Ok(ix) : Bad(ix, message);\n    });\n  }\n  const [fn] = args;\n  return ix => fn(ix, {\n    Ok,\n    Bad\n  });\n}\n\n/**\n * @description - Sends arbitrary scripts, transactions, and requests to Flow\n * @param {Array.<Function>} args - An array of functions that take interaction and return interaction\n * @param {object} opts - Optional parameters\n * @returns {Promise<*>} - A promise that resolves to a response\n */\nconst send = async function () {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], opts.send || _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n  invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n  const resolveFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.resolve\"], opts.resolve || resolve);\n  opts.node = opts.node || (await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\"));\n  if (Array.isArray(args)) args = pipe(interaction(), args);\n  return sendFn(await resolveFn(args), {\n    config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n    response,\n    ix: ixModule,\n    Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer\n  }, opts);\n};\n\nasync function decode(response) {\n  const decodersFromConfig = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().where(/^decoder\\./);\n  const decoders = Object.entries(decodersFromConfig).map(_ref => {\n    let [pattern, xform] = _ref;\n    pattern = `/${pattern.replace(/^decoder\\./, \"\")}$/`;\n    return [pattern, xform];\n  });\n  return decodeResponse(response, Object.fromEntries(decoders));\n}\n\nconst findPayloadSigners = voucher => {\n  // Payload Signers Are: (authorizers + proposer) - payer\n  let payload = new Set(voucher.authorizers);\n  payload.add(voucher.proposalKey.address);\n  payload.delete(voucher.payer);\n  return Array.from(payload).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix);\n};\nconst findEnvelopeSigners = voucher => {\n  // Envelope Signers Are: (payer)\n  let envelope = new Set([voucher.payer]);\n  return Array.from(envelope).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix);\n};\nclass UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {\n  constructor(signerAddress) {\n    const msg = `\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. \n        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.\n      `.trim();\n    super(msg);\n    this.name = \"Unable To Determine Message Encoding For Signer Addresss\";\n  }\n}\nconst encodeMessageFromSignable = (signable, signerAddress) => {\n  let payloadSigners = findPayloadSigners(signable.voucher);\n  let envelopeSigners = findEnvelopeSigners(signable.voucher);\n  const isPayloadSigner = payloadSigners.includes((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(signerAddress));\n  const isEnvelopeSigner = envelopeSigners.includes((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(signerAddress));\n  if (!isPayloadSigner && !isEnvelopeSigner) {\n    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);\n  }\n  const message = {\n    cadence: signable.voucher.cadence,\n    refBlock: signable.voucher.refBlock,\n    computeLimit: signable.voucher.computeLimit,\n    arguments: signable.voucher.arguments,\n    proposalKey: {\n      ...signable.voucher.proposalKey,\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(signable.voucher.proposalKey.address)\n    },\n    payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(signable.voucher.payer),\n    authorizers: signable.voucher.authorizers.map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix),\n    payloadSigs: signable.voucher.payloadSigs.map(ps => ({\n      ...ps,\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ps.address)\n    }))\n  };\n  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);\n};\n\nfunction validator(cb) {\n  return update(\"ix.validators\", validators => Array.isArray(validators) ? validators.push(cb) : [cb]);\n}\n\n/**\n * @description - A builder function that returns a partial interaction to a block at a specific height\n * @param {number} height - The height of the block to get\n * @returns {Function} - A partial interaction object\n */\nfunction atBlockHeight(height) {\n  return pipe([ix => {\n    ix.block.height = height;\n    return ix;\n  }, validator(ix => {\n    if (typeof ix.block.isSealed === \"boolean\") throw new Error(\"Unable to specify both block height and isSealed.\");\n    if (ix.block.id) throw new Error(\"Unable to specify both block height and block id.\");\n    return ix;\n  })]);\n}\n\nfunction atBlockId(id) {\n  return pipe([ix => {\n    ix.block.id = id;\n    return Ok(ix);\n  }, validator((ix, _ref) => {\n    let {\n      Ok,\n      Bad\n    } = _ref;\n    if (isGetAccount(ix)) return Bad(ix, \"Unable to specify a block id with a Get Account interaction.\");\n    if (typeof ix.block.isSealed === \"boolean\") return Bad(ix, \"Unable to specify both block id and isSealed.\");\n    if (ix.block.height) return Bad(ix, \"Unable to specify both block id and block height.\");\n    return Ok(ix);\n  })]);\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Account} Account\n */\n\n/**\n * @description  Returns the details of an account from their public address\n * @param {string} address - Address of the account\n * @param {object} [queryOptions] - Query parameters\n * @param {number} [queryOptions.height] - Block height to query\n * @param {string} [queryOptions.id] - Block ID to query\n * @param {object} [opts] - Optional parameters\n * @returns {Promise<Account>} - A promise that resolves to an account response\n */\nfunction account(address) {\n  let {\n    height,\n    id\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 ? arguments[2] : undefined;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(id && height), `Method: account -- Cannot pass \"id\" and \"height\" simultaneously`);\n\n  // Get account by ID\n  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse);\n\n  // Get account by height\n  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);\n  return send([getAccount(address)], opts).then(decodeResponse);\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Block} Block\n */\n\n/**\n * @description Returns the latest block (optionally sealed or not), by id, or by height\n * @param {object} [queryOptions] - Query parameters\n * @param {boolean} [queryOptions.sealed=false] - Whether to query for a sealed block\n * @param {number} [queryOptions.height] - Block height to query\n * @param {string} [queryOptions.id] - Block ID to query\n * @param {object} [opts] - Optional parameters\n * @returns {Promise<Block>} - A promise that resolves to a block response\n */\nfunction block() {\n  let {\n    sealed = false,\n    id,\n    height\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(sealed && id || sealed && height), `Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(id && height), `Method: block -- Cannot pass \"id\" and \"height\" simultaneously`);\n\n  // Get block by ID\n  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse);\n\n  // Get block by height\n  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);\n\n  // Get latest block\n  return send([getBlock(sealed)], opts).then(decodeResponse);\n}\n\nfunction authorizations() {\n  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(ax.map(authz => {\n    return prepAccount(authz, {\n      role: AUTHORIZER\n    });\n  }));\n}\nfunction authorization(addr, signingFunction, keyId, sequenceNum) {\n  return {\n    addr,\n    signingFunction,\n    keyId,\n    sequenceNum\n  };\n}\n\nfunction getEvents(eventType, start, end) {\n  if (typeof start !== \"undefined\" || typeof end !== \"undefined\") {\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n      pkg: \"FCL/SDK\",\n      subject: \"Passing a start and end into getEvents\",\n      transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\"\n    });\n  }\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventType;\n    ix.events.start = start;\n    ix.events.end = end;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all instances of a particular event (by name) within a height range\n * NOTE:\n * - The block range provided must be from the current spork.\n * - The block range provided must be 250 blocks or lower per request.\n * @param {string} eventName - The name of the event to get\n * @param {number} fromBlockHeight - The height of the block to start looking for events (inclusive)\n * @param {number} toBlockHeight - The height of the block to stop looking for events (inclusive)\n * @returns {Function} - An interaction object\n */\nfunction getEventsAtBlockHeightRange(eventName, fromBlockHeight, toBlockHeight) {\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventName;\n    ix.events.start = fromBlockHeight;\n    ix.events.end = toBlockHeight;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids\n * NOTE:\n * - The block range provided must be from the current spork.\n * @param {string} eventName - The name of the event to get\n * @param {number[]} blockIds - The ids of the blocks to look for events\n * @returns {Function} - An interaction object\n */\nfunction getEventsAtBlockIds(eventName) {\n  let blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventName;\n    ix.events.blockIds = blockIds;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns the interaction to get a block header\n * @param {boolean} [isSealed] - Whether or not the block should be sealed\n * @returns {Function} - An interaction object\n */\nfunction getBlockHeader() {\n  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetBlockHeader, ix => {\n    ix.block.isSealed = isSealed;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all a collection containing a list of transaction ids by its collection id\n * NOTE:\n * - The block range provided must be from the current spork. All events emitted during past sporks is current unavailable.\n * @param {string} [id] - The id of the collection to get\n * @returns {Function} - An interaction object\n */\nfunction getCollection() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetCollection, ix => {\n    ix.collection.id = id;\n    return ix;\n  }]);\n}\n\n/**\n * @description - A builder function that returns the status of transaction\n * NOTE: The transactionID provided must be from the current spork.\n * @param {string} transactionId - The id of the transaction to get status\n * @returns {Function} - An interaction object\n */\nfunction getTransactionStatus(transactionId) {\n  return pipe([makeGetTransactionStatus, ix => {\n    ix.transaction.id = transactionId;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns a transaction\n * NOTE: The transactionID provided must be from the current spork.\n * @param {string} transactionId - The id of the transaction to get\n * @returns {Function} - An interaction object\n */\nfunction getTransaction(transactionId) {\n  return pipe([makeGetTransaction, ix => {\n    ix.transaction.id = transactionId;\n    return Ok(ix);\n  }]);\n}\n\nfunction getNetworkParameters() {\n  return pipe([makeGetNetworkParameters, ix => {\n    return Ok(ix);\n  }]);\n}\n\nfunction limit(computeLimit) {\n  return ix => {\n    ix.message.computeLimit = computeLimit;\n    return ix;\n  };\n}\n\n/**\n * @description - A utility builder to be used with other builders to pass in arguments with a value and supported type\n * @param {Array.<*>} ax - An array of arguments\n * @returns {Function} - An interaction object\n */\nfunction args() {\n  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(ax.map(makeArgument));\n}\n\n/**\n * @description - A utility builder to be used with fcl.args[...] to create FCL supported arguments for interactions\n * @param {any} value - The value of the argument\n * @param {Function} xform - A function to transform the value\n * @returns {object} - An argument object\n */\nfunction arg(value, xform) {\n  return {\n    value,\n    xform\n  };\n}\n\nasync function proposer(authz) {\n  return prepAccount(authz, {\n    role: PROPOSER\n  });\n}\n\nasync function payer(authz) {\n  return prepAccount(authz, {\n    role: PAYER\n  });\n}\n\nfunction ping() {\n  return makePing;\n}\n\nfunction ref(refBlock) {\n  return pipe([ix => {\n    ix.message.refBlock = refBlock;\n    return Ok(ix);\n  }]);\n}\n\nfunction script() {\n  return pipe([makeScript, put(\"ix.cadence\", (0,_onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template)(...arguments))]);\n}\n\nconst DEFAULT_SCRIPT_ACCOUNTS = [];\nconst DEFUALT_REF = null;\n\n/**\n * @description - A template builder to use a Cadence transaction for an interaction\n * @param {...*} args - The arguments to pass\n * @returns {Function} - An interaction object\n */\nfunction transaction() {\n  return pipe([makeTransaction, put(\"ix.cadence\", (0,_onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template)(...arguments)), ix => {\n    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;\n    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;\n    return Ok(ix);\n  }]);\n}\n\nfunction voucherIntercept(fn) {\n  return put(\"ix.voucher-intercept\", fn);\n}\n\nconst resolveProposerSequenceNumber = _ref => {\n  let {\n    node\n  } = _ref;\n  return async ix => {\n    if (!isTransaction(ix)) return Ok(ix);\n    if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);\n    const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n    const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {\n      config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n      response: response,\n      Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n      ix: ixModule\n    }, {\n      node\n    });\n    const decoded = await decodeResponse(response$1);\n    ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;\n    return Ok(ix);\n  };\n};\n\nasync function getRefId(opts) {\n  const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n  const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n  var ix;\n  ix = await pipe(interaction(), [getBlock()]);\n  ix = await sendFn(ix, {\n    config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n    response,\n    Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n    ix: ixModule\n  }, {\n    node\n  });\n  ix = await decodeResponse(ix);\n  return ix.id;\n}\nfunction resolveRefBlockId(opts) {\n  return async ix => {\n    if (!isTransaction(ix)) return Ok(ix);\n    if (ix.message.refBlock) return Ok(ix);\n    ix.message.refBlock = await getRefId();\n    return Ok(ix);\n  };\n}\n\nfunction mockAccountResponse(ix) {\n  let numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(ix.account, \"mockAccountResponse(ix) -- ix.account is missing\", ix);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(ix.account.addr, \"mockAccountResponse(ix) -- ix.account.addr is missing\", ix);\n  const address = ix.account.addr;\n  return {\n    account: {\n      addr: address,\n      keys: Array.from({\n        length: numberOfKeys\n      }, (_, i) => ({\n        index: i,\n        sequenceNumber: 42\n      }))\n    }\n  };\n}\nfunction mockGetBlockResponse(ix) {\n  return {\n    tag: \"GET_BLOCK\",\n    block: {\n      id: \"32\"\n    }\n  };\n}\nconst identity = v => v;\nfunction mockSend() {\n  let fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n  return async function execSend(ix) {\n    ix = await ix;\n    switch (true) {\n      case isGetAccount(ix):\n        return mockAccountResponse(ix);\n      case isGetBlock(ix):\n        return mockGetBlockResponse();\n      default:\n        return fallback(ix);\n    }\n  };\n}\n\nconst idof = acct => `${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(acct.addr)}-${acct.keyId}`;\nfunction sig(opts) {\n  return [\"SIGNATURE\", opts.addr, opts.keyId].join(\".\");\n}\nfunction authzFn() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const acct = {\n      ...account,\n      ...opts,\n      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction\n    };\n    return acct;\n    function fallbackSigningFunction(signable) {\n      return {\n        addr: acct.addr,\n        keyId: acct.keyId,\n        signature: sig(acct)\n      };\n    }\n  };\n}\nfunction authzResolve() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const {\n      tempId,\n      ...rest\n    } = opts;\n    return {\n      ...account,\n      tempId: tempId || \"WITH_RESOLVE\",\n      resolve: authzFn(rest)\n    };\n  };\n}\nconst ROLE = {\n  proposer: false,\n  authorizer: false,\n  payer: false\n};\nfunction authzResolveMany() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const tempId = opts.tempId || \"AUTHZ_RESOLVE_MANY\";\n    return {\n      ...account,\n      tempId,\n      resolve: () => [opts.proposer && authzFn(opts.proposer)({\n        role: {\n          ...ROLE,\n          proposer: true\n        }\n      }), ...opts.authorizations.map(authzFn).map(d => d({\n        role: {\n          ...ROLE,\n          authorizer: true\n        }\n      })), opts.payer && authzFn(opts.payer)({\n        role: {\n          ...ROLE,\n          payer: true\n        }\n      })].filter(Boolean)\n    };\n  };\n}\n\nconst run = function () {\n  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return build([ref(\"123\"), ...fns]).then(resolve);\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mockSend: mockSend,\n  authzFn: authzFn,\n  authzResolve: authzResolve,\n  authzResolveMany: authzResolveMany,\n  sig: sig,\n  idof: idof,\n  run: run\n});\n\nconst VERSION = \"1.2.2\" ;\n\n// Deprecated\nconst params = params => _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n  pkg: \"FCL/SDK\",\n  message: `The params builder has been removed from the Flow JS-SDK/FCL.`,\n  transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n  level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.error\n});\nconst param = params => _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n  pkg: \"FCL/SDK\",\n  message: `The param builder has been removed from the Flow JS-SDK/FCL.`,\n  transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n  level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.error\n});\n\n\n//# sourceMappingURL=sdk.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9zZGsvZGlzdC9zZGsubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNKO0FBQ3dCO0FBQzFCO0FBQ0E7QUFDSztBQUNXO0FBQ007QUFDbEM7QUFDcUI7QUFDNEI7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsY0FBYztBQUNkLGNBQWMsR0FBRztBQUNqQjtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFXO0FBQ2YsSUFBSSxpRUFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQVU7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxFQUFFLG9EQUFHO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXdCLEdBQUcsZ0JBQWdCO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBVztBQUNiLGlEQUFpRDtBQUNqRCxFQUFFLGlFQUFXO0FBQ2IsRUFBRSxpRUFBVztBQUNiO0FBQ0Esb0JBQW9CLHNEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQU0sMkJBQTJCLGFBQWE7QUFDMUU7QUFDQSx1REFBdUQsY0FBYyxPQUFPLGdFQUFVLFVBQVU7QUFDaEcsUUFBUTtBQUNSLFFBQVEsb0RBQVU7QUFDbEI7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRixpQkFBaUIsdURBQWE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlFQUFXLDhEQUE4RCxVQUFVO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGlFQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBVyxrRUFBa0UsV0FBVztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQ0FBTTtBQUNuRCw0Q0FBNEMsK0NBQU07QUFDbEQsb0RBQW9ELCtDQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQ0FBTTtBQUN0QywrQkFBK0IsK0NBQU07QUFDckMscUNBQXFDLCtDQUFNO0FBQzNDO0FBQ0EsU0FBUyxtREFBTTtBQUNmO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQUk7QUFDdEIsYUFBYSwrQ0FBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSxnRUFBVSwyRkFBMkYsZ0VBQVUsNERBQTRELGdFQUFVO0FBQ3RUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0pBQXNKLGdFQUFVLDBHQUEwRyxnRUFBVSxzRUFBc0UsZ0VBQVU7QUFDcFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSyxHQUFHLE1BQU0sT0FBTyxLQUFLLEdBQUcsTUFBTSxHQUFHLE1BQU07QUFDcEY7QUFDQTtBQUNBLDZFQUE2RSxtQ0FB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QUM7O0FBRW1nQztBQUNwZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvc2RrL2Rpc3Qvc2RrLm1vZHVsZS5qcz9kMDI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICdAb25mbG93L3V0aWwtbG9nZ2VyJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJ0BvbmZsb3cvdXRpbC1sb2dnZXInO1xuaW1wb3J0IHsgaW52YXJpYW50IGFzIGludmFyaWFudCQxIH0gZnJvbSAnQG9uZmxvdy91dGlsLWludmFyaWFudCc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAb25mbG93L2NvbmZpZyc7XG5leHBvcnQgeyBjb25maWcgfSBmcm9tICdAb25mbG93L2NvbmZpZyc7XG5pbXBvcnQgeyBCdWZmZXIsIGVuY29kZSB9IGZyb20gJ0BvbmZsb3cvcmxwJztcbmltcG9ydCB7IHNlbmQgYXMgc2VuZCQxIH0gZnJvbSAnQG9uZmxvdy90cmFuc3BvcnQtaHR0cCc7XG5pbXBvcnQgeyBzYW5zUHJlZml4LCB3aXRoUHJlZml4IH0gZnJvbSAnQG9uZmxvdy91dGlsLWFkZHJlc3MnO1xuaW1wb3J0IHsgU0hBMyB9IGZyb20gJ3NoYTMnO1xuaW1wb3J0IHsgdGVtcGxhdGUgfSBmcm9tICdAb25mbG93L3V0aWwtdGVtcGxhdGUnO1xuZXhwb3J0IHsgdGVtcGxhdGUgYXMgY2FkZW5jZSwgdGVtcGxhdGUgYXMgY2RjIH0gZnJvbSAnQG9uZmxvdy91dGlsLXRlbXBsYXRlJztcblxuY29uc3QgVU5LTk9XTiAvKiAgICAgICAgICAgICAgICAgICAgICAgKi8gPSBcIlVOS05PV05cIjtcbmNvbnN0IFNDUklQVCAvKiAgICAgICAgICAgICAgICAgICAgICAgICovID0gXCJTQ1JJUFRcIjtcbmNvbnN0IFRSQU5TQUNUSU9OIC8qICAgICAgICAgICAgICAgICAgICovID0gXCJUUkFOU0FDVElPTlwiO1xuY29uc3QgR0VUX1RSQU5TQUNUSU9OX1NUQVRVUyAvKiAgICAgICAgKi8gPSBcIkdFVF9UUkFOU0FDVElPTl9TVEFUVVNcIjtcbmNvbnN0IEdFVF9BQ0NPVU5UIC8qICAgICAgICAgICAgICAgICAgICovID0gXCJHRVRfQUNDT1VOVFwiO1xuY29uc3QgR0VUX0VWRU5UUyAvKiAgICAgICAgICAgICAgICAgICAgKi8gPSBcIkdFVF9FVkVOVFNcIjtcbmNvbnN0IFBJTkcgLyogICAgICAgICAgICAgICAgICAgICAgICAgICovID0gXCJQSU5HXCI7XG5jb25zdCBHRVRfVFJBTlNBQ1RJT04gLyogICAgICAgICAgICAgICAqLyA9IFwiR0VUX1RSQU5TQUNUSU9OXCI7XG5jb25zdCBHRVRfQkxPQ0sgLyogICAgICAgICAgICAgICAgICAgICAqLyA9IFwiR0VUX0JMT0NLXCI7XG5jb25zdCBHRVRfQkxPQ0tfSEVBREVSIC8qICAgICAgICAgICAgICAqLyA9IFwiR0VUX0JMT0NLX0hFQURFUlwiO1xuY29uc3QgR0VUX0NPTExFQ1RJT04gLyogICAgICAgICAgICAgICAgKi8gPSBcIkdFVF9DT0xMRUNUSU9OXCI7XG5jb25zdCBHRVRfTkVUV09SS19QQVJBTUVURVJTIC8qICAgICAgICAqLyA9IFwiR0VUX05FVFdPUktfUEFSQU1FVEVSU1wiO1xuY29uc3QgQkFEIC8qICovID0gXCJCQURcIjtcbmNvbnN0IE9LIC8qICAqLyA9IFwiT0tcIjtcbmNvbnN0IEFDQ09VTlQgLyogICovID0gXCJBQ0NPVU5UXCI7XG5jb25zdCBQQVJBTSAvKiAgICAqLyA9IFwiUEFSQU1cIjtcbmNvbnN0IEFSR1VNRU5UIC8qICovID0gXCJBUkdVTUVOVFwiO1xuY29uc3QgQVVUSE9SSVpFUiAvKiAqLyA9IFwiYXV0aG9yaXplclwiO1xuY29uc3QgUEFZRVIgLyogICAgICAqLyA9IFwicGF5ZXJcIjtcbmNvbnN0IFBST1BPU0VSIC8qICAgKi8gPSBcInByb3Bvc2VyXCI7XG5jb25zdCBBQ0NUID0gYHtcbiAgXCJraW5kXCI6XCIke0FDQ09VTlR9XCIsXG4gIFwidGVtcElkXCI6bnVsbCxcbiAgXCJhZGRyXCI6bnVsbCxcbiAgXCJrZXlJZFwiOm51bGwsXG4gIFwic2VxdWVuY2VOdW1cIjpudWxsLFxuICBcInNpZ25hdHVyZVwiOm51bGwsXG4gIFwic2lnbmluZ0Z1bmN0aW9uXCI6bnVsbCxcbiAgXCJyZXNvbHZlXCI6bnVsbCxcbiAgXCJyb2xlXCI6IHtcbiAgICBcInByb3Bvc2VyXCI6ZmFsc2UsXG4gICAgXCJhdXRob3JpemVyXCI6ZmFsc2UsXG4gICAgXCJwYXllclwiOmZhbHNlLFxuICAgIFwicGFyYW1cIjpmYWxzZVxuICB9XG59YDtcbmNvbnN0IEFSRyA9IGB7XG4gIFwia2luZFwiOlwiJHtBUkdVTUVOVH1cIixcbiAgXCJ0ZW1wSWRcIjpudWxsLFxuICBcInZhbHVlXCI6bnVsbCxcbiAgXCJhc0FyZ3VtZW50XCI6bnVsbCxcbiAgXCJ4Zm9ybVwiOm51bGwsXG4gIFwicmVzb2x2ZVwiOiBudWxsLFxuICBcInJlc29sdmVBcmd1bWVudFwiOiBudWxsXG59YDtcbmNvbnN0IElYID0gYHtcbiAgXCJ0YWdcIjpcIiR7VU5LTk9XTn1cIixcbiAgXCJhc3NpZ25zXCI6e30sXG4gIFwic3RhdHVzXCI6XCIke09LfVwiLFxuICBcInJlYXNvblwiOm51bGwsXG4gIFwiYWNjb3VudHNcIjp7fSxcbiAgXCJwYXJhbXNcIjp7fSxcbiAgXCJhcmd1bWVudHNcIjp7fSxcbiAgXCJtZXNzYWdlXCI6IHtcbiAgICBcImNhZGVuY2VcIjpudWxsLFxuICAgIFwicmVmQmxvY2tcIjpudWxsLFxuICAgIFwiY29tcHV0ZUxpbWl0XCI6bnVsbCxcbiAgICBcInByb3Bvc2VyXCI6bnVsbCxcbiAgICBcInBheWVyXCI6bnVsbCxcbiAgICBcImF1dGhvcml6YXRpb25zXCI6W10sXG4gICAgXCJwYXJhbXNcIjpbXSxcbiAgICBcImFyZ3VtZW50c1wiOltdXG4gIH0sXG4gIFwicHJvcG9zZXJcIjpudWxsLFxuICBcImF1dGhvcml6YXRpb25zXCI6W10sXG4gIFwicGF5ZXJcIjpbXSxcbiAgXCJldmVudHNcIjoge1xuICAgIFwiZXZlbnRUeXBlXCI6bnVsbCxcbiAgICBcInN0YXJ0XCI6bnVsbCxcbiAgICBcImVuZFwiOm51bGwsXG4gICAgXCJibG9ja0lkc1wiOltdXG4gIH0sXG4gIFwidHJhbnNhY3Rpb25cIjoge1xuICAgIFwiaWRcIjpudWxsXG4gIH0sXG4gIFwiYmxvY2tcIjoge1xuICAgIFwiaWRcIjpudWxsLFxuICAgIFwiaGVpZ2h0XCI6bnVsbCxcbiAgICBcImlzU2VhbGVkXCI6bnVsbFxuICB9LFxuICBcImFjY291bnRcIjoge1xuICAgIFwiYWRkclwiOm51bGxcbiAgfSxcbiAgXCJjb2xsZWN0aW9uXCI6IHtcbiAgICBcImlkXCI6bnVsbFxuICB9XG59YDtcbmNvbnN0IEtFWVMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKEpTT04ucGFyc2UoSVgpKSk7XG5jb25zdCBpbnRlcmFjdGlvbiA9ICgpID0+IEpTT04ucGFyc2UoSVgpO1xuY29uc3QgQ0hBUlMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiLnNwbGl0KFwiXCIpO1xuY29uc3QgcmFuZENoYXIgPSAoKSA9PiBDSEFSU1t+fihNYXRoLnJhbmRvbSgpICogQ0hBUlMubGVuZ3RoKV07XG5jb25zdCB1dWlkID0gKCkgPT4gQXJyYXkuZnJvbSh7XG4gIGxlbmd0aDogMTBcbn0sIHJhbmRDaGFyKS5qb2luKFwiXCIpO1xuY29uc3QgaXNOdW1iZXIkMSA9IGQgPT4gdHlwZW9mIGQgPT09IFwibnVtYmVyXCI7XG5jb25zdCBpc0FycmF5JDEgPSBkID0+IEFycmF5LmlzQXJyYXkoZCk7XG5jb25zdCBpc09iaiA9IGQgPT4gZCAhPT0gbnVsbCAmJiB0eXBlb2YgZCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzTnVsbCA9IGQgPT4gZCA9PSBudWxsO1xuY29uc3QgaXNGbiQzID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNJbnRlcmFjdGlvbiA9IGl4ID0+IHtcbiAgaWYgKCFpc09iaihpeCkgfHwgaXNOdWxsKGl4KSB8fCBpc051bWJlciQxKGl4KSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBrZXkgb2YgS0VZUykgaWYgKCFpeC5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IE9rID0gaXggPT4ge1xuICBpeC5zdGF0dXMgPSBPSztcbiAgcmV0dXJuIGl4O1xufTtcbmNvbnN0IEJhZCA9IChpeCwgcmVhc29uKSA9PiB7XG4gIGl4LnN0YXR1cyA9IEJBRDtcbiAgaXgucmVhc29uID0gcmVhc29uO1xuICByZXR1cm4gaXg7XG59O1xuY29uc3QgbWFrZUl4ID0gd2F0ID0+IGl4ID0+IHtcbiAgaXgudGFnID0gd2F0O1xuICByZXR1cm4gT2soaXgpO1xufTtcbmNvbnN0IHByZXBBY2NvdW50S2V5SWQgPSBhY2N0ID0+IHtcbiAgaWYgKGFjY3Qua2V5SWQgPT0gbnVsbCkgcmV0dXJuIGFjY3Q7XG4gIGludmFyaWFudCQxKCFpc05hTihwYXJzZUludChhY2N0LmtleUlkKSksIFwiYWNjb3VudC5rZXlJZCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gIHJldHVybiB7XG4gICAgLi4uYWNjdCxcbiAgICBrZXlJZDogcGFyc2VJbnQoYWNjdC5rZXlJZClcbiAgfTtcbn07XG5jb25zdCBwcmVwQWNjb3VudCA9IGZ1bmN0aW9uIChhY2N0KSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIGl4ID0+IHtcbiAgICBpbnZhcmlhbnQkMSh0eXBlb2YgYWNjdCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBhY2N0ID09PSBcIm9iamVjdFwiLCBcInByZXBBY2NvdW50IG11c3QgYmUgcGFzc2VkIGFuIGF1dGhvcml6YXRpb24gZnVuY3Rpb24gb3IgYW4gYWNjb3VudCBvYmplY3RcIik7XG4gICAgaW52YXJpYW50JDEob3B0cy5yb2xlICE9IG51bGwsIFwiQWNjb3VudCBtdXN0IGhhdmUgYSByb2xlXCIpO1xuICAgIGNvbnN0IEFDQ09VTlQgPSBKU09OLnBhcnNlKEFDQ1QpO1xuICAgIGNvbnN0IHJvbGUgPSBvcHRzLnJvbGU7XG4gICAgY29uc3QgdGVtcElkID0gdXVpZCgpO1xuICAgIGlmIChhY2N0LmF1dGhvcml6YXRpb24gJiYgaXNGbiQzKGFjY3QuYXV0aG9yaXphdGlvbikpIGFjY3QgPSB7XG4gICAgICByZXNvbHZlOiBhY2N0LmF1dGhvcml6YXRpb25cbiAgICB9O1xuICAgIGlmICghYWNjdC5hdXRob3JpemF0aW9uICYmIGlzRm4kMyhhY2N0KSkgYWNjdCA9IHtcbiAgICAgIHJlc29sdmU6IGFjY3RcbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmUgPSBhY2N0LnJlc29sdmU7XG4gICAgaWYgKHJlc29sdmUpIGFjY3QucmVzb2x2ZSA9IGZ1bmN0aW9uIChhY2N0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXNvbHZlLCBwcmVwQWNjb3VudEtleUlkXS5yZWR1Y2UoYXN5bmMgKGQsIGZuKSA9PiBmbihhd2FpdCBkLCAuLi5yZXN0KSwgYWNjdCk7XG4gICAgfTtcbiAgICBhY2N0ID0gcHJlcEFjY291bnRLZXlJZChhY2N0KTtcbiAgICBpeC5hY2NvdW50c1t0ZW1wSWRdID0ge1xuICAgICAgLi4uQUNDT1VOVCxcbiAgICAgIHRlbXBJZCxcbiAgICAgIC4uLmFjY3QsXG4gICAgICByb2xlOiB7XG4gICAgICAgIC4uLkFDQ09VTlQucm9sZSxcbiAgICAgICAgLi4uKHR5cGVvZiBhY2N0LnJvbGUgPT09IFwib2JqZWN0XCIgPyBhY2N0LnJvbGUgOiB7fSksXG4gICAgICAgIFtyb2xlXTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJvbGUgPT09IEFVVEhPUklaRVIpIHtcbiAgICAgIGl4LmF1dGhvcml6YXRpb25zLnB1c2godGVtcElkKTtcbiAgICB9IGVsc2UgaWYgKHJvbGUgPT09IFBBWUVSKSB7XG4gICAgICBpeC5wYXllci5wdXNoKHRlbXBJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl4W3JvbGVdID0gdGVtcElkO1xuICAgIH1cbiAgICByZXR1cm4gaXg7XG4gIH07XG59O1xuY29uc3QgbWFrZUFyZ3VtZW50ID0gYXJnID0+IGl4ID0+IHtcbiAgbGV0IHRlbXBJZCA9IHV1aWQoKTtcbiAgaXgubWVzc2FnZS5hcmd1bWVudHMucHVzaCh0ZW1wSWQpO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXSA9IEpTT04ucGFyc2UoQVJHKTtcbiAgaXguYXJndW1lbnRzW3RlbXBJZF0udGVtcElkID0gdGVtcElkO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS52YWx1ZSA9IGFyZy52YWx1ZTtcbiAgaXguYXJndW1lbnRzW3RlbXBJZF0uYXNBcmd1bWVudCA9IGFyZy5hc0FyZ3VtZW50O1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS54Zm9ybSA9IGFyZy54Zm9ybTtcbiAgaXguYXJndW1lbnRzW3RlbXBJZF0ucmVzb2x2ZSA9IGFyZy5yZXNvbHZlO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS5yZXNvbHZlQXJndW1lbnQgPSBpc0ZuJDMoYXJnLnJlc29sdmVBcmd1bWVudCkgPyBhcmcucmVzb2x2ZUFyZ3VtZW50LmJpbmQoYXJnKSA6IGFyZy5yZXNvbHZlQXJndW1lbnQ7XG4gIHJldHVybiBPayhpeCk7XG59O1xuY29uc3QgbWFrZVVua25vd24gLyogICAgICAgICAgICAgICAgICovID0gbWFrZUl4KFVOS05PV04pO1xuY29uc3QgbWFrZVNjcmlwdCAvKiAgICAgICAgICAgICAgICAgICovID0gbWFrZUl4KFNDUklQVCk7XG5jb25zdCBtYWtlVHJhbnNhY3Rpb24gLyogICAgICAgICAgICAgKi8gPSBtYWtlSXgoVFJBTlNBQ1RJT04pO1xuY29uc3QgbWFrZUdldFRyYW5zYWN0aW9uU3RhdHVzIC8qICAgICovID0gbWFrZUl4KEdFVF9UUkFOU0FDVElPTl9TVEFUVVMpO1xuY29uc3QgbWFrZUdldFRyYW5zYWN0aW9uIC8qICAgICAgICAgICovID0gbWFrZUl4KEdFVF9UUkFOU0FDVElPTik7XG5jb25zdCBtYWtlR2V0QWNjb3VudCAvKiAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX0FDQ09VTlQpO1xuY29uc3QgbWFrZUdldEV2ZW50cyAvKiAgICAgICAgICAgICAgICovID0gbWFrZUl4KEdFVF9FVkVOVFMpO1xuY29uc3QgbWFrZVBpbmcgLyogICAgICAgICAgICAgICAgICAgICovID0gbWFrZUl4KFBJTkcpO1xuY29uc3QgbWFrZUdldEJsb2NrIC8qICAgICAgICAgICAgICAgICovID0gbWFrZUl4KEdFVF9CTE9DSyk7XG5jb25zdCBtYWtlR2V0QmxvY2tIZWFkZXIgLyogICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX0JMT0NLX0hFQURFUik7XG5jb25zdCBtYWtlR2V0Q29sbGVjdGlvbiAvKiAgICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX0NPTExFQ1RJT04pO1xuY29uc3QgbWFrZUdldE5ldHdvcmtQYXJhbWV0ZXJzIC8qICAgICovID0gbWFrZUl4KEdFVF9ORVRXT1JLX1BBUkFNRVRFUlMpO1xuY29uc3QgaXMgPSB3YXQgPT4gaXggPT4gaXgudGFnID09PSB3YXQ7XG5jb25zdCBpc1Vua25vd24gLyogICAgICAgICAgICAgICAgICovID0gaXMoVU5LTk9XTik7XG5jb25zdCBpc1NjcmlwdCAvKiAgICAgICAgICAgICAgICAgICovID0gaXMoU0NSSVBUKTtcbmNvbnN0IGlzVHJhbnNhY3Rpb24gLyogICAgICAgICAgICAgKi8gPSBpcyhUUkFOU0FDVElPTik7XG5jb25zdCBpc0dldFRyYW5zYWN0aW9uU3RhdHVzIC8qICAgICovID0gaXMoR0VUX1RSQU5TQUNUSU9OX1NUQVRVUyk7XG5jb25zdCBpc0dldFRyYW5zYWN0aW9uIC8qICAgICAgICAgICovID0gaXMoR0VUX1RSQU5TQUNUSU9OKTtcbmNvbnN0IGlzR2V0QWNjb3VudCAvKiAgICAgICAgICAgICAgKi8gPSBpcyhHRVRfQUNDT1VOVCk7XG5jb25zdCBpc0dldEV2ZW50cyAvKiAgICAgICAgICAgICAgICovID0gaXMoR0VUX0VWRU5UUyk7XG5jb25zdCBpc1BpbmcgLyogICAgICAgICAgICAgICAgICAgICovID0gaXMoUElORyk7XG5jb25zdCBpc0dldEJsb2NrIC8qICAgICAgICAgICAgICAgICovID0gaXMoR0VUX0JMT0NLKTtcbmNvbnN0IGlzR2V0QmxvY2tIZWFkZXIgLyogICAgICAgICAgKi8gPSBpcyhHRVRfQkxPQ0tfSEVBREVSKTtcbmNvbnN0IGlzR2V0Q29sbGVjdGlvbiAvKiAgICAgICAgICAgKi8gPSBpcyhHRVRfQ09MTEVDVElPTik7XG5jb25zdCBpc0dldE5ldHdvcmtQYXJhbWV0ZXJzIC8qICAgICovID0gaXMoR0VUX05FVFdPUktfUEFSQU1FVEVSUyk7XG5jb25zdCBpc09rIC8qICAqLyA9IGl4ID0+IGl4LnN0YXR1cyA9PT0gT0s7XG5jb25zdCBpc0JhZCAvKiAqLyA9IGl4ID0+IGl4LnN0YXR1cyA9PT0gQkFEO1xuY29uc3Qgd2h5IC8qICAgKi8gPSBpeCA9PiBpeC5yZWFzb247XG5jb25zdCBpc0FjY291bnQgLyogICovID0gYWNjb3VudCA9PiBhY2NvdW50LmtpbmQgPT09IEFDQ09VTlQ7XG5jb25zdCBpc1BhcmFtIC8qICAgICovID0gcGFyYW0gPT4gcGFyYW0ua2luZCA9PT0gUEFSQU07XG5jb25zdCBpc0FyZ3VtZW50IC8qICovID0gYXJndW1lbnQgPT4gYXJndW1lbnQua2luZCA9PT0gQVJHVU1FTlQ7XG5jb25zdCBoYXJkTW9kZSA9IGl4ID0+IHtcbiAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGl4KSkge1xuICAgIGlmICghS0VZUy5oYXMoa2V5KSkgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5fVwiIGlzIGFuIGludmFsaWQgcm9vdCBsZXZlbCBJbnRlcmFjdGlvbiBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gaXg7XG59O1xuY29uc3QgcmVjUGlwZSA9IGFzeW5jIGZ1bmN0aW9uIChpeCkge1xuICBsZXQgZm5zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdHJ5IHtcbiAgICBpeCA9IGhhcmRNb2RlKGF3YWl0IGl4KTtcbiAgICBpZiAoaXNCYWQoaXgpKSB0aHJvdyBuZXcgRXJyb3IoYEludGVyYWN0aW9uIEVycm9yOiAke2l4LnJlYXNvbn1gKTtcbiAgICBpZiAoIWZucy5sZW5ndGgpIHJldHVybiBpeDtcbiAgICBjb25zdCBbaGQsIC4uLnJlc3RdID0gZm5zO1xuICAgIGNvbnN0IGN1ciA9IGF3YWl0IGhkO1xuICAgIGlmIChpc0ZuJDMoY3VyKSkgcmV0dXJuIHJlY1BpcGUoY3VyKGl4KSwgcmVzdCk7XG4gICAgaWYgKGlzTnVsbChjdXIpIHx8ICFjdXIpIHJldHVybiByZWNQaXBlKGl4LCByZXN0KTtcbiAgICBpZiAoaXNJbnRlcmFjdGlvbihjdXIpKSByZXR1cm4gcmVjUGlwZShjdXIsIHJlc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSW50ZXJhY3Rpb24gQ29tcG9zaXRpb25cIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuY29uc3QgcGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IFthcmcxLCBhcmcyXSA9IGFyZ3M7XG4gIGlmIChpc0FycmF5JDEoYXJnMSkgJiYgYXJnMiA9PSBudWxsKSByZXR1cm4gZCA9PiBwaXBlKGQsIGFyZzEpO1xuICByZXR1cm4gcmVjUGlwZShhcmcxLCBhcmcyKTtcbn07XG5jb25zdCBpZGVudGl0eSQxID0gdiA9PiB2O1xuY29uc3QgZ2V0ID0gKGl4LCBrZXksIGZhbGxiYWNrKSA9PiB7XG4gIHJldHVybiBpeC5hc3NpZ25zW2tleV0gPT0gbnVsbCA/IGZhbGxiYWNrIDogaXguYXNzaWduc1trZXldO1xufTtcbmNvbnN0IHB1dCA9IChrZXksIHZhbHVlKSA9PiBpeCA9PiB7XG4gIGl4LmFzc2lnbnNba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gT2soaXgpO1xufTtcbmNvbnN0IHVwZGF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgbGV0IGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZGVudGl0eSQxO1xuICByZXR1cm4gaXggPT4ge1xuICAgIGl4LmFzc2lnbnNba2V5XSA9IGZuKGl4LmFzc2lnbnNba2V5XSwgaXgpO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH07XG59O1xuY29uc3QgZGVzdHJveSA9IGtleSA9PiBpeCA9PiB7XG4gIGRlbGV0ZSBpeC5hc3NpZ25zW2tleV07XG4gIHJldHVybiBPayhpeCk7XG59O1xuXG52YXIgaXhNb2R1bGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgVU5LTk9XTjogVU5LTk9XTixcbiAgU0NSSVBUOiBTQ1JJUFQsXG4gIFRSQU5TQUNUSU9OOiBUUkFOU0FDVElPTixcbiAgR0VUX1RSQU5TQUNUSU9OX1NUQVRVUzogR0VUX1RSQU5TQUNUSU9OX1NUQVRVUyxcbiAgR0VUX0FDQ09VTlQ6IEdFVF9BQ0NPVU5ULFxuICBHRVRfRVZFTlRTOiBHRVRfRVZFTlRTLFxuICBQSU5HOiBQSU5HLFxuICBHRVRfVFJBTlNBQ1RJT046IEdFVF9UUkFOU0FDVElPTixcbiAgR0VUX0JMT0NLOiBHRVRfQkxPQ0ssXG4gIEdFVF9CTE9DS19IRUFERVI6IEdFVF9CTE9DS19IRUFERVIsXG4gIEdFVF9DT0xMRUNUSU9OOiBHRVRfQ09MTEVDVElPTixcbiAgR0VUX05FVFdPUktfUEFSQU1FVEVSUzogR0VUX05FVFdPUktfUEFSQU1FVEVSUyxcbiAgQkFEOiBCQUQsXG4gIE9LOiBPSyxcbiAgQUNDT1VOVDogQUNDT1VOVCxcbiAgUEFSQU06IFBBUkFNLFxuICBBUkdVTUVOVDogQVJHVU1FTlQsXG4gIEFVVEhPUklaRVI6IEFVVEhPUklaRVIsXG4gIFBBWUVSOiBQQVlFUixcbiAgUFJPUE9TRVI6IFBST1BPU0VSLFxuICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sXG4gIHV1aWQ6IHV1aWQsXG4gIGlzTnVtYmVyOiBpc051bWJlciQxLFxuICBpc0FycmF5OiBpc0FycmF5JDEsXG4gIGlzT2JqOiBpc09iaixcbiAgaXNOdWxsOiBpc051bGwsXG4gIGlzRm46IGlzRm4kMyxcbiAgaXNJbnRlcmFjdGlvbjogaXNJbnRlcmFjdGlvbixcbiAgT2s6IE9rLFxuICBCYWQ6IEJhZCxcbiAgcHJlcEFjY291bnQ6IHByZXBBY2NvdW50LFxuICBtYWtlQXJndW1lbnQ6IG1ha2VBcmd1bWVudCxcbiAgbWFrZVVua25vd246IG1ha2VVbmtub3duLFxuICBtYWtlU2NyaXB0OiBtYWtlU2NyaXB0LFxuICBtYWtlVHJhbnNhY3Rpb246IG1ha2VUcmFuc2FjdGlvbixcbiAgbWFrZUdldFRyYW5zYWN0aW9uU3RhdHVzOiBtYWtlR2V0VHJhbnNhY3Rpb25TdGF0dXMsXG4gIG1ha2VHZXRUcmFuc2FjdGlvbjogbWFrZUdldFRyYW5zYWN0aW9uLFxuICBtYWtlR2V0QWNjb3VudDogbWFrZUdldEFjY291bnQsXG4gIG1ha2VHZXRFdmVudHM6IG1ha2VHZXRFdmVudHMsXG4gIG1ha2VQaW5nOiBtYWtlUGluZyxcbiAgbWFrZUdldEJsb2NrOiBtYWtlR2V0QmxvY2ssXG4gIG1ha2VHZXRCbG9ja0hlYWRlcjogbWFrZUdldEJsb2NrSGVhZGVyLFxuICBtYWtlR2V0Q29sbGVjdGlvbjogbWFrZUdldENvbGxlY3Rpb24sXG4gIG1ha2VHZXROZXR3b3JrUGFyYW1ldGVyczogbWFrZUdldE5ldHdvcmtQYXJhbWV0ZXJzLFxuICBpc1Vua25vd246IGlzVW5rbm93bixcbiAgaXNTY3JpcHQ6IGlzU2NyaXB0LFxuICBpc1RyYW5zYWN0aW9uOiBpc1RyYW5zYWN0aW9uLFxuICBpc0dldFRyYW5zYWN0aW9uU3RhdHVzOiBpc0dldFRyYW5zYWN0aW9uU3RhdHVzLFxuICBpc0dldFRyYW5zYWN0aW9uOiBpc0dldFRyYW5zYWN0aW9uLFxuICBpc0dldEFjY291bnQ6IGlzR2V0QWNjb3VudCxcbiAgaXNHZXRFdmVudHM6IGlzR2V0RXZlbnRzLFxuICBpc1Bpbmc6IGlzUGluZyxcbiAgaXNHZXRCbG9jazogaXNHZXRCbG9jayxcbiAgaXNHZXRCbG9ja0hlYWRlcjogaXNHZXRCbG9ja0hlYWRlcixcbiAgaXNHZXRDb2xsZWN0aW9uOiBpc0dldENvbGxlY3Rpb24sXG4gIGlzR2V0TmV0d29ya1BhcmFtZXRlcnM6IGlzR2V0TmV0d29ya1BhcmFtZXRlcnMsXG4gIGlzT2s6IGlzT2ssXG4gIGlzQmFkOiBpc0JhZCxcbiAgd2h5OiB3aHksXG4gIGlzQWNjb3VudDogaXNBY2NvdW50LFxuICBpc1BhcmFtOiBpc1BhcmFtLFxuICBpc0FyZ3VtZW50OiBpc0FyZ3VtZW50LFxuICBwaXBlOiBwaXBlLFxuICBnZXQ6IGdldCxcbiAgcHV0OiBwdXQsXG4gIHVwZGF0ZTogdXBkYXRlLFxuICBkZXN0cm95OiBkZXN0cm95XG59KTtcblxuZnVuY3Rpb24gYnVpbGQoKSB7XG4gIGxldCBmbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gcGlwZShpbnRlcmFjdGlvbigpLCBmbnMpO1xufVxuXG5jb25zdCBERUZBVUxUX1JFU1BPTlNFID0gYHtcbiAgICBcInRhZ1wiOm51bGwsXG4gICAgXCJ0cmFuc2FjdGlvblwiOm51bGwsXG4gICAgXCJ0cmFuc2FjdGlvblN0YXR1c1wiOm51bGwsXG4gICAgXCJ0cmFuc2FjdGlvbklkXCI6bnVsbCxcbiAgICBcImVuY29kZWREYXRhXCI6bnVsbCxcbiAgICBcImV2ZW50c1wiOm51bGwsXG4gICAgXCJhY2NvdW50XCI6bnVsbCxcbiAgICBcImJsb2NrXCI6bnVsbCxcbiAgICBcImJsb2NrSGVhZGVyXCI6bnVsbCxcbiAgICBcImxhdGVzdEJsb2NrXCI6bnVsbCxcbiAgICBcImNvbGxlY3Rpb25cIjpudWxsLFxuICAgIFwibmV0d29ya1BhcmFtZXRlcnNcIjpudWxsXG59YDtcbmNvbnN0IHJlc3BvbnNlID0gKCkgPT4gSlNPTi5wYXJzZShERUZBVUxUX1JFU1BPTlNFKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIGJ1aWxkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBpbnRlcmFjdGlvbiB0byBnZXQgdGhlIGxhdGVzdCBibG9ja1xuICogQHBhcmFtIHtib29sZWFufSBbaXNTZWFsZWRdIC0gV2hldGhlciBvciBub3QgdGhlIGJsb2NrIHNob3VsZCBiZSBzZWFsZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBbiBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0QmxvY2soKSB7XG4gIGxldCBpc1NlYWxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRCbG9jaywgaXggPT4ge1xuICAgIGl4LmJsb2NrLmlzU2VhbGVkID0gaXNTZWFsZWQ7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGludGVyYWN0aW9uIHRvIGdldCBhbiBhY2NvdW50IGJ5IGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZ2V0cVxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRBY2NvdW50KGFkZHIpIHtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRBY2NvdW50LCBpeCA9PiB7XG4gICAgaXguYWNjb3VudC5hZGRyID0gc2Fuc1ByZWZpeChhZGRyKTtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbmNvbnN0IGxhdGVzdEJsb2NrRGVwcmVjYXRpb25Ob3RpY2UgPSAoKSA9PiB7XG4gIGxvZy5kZXByZWNhdGUoe1xuICAgIHBrZzogXCJAb25mbG93L2RlY29kZVwiLFxuICAgIHN1YmplY3Q6IFwiT3BlcmF0aW5nIHVwb24gZGF0YSBvZiB0aGUgbGF0ZXN0QmxvY2sgZmllbGQgb2YgdGhlIHJlc3BvbnNlIG9iamVjdFwiLFxuICAgIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9kZWNvZGUvV0FSTklOR1MubWQjMDAwMS1EZXByZWNhdGluZy1sYXRlc3RCbG9jay1maWVsZFwiXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZUltcGxpY2l0ID0gYXN5bmMgaSA9PiBpO1xuY29uc3QgZGVjb2RlVm9pZCA9IGFzeW5jICgpID0+IG51bGw7XG5jb25zdCBkZWNvZGVUeXBlID0gYXN5bmMgdHlwZSA9PiB7XG4gIHJldHVybiB0eXBlLnN0YXRpY1R5cGU7XG59O1xuY29uc3QgZGVjb2RlUGF0aCA9IGFzeW5jIHBhdGggPT4ge1xuICByZXR1cm4ge1xuICAgIGRvbWFpbjogcGF0aC5kb21haW4sXG4gICAgaWRlbnRpZmllcjogcGF0aC5pZGVudGlmaWVyXG4gIH07XG59O1xuY29uc3QgZGVjb2RlQ2FwYWJpbGl0eSA9IGFzeW5jIGNhcCA9PiB7XG4gIHJldHVybiB7XG4gICAgcGF0aDogY2FwLnBhdGgsXG4gICAgYWRkcmVzczogY2FwLmFkZHJlc3MsXG4gICAgYm9ycm93VHlwZTogY2FwLmJvcnJvd1R5cGVcbiAgfTtcbn07XG5jb25zdCBkZWNvZGVPcHRpb25hbCA9IGFzeW5jIChvcHRpb25hbCwgZGVjb2RlcnMsIHN0YWNrKSA9PiBvcHRpb25hbCA/IGF3YWl0IHJlY3Vyc2VEZWNvZGUob3B0aW9uYWwsIGRlY29kZXJzLCBzdGFjaykgOiBudWxsO1xuY29uc3QgZGVjb2RlUmVmZXJlbmNlID0gYXN5bmMgdiA9PiAoe1xuICBhZGRyZXNzOiB2LmFkZHJlc3MsXG4gIHR5cGU6IHYudHlwZVxufSk7XG5jb25zdCBkZWNvZGVBcnJheSA9IGFzeW5jIChhcnJheSwgZGVjb2RlcnMsIHN0YWNrKSA9PiBhd2FpdCBQcm9taXNlLmFsbChhcnJheS5tYXAodiA9PiBuZXcgUHJvbWlzZShhc3luYyByZXMgPT4gcmVzKGF3YWl0IHJlY3Vyc2VEZWNvZGUodiwgZGVjb2RlcnMsIFsuLi5zdGFjaywgdi50eXBlXSkpKSkpO1xuY29uc3QgZGVjb2RlRGljdGlvbmFyeSA9IGFzeW5jIChkaWN0aW9uYXJ5LCBkZWNvZGVycywgc3RhY2spID0+IGF3YWl0IGRpY3Rpb25hcnkucmVkdWNlKGFzeW5jIChhY2MsIHYpID0+IHtcbiAgYWNjID0gYXdhaXQgYWNjO1xuICBhY2NbYXdhaXQgcmVjdXJzZURlY29kZSh2LmtleSwgZGVjb2RlcnMsIFsuLi5zdGFjaywgdi5rZXldKV0gPSBhd2FpdCByZWN1cnNlRGVjb2RlKHYudmFsdWUsIGRlY29kZXJzLCBbLi4uc3RhY2ssIHYua2V5XSk7XG4gIHJldHVybiBhY2M7XG59LCBQcm9taXNlLnJlc29sdmUoe30pKTtcbmNvbnN0IGRlY29kZUNvbXBvc2l0ZSA9IGFzeW5jIChjb21wb3NpdGUsIGRlY29kZXJzLCBzdGFjaykgPT4ge1xuICBjb25zdCBkZWNvZGVkID0gYXdhaXQgY29tcG9zaXRlLmZpZWxkcy5yZWR1Y2UoYXN5bmMgKGFjYywgdikgPT4ge1xuICAgIGFjYyA9IGF3YWl0IGFjYztcbiAgICBhY2Nbdi5uYW1lXSA9IGF3YWl0IHJlY3Vyc2VEZWNvZGUodi52YWx1ZSwgZGVjb2RlcnMsIFsuLi5zdGFjaywgdi5uYW1lXSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKHt9KSk7XG4gIGNvbnN0IGRlY29kZXIgPSBjb21wb3NpdGUuaWQgJiYgZGVjb2Rlckxvb2t1cChkZWNvZGVycywgY29tcG9zaXRlLmlkKTtcbiAgcmV0dXJuIGRlY29kZXIgPyBhd2FpdCBkZWNvZGVyKGRlY29kZWQpIDogZGVjb2RlZDtcbn07XG5jb25zdCBkZWZhdWx0RGVjb2RlcnMgPSB7XG4gIFVJbnQ6IGRlY29kZUltcGxpY2l0LFxuICBJbnQ6IGRlY29kZUltcGxpY2l0LFxuICBVSW50ODogZGVjb2RlSW1wbGljaXQsXG4gIEludDg6IGRlY29kZUltcGxpY2l0LFxuICBVSW50MTY6IGRlY29kZUltcGxpY2l0LFxuICBJbnQxNjogZGVjb2RlSW1wbGljaXQsXG4gIFVJbnQzMjogZGVjb2RlSW1wbGljaXQsXG4gIEludDMyOiBkZWNvZGVJbXBsaWNpdCxcbiAgVUludDY0OiBkZWNvZGVJbXBsaWNpdCxcbiAgSW50NjQ6IGRlY29kZUltcGxpY2l0LFxuICBVSW50MTI4OiBkZWNvZGVJbXBsaWNpdCxcbiAgSW50MTI4OiBkZWNvZGVJbXBsaWNpdCxcbiAgVUludDI1NjogZGVjb2RlSW1wbGljaXQsXG4gIEludDI1NjogZGVjb2RlSW1wbGljaXQsXG4gIFdvcmQ4OiBkZWNvZGVJbXBsaWNpdCxcbiAgV29yZDE2OiBkZWNvZGVJbXBsaWNpdCxcbiAgV29yZDMyOiBkZWNvZGVJbXBsaWNpdCxcbiAgV29yZDY0OiBkZWNvZGVJbXBsaWNpdCxcbiAgVUZpeDY0OiBkZWNvZGVJbXBsaWNpdCxcbiAgRml4NjQ6IGRlY29kZUltcGxpY2l0LFxuICBTdHJpbmc6IGRlY29kZUltcGxpY2l0LFxuICBDaGFyYWN0ZXI6IGRlY29kZUltcGxpY2l0LFxuICBCb29sOiBkZWNvZGVJbXBsaWNpdCxcbiAgQWRkcmVzczogZGVjb2RlSW1wbGljaXQsXG4gIFZvaWQ6IGRlY29kZVZvaWQsXG4gIE9wdGlvbmFsOiBkZWNvZGVPcHRpb25hbCxcbiAgUmVmZXJlbmNlOiBkZWNvZGVSZWZlcmVuY2UsXG4gIEFycmF5OiBkZWNvZGVBcnJheSxcbiAgRGljdGlvbmFyeTogZGVjb2RlRGljdGlvbmFyeSxcbiAgRXZlbnQ6IGRlY29kZUNvbXBvc2l0ZSxcbiAgUmVzb3VyY2U6IGRlY29kZUNvbXBvc2l0ZSxcbiAgU3RydWN0OiBkZWNvZGVDb21wb3NpdGUsXG4gIEVudW06IGRlY29kZUNvbXBvc2l0ZSxcbiAgVHlwZTogZGVjb2RlVHlwZSxcbiAgUGF0aDogZGVjb2RlUGF0aCxcbiAgQ2FwYWJpbGl0eTogZGVjb2RlQ2FwYWJpbGl0eVxufTtcbmNvbnN0IGRlY29kZXJMb29rdXAgPSAoZGVjb2RlcnMsIGxvb2t1cCkgPT4ge1xuICBjb25zdCBmb3VuZCA9IE9iamVjdC5rZXlzKGRlY29kZXJzKS5maW5kKGRlY29kZXIgPT4ge1xuICAgIGlmICgvXlxcLy4qXFwvJC8udGVzdChkZWNvZGVyKSkge1xuICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChkZWNvZGVyLnN1YnN0cmluZygxLCBkZWNvZGVyLmxlbmd0aCAtIDEpKTtcbiAgICAgIHJldHVybiByZWcudGVzdChsb29rdXApO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlciA9PT0gbG9va3VwO1xuICB9KTtcbiAgcmV0dXJuIGxvb2t1cCAmJiBmb3VuZCAmJiBkZWNvZGVyc1tmb3VuZF07XG59O1xuY29uc3QgcmVjdXJzZURlY29kZSA9IGFzeW5jIChkZWNvZGVJbnN0cnVjdGlvbnMsIGRlY29kZXJzLCBzdGFjaykgPT4ge1xuICBsZXQgZGVjb2RlciA9IGRlY29kZXJMb29rdXAoZGVjb2RlcnMsIGRlY29kZUluc3RydWN0aW9ucy50eXBlKTtcbiAgaWYgKCFkZWNvZGVyKSB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBEZWNvZGVyIEVycm9yOiAke2RlY29kZUluc3RydWN0aW9ucy50eXBlfUAke3N0YWNrLmpvaW4oXCIuXCIpfWApO1xuICByZXR1cm4gYXdhaXQgZGVjb2RlcihkZWNvZGVJbnN0cnVjdGlvbnMudmFsdWUsIGRlY29kZXJzLCBzdGFjayk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIERlY29kZXMgYSByZXNwb25zZSBmcm9tIEZsb3cgaW50byBKU09OXG4gKiBAcGFyYW0geyp9IGRlY29kZUluc3RydWN0aW9ucyAtIFRoZSByZXNwb25zZSBvYmplY3QgZnJvbSBGbG93XG4gKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tRGVjb2RlcnMgLSBBbiBvYmplY3Qgb2YgY3VzdG9tIGRlY29kZXJzXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBzdGFjayAtIFRoZSBzdGFjayBvZiB0aGUgY3VycmVudCBkZWNvZGluZ1xuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIGRlY29kZWQgcmVzcG9uc2VcbiAqL1xuY29uc3QgZGVjb2RlJDEgPSBhc3luYyBmdW5jdGlvbiAoZGVjb2RlSW5zdHJ1Y3Rpb25zKSB7XG4gIGxldCBjdXN0b21EZWNvZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBzdGFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gIC8vIEZpbHRlciBvdXQgYWxsIGRlZmF1bHQgZGVjb2RlcnMgd2hpY2ggYXJlIG92ZXJyaWRkZW4gYnkgYSBjdXN0b20gZGVjb2RlciByZWdleFxuICBjb25zdCBmaWx0ZXJlZERlY29kZXJzID0gT2JqZWN0LmtleXMoZGVmYXVsdERlY29kZXJzKS5maWx0ZXIoZGVjb2RlciA9PiAhT2JqZWN0LmtleXMoY3VzdG9tRGVjb2RlcnMpLmZpbmQoY3VzdG9tRGVjb2RlciA9PiBuZXcgUmVnRXhwKGN1c3RvbURlY29kZXIpLnRlc3QoZGVjb2RlcikpKS5yZWR1Y2UoKGRlY29kZXJzLCBkZWNvZGVyS2V5KSA9PiB7XG4gICAgZGVjb2RlcnNbZGVjb2RlcktleV0gPSBkZWZhdWx0RGVjb2RlcnNbZGVjb2RlcktleV07XG4gICAgcmV0dXJuIGRlY29kZXJzO1xuICB9LCBjdXN0b21EZWNvZGVycyk7XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC4uLmZpbHRlcmVkRGVjb2RlcnMsXG4gICAgLi4uY3VzdG9tRGVjb2RlcnNcbiAgfTtcbiAgcmV0dXJuIHJlY3Vyc2VEZWNvZGUoZGVjb2RlSW5zdHJ1Y3Rpb25zLCBkZWNvZGVycywgc3RhY2spO1xufTtcbmNvbnN0IGRlY29kZVJlc3BvbnNlID0gYXN5bmMgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIGxldCBjdXN0b21EZWNvZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChyZXNwb25zZS5lbmNvZGVkRGF0YSkge1xuICAgIHJldHVybiBkZWNvZGUkMShyZXNwb25zZS5lbmNvZGVkRGF0YSwgY3VzdG9tRGVjb2RlcnMpO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLnRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLnRyYW5zYWN0aW9uU3RhdHVzLFxuICAgICAgZXZlbnRzOiBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS50cmFuc2FjdGlvblN0YXR1cy5ldmVudHMubWFwKGFzeW5jIGZ1bmN0aW9uIGRlY29kZUV2ZW50cyhlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogZS50eXBlLFxuICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IGUudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBlLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgICAgZXZlbnRJbmRleDogZS5ldmVudEluZGV4LFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGRlY29kZSQxKGUucGF5bG9hZCwgY3VzdG9tRGVjb2RlcnMpXG4gICAgICAgIH07XG4gICAgICB9KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLnRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRyYW5zYWN0aW9uO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLmV2ZW50cykge1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS5ldmVudHMubWFwKGFzeW5jIGZ1bmN0aW9uIGRlY29kZUV2ZW50cyhlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBibG9ja0lkOiBlLmJsb2NrSWQsXG4gICAgICAgIGJsb2NrSGVpZ2h0OiBlLmJsb2NrSGVpZ2h0LFxuICAgICAgICBibG9ja1RpbWVzdGFtcDogZS5ibG9ja1RpbWVzdGFtcCxcbiAgICAgICAgdHlwZTogZS50eXBlLFxuICAgICAgICB0cmFuc2FjdGlvbklkOiBlLnRyYW5zYWN0aW9uSWQsXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGUudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgZXZlbnRJbmRleDogZS5ldmVudEluZGV4LFxuICAgICAgICBkYXRhOiBhd2FpdCBkZWNvZGUkMShlLnBheWxvYWQsIGN1c3RvbURlY29kZXJzKVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuYWNjb3VudCkge1xuICAgIHJldHVybiByZXNwb25zZS5hY2NvdW50O1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLmJsb2NrKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJsb2NrO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLmJsb2NrSGVhZGVyKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJsb2NrSGVhZGVyO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLmxhdGVzdEJsb2NrKSB7XG4gICAgbGF0ZXN0QmxvY2tEZXByZWNhdGlvbk5vdGljZSgpO1xuICAgIHJldHVybiByZXNwb25zZS5sYXRlc3RCbG9jaztcbiAgfSBlbHNlIGlmIChyZXNwb25zZS50cmFuc2FjdGlvbklkKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRyYW5zYWN0aW9uSWQ7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuY29sbGVjdGlvbikge1xuICAgIHJldHVybiByZXNwb25zZS5jb2xsZWN0aW9uO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLm5ldHdvcmtQYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgY2hhaW5JZE1hcCA9IHtcbiAgICAgIFwiZmxvdy10ZXN0bmV0XCI6IFwidGVzdG5ldFwiLFxuICAgICAgXCJmbG93LW1haW5uZXRcIjogXCJtYWlubmV0XCIsXG4gICAgICBcImZsb3ctZW11bGF0b3JcIjogXCJsb2NhbFwiXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhaW5JZDogY2hhaW5JZE1hcFtyZXNwb25zZS5uZXR3b3JrUGFyYW1ldGVycy5jaGFpbklkXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBpc0ZuJDIgPSB2ID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyQxID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IG9sZElkZW50aWZpZXJQYXR0ZXJuRm4gPSAoKSA9PiAvXFxiKDB4XFx3KylcXGIvZztcbmZ1bmN0aW9uIGlzT2xkSWRlbnRpZmllclN5bnRheChjYWRlbmNlKSB7XG4gIHJldHVybiBvbGRJZGVudGlmaWVyUGF0dGVybkZuKCkudGVzdChjYWRlbmNlKTtcbn1cbmNvbnN0IG5ld0lkZW50aWZpZXJQYXR0ZXJuRm4gPSAoKSA9PiAvaW1wb3J0XFxzK1wiKFxcdyspXCIvZztcbmZ1bmN0aW9uIGlzTmV3SWRlbnRpZmllclN5bnRheChjYWRlbmNlKSB7XG4gIHJldHVybiBuZXdJZGVudGlmaWVyUGF0dGVybkZuKCkudGVzdChjYWRlbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyYWN0SWRlbnRpZmllclN5bnRheE1hdGNoZXMoY2FkZW5jZSkge1xuICByZXR1cm4gY2FkZW5jZS5tYXRjaEFsbChuZXdJZGVudGlmaWVyUGF0dGVybkZuKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNhZGVuY2UoaXgpIHtcbiAgaWYgKCFpc1RyYW5zYWN0aW9uKGl4KSAmJiAhaXNTY3JpcHQoaXgpKSByZXR1cm4gaXg7XG4gIHZhciBjYWRlbmNlID0gZ2V0KGl4LCBcIml4LmNhZGVuY2VcIik7XG4gIGludmFyaWFudCQxKGlzRm4kMihjYWRlbmNlKSB8fCBpc1N0cmluZyQxKGNhZGVuY2UpLCBcIkNhZGVuY2UgbmVlZHMgdG8gYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZy5cIik7XG4gIGlmIChpc0ZuJDIoY2FkZW5jZSkpIGNhZGVuY2UgPSBhd2FpdCBjYWRlbmNlKHt9KTtcbiAgaW52YXJpYW50JDEoaXNTdHJpbmckMShjYWRlbmNlKSwgXCJDYWRlbmNlIG5lZWRzIHRvIGJlIGEgc3RyaW5nIGF0IHRoaXMgcG9pbnQuXCIpO1xuICBpbnZhcmlhbnQkMSghaXNPbGRJZGVudGlmaWVyU3ludGF4KGNhZGVuY2UpIHx8ICFpc05ld0lkZW50aWZpZXJTeW50YXgoY2FkZW5jZSksIFwiQm90aCBhY2NvdW50IGlkZW50aWZpZXIgYW5kIGNvbnRyYWN0IGlkZW50aWZpZXIgc3ludGF4IG5vdCBzaW11bHRhbmVvdXNseSBzdXBwb3J0ZWQuXCIpO1xuICBpZiAoaXNPbGRJZGVudGlmaWVyU3ludGF4KGNhZGVuY2UpKSB7XG4gICAgY2FkZW5jZSA9IGF3YWl0IGNvbmZpZygpLndoZXJlKC9eMHgvKS50aGVuKGQgPT4gT2JqZWN0LmVudHJpZXMoZCkucmVkdWNlKChjYWRlbmNlLCBfcmVmKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcIihcXFxcYlwiICsga2V5ICsgXCJcXFxcYilcIiwgXCJnXCIpO1xuICAgICAgcmV0dXJuIGNhZGVuY2UucmVwbGFjZShyZWdleCwgdmFsdWUpO1xuICAgIH0sIGNhZGVuY2UpKTtcbiAgfVxuICBpZiAoaXNOZXdJZGVudGlmaWVyU3ludGF4KGNhZGVuY2UpKSB7XG4gICAgZm9yIChjb25zdCBbZnVsbE1hdGNoLCBjb250cmFjdE5hbWVdIG9mIGdldENvbnRyYWN0SWRlbnRpZmllclN5bnRheE1hdGNoZXMoY2FkZW5jZSkpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb25maWcoKS5nZXQoYHN5c3RlbS5jb250cmFjdHMuJHtjb250cmFjdE5hbWV9YCk7XG4gICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICBjYWRlbmNlID0gY2FkZW5jZS5yZXBsYWNlKGZ1bGxNYXRjaCwgYGltcG9ydCAke2NvbnRyYWN0TmFtZX0gZnJvbSAke3dpdGhQcmVmaXgoYWRkcmVzcyl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKHtcbiAgICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBub3QgZm91bmRcIixcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGZpbmQgYSB2YWx1ZSBmb3IgY29udHJhY3QgcGxhY2Vob2xkZXIgJHtjb250cmFjdE5hbWV9LiBQbGVhc2UgYWRkIHRvIHlvdXIgZmxvdy5qc29uIG9yIGV4cGxpY2l0bHkgYWRkIGl0IHRvIHRoZSBjb25maWcgJ2NvbnRyYWN0cy4qJyBuYW1lc3BhY2UuYCxcbiAgICAgICAgICBsZXZlbDogbG9nZ2VyLkxFVkVMUy53YXJuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbW92ZSB0aGlzIG92ZXIgaW4gYW55IGNhc2UuXG4gIGl4Lm1lc3NhZ2UuY2FkZW5jZSA9IGNhZGVuY2U7XG4gIHJldHVybiBpeDtcbn1cblxuY29uc3QgaXNGbiQxID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gY2FzdChhcmcpIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGludmFyaWFudCQxKHR5cGVvZiBhcmcueGZvcm0gIT0gbnVsbCwgYE5vIHR5cGUgc3BlY2lmaWVkIGZvciBhcmd1bWVudDogJHthcmcudmFsdWV9YCk7XG4gIGlmIChpc0ZuJDEoYXJnLnhmb3JtKSkgcmV0dXJuIGFyZy54Zm9ybShhcmcudmFsdWUpO1xuICBpZiAoaXNGbiQxKGFyZy54Zm9ybS5hc0FyZ3VtZW50KSkgcmV0dXJuIGFyZy54Zm9ybS5hc0FyZ3VtZW50KGFyZy52YWx1ZSk7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGludmFyaWFudCQxKGZhbHNlLCBgSW52YWxpZCBBcmd1bWVudGAsIGFyZyk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVBcmdSZXNvbHV0aW9uKGFyZykge1xuICBsZXQgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDM7XG4gIGludmFyaWFudCQxKGRlcHRoID4gMCwgYEFyZ3VtZW50IFJlc29sdmUgUmVjdXJzaW9uIExpbWl0IEV4Y2VlZGVkIGZvciBBcmc6ICR7YXJnLnRlbXBJZH1gKTtcbiAgaWYgKGlzRm4kMShhcmcucmVzb2x2ZUFyZ3VtZW50KSkge1xuICAgIGNvbnN0IHJlc29sdmVkQXJnID0gYXdhaXQgYXJnLnJlc29sdmVBcmd1bWVudCgpO1xuICAgIHJldHVybiBoYW5kbGVBcmdSZXNvbHV0aW9uKHJlc29sdmVkQXJnLCBkZXB0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmd1bWVudHMoaXgpIHtcbiAgaWYgKGlzVHJhbnNhY3Rpb24oaXgpIHx8IGlzU2NyaXB0KGl4KSkge1xuICAgIGZvciAobGV0IFtpZCwgYXJnXSBvZiBPYmplY3QuZW50cmllcyhpeC5hcmd1bWVudHMpKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBoYW5kbGVBcmdSZXNvbHV0aW9uKGFyZyk7XG4gICAgICBpeC5hcmd1bWVudHNbaWRdLmFzQXJndW1lbnQgPSBjYXN0KHJlcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpeDtcbn1cblxuY29uc3QgZW5jb2RlVHJhbnNhY3Rpb25QYXlsb2FkID0gdHggPT4gcHJlcGVuZFRyYW5zYWN0aW9uRG9tYWluVGFnKHJscEVuY29kZShwcmVwYXJlUGF5bG9hZCh0eCkpKTtcbmNvbnN0IGVuY29kZVRyYW5zYWN0aW9uRW52ZWxvcGUgPSB0eCA9PiBwcmVwZW5kVHJhbnNhY3Rpb25Eb21haW5UYWcocmxwRW5jb2RlKHByZXBhcmVFbnZlbG9wZSh0eCkpKTtcbmNvbnN0IGVuY29kZVR4SWRGcm9tVm91Y2hlciA9IHZvdWNoZXIgPT4gc2hhM18yNTYocmxwRW5jb2RlKHByZXBhcmVWb3VjaGVyKHZvdWNoZXIpKSk7XG5jb25zdCByaWdodFBhZGRlZEhleEJ1ZmZlciA9ICh2YWx1ZSwgcGFkKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZS5wYWRFbmQocGFkICogMiwgMCksIFwiaGV4XCIpO1xuY29uc3QgbGVmdFBhZGRlZEhleEJ1ZmZlciA9ICh2YWx1ZSwgcGFkKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZS5wYWRTdGFydChwYWQgKiAyLCAwKSwgXCJoZXhcIik7XG5jb25zdCBUUkFOU0FDVElPTl9ET01BSU5fVEFHID0gcmlnaHRQYWRkZWRIZXhCdWZmZXIoQnVmZmVyLmZyb20oXCJGTE9XLVYwLjAtdHJhbnNhY3Rpb25cIikudG9TdHJpbmcoXCJoZXhcIiksIDMyKS50b1N0cmluZyhcImhleFwiKTtcbmNvbnN0IHByZXBlbmRUcmFuc2FjdGlvbkRvbWFpblRhZyA9IHR4ID0+IFRSQU5TQUNUSU9OX0RPTUFJTl9UQUcgKyB0eDtcbmNvbnN0IGFkZHJlc3NCdWZmZXIgPSBhZGRyID0+IGxlZnRQYWRkZWRIZXhCdWZmZXIoYWRkciwgOCk7XG5jb25zdCBibG9ja0J1ZmZlciA9IGJsb2NrID0+IGxlZnRQYWRkZWRIZXhCdWZmZXIoYmxvY2ssIDMyKTtcbmNvbnN0IGFyZ3VtZW50VG9TdHJpbmcgPSBhcmcgPT4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoYXJnKSwgXCJ1dGY4XCIpO1xuY29uc3Qgc2NyaXB0QnVmZmVyID0gc2NyaXB0ID0+IEJ1ZmZlci5mcm9tKHNjcmlwdCwgXCJ1dGY4XCIpO1xuY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gc2lnbmF0dXJlID0+IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgXCJoZXhcIik7XG5jb25zdCBybHBFbmNvZGUgPSB2ID0+IHtcbiAgcmV0dXJuIGVuY29kZSh2KS50b1N0cmluZyhcImhleFwiKTtcbn07XG5jb25zdCBzaGEzXzI1NiA9IG1zZyA9PiB7XG4gIGNvbnN0IHNoYSA9IG5ldyBTSEEzKDI1Nik7XG4gIHNoYS51cGRhdGUoQnVmZmVyLmZyb20obXNnLCBcImhleFwiKSk7XG4gIHJldHVybiBzaGEuZGlnZXN0KCkudG9TdHJpbmcoXCJoZXhcIik7XG59O1xuY29uc3QgcHJlcGFyZVBheWxvYWQgPSB0eCA9PiB7XG4gIHZhbGlkYXRlUGF5bG9hZCh0eCk7XG4gIHJldHVybiBbc2NyaXB0QnVmZmVyKHR4LmNhZGVuY2UpLCB0eC5hcmd1bWVudHMubWFwKGFyZ3VtZW50VG9TdHJpbmcpLCBibG9ja0J1ZmZlcih0eC5yZWZCbG9jayksIHR4LmNvbXB1dGVMaW1pdCwgYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KHR4LnByb3Bvc2FsS2V5LmFkZHJlc3MpKSwgdHgucHJvcG9zYWxLZXkua2V5SWQsIHR4LnByb3Bvc2FsS2V5LnNlcXVlbmNlTnVtLCBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgodHgucGF5ZXIpKSwgdHguYXV0aG9yaXplcnMubWFwKGF1dGhvcml6ZXIgPT4gYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KGF1dGhvcml6ZXIpKSldO1xufTtcbmNvbnN0IHByZXBhcmVFbnZlbG9wZSA9IHR4ID0+IHtcbiAgdmFsaWRhdGVFbnZlbG9wZSh0eCk7XG4gIHJldHVybiBbcHJlcGFyZVBheWxvYWQodHgpLCBwcmVwYXJlUGF5bG9hZFNpZ25hdHVyZXModHgpXTtcbn07XG5jb25zdCBwcmVwYXJlUGF5bG9hZFNpZ25hdHVyZXMgPSB0eCA9PiB7XG4gIGNvbnN0IHNpZ25lcnMgPSBjb2xsZWN0U2lnbmVycyh0eCk7XG4gIHJldHVybiB0eC5wYXlsb2FkU2lncy5tYXAoc2lnID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmVySW5kZXg6IHNpZ25lcnMuZ2V0KHNpZy5hZGRyZXNzKSxcbiAgICAgIGtleUlkOiBzaWcua2V5SWQsXG4gICAgICBzaWc6IHNpZy5zaWdcbiAgICB9O1xuICB9KS5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2lnbmVySW5kZXggPiBiLnNpZ25lckluZGV4KSByZXR1cm4gMTtcbiAgICBpZiAoYS5zaWduZXJJbmRleCA8IGIuc2lnbmVySW5kZXgpIHJldHVybiAtMTtcbiAgICBpZiAoYS5rZXlJZCA+IGIua2V5SWQpIHJldHVybiAxO1xuICAgIGlmIChhLmtleUlkIDwgYi5rZXlJZCkgcmV0dXJuIC0xO1xuICB9KS5tYXAoc2lnID0+IHtcbiAgICByZXR1cm4gW3NpZy5zaWduZXJJbmRleCwgc2lnLmtleUlkLCBzaWduYXR1cmVCdWZmZXIoc2lnLnNpZyldO1xuICB9KTtcbn07XG5jb25zdCBjb2xsZWN0U2lnbmVycyA9IHR4ID0+IHtcbiAgY29uc3Qgc2lnbmVycyA9IG5ldyBNYXAoKTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBhZGRTaWduZXIgPSBhZGRyID0+IHtcbiAgICBpZiAoIXNpZ25lcnMuaGFzKGFkZHIpKSB7XG4gICAgICBzaWduZXJzLnNldChhZGRyLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIGFkZFNpZ25lcih0eC5wcm9wb3NhbEtleS5hZGRyZXNzKTtcbiAgYWRkU2lnbmVyKHR4LnBheWVyKTtcbiAgdHguYXV0aG9yaXplcnMuZm9yRWFjaChhZGRTaWduZXIpO1xuICByZXR1cm4gc2lnbmVycztcbn07XG5jb25zdCBwcmVwYXJlVm91Y2hlciA9IHZvdWNoZXIgPT4ge1xuICB2YWxpZGF0ZVZvdWNoZXIodm91Y2hlcik7XG4gIGNvbnN0IHNpZ25lcnMgPSBjb2xsZWN0U2lnbmVycyh2b3VjaGVyKTtcbiAgY29uc3QgcHJlcGFyZVNpZ3MgPSBzaWdzID0+IHtcbiAgICByZXR1cm4gc2lncy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBrZXlJZCxcbiAgICAgICAgc2lnXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25lckluZGV4OiBzaWduZXJzLmdldChhZGRyZXNzKSxcbiAgICAgICAga2V5SWQsXG4gICAgICAgIHNpZ1xuICAgICAgfTtcbiAgICB9KS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5zaWduZXJJbmRleCA+IGIuc2lnbmVySW5kZXgpIHJldHVybiAxO1xuICAgICAgaWYgKGEuc2lnbmVySW5kZXggPCBiLnNpZ25lckluZGV4KSByZXR1cm4gLTE7XG4gICAgICBpZiAoYS5rZXlJZCA+IGIua2V5SWQpIHJldHVybiAxO1xuICAgICAgaWYgKGEua2V5SWQgPCBiLmtleUlkKSByZXR1cm4gLTE7XG4gICAgfSkubWFwKHNpZyA9PiB7XG4gICAgICByZXR1cm4gW3NpZy5zaWduZXJJbmRleCwgc2lnLmtleUlkLCBzaWduYXR1cmVCdWZmZXIoc2lnLnNpZyldO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gW1tzY3JpcHRCdWZmZXIodm91Y2hlci5jYWRlbmNlKSwgdm91Y2hlci5hcmd1bWVudHMubWFwKGFyZ3VtZW50VG9TdHJpbmcpLCBibG9ja0J1ZmZlcih2b3VjaGVyLnJlZkJsb2NrKSwgdm91Y2hlci5jb21wdXRlTGltaXQsIGFkZHJlc3NCdWZmZXIoc2Fuc1ByZWZpeCh2b3VjaGVyLnByb3Bvc2FsS2V5LmFkZHJlc3MpKSwgdm91Y2hlci5wcm9wb3NhbEtleS5rZXlJZCwgdm91Y2hlci5wcm9wb3NhbEtleS5zZXF1ZW5jZU51bSwgYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KHZvdWNoZXIucGF5ZXIpKSwgdm91Y2hlci5hdXRob3JpemVycy5tYXAoYXV0aG9yaXplciA9PiBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgoYXV0aG9yaXplcikpKV0sIHByZXBhcmVTaWdzKHZvdWNoZXIucGF5bG9hZFNpZ3MpLCBwcmVwYXJlU2lncyh2b3VjaGVyLmVudmVsb3BlU2lncyldO1xufTtcbmNvbnN0IHZhbGlkYXRlUGF5bG9hZCA9IHR4ID0+IHtcbiAgcGF5bG9hZEZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNoZWNrRmllbGQodHgsIGZpZWxkKSk7XG4gIHByb3Bvc2FsS2V5RmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZCh0eC5wcm9wb3NhbEtleSwgZmllbGQsIFwicHJvcG9zYWxLZXlcIikpO1xufTtcbmNvbnN0IHZhbGlkYXRlRW52ZWxvcGUgPSB0eCA9PiB7XG4gIHBheWxvYWRTaWdzRmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZCh0eCwgZmllbGQpKTtcbiAgdHgucGF5bG9hZFNpZ3MuZm9yRWFjaCgoc2lnLCBpbmRleCkgPT4ge1xuICAgIHBheWxvYWRTaWdGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHNpZywgZmllbGQsIFwicGF5bG9hZFNpZ3NcIiwgaW5kZXgpKTtcbiAgfSk7XG59O1xuY29uc3QgdmFsaWRhdGVWb3VjaGVyID0gdm91Y2hlciA9PiB7XG4gIHBheWxvYWRGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHZvdWNoZXIsIGZpZWxkKSk7XG4gIHByb3Bvc2FsS2V5RmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZCh2b3VjaGVyLnByb3Bvc2FsS2V5LCBmaWVsZCwgXCJwcm9wb3NhbEtleVwiKSk7XG4gIHBheWxvYWRTaWdzRmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZCh2b3VjaGVyLCBmaWVsZCkpO1xuICB2b3VjaGVyLnBheWxvYWRTaWdzLmZvckVhY2goKHNpZywgaW5kZXgpID0+IHtcbiAgICBwYXlsb2FkU2lnRmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZChzaWcsIGZpZWxkLCBcInBheWxvYWRTaWdzXCIsIGluZGV4KSk7XG4gIH0pO1xuICBlbnZlbG9wZVNpZ3NGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHZvdWNoZXIsIGZpZWxkKSk7XG4gIHZvdWNoZXIuZW52ZWxvcGVTaWdzLmZvckVhY2goKHNpZywgaW5kZXgpID0+IHtcbiAgICBlbnZlbG9wZVNpZ0ZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNoZWNrRmllbGQoc2lnLCBmaWVsZCwgXCJlbnZlbG9wZVNpZ3NcIiwgaW5kZXgpKTtcbiAgfSk7XG59O1xuY29uc3QgaXNOdW1iZXIgPSB2ID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xuY29uc3QgaXNTdHJpbmcgPSB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNPYmplY3QgPSB2ID0+IHYgIT09IG51bGwgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc0FycmF5ID0gdiA9PiBpc09iamVjdCh2KSAmJiB2IGluc3RhbmNlb2YgQXJyYXk7XG5jb25zdCBwYXlsb2FkRmllbGRzID0gW3tcbiAgbmFtZTogXCJjYWRlbmNlXCIsXG4gIGNoZWNrOiBpc1N0cmluZ1xufSwge1xuICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICBjaGVjazogaXNBcnJheVxufSwge1xuICBuYW1lOiBcInJlZkJsb2NrXCIsXG4gIGNoZWNrOiBpc1N0cmluZyxcbiAgZGVmYXVsdFZhbDogXCIwXCJcbn0sIHtcbiAgbmFtZTogXCJjb21wdXRlTGltaXRcIixcbiAgY2hlY2s6IGlzTnVtYmVyXG59LCB7XG4gIG5hbWU6IFwicHJvcG9zYWxLZXlcIixcbiAgY2hlY2s6IGlzT2JqZWN0XG59LCB7XG4gIG5hbWU6IFwicGF5ZXJcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59LCB7XG4gIG5hbWU6IFwiYXV0aG9yaXplcnNcIixcbiAgY2hlY2s6IGlzQXJyYXlcbn1dO1xuY29uc3QgcHJvcG9zYWxLZXlGaWVsZHMgPSBbe1xuICBuYW1lOiBcImFkZHJlc3NcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59LCB7XG4gIG5hbWU6IFwia2V5SWRcIixcbiAgY2hlY2s6IGlzTnVtYmVyXG59LCB7XG4gIG5hbWU6IFwic2VxdWVuY2VOdW1cIixcbiAgY2hlY2s6IGlzTnVtYmVyXG59XTtcbmNvbnN0IHBheWxvYWRTaWdzRmllbGRzID0gW3tcbiAgbmFtZTogXCJwYXlsb2FkU2lnc1wiLFxuICBjaGVjazogaXNBcnJheVxufV07XG5jb25zdCBwYXlsb2FkU2lnRmllbGRzID0gW3tcbiAgbmFtZTogXCJhZGRyZXNzXCIsXG4gIGNoZWNrOiBpc1N0cmluZ1xufSwge1xuICBuYW1lOiBcImtleUlkXCIsXG4gIGNoZWNrOiBpc051bWJlclxufSwge1xuICBuYW1lOiBcInNpZ1wiLFxuICBjaGVjazogaXNTdHJpbmdcbn1dO1xuY29uc3QgZW52ZWxvcGVTaWdzRmllbGRzID0gW3tcbiAgbmFtZTogXCJlbnZlbG9wZVNpZ3NcIixcbiAgY2hlY2s6IGlzQXJyYXlcbn1dO1xuY29uc3QgZW52ZWxvcGVTaWdGaWVsZHMgPSBbe1xuICBuYW1lOiBcImFkZHJlc3NcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59LCB7XG4gIG5hbWU6IFwia2V5SWRcIixcbiAgY2hlY2s6IGlzTnVtYmVyXG59LCB7XG4gIG5hbWU6IFwic2lnXCIsXG4gIGNoZWNrOiBpc1N0cmluZ1xufV07XG5jb25zdCBjaGVja0ZpZWxkID0gKG9iaiwgZmllbGQsIGJhc2UsIGluZGV4KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIGNoZWNrLFxuICAgIGRlZmF1bHRWYWxcbiAgfSA9IGZpZWxkO1xuICBpZiAob2JqW25hbWVdID09IG51bGwgJiYgZGVmYXVsdFZhbCAhPSBudWxsKSBvYmpbbmFtZV0gPSBkZWZhdWx0VmFsO1xuICBpZiAob2JqW25hbWVdID09IG51bGwpIHRocm93IG1pc3NpbmdGaWVsZEVycm9yKG5hbWUsIGJhc2UsIGluZGV4KTtcbiAgaWYgKCFjaGVjayhvYmpbbmFtZV0pKSB0aHJvdyBpbnZhbGlkRmllbGRFcnJvcihuYW1lLCBiYXNlLCBpbmRleCk7XG59O1xuY29uc3QgcHJpbnRGaWVsZE5hbWUgPSAoZmllbGQsIGJhc2UsIGluZGV4KSA9PiB7XG4gIGlmICghIWJhc2UpIHJldHVybiBpbmRleCA9PSBudWxsID8gYCR7YmFzZX0uJHtmaWVsZH1gIDogYCR7YmFzZX0uJHtpbmRleH0uJHtmaWVsZH1gO1xuICByZXR1cm4gZmllbGQ7XG59O1xuY29uc3QgbWlzc2luZ0ZpZWxkRXJyb3IgPSAoZmllbGQsIGJhc2UsIGluZGV4KSA9PiBuZXcgRXJyb3IoYE1pc3NpbmcgZmllbGQgJHtwcmludEZpZWxkTmFtZShmaWVsZCwgYmFzZSwgaW5kZXgpfWApO1xuY29uc3QgaW52YWxpZEZpZWxkRXJyb3IgPSAoZmllbGQsIGJhc2UsIGluZGV4KSA9PiBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgJHtwcmludEZpZWxkTmFtZShmaWVsZCwgYmFzZSwgaW5kZXgpfWApO1xuXG5mdW5jdGlvbiBmaW5kSW5zaWRlU2lnbmVycyhpeCkge1xuICAvLyBJbnNpZGUgU2lnbmVycyBBcmU6IChhdXRob3JpemVycyArIHByb3Bvc2VyKSAtIHBheWVyXG4gIGxldCBpbnNpZGUgPSBuZXcgU2V0KGl4LmF1dGhvcml6YXRpb25zKTtcbiAgaW5zaWRlLmFkZChpeC5wcm9wb3Nlcik7XG4gIGlmIChBcnJheS5pc0FycmF5KGl4LnBheWVyKSkge1xuICAgIGl4LnBheWVyLmZvckVhY2gocCA9PiBpbnNpZGUuZGVsZXRlKHApKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNpZGUuZGVsZXRlKGl4LnBheWVyKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShpbnNpZGUpO1xufVxuZnVuY3Rpb24gZmluZE91dHNpZGVTaWduZXJzKGl4KSB7XG4gIC8vIE91dHNpZGUgU2lnbmVycyBBcmU6IChwYXllcilcbiAgbGV0IG91dHNpZGUgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoaXgucGF5ZXIpID8gaXgucGF5ZXIgOiBbaXgucGF5ZXJdKTtcbiAgcmV0dXJuIEFycmF5LmZyb20ob3V0c2lkZSk7XG59XG5jb25zdCBjcmVhdGVTaWduYWJsZVZvdWNoZXIgPSBpeCA9PiB7XG4gIGNvbnN0IGJ1aWxkQXV0aG9yaXplcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbnMgPSBpeC5hdXRob3JpemF0aW9ucy5tYXAoY2lkID0+IHdpdGhQcmVmaXgoaXguYWNjb3VudHNbY2lkXS5hZGRyKSkucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICByZXR1cm4gcHJldi5maW5kKGl0ZW0gPT4gaXRlbSA9PT0gY3VycmVudCkgPyBwcmV2IDogWy4uLnByZXYsIGN1cnJlbnRdO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbnNbMF0gPyBhdXRob3JpemF0aW9ucyA6IFtdO1xuICB9O1xuICBjb25zdCBidWlsZEluc2lkZVNpZ25lcnMgPSAoKSA9PiBmaW5kSW5zaWRlU2lnbmVycyhpeCkubWFwKGlkID0+ICh7XG4gICAgYWRkcmVzczogd2l0aFByZWZpeChpeC5hY2NvdW50c1tpZF0uYWRkciksXG4gICAga2V5SWQ6IGl4LmFjY291bnRzW2lkXS5rZXlJZCxcbiAgICBzaWc6IGl4LmFjY291bnRzW2lkXS5zaWduYXR1cmVcbiAgfSkpO1xuICBjb25zdCBidWlsZE91dHNpZGVTaWduZXJzID0gKCkgPT4gZmluZE91dHNpZGVTaWduZXJzKGl4KS5tYXAoaWQgPT4gKHtcbiAgICBhZGRyZXNzOiB3aXRoUHJlZml4KGl4LmFjY291bnRzW2lkXS5hZGRyKSxcbiAgICBrZXlJZDogaXguYWNjb3VudHNbaWRdLmtleUlkLFxuICAgIHNpZzogaXguYWNjb3VudHNbaWRdLnNpZ25hdHVyZVxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgY2FkZW5jZTogaXgubWVzc2FnZS5jYWRlbmNlLFxuICAgIHJlZkJsb2NrOiBpeC5tZXNzYWdlLnJlZkJsb2NrIHx8IG51bGwsXG4gICAgY29tcHV0ZUxpbWl0OiBpeC5tZXNzYWdlLmNvbXB1dGVMaW1pdCxcbiAgICBhcmd1bWVudHM6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChpZCA9PiBpeC5hcmd1bWVudHNbaWRdLmFzQXJndW1lbnQpLFxuICAgIHByb3Bvc2FsS2V5OiB7XG4gICAgICBhZGRyZXNzOiB3aXRoUHJlZml4KGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5hZGRyKSxcbiAgICAgIGtleUlkOiBpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0ua2V5SWQsXG4gICAgICBzZXF1ZW5jZU51bTogaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLnNlcXVlbmNlTnVtXG4gICAgfSxcbiAgICBwYXllcjogd2l0aFByZWZpeChpeC5hY2NvdW50c1tBcnJheS5pc0FycmF5KGl4LnBheWVyKSA/IGl4LnBheWVyWzBdIDogaXgucGF5ZXJdLmFkZHIpLFxuICAgIGF1dGhvcml6ZXJzOiBidWlsZEF1dGhvcml6ZXJzKCksXG4gICAgcGF5bG9hZFNpZ3M6IGJ1aWxkSW5zaWRlU2lnbmVycygpLFxuICAgIGVudmVsb3BlU2lnczogYnVpbGRPdXRzaWRlU2lnbmVycygpXG4gIH07XG59O1xuY29uc3Qgdm91Y2hlclRvVHhJZCA9IHZvdWNoZXIgPT4ge1xuICByZXR1cm4gZW5jb2RlVHhJZEZyb21Wb3VjaGVyKHZvdWNoZXIpO1xufTtcblxuY29uc3QgaWRvZiQxID0gYWNjdCA9PiBgJHt3aXRoUHJlZml4KGFjY3QuYWRkcil9LSR7YWNjdC5rZXlJZH1gO1xuY29uc3QgaXNGbiA9IHYgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGJ1aWxkUHJlU2lnbmFibGUoYWNjdCwgaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgZl90eXBlOiBcIlByZVNpZ25hYmxlXCIsXG4gICAgICBmX3ZzbjogXCIxLjAuMVwiLFxuICAgICAgcm9sZXM6IGFjY3Qucm9sZSxcbiAgICAgIGNhZGVuY2U6IGl4Lm1lc3NhZ2UuY2FkZW5jZSxcbiAgICAgIGFyZ3M6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChkID0+IGl4LmFyZ3VtZW50c1tkXS5hc0FyZ3VtZW50KSxcbiAgICAgIGRhdGE6IHt9LFxuICAgICAgaW50ZXJhY3Rpb246IGl4LFxuICAgICAgdm91Y2hlcjogY3JlYXRlU2lnbmFibGVWb3VjaGVyKGl4KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcImJ1aWxkUHJlU2lnbmFibGVcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjb2xsZWN0QWNjb3VudHMoaXgsIGFjY291bnRzLCBsYXN0KSB7XG4gIGxldCBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMztcbiAgaW52YXJpYW50JDEoZGVwdGgsIFwiQWNjb3VudCBSZXNvbHZlIFJlY3Vyc2lvbiBMaW1pdCBFeGNlZWRlZFwiLCB7XG4gICAgaXgsXG4gICAgYWNjb3VudHNcbiAgfSk7XG4gIGxldCBhdXRob3JpemF0aW9ucyA9IFtdO1xuICBmb3IgKGxldCBheCBvZiBhY2NvdW50cykge1xuICAgIGxldCByZXNvbHZlID0gYXgucmVzb2x2ZTtcbiAgICBheC5yZXNvbHZlID0gbnVsbDtcbiAgICB2YXIgb2xkID0gbGFzdCB8fCBheDtcbiAgICBpZiAoaXNGbihyZXNvbHZlKSkgYXggPSBhd2FpdCByZXNvbHZlKGF4LCBidWlsZFByZVNpZ25hYmxlKGF4LCBpeCkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGF4KSkge1xuICAgICAgYXdhaXQgY29sbGVjdEFjY291bnRzKGl4LCBheCwgb2xkLCBkZXB0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXguYWRkcikge1xuICAgICAgICBheC5hZGRyID0gc2Fuc1ByZWZpeChheC5hZGRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChheC5hZGRyICE9IG51bGwgJiYgYXgua2V5SWQgIT0gbnVsbCkge1xuICAgICAgICBheC50ZW1wSWQgPSBpZG9mJDEoYXgpO1xuICAgICAgfVxuICAgICAgaXguYWNjb3VudHNbYXgudGVtcElkXSA9IGl4LmFjY291bnRzW2F4LnRlbXBJZF0gfHwgYXg7XG4gICAgICBpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUucHJvcG9zZXIgPSBpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUucHJvcG9zZXIgfHwgYXgucm9sZS5wcm9wb3NlcjtcbiAgICAgIGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5wYXllciA9IGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5wYXllciB8fCBheC5yb2xlLnBheWVyO1xuICAgICAgaXguYWNjb3VudHNbYXgudGVtcElkXS5yb2xlLmF1dGhvcml6ZXIgPSBpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUuYXV0aG9yaXplciB8fCBheC5yb2xlLmF1dGhvcml6ZXI7XG4gICAgICBpZiAoaXguYWNjb3VudHNbYXgudGVtcElkXS5yb2xlLnByb3Bvc2VyICYmIGl4LnByb3Bvc2VyID09PSBvbGQudGVtcElkKSB7XG4gICAgICAgIGl4LnByb3Bvc2VyID0gYXgudGVtcElkO1xuICAgICAgfVxuICAgICAgaWYgKGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5wYXllcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpeC5wYXllcikpIHtcbiAgICAgICAgICBpeC5wYXllciA9IEFycmF5LmZyb20obmV3IFNldChbLi4uaXgucGF5ZXIsIGF4LnRlbXBJZF0ubWFwKGQgPT4gZCA9PT0gb2xkLnRlbXBJZCA/IGF4LnRlbXBJZCA6IGQpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXgucGF5ZXIgPSBBcnJheS5mcm9tKG5ldyBTZXQoW2l4LnBheWVyLCBheC50ZW1wSWRdLm1hcChkID0+IGQgPT09IG9sZC50ZW1wSWQgPyBheC50ZW1wSWQgOiBkKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpeC5wYXllci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBheWVyIGR1cHMgYmFzZWQgb24gYWRkciBhbmQga2V5SWRcbiAgICAgICAgICBjb25zdCBkdXBMaXN0ID0gW107XG4gICAgICAgICAgY29uc3QgcGF5ZXJBY2N0cyA9IFtdO1xuICAgICAgICAgIGl4LnBheWVyID0gaXgucGF5ZXIucmVkdWNlKChnLCB0ZW1wSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYWRkclxuICAgICAgICAgICAgfSA9IGl4LmFjY291bnRzW3RlbXBJZF07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpZG9mJDEoaXguYWNjb3VudHNbdGVtcElkXSk7XG4gICAgICAgICAgICBwYXllckFjY3RzLnB1c2goYWRkcik7XG4gICAgICAgICAgICBpZiAoZHVwTGlzdC5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZztcbiAgICAgICAgICAgIGR1cExpc3QucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5nLCB0ZW1wSWRdO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICBjb25zdCBtdWx0aUFjY3RzID0gQXJyYXkuZnJvbShuZXcgU2V0KHBheWVyQWNjdHMpKTtcbiAgICAgICAgICBpZiAobXVsdGlBY2N0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXllciBjYW4gbm90IGJlIGRpZmZlcmVudCBhY2NvdW50c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUuYXV0aG9yaXplcikge1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIC8vIGRvIGdyb3VwIHJlcGxhY2VtZW50XG4gICAgICAgICAgYXV0aG9yaXphdGlvbnMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmF1dGhvcml6YXRpb25zLCBheC50ZW1wSWRdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZG8gMS0xIHJlcGxhY2VtZW50XG4gICAgICAgICAgaXguYXV0aG9yaXphdGlvbnMgPSBpeC5hdXRob3JpemF0aW9ucy5tYXAoZCA9PiBkID09PSBvbGQudGVtcElkID8gYXgudGVtcElkIDogZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZC50ZW1wSWQgIT0gYXgudGVtcElkKSBkZWxldGUgaXguYWNjb3VudHNbb2xkLnRlbXBJZF07XG4gIH1cbiAgaWYgKGxhc3QpIHtcbiAgICAvLyBjb21wbGV0ZSAoZmxhdG1hcCkgZ3JvdXAgcmVwbGFjZW1lbnRcbiAgICBpeC5hdXRob3JpemF0aW9ucyA9IGl4LmF1dGhvcml6YXRpb25zLm1hcChkID0+IGQgPT09IGxhc3QudGVtcElkID8gYXV0aG9yaXphdGlvbnMgOiBkKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IEFycmF5LmlzQXJyYXkoY3VycikgPyBbLi4ucHJldiwgLi4uY3Vycl0gOiBbLi4ucHJldiwgY3Vycl0sIFtdKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFjY291bnRzKGl4KSB7XG4gIGlmIChpc1RyYW5zYWN0aW9uKGl4KSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpeC5wYXllcikpIHtcbiAgICAgIGxvZy5kZXByZWNhdGUoe1xuICAgICAgICBwa2c6IFwiRkNMXCIsXG4gICAgICAgIHN1YmplY3Q6ICdcIml4LnBheWVyXCIgbXVzdCBiZSBhbiBhcnJheS4gU3VwcG9ydCBmb3IgaXgucGF5ZXIgYXMgYSBzaW5ndWxhcicsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2VlIGNoYW5nZWxvZyBmb3IgbW9yZSBpbmZvLlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvbGxlY3RBY2NvdW50cyhpeCwgT2JqZWN0LnZhbHVlcyhpeC5hY2NvdW50cykpO1xuICAgICAgYXdhaXQgY29sbGVjdEFjY291bnRzKGl4LCBPYmplY3QudmFsdWVzKGl4LmFjY291bnRzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCI9PT0gU0FEIFBBTkRBID09PVxcblxcblwiLCBlcnJvciwgXCJcXG5cXG49PT0gU0FEIFBBTkRBID09PVwiKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVTaWduYXR1cmVzKGl4KSB7XG4gIGlmIChpc1RyYW5zYWN0aW9uKGl4KSkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgaW5zaWRlU2lnbmVycyA9IGZpbmRJbnNpZGVTaWduZXJzKGl4KTtcbiAgICAgIGNvbnN0IGluc2lkZVBheWxvYWQgPSBlbmNvZGVUcmFuc2FjdGlvblBheWxvYWQocHJlcEZvckVuY29kaW5nKGl4KSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnNpZGVTaWduZXJzLm1hcChmZXRjaFNpZ25hdHVyZShpeCwgaW5zaWRlUGF5bG9hZCkpKTtcbiAgICAgIGxldCBvdXRzaWRlU2lnbmVycyA9IGZpbmRPdXRzaWRlU2lnbmVycyhpeCk7XG4gICAgICBjb25zdCBvdXRzaWRlUGF5bG9hZCA9IGVuY29kZVRyYW5zYWN0aW9uRW52ZWxvcGUoe1xuICAgICAgICAuLi5wcmVwRm9yRW5jb2RpbmcoaXgpLFxuICAgICAgICBwYXlsb2FkU2lnczogaW5zaWRlU2lnbmVycy5tYXAoaWQgPT4gKHtcbiAgICAgICAgICBhZGRyZXNzOiBpeC5hY2NvdW50c1tpZF0uYWRkcixcbiAgICAgICAgICBrZXlJZDogaXguYWNjb3VudHNbaWRdLmtleUlkLFxuICAgICAgICAgIHNpZzogaXguYWNjb3VudHNbaWRdLnNpZ25hdHVyZVxuICAgICAgICB9KSlcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3V0c2lkZVNpZ25lcnMubWFwKGZldGNoU2lnbmF0dXJlKGl4LCBvdXRzaWRlUGF5bG9hZCkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNpZ25hdHVyZXNcIiwgZXJyb3IsIHtcbiAgICAgICAgaXhcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBpeDtcbn1cbmZ1bmN0aW9uIGZldGNoU2lnbmF0dXJlKGl4LCBwYXlsb2FkKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBpbm5lckZldGNoU2lnbmF0dXJlKGlkKSB7XG4gICAgY29uc3QgYWNjdCA9IGl4LmFjY291bnRzW2lkXTtcbiAgICBpZiAoYWNjdC5zaWduYXR1cmUgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0gPSBhd2FpdCBhY2N0LnNpZ25pbmdGdW5jdGlvbihidWlsZFNpZ25hYmxlKGFjY3QsIHBheWxvYWQsIGl4KSk7XG4gICAgaXguYWNjb3VudHNbaWRdLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2lnbmFibGUoYWNjdCwgbWVzc2FnZSwgaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgZl90eXBlOiBcIlNpZ25hYmxlXCIsXG4gICAgICBmX3ZzbjogXCIxLjAuMVwiLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGFkZHI6IHNhbnNQcmVmaXgoYWNjdC5hZGRyKSxcbiAgICAgIGtleUlkOiBhY2N0LmtleUlkLFxuICAgICAgcm9sZXM6IGFjY3Qucm9sZSxcbiAgICAgIGNhZGVuY2U6IGl4Lm1lc3NhZ2UuY2FkZW5jZSxcbiAgICAgIGFyZ3M6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChkID0+IGl4LmFyZ3VtZW50c1tkXS5hc0FyZ3VtZW50KSxcbiAgICAgIGRhdGE6IHt9LFxuICAgICAgaW50ZXJhY3Rpb246IGl4LFxuICAgICAgdm91Y2hlcjogY3JlYXRlU2lnbmFibGVWb3VjaGVyKGl4KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcImJ1aWxkU2lnbmFibGVcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwRm9yRW5jb2RpbmcoaXgpIHtcbiAgY29uc3QgcGF5ZXJBZGRyZXNzID0gc2Fuc1ByZWZpeCgoQXJyYXkuaXNBcnJheShpeC5wYXllcikgPyBpeC5hY2NvdW50c1tpeC5wYXllclswXV0gOiBpeC5hY2NvdW50c1tpeC5wYXllcl0pLmFkZHIpO1xuICByZXR1cm4ge1xuICAgIGNhZGVuY2U6IGl4Lm1lc3NhZ2UuY2FkZW5jZSxcbiAgICByZWZCbG9jazogaXgubWVzc2FnZS5yZWZCbG9jayB8fCBudWxsLFxuICAgIGNvbXB1dGVMaW1pdDogaXgubWVzc2FnZS5jb21wdXRlTGltaXQsXG4gICAgYXJndW1lbnRzOiBpeC5tZXNzYWdlLmFyZ3VtZW50cy5tYXAoaWQgPT4gaXguYXJndW1lbnRzW2lkXS5hc0FyZ3VtZW50KSxcbiAgICBwcm9wb3NhbEtleToge1xuICAgICAgYWRkcmVzczogc2Fuc1ByZWZpeChpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uYWRkciksXG4gICAgICBrZXlJZDogaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmtleUlkLFxuICAgICAgc2VxdWVuY2VOdW06IGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5zZXF1ZW5jZU51bVxuICAgIH0sXG4gICAgcGF5ZXI6IHBheWVyQWRkcmVzcyxcbiAgICBhdXRob3JpemVyczogaXguYXV0aG9yaXphdGlvbnMubWFwKGNpZCA9PiBzYW5zUHJlZml4KGl4LmFjY291bnRzW2NpZF0uYWRkcikpLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgcmV0dXJuIHByZXYuZmluZChpdGVtID0+IGl0ZW0gPT09IGN1cnJlbnQpID8gcHJldiA6IFsuLi5wcmV2LCBjdXJyZW50XTtcbiAgICB9LCBbXSlcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVZhbGlkYXRvcnMoaXgpIHtcbiAgY29uc3QgdmFsaWRhdG9ycyA9IGdldChpeCwgXCJpeC52YWxpZGF0b3JzXCIsIFtdKTtcbiAgcmV0dXJuIHBpcGUoaXgsIHZhbGlkYXRvcnMubWFwKGNiID0+IGl4ID0+IGNiKGl4LCB7XG4gICAgT2ssXG4gICAgQmFkXG4gIH0pKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGaW5hbE5vcm1hbGl6YXRpb24oaXgpIHtcbiAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGl4LmFjY291bnRzKSkge1xuICAgIGl4LmFjY291bnRzW2tleV0uYWRkciA9IHNhbnNQcmVmaXgoaXguYWNjb3VudHNba2V5XS5hZGRyKTtcbiAgfVxuICByZXR1cm4gaXg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWb3VjaGVySW50ZXJjZXB0KGl4KSB7XG4gIGNvbnN0IGZuID0gZ2V0KGl4LCBcIml4LnZvdWNoZXItaW50ZXJjZXB0XCIpO1xuICBpZiAoaXNGbiQzKGZuKSkge1xuICAgIGF3YWl0IGZuKGNyZWF0ZVNpZ25hYmxlVm91Y2hlcihpeCkpO1xuICB9XG4gIHJldHVybiBpeDtcbn1cblxuY29uc3QgREVGQVVMVF9DT01QVVRFX0xJTUlUID0gMTAwO1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvbXB1dGVMaW1pdChpeCkge1xuICBpZiAoaXNUcmFuc2FjdGlvbihpeCkpIHtcbiAgICBpeC5tZXNzYWdlLmNvbXB1dGVMaW1pdCA9IGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0IHx8IChhd2FpdCBjb25maWcuZ2V0KFwiZmNsLmxpbWl0XCIpKTtcbiAgICBpZiAoIWl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0KSB7XG4gICAgICBsb2dnZXIubG9nLmRlcHJlY2F0ZSh7XG4gICAgICAgIHBrZzogXCJGQ0wvU0RLXCIsXG4gICAgICAgIHN1YmplY3Q6IFwiVGhlIGJ1aWx0LWluIGRlZmF1bHQgY29tcHV0ZSBsaW1pdCAoREVGQVVMVF9DT01QVVRFX0xJTUlUPTEwKVwiLFxuICAgICAgICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL1RSQU5TSVRJT05TLm1kIzAwMDktZGVwcmVjYXRlLWRlZmF1bHQtY29tcHV0ZS1saW1pdFwiXG4gICAgICB9KTtcbiAgICAgIGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0ID0gREVGQVVMVF9DT01QVVRFX0xJTUlUO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXg7XG59XG5cbmNvbnN0IG5vb3AgPSB2ID0+IHY7XG5jb25zdCBkZWJ1ZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgbGV0IGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICByZXR1cm4gYXN5bmMgaXggPT4ge1xuICAgIGNvbnN0IGFjY3RzID0gaXggPT4gW1wiXFxuQWNjb3VudHM6XCIsIHtcbiAgICAgIHByb3Bvc2VyOiBpeC5wcm9wb3NlcixcbiAgICAgIGF1dGhvcml6YXRpb25zOiBpeC5hdXRob3JpemF0aW9ucyxcbiAgICAgIHBheWVyOiBpeC5wYXllclxuICAgIH0sIFwiXFxuXFxuRGV0YWlsczpcIiwgaXguYWNjb3VudHNdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbXNnID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBtc2dbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgZGVidWdbJHtrZXl9XSAtLS1cXG5gLCAuLi5tc2csIFwiXFxuXFxuXFxuLS0tXCIpO1xuICAgIH07XG4gICAgaWYgKGF3YWl0IGNvbmZpZy5nZXQoYGRlYnVnLiR7a2V5fWApKSBhd2FpdCBmbihpeCwgbG9nLCBhY2N0cyk7XG4gICAgcmV0dXJuIGl4O1xuICB9O1xufTtcbmNvbnN0IHJlc29sdmUgPSBwaXBlKFtyZXNvbHZlQ2FkZW5jZSwgZGVidWcoXCJjYWRlbmNlXCIsIChpeCwgbG9nKSA9PiBsb2coaXgubWVzc2FnZS5jYWRlbmNlKSksIHJlc29sdmVDb21wdXRlTGltaXQsIGRlYnVnKFwiY29tcHV0ZSBsaW1pdFwiLCAoaXgsIGxvZykgPT4gbG9nKGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0KSksIHJlc29sdmVBcmd1bWVudHMsIGRlYnVnKFwiYXJndW1lbnRzXCIsIChpeCwgbG9nKSA9PiBsb2coaXgubWVzc2FnZS5hcmd1bWVudHMsIGl4Lm1lc3NhZ2UpKSwgcmVzb2x2ZUFjY291bnRzLCBkZWJ1ZyhcImFjY291bnRzXCIsIChpeCwgbG9nLCBhY2N0cykgPT4gbG9nKC4uLmFjY3RzKGl4KSkpLCAvKiBzcGVjaWFsICovZXhlY0ZldGNoUmVmLCAvKiBzcGVjaWFsICovZXhlY0ZldGNoU2VxdWVuY2VOdW1iZXIsIHJlc29sdmVTaWduYXR1cmVzLCBkZWJ1ZyhcInNpZ25hdHVyZXNcIiwgKGl4LCBsb2csIGFjY3RzKSA9PiBsb2coLi4uYWNjdHMoaXgpKSksIHJlc29sdmVGaW5hbE5vcm1hbGl6YXRpb24sIHJlc29sdmVWYWxpZGF0b3JzLCByZXNvbHZlVm91Y2hlckludGVyY2VwdCwgZGVidWcoXCJyZXNvbHZlZFwiLCAoaXgsIGxvZykgPT4gbG9nKGl4KSldKTtcbmFzeW5jIGZ1bmN0aW9uIGV4ZWNGZXRjaFJlZihpeCkge1xuICBpZiAoaXNUcmFuc2FjdGlvbihpeCkgJiYgaXgubWVzc2FnZS5yZWZCbG9jayA9PSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9IGF3YWl0IGNvbmZpZygpLmdldChcImFjY2Vzc05vZGUuYXBpXCIpO1xuICAgIGNvbnN0IHNlbmRGbiA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJzZGsudHJhbnNwb3J0XCIsIFwic2RrLnNlbmRcIl0sIHNlbmQkMSk7XG4gICAgaW52YXJpYW50JDEoc2VuZEZuLCBgUmVxdWlyZWQgdmFsdWUgZm9yIHNkay50cmFuc3BvcnQgaXMgbm90IGRlZmluZWQgaW4gY29uZmlnLiBTZWU6ICR7XCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2ZjbC1qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy9zZGsvQ0hBTkdFTE9HLm1kIzAwNTctYWxwaGExLS0tLTIwMjItMDEtMjFcIn1gKTtcbiAgICBpeC5tZXNzYWdlLnJlZkJsb2NrID0gKGF3YWl0IHNlbmRGbihidWlsZChbZ2V0QmxvY2soKV0pLCB7XG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZSxcbiAgICAgIEJ1ZmZlcixcbiAgICAgIGl4OiBpeE1vZHVsZVxuICAgIH0sIHtcbiAgICAgIG5vZGVcbiAgICB9KS50aGVuKGRlY29kZVJlc3BvbnNlKSkuaWQ7XG4gIH1cbiAgcmV0dXJuIGl4O1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY0ZldGNoU2VxdWVuY2VOdW1iZXIoaXgpIHtcbiAgaWYgKGlzVHJhbnNhY3Rpb24oaXgpKSB7XG4gICAgdmFyIGFjY3QgPSBPYmplY3QudmFsdWVzKGl4LmFjY291bnRzKS5maW5kKGEgPT4gYS5yb2xlLnByb3Bvc2VyKTtcbiAgICBpbnZhcmlhbnQkMShhY2N0LCBgVHJhbnNhY3Rpb25zIHJlcXVpcmUgYSBwcm9wb3NlcmApO1xuICAgIGlmIChhY2N0LnNlcXVlbmNlTnVtID09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCBjb25maWcoKS5nZXQoXCJhY2Nlc3NOb2RlLmFwaVwiKTtcbiAgICAgIGNvbnN0IHNlbmRGbiA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJzZGsudHJhbnNwb3J0XCIsIFwic2RrLnNlbmRcIl0sIHNlbmQkMSk7XG4gICAgICBpbnZhcmlhbnQkMShzZW5kRm4sIGBSZXF1aXJlZCB2YWx1ZSBmb3Igc2RrLnRyYW5zcG9ydCBpcyBub3QgZGVmaW5lZCBpbiBjb25maWcuIFNlZTogJHtcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmNsLWpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9DSEFOR0VMT0cubWQjMDA1Ny1hbHBoYTEtLS0tMjAyMi0wMS0yMVwifWApO1xuICAgICAgaXguYWNjb3VudHNbYWNjdC50ZW1wSWRdLnNlcXVlbmNlTnVtID0gYXdhaXQgc2VuZEZuKGF3YWl0IGJ1aWxkKFtnZXRBY2NvdW50KGFjY3QuYWRkcildKSwge1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBCdWZmZXIsXG4gICAgICAgIGl4OiBpeE1vZHVsZVxuICAgICAgfSwge1xuICAgICAgICBub2RlXG4gICAgICB9KS50aGVuKGRlY29kZVJlc3BvbnNlKS50aGVuKGFjY3QgPT4gYWNjdC5rZXlzKS50aGVuKGtleXMgPT4ga2V5cy5maW5kKGtleSA9PiBrZXkuaW5kZXggPT09IGFjY3Qua2V5SWQpKS50aGVuKGtleSA9PiBrZXkuc2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXg7XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgW3ByZWRpY2F0ZSwgbWVzc2FnZV0gPSBhcmdzO1xuICAgIHJldHVybiBpbnZhcmlhbnQoKGl4LCBfcmVmKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBPayxcbiAgICAgICAgQmFkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBwcmVkaWNhdGUgPyBPayhpeCkgOiBCYWQoaXgsIG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IFtmbl0gPSBhcmdzO1xuICByZXR1cm4gaXggPT4gZm4oaXgsIHtcbiAgICBPayxcbiAgICBCYWRcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gU2VuZHMgYXJiaXRyYXJ5IHNjcmlwdHMsIHRyYW5zYWN0aW9ucywgYW5kIHJlcXVlc3RzIHRvIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gYXJncyAtIEFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHRha2UgaW50ZXJhY3Rpb24gYW5kIHJldHVybiBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHJlc3BvbnNlXG4gKi9cbmNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCBzZW5kRm4gPSBhd2FpdCBjb25maWcuZmlyc3QoW1wic2RrLnRyYW5zcG9ydFwiLCBcInNkay5zZW5kXCJdLCBvcHRzLnNlbmQgfHwgc2VuZCQxKTtcbiAgaW52YXJpYW50KHNlbmRGbiwgYFJlcXVpcmVkIHZhbHVlIGZvciBzZGsudHJhbnNwb3J0IGlzIG5vdCBkZWZpbmVkIGluIGNvbmZpZy4gU2VlOiAke1wiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mY2wtanMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL0NIQU5HRUxPRy5tZCMwMDU3LWFscGhhMS0tLS0yMDIyLTAxLTIxXCJ9YCk7XG4gIGNvbnN0IHJlc29sdmVGbiA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJzZGsucmVzb2x2ZVwiXSwgb3B0cy5yZXNvbHZlIHx8IHJlc29sdmUpO1xuICBvcHRzLm5vZGUgPSBvcHRzLm5vZGUgfHwgKGF3YWl0IGNvbmZpZygpLmdldChcImFjY2Vzc05vZGUuYXBpXCIpKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIGFyZ3MgPSBwaXBlKGludGVyYWN0aW9uKCksIGFyZ3MpO1xuICByZXR1cm4gc2VuZEZuKGF3YWl0IHJlc29sdmVGbihhcmdzKSwge1xuICAgIGNvbmZpZyxcbiAgICByZXNwb25zZSxcbiAgICBpeDogaXhNb2R1bGUsXG4gICAgQnVmZmVyXG4gIH0sIG9wdHMpO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGRlY29kZXJzRnJvbUNvbmZpZyA9IGF3YWl0IGNvbmZpZygpLndoZXJlKC9eZGVjb2RlclxcLi8pO1xuICBjb25zdCBkZWNvZGVycyA9IE9iamVjdC5lbnRyaWVzKGRlY29kZXJzRnJvbUNvbmZpZykubWFwKF9yZWYgPT4ge1xuICAgIGxldCBbcGF0dGVybiwgeGZvcm1dID0gX3JlZjtcbiAgICBwYXR0ZXJuID0gYC8ke3BhdHRlcm4ucmVwbGFjZSgvXmRlY29kZXJcXC4vLCBcIlwiKX0kL2A7XG4gICAgcmV0dXJuIFtwYXR0ZXJuLCB4Zm9ybV07XG4gIH0pO1xuICByZXR1cm4gZGVjb2RlUmVzcG9uc2UocmVzcG9uc2UsIE9iamVjdC5mcm9tRW50cmllcyhkZWNvZGVycykpO1xufVxuXG5jb25zdCBmaW5kUGF5bG9hZFNpZ25lcnMgPSB2b3VjaGVyID0+IHtcbiAgLy8gUGF5bG9hZCBTaWduZXJzIEFyZTogKGF1dGhvcml6ZXJzICsgcHJvcG9zZXIpIC0gcGF5ZXJcbiAgbGV0IHBheWxvYWQgPSBuZXcgU2V0KHZvdWNoZXIuYXV0aG9yaXplcnMpO1xuICBwYXlsb2FkLmFkZCh2b3VjaGVyLnByb3Bvc2FsS2V5LmFkZHJlc3MpO1xuICBwYXlsb2FkLmRlbGV0ZSh2b3VjaGVyLnBheWVyKTtcbiAgcmV0dXJuIEFycmF5LmZyb20ocGF5bG9hZCkubWFwKHdpdGhQcmVmaXgpO1xufTtcbmNvbnN0IGZpbmRFbnZlbG9wZVNpZ25lcnMgPSB2b3VjaGVyID0+IHtcbiAgLy8gRW52ZWxvcGUgU2lnbmVycyBBcmU6IChwYXllcilcbiAgbGV0IGVudmVsb3BlID0gbmV3IFNldChbdm91Y2hlci5wYXllcl0pO1xuICByZXR1cm4gQXJyYXkuZnJvbShlbnZlbG9wZSkubWFwKHdpdGhQcmVmaXgpO1xufTtcbmNsYXNzIFVuYWJsZVRvRGV0ZXJtaW5lTWVzc2FnZUVuY29kaW5nVHlwZUZvclNpZ25lckFkZHJlc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25lckFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2cgPSBgXG4gICAgICAgIEVuY29kZSBNZXNzYWdlIEZyb20gU2lnbmFibGUgRXJyb3I6IFVuYWJsZSB0byBkZXRlcm1pbmUgbWVzc2FnZSBlbmNvZGluZyBmb3Igc2lnbmVyIGFkZHJlc3NzOiAke3NpZ25lckFkZHJlc3N9LiBcbiAgICAgICAgUGxlYXNlIGVuc3VyZSB0aGUgYWRkcmVzczogJHtzaWduZXJBZGRyZXNzfSBpcyBpbnRlbmRlZCB0byBzaWduIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBhcyBzcGVjaWZpZWQgYnkgdGhlIHRyYW5zYWN0aW9uIHNpZ25hYmxlLlxuICAgICAgYC50cmltKCk7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVuYWJsZSBUbyBEZXRlcm1pbmUgTWVzc2FnZSBFbmNvZGluZyBGb3IgU2lnbmVyIEFkZHJlc3NzXCI7XG4gIH1cbn1cbmNvbnN0IGVuY29kZU1lc3NhZ2VGcm9tU2lnbmFibGUgPSAoc2lnbmFibGUsIHNpZ25lckFkZHJlc3MpID0+IHtcbiAgbGV0IHBheWxvYWRTaWduZXJzID0gZmluZFBheWxvYWRTaWduZXJzKHNpZ25hYmxlLnZvdWNoZXIpO1xuICBsZXQgZW52ZWxvcGVTaWduZXJzID0gZmluZEVudmVsb3BlU2lnbmVycyhzaWduYWJsZS52b3VjaGVyKTtcbiAgY29uc3QgaXNQYXlsb2FkU2lnbmVyID0gcGF5bG9hZFNpZ25lcnMuaW5jbHVkZXMod2l0aFByZWZpeChzaWduZXJBZGRyZXNzKSk7XG4gIGNvbnN0IGlzRW52ZWxvcGVTaWduZXIgPSBlbnZlbG9wZVNpZ25lcnMuaW5jbHVkZXMod2l0aFByZWZpeChzaWduZXJBZGRyZXNzKSk7XG4gIGlmICghaXNQYXlsb2FkU2lnbmVyICYmICFpc0VudmVsb3BlU2lnbmVyKSB7XG4gICAgdGhyb3cgbmV3IFVuYWJsZVRvRGV0ZXJtaW5lTWVzc2FnZUVuY29kaW5nVHlwZUZvclNpZ25lckFkZHJlc3Moc2lnbmVyQWRkcmVzcyk7XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICBjYWRlbmNlOiBzaWduYWJsZS52b3VjaGVyLmNhZGVuY2UsXG4gICAgcmVmQmxvY2s6IHNpZ25hYmxlLnZvdWNoZXIucmVmQmxvY2ssXG4gICAgY29tcHV0ZUxpbWl0OiBzaWduYWJsZS52b3VjaGVyLmNvbXB1dGVMaW1pdCxcbiAgICBhcmd1bWVudHM6IHNpZ25hYmxlLnZvdWNoZXIuYXJndW1lbnRzLFxuICAgIHByb3Bvc2FsS2V5OiB7XG4gICAgICAuLi5zaWduYWJsZS52b3VjaGVyLnByb3Bvc2FsS2V5LFxuICAgICAgYWRkcmVzczogc2Fuc1ByZWZpeChzaWduYWJsZS52b3VjaGVyLnByb3Bvc2FsS2V5LmFkZHJlc3MpXG4gICAgfSxcbiAgICBwYXllcjogc2Fuc1ByZWZpeChzaWduYWJsZS52b3VjaGVyLnBheWVyKSxcbiAgICBhdXRob3JpemVyczogc2lnbmFibGUudm91Y2hlci5hdXRob3JpemVycy5tYXAoc2Fuc1ByZWZpeCksXG4gICAgcGF5bG9hZFNpZ3M6IHNpZ25hYmxlLnZvdWNoZXIucGF5bG9hZFNpZ3MubWFwKHBzID0+ICh7XG4gICAgICAuLi5wcyxcbiAgICAgIGFkZHJlc3M6IHNhbnNQcmVmaXgocHMuYWRkcmVzcylcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIGlzUGF5bG9hZFNpZ25lciA/IGVuY29kZVRyYW5zYWN0aW9uUGF5bG9hZChtZXNzYWdlKSA6IGVuY29kZVRyYW5zYWN0aW9uRW52ZWxvcGUobWVzc2FnZSk7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0b3IoY2IpIHtcbiAgcmV0dXJuIHVwZGF0ZShcIml4LnZhbGlkYXRvcnNcIiwgdmFsaWRhdG9ycyA9PiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpID8gdmFsaWRhdG9ycy5wdXNoKGNiKSA6IFtjYl0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXJ0aWFsIGludGVyYWN0aW9uIHRvIGEgYmxvY2sgYXQgYSBzcGVjaWZpYyBoZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBibG9jayB0byBnZXRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBIHBhcnRpYWwgaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGF0QmxvY2tIZWlnaHQoaGVpZ2h0KSB7XG4gIHJldHVybiBwaXBlKFtpeCA9PiB7XG4gICAgaXguYmxvY2suaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBpeDtcbiAgfSwgdmFsaWRhdG9yKGl4ID0+IHtcbiAgICBpZiAodHlwZW9mIGl4LmJsb2NrLmlzU2VhbGVkID09PSBcImJvb2xlYW5cIikgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNwZWNpZnkgYm90aCBibG9jayBoZWlnaHQgYW5kIGlzU2VhbGVkLlwiKTtcbiAgICBpZiAoaXguYmxvY2suaWQpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzcGVjaWZ5IGJvdGggYmxvY2sgaGVpZ2h0IGFuZCBibG9jayBpZC5cIik7XG4gICAgcmV0dXJuIGl4O1xuICB9KV0pO1xufVxuXG5mdW5jdGlvbiBhdEJsb2NrSWQoaWQpIHtcbiAgcmV0dXJuIHBpcGUoW2l4ID0+IHtcbiAgICBpeC5ibG9jay5pZCA9IGlkO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH0sIHZhbGlkYXRvcigoaXgsIF9yZWYpID0+IHtcbiAgICBsZXQge1xuICAgICAgT2ssXG4gICAgICBCYWRcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAoaXNHZXRBY2NvdW50KGl4KSkgcmV0dXJuIEJhZChpeCwgXCJVbmFibGUgdG8gc3BlY2lmeSBhIGJsb2NrIGlkIHdpdGggYSBHZXQgQWNjb3VudCBpbnRlcmFjdGlvbi5cIik7XG4gICAgaWYgKHR5cGVvZiBpeC5ibG9jay5pc1NlYWxlZCA9PT0gXCJib29sZWFuXCIpIHJldHVybiBCYWQoaXgsIFwiVW5hYmxlIHRvIHNwZWNpZnkgYm90aCBibG9jayBpZCBhbmQgaXNTZWFsZWQuXCIpO1xuICAgIGlmIChpeC5ibG9jay5oZWlnaHQpIHJldHVybiBCYWQoaXgsIFwiVW5hYmxlIHRvIHNwZWNpZnkgYm90aCBibG9jayBpZCBhbmQgYmxvY2sgaGVpZ2h0LlwiKTtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9KV0pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJAb25mbG93L3R5cGVkZWZzXCIpLkFjY291bnR9IEFjY291bnRcbiAqL1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAgUmV0dXJucyB0aGUgZGV0YWlscyBvZiBhbiBhY2NvdW50IGZyb20gdGhlaXIgcHVibGljIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgYWNjb3VudFxuICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeU9wdGlvbnNdIC0gUXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtxdWVyeU9wdGlvbnMuaGVpZ2h0XSAtIEJsb2NrIGhlaWdodCB0byBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeU9wdGlvbnMuaWRdIC0gQmxvY2sgSUQgdG8gcXVlcnlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhY2NvdW50IHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFjY291bnQoYWRkcmVzcykge1xuICBsZXQge1xuICAgIGhlaWdodCxcbiAgICBpZFxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgaW52YXJpYW50JDEoIShpZCAmJiBoZWlnaHQpLCBgTWV0aG9kOiBhY2NvdW50IC0tIENhbm5vdCBwYXNzIFwiaWRcIiBhbmQgXCJoZWlnaHRcIiBzaW11bHRhbmVvdXNseWApO1xuXG4gIC8vIEdldCBhY2NvdW50IGJ5IElEXG4gIGlmIChpZCkgcmV0dXJuIHNlbmQoW2dldEFjY291bnQoYWRkcmVzcyksIGF0QmxvY2tJZChpZCldLCBvcHRzKS50aGVuKGRlY29kZVJlc3BvbnNlKTtcblxuICAvLyBHZXQgYWNjb3VudCBieSBoZWlnaHRcbiAgaWYgKGhlaWdodCkgcmV0dXJuIHNlbmQoW2dldEFjY291bnQoYWRkcmVzcyksIGF0QmxvY2tIZWlnaHQoaGVpZ2h0KV0sIG9wdHMpLnRoZW4oZGVjb2RlUmVzcG9uc2UpO1xuICByZXR1cm4gc2VuZChbZ2V0QWNjb3VudChhZGRyZXNzKV0sIG9wdHMpLnRoZW4oZGVjb2RlUmVzcG9uc2UpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJAb25mbG93L3R5cGVkZWZzXCIpLkJsb2NrfSBCbG9ja1xuICovXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGxhdGVzdCBibG9jayAob3B0aW9uYWxseSBzZWFsZWQgb3Igbm90KSwgYnkgaWQsIG9yIGJ5IGhlaWdodFxuICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeU9wdGlvbnNdIC0gUXVlcnkgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtib29sZWFufSBbcXVlcnlPcHRpb25zLnNlYWxlZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHF1ZXJ5IGZvciBhIHNlYWxlZCBibG9ja1xuICogQHBhcmFtIHtudW1iZXJ9IFtxdWVyeU9wdGlvbnMuaGVpZ2h0XSAtIEJsb2NrIGhlaWdodCB0byBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeU9wdGlvbnMuaWRdIC0gQmxvY2sgSUQgdG8gcXVlcnlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9jaz59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBibG9jayByZXNwb25zZVxuICovXG5mdW5jdGlvbiBibG9jaygpIHtcbiAgbGV0IHtcbiAgICBzZWFsZWQgPSBmYWxzZSxcbiAgICBpZCxcbiAgICBoZWlnaHRcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaW52YXJpYW50JDEoIShzZWFsZWQgJiYgaWQgfHwgc2VhbGVkICYmIGhlaWdodCksIGBNZXRob2Q6IGJsb2NrIC0tIENhbm5vdCBwYXNzIFwic2VhbGVkXCIgd2l0aCBcImlkXCIgb3IgXCJoZWlnaHRcImApO1xuICBpbnZhcmlhbnQkMSghKGlkICYmIGhlaWdodCksIGBNZXRob2Q6IGJsb2NrIC0tIENhbm5vdCBwYXNzIFwiaWRcIiBhbmQgXCJoZWlnaHRcIiBzaW11bHRhbmVvdXNseWApO1xuXG4gIC8vIEdldCBibG9jayBieSBJRFxuICBpZiAoaWQpIHJldHVybiBzZW5kKFtnZXRCbG9jaygpLCBhdEJsb2NrSWQoaWQpXSwgb3B0cykudGhlbihkZWNvZGVSZXNwb25zZSk7XG5cbiAgLy8gR2V0IGJsb2NrIGJ5IGhlaWdodFxuICBpZiAoaGVpZ2h0KSByZXR1cm4gc2VuZChbZ2V0QmxvY2soKSwgYXRCbG9ja0hlaWdodChoZWlnaHQpXSwgb3B0cykudGhlbihkZWNvZGVSZXNwb25zZSk7XG5cbiAgLy8gR2V0IGxhdGVzdCBibG9ja1xuICByZXR1cm4gc2VuZChbZ2V0QmxvY2soc2VhbGVkKV0sIG9wdHMpLnRoZW4oZGVjb2RlUmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBhdXRob3JpemF0aW9ucygpIHtcbiAgbGV0IGF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuIHBpcGUoYXgubWFwKGF1dGh6ID0+IHtcbiAgICByZXR1cm4gcHJlcEFjY291bnQoYXV0aHosIHtcbiAgICAgIHJvbGU6IEFVVEhPUklaRVJcbiAgICB9KTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXV0aG9yaXphdGlvbihhZGRyLCBzaWduaW5nRnVuY3Rpb24sIGtleUlkLCBzZXF1ZW5jZU51bSkge1xuICByZXR1cm4ge1xuICAgIGFkZHIsXG4gICAgc2lnbmluZ0Z1bmN0aW9uLFxuICAgIGtleUlkLFxuICAgIHNlcXVlbmNlTnVtXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50cyhldmVudFR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbG9nZ2VyLmxvZy5kZXByZWNhdGUoe1xuICAgICAgcGtnOiBcIkZDTC9TREtcIixcbiAgICAgIHN1YmplY3Q6IFwiUGFzc2luZyBhIHN0YXJ0IGFuZCBlbmQgaW50byBnZXRFdmVudHNcIixcbiAgICAgIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9zZGsvVFJBTlNJVElPTlMubWQjMDAwNS1kZXByZWNhdGUtc3RhcnQtZW5kLWdldC1ldmVudHMtYnVpbGRlclwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRFdmVudHMsIGl4ID0+IHtcbiAgICBpeC5ldmVudHMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgIGl4LmV2ZW50cy5zdGFydCA9IHN0YXJ0O1xuICAgIGl4LmV2ZW50cy5lbmQgPSBlbmQ7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWxsIGluc3RhbmNlcyBvZiBhIHBhcnRpY3VsYXIgZXZlbnQgKGJ5IG5hbWUpIHdpdGhpbiBhIGhlaWdodCByYW5nZVxuICogTk9URTpcbiAqIC0gVGhlIGJsb2NrIHJhbmdlIHByb3ZpZGVkIG11c3QgYmUgZnJvbSB0aGUgY3VycmVudCBzcG9yay5cbiAqIC0gVGhlIGJsb2NrIHJhbmdlIHByb3ZpZGVkIG11c3QgYmUgMjUwIGJsb2NrcyBvciBsb3dlciBwZXIgcmVxdWVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgYmxvY2sgdG8gc3RhcnQgbG9va2luZyBmb3IgZXZlbnRzIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGJsb2NrIHRvIHN0b3AgbG9va2luZyBmb3IgZXZlbnRzIChpbmNsdXNpdmUpXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50c0F0QmxvY2tIZWlnaHRSYW5nZShldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCkge1xuICByZXR1cm4gcGlwZShbbWFrZUdldEV2ZW50cywgaXggPT4ge1xuICAgIGl4LmV2ZW50cy5ldmVudFR5cGUgPSBldmVudE5hbWU7XG4gICAgaXguZXZlbnRzLnN0YXJ0ID0gZnJvbUJsb2NrSGVpZ2h0O1xuICAgIGl4LmV2ZW50cy5lbmQgPSB0b0Jsb2NrSGVpZ2h0O1xuICAgIHJldHVybiBPayhpeCk7XG4gIH1dKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIGJ1aWxkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFsbCBpbnN0YW5jZXMgb2YgYSBwYXJ0aWN1bGFyIGV2ZW50IChieSBuYW1lKSB3aXRoaW4gYSBzZXQgb2YgYmxvY2tzLCBzcGVjaWZpZWQgYnkgYmxvY2sgaWRzXG4gKiBOT1RFOlxuICogLSBUaGUgYmxvY2sgcmFuZ2UgcHJvdmlkZWQgbXVzdCBiZSBmcm9tIHRoZSBjdXJyZW50IHNwb3JrLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJsb2NrSWRzIC0gVGhlIGlkcyBvZiB0aGUgYmxvY2tzIHRvIGxvb2sgZm9yIGV2ZW50c1xuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRFdmVudHNBdEJsb2NrSWRzKGV2ZW50TmFtZSkge1xuICBsZXQgYmxvY2tJZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICByZXR1cm4gcGlwZShbbWFrZUdldEV2ZW50cywgaXggPT4ge1xuICAgIGl4LmV2ZW50cy5ldmVudFR5cGUgPSBldmVudE5hbWU7XG4gICAgaXguZXZlbnRzLmJsb2NrSWRzID0gYmxvY2tJZHM7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGludGVyYWN0aW9uIHRvIGdldCBhIGJsb2NrIGhlYWRlclxuICogQHBhcmFtIHtib29sZWFufSBbaXNTZWFsZWRdIC0gV2hldGhlciBvciBub3QgdGhlIGJsb2NrIHNob3VsZCBiZSBzZWFsZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBbiBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0QmxvY2tIZWFkZXIoKSB7XG4gIGxldCBpc1NlYWxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRCbG9ja0hlYWRlciwgaXggPT4ge1xuICAgIGl4LmJsb2NrLmlzU2VhbGVkID0gaXNTZWFsZWQ7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWxsIGEgY29sbGVjdGlvbiBjb250YWluaW5nIGEgbGlzdCBvZiB0cmFuc2FjdGlvbiBpZHMgYnkgaXRzIGNvbGxlY3Rpb24gaWRcbiAqIE5PVEU6XG4gKiAtIFRoZSBibG9jayByYW5nZSBwcm92aWRlZCBtdXN0IGJlIGZyb20gdGhlIGN1cnJlbnQgc3BvcmsuIEFsbCBldmVudHMgZW1pdHRlZCBkdXJpbmcgcGFzdCBzcG9ya3MgaXMgY3VycmVudCB1bmF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIC0gVGhlIGlkIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGdldFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uKCkge1xuICBsZXQgaWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gIHJldHVybiBwaXBlKFttYWtlR2V0Q29sbGVjdGlvbiwgaXggPT4ge1xuICAgIGl4LmNvbGxlY3Rpb24uaWQgPSBpZDtcbiAgICByZXR1cm4gaXg7XG4gIH1dKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIGJ1aWxkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzdGF0dXMgb2YgdHJhbnNhY3Rpb25cbiAqIE5PVEU6IFRoZSB0cmFuc2FjdGlvbklEIHByb3ZpZGVkIG11c3QgYmUgZnJvbSB0aGUgY3VycmVudCBzcG9yay5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvbklkIC0gVGhlIGlkIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBnZXQgc3RhdHVzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSWQpIHtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRUcmFuc2FjdGlvblN0YXR1cywgaXggPT4ge1xuICAgIGl4LnRyYW5zYWN0aW9uLmlkID0gdHJhbnNhY3Rpb25JZDtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uXG4gKiBOT1RFOiBUaGUgdHJhbnNhY3Rpb25JRCBwcm92aWRlZCBtdXN0IGJlIGZyb20gdGhlIGN1cnJlbnQgc3BvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNhY3Rpb25JZCAtIFRoZSBpZCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQpIHtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRUcmFuc2FjdGlvbiwgaXggPT4ge1xuICAgIGl4LnRyYW5zYWN0aW9uLmlkID0gdHJhbnNhY3Rpb25JZDtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbmZ1bmN0aW9uIGdldE5ldHdvcmtQYXJhbWV0ZXJzKCkge1xuICByZXR1cm4gcGlwZShbbWFrZUdldE5ldHdvcmtQYXJhbWV0ZXJzLCBpeCA9PiB7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG5mdW5jdGlvbiBsaW1pdChjb21wdXRlTGltaXQpIHtcbiAgcmV0dXJuIGl4ID0+IHtcbiAgICBpeC5tZXNzYWdlLmNvbXB1dGVMaW1pdCA9IGNvbXB1dGVMaW1pdDtcbiAgICByZXR1cm4gaXg7XG4gIH07XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSB1dGlsaXR5IGJ1aWxkZXIgdG8gYmUgdXNlZCB3aXRoIG90aGVyIGJ1aWxkZXJzIHRvIHBhc3MgaW4gYXJndW1lbnRzIHdpdGggYSB2YWx1ZSBhbmQgc3VwcG9ydGVkIHR5cGVcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBheCAtIEFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcmdzKCkge1xuICBsZXQgYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gcGlwZShheC5tYXAobWFrZUFyZ3VtZW50KSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSB1dGlsaXR5IGJ1aWxkZXIgdG8gYmUgdXNlZCB3aXRoIGZjbC5hcmdzWy4uLl0gdG8gY3JlYXRlIEZDTCBzdXBwb3J0ZWQgYXJndW1lbnRzIGZvciBpbnRlcmFjdGlvbnNcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmb3JtIC0gQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHZhbHVlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIEFuIGFyZ3VtZW50IG9iamVjdFxuICovXG5mdW5jdGlvbiBhcmcodmFsdWUsIHhmb3JtKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgeGZvcm1cbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvcG9zZXIoYXV0aHopIHtcbiAgcmV0dXJuIHByZXBBY2NvdW50KGF1dGh6LCB7XG4gICAgcm9sZTogUFJPUE9TRVJcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBheWVyKGF1dGh6KSB7XG4gIHJldHVybiBwcmVwQWNjb3VudChhdXRoeiwge1xuICAgIHJvbGU6IFBBWUVSXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwaW5nKCkge1xuICByZXR1cm4gbWFrZVBpbmc7XG59XG5cbmZ1bmN0aW9uIHJlZihyZWZCbG9jaykge1xuICByZXR1cm4gcGlwZShbaXggPT4ge1xuICAgIGl4Lm1lc3NhZ2UucmVmQmxvY2sgPSByZWZCbG9jaztcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbmZ1bmN0aW9uIHNjcmlwdCgpIHtcbiAgcmV0dXJuIHBpcGUoW21ha2VTY3JpcHQsIHB1dChcIml4LmNhZGVuY2VcIiwgdGVtcGxhdGUoLi4uYXJndW1lbnRzKSldKTtcbn1cblxuY29uc3QgREVGQVVMVF9TQ1JJUFRfQUNDT1VOVFMgPSBbXTtcbmNvbnN0IERFRlVBTFRfUkVGID0gbnVsbDtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIHRlbXBsYXRlIGJ1aWxkZXIgdG8gdXNlIGEgQ2FkZW5jZSB0cmFuc2FjdGlvbiBmb3IgYW4gaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzc1xuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiB0cmFuc2FjdGlvbigpIHtcbiAgcmV0dXJuIHBpcGUoW21ha2VUcmFuc2FjdGlvbiwgcHV0KFwiaXguY2FkZW5jZVwiLCB0ZW1wbGF0ZSguLi5hcmd1bWVudHMpKSwgaXggPT4ge1xuICAgIGl4Lm1lc3NhZ2UucmVmQmxvY2sgPSBpeC5tZXNzYWdlLnJlZkJsb2NrIHx8IERFRlVBTFRfUkVGO1xuICAgIGl4LmF1dGhvcml6YXRpb25zID0gaXguYXV0aG9yaXphdGlvbnMgfHwgREVGQVVMVF9TQ1JJUFRfQUNDT1VOVFM7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG5mdW5jdGlvbiB2b3VjaGVySW50ZXJjZXB0KGZuKSB7XG4gIHJldHVybiBwdXQoXCJpeC52b3VjaGVyLWludGVyY2VwdFwiLCBmbik7XG59XG5cbmNvbnN0IHJlc29sdmVQcm9wb3NlclNlcXVlbmNlTnVtYmVyID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgbm9kZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIGFzeW5jIGl4ID0+IHtcbiAgICBpZiAoIWlzVHJhbnNhY3Rpb24oaXgpKSByZXR1cm4gT2soaXgpO1xuICAgIGlmIChpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uc2VxdWVuY2VOdW0pIHJldHVybiBPayhpeCk7XG4gICAgY29uc3Qgc2VuZEZuID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcInNkay50cmFuc3BvcnRcIiwgXCJzZGsuc2VuZFwiXSwgc2VuZCQxKTtcbiAgICBpbnZhcmlhbnQkMShzZW5kRm4sIGBSZXF1aXJlZCB2YWx1ZSBmb3Igc2RrLnRyYW5zcG9ydCBpcyBub3QgZGVmaW5lZCBpbiBjb25maWcuIFNlZTogJHtcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmNsLWpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9DSEFOR0VMT0cubWQjMDA1Ny1hbHBoYTEtLS0tMjAyMi0wMS0yMVwifWApO1xuICAgIGNvbnN0IHJlc3BvbnNlJDEgPSBhd2FpdCBzZW5kRm4oYXdhaXQgYnVpbGQoW2dldEFjY291bnQoaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmFkZHIpXSksIHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgIEJ1ZmZlcixcbiAgICAgIGl4OiBpeE1vZHVsZVxuICAgIH0sIHtcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlUmVzcG9uc2UocmVzcG9uc2UkMSk7XG4gICAgaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLnNlcXVlbmNlTnVtID0gZGVjb2RlZC5rZXlzW2l4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5rZXlJZF0uc2VxdWVuY2VOdW1iZXI7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlZklkKG9wdHMpIHtcbiAgY29uc3Qgbm9kZSA9IGF3YWl0IGNvbmZpZygpLmdldChcImFjY2Vzc05vZGUuYXBpXCIpO1xuICBjb25zdCBzZW5kRm4gPSBhd2FpdCBjb25maWcuZmlyc3QoW1wic2RrLnRyYW5zcG9ydFwiLCBcInNkay5zZW5kXCJdLCBzZW5kJDEpO1xuICBpbnZhcmlhbnQkMShzZW5kRm4sIGBSZXF1aXJlZCB2YWx1ZSBmb3Igc2RrLnRyYW5zcG9ydCBpcyBub3QgZGVmaW5lZCBpbiBjb25maWcuIFNlZTogJHtcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmNsLWpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9DSEFOR0VMT0cubWQjMDA1Ny1hbHBoYTEtLS0tMjAyMi0wMS0yMVwifWApO1xuICB2YXIgaXg7XG4gIGl4ID0gYXdhaXQgcGlwZShpbnRlcmFjdGlvbigpLCBbZ2V0QmxvY2soKV0pO1xuICBpeCA9IGF3YWl0IHNlbmRGbihpeCwge1xuICAgIGNvbmZpZyxcbiAgICByZXNwb25zZSxcbiAgICBCdWZmZXIsXG4gICAgaXg6IGl4TW9kdWxlXG4gIH0sIHtcbiAgICBub2RlXG4gIH0pO1xuICBpeCA9IGF3YWl0IGRlY29kZVJlc3BvbnNlKGl4KTtcbiAgcmV0dXJuIGl4LmlkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlZkJsb2NrSWQob3B0cykge1xuICByZXR1cm4gYXN5bmMgaXggPT4ge1xuICAgIGlmICghaXNUcmFuc2FjdGlvbihpeCkpIHJldHVybiBPayhpeCk7XG4gICAgaWYgKGl4Lm1lc3NhZ2UucmVmQmxvY2spIHJldHVybiBPayhpeCk7XG4gICAgaXgubWVzc2FnZS5yZWZCbG9jayA9IGF3YWl0IGdldFJlZklkKCk7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9ja0FjY291bnRSZXNwb25zZShpeCkge1xuICBsZXQgbnVtYmVyT2ZLZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50JDEoaXguYWNjb3VudCwgXCJtb2NrQWNjb3VudFJlc3BvbnNlKGl4KSAtLSBpeC5hY2NvdW50IGlzIG1pc3NpbmdcIiwgaXgpO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50JDEoaXguYWNjb3VudC5hZGRyLCBcIm1vY2tBY2NvdW50UmVzcG9uc2UoaXgpIC0tIGl4LmFjY291bnQuYWRkciBpcyBtaXNzaW5nXCIsIGl4KTtcbiAgY29uc3QgYWRkcmVzcyA9IGl4LmFjY291bnQuYWRkcjtcbiAgcmV0dXJuIHtcbiAgICBhY2NvdW50OiB7XG4gICAgICBhZGRyOiBhZGRyZXNzLFxuICAgICAga2V5czogQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogbnVtYmVyT2ZLZXlzXG4gICAgICB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyOiA0MlxuICAgICAgfSkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbW9ja0dldEJsb2NrUmVzcG9uc2UoaXgpIHtcbiAgcmV0dXJuIHtcbiAgICB0YWc6IFwiR0VUX0JMT0NLXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIGlkOiBcIjMyXCJcbiAgICB9XG4gIH07XG59XG5jb25zdCBpZGVudGl0eSA9IHYgPT4gdjtcbmZ1bmN0aW9uIG1vY2tTZW5kKCkge1xuICBsZXQgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGlkZW50aXR5O1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gZXhlY1NlbmQoaXgpIHtcbiAgICBpeCA9IGF3YWl0IGl4O1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0dldEFjY291bnQoaXgpOlxuICAgICAgICByZXR1cm4gbW9ja0FjY291bnRSZXNwb25zZShpeCk7XG4gICAgICBjYXNlIGlzR2V0QmxvY2soaXgpOlxuICAgICAgICByZXR1cm4gbW9ja0dldEJsb2NrUmVzcG9uc2UoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxsYmFjayhpeCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBpZG9mID0gYWNjdCA9PiBgJHt3aXRoUHJlZml4KGFjY3QuYWRkcil9LSR7YWNjdC5rZXlJZH1gO1xuZnVuY3Rpb24gc2lnKG9wdHMpIHtcbiAgcmV0dXJuIFtcIlNJR05BVFVSRVwiLCBvcHRzLmFkZHIsIG9wdHMua2V5SWRdLmpvaW4oXCIuXCIpO1xufVxuZnVuY3Rpb24gYXV0aHpGbigpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICBjb25zdCBhY2N0ID0ge1xuICAgICAgLi4uYWNjb3VudCxcbiAgICAgIC4uLm9wdHMsXG4gICAgICBzaWduaW5nRnVuY3Rpb246IG9wdHMuc2lnbmluZ0Z1bmN0aW9uIHx8IGFjY291bnQuc2lnbmluZ0Z1bmN0aW9uIHx8IGZhbGxiYWNrU2lnbmluZ0Z1bmN0aW9uXG4gICAgfTtcbiAgICByZXR1cm4gYWNjdDtcbiAgICBmdW5jdGlvbiBmYWxsYmFja1NpZ25pbmdGdW5jdGlvbihzaWduYWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcjogYWNjdC5hZGRyLFxuICAgICAgICBrZXlJZDogYWNjdC5rZXlJZCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWcoYWNjdClcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYXV0aHpSZXNvbHZlKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRlbXBJZCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gb3B0cztcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjb3VudCxcbiAgICAgIHRlbXBJZDogdGVtcElkIHx8IFwiV0lUSF9SRVNPTFZFXCIsXG4gICAgICByZXNvbHZlOiBhdXRoekZuKHJlc3QpXG4gICAgfTtcbiAgfTtcbn1cbmNvbnN0IFJPTEUgPSB7XG4gIHByb3Bvc2VyOiBmYWxzZSxcbiAgYXV0aG9yaXplcjogZmFsc2UsXG4gIHBheWVyOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGF1dGh6UmVzb2x2ZU1hbnkoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgY29uc3QgdGVtcElkID0gb3B0cy50ZW1wSWQgfHwgXCJBVVRIWl9SRVNPTFZFX01BTllcIjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjb3VudCxcbiAgICAgIHRlbXBJZCxcbiAgICAgIHJlc29sdmU6ICgpID0+IFtvcHRzLnByb3Bvc2VyICYmIGF1dGh6Rm4ob3B0cy5wcm9wb3Nlcikoe1xuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgLi4uUk9MRSxcbiAgICAgICAgICBwcm9wb3NlcjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KSwgLi4ub3B0cy5hdXRob3JpemF0aW9ucy5tYXAoYXV0aHpGbikubWFwKGQgPT4gZCh7XG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAuLi5ST0xFLFxuICAgICAgICAgIGF1dGhvcml6ZXI6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSkpLCBvcHRzLnBheWVyICYmIGF1dGh6Rm4ob3B0cy5wYXllcikoe1xuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgLi4uUk9MRSxcbiAgICAgICAgICBwYXllcjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KV0uZmlsdGVyKEJvb2xlYW4pXG4gICAgfTtcbiAgfTtcbn1cblxuY29uc3QgcnVuID0gZnVuY3Rpb24gKCkge1xuICBsZXQgZm5zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuIGJ1aWxkKFtyZWYoXCIxMjNcIiksIC4uLmZuc10pLnRoZW4ocmVzb2x2ZSk7XG59O1xuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbW9ja1NlbmQ6IG1vY2tTZW5kLFxuICBhdXRoekZuOiBhdXRoekZuLFxuICBhdXRoelJlc29sdmU6IGF1dGh6UmVzb2x2ZSxcbiAgYXV0aHpSZXNvbHZlTWFueTogYXV0aHpSZXNvbHZlTWFueSxcbiAgc2lnOiBzaWcsXG4gIGlkb2Y6IGlkb2YsXG4gIHJ1bjogcnVuXG59KTtcblxuY29uc3QgVkVSU0lPTiA9IFwiMS4yLjJcIiA7XG5cbi8vIERlcHJlY2F0ZWRcbmNvbnN0IHBhcmFtcyA9IHBhcmFtcyA9PiBsb2dnZXIubG9nLmRlcHJlY2F0ZSh7XG4gIHBrZzogXCJGQ0wvU0RLXCIsXG4gIG1lc3NhZ2U6IGBUaGUgcGFyYW1zIGJ1aWxkZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBGbG93IEpTLVNESy9GQ0wuYCxcbiAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9UUkFOU0lUSU9OUy5tZCMwMDAxLWRlcHJlY2F0ZS1wYXJhbXNcIixcbiAgbGV2ZWw6IGxvZ2dlci5MRVZFTFMuZXJyb3Jcbn0pO1xuY29uc3QgcGFyYW0gPSBwYXJhbXMgPT4gbG9nZ2VyLmxvZy5kZXByZWNhdGUoe1xuICBwa2c6IFwiRkNML1NES1wiLFxuICBtZXNzYWdlOiBgVGhlIHBhcmFtIGJ1aWxkZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBGbG93IEpTLVNESy9GQ0wuYCxcbiAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9UUkFOU0lUSU9OUy5tZCMwMDAxLWRlcHJlY2F0ZS1wYXJhbXNcIixcbiAgbGV2ZWw6IGxvZ2dlci5MRVZFTFMuZXJyb3Jcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBUZXN0VXRpbHMsIFZFUlNJT04sIGFjY291bnQsIGFyZywgYXJncywgYXRCbG9ja0hlaWdodCwgYXRCbG9ja0lkLCBhdXRob3JpemF0aW9uLCBhdXRob3JpemF0aW9ucywgYmxvY2ssIGJ1aWxkLCBjcmVhdGVTaWduYWJsZVZvdWNoZXIsIGRlY29kZSwgZGVzdHJveSwgZW5jb2RlTWVzc2FnZUZyb21TaWduYWJsZSwgZW5jb2RlVHJhbnNhY3Rpb25FbnZlbG9wZSwgZW5jb2RlVHJhbnNhY3Rpb25QYXlsb2FkLCBlbmNvZGVUeElkRnJvbVZvdWNoZXIsIGdldCwgZ2V0QWNjb3VudCwgZ2V0QmxvY2ssIGdldEJsb2NrSGVhZGVyLCBnZXRDb2xsZWN0aW9uLCBnZXRFdmVudHMsIGdldEV2ZW50c0F0QmxvY2tIZWlnaHRSYW5nZSwgZ2V0RXZlbnRzQXRCbG9ja0lkcywgZ2V0TmV0d29ya1BhcmFtZXRlcnMsIGdldFRyYW5zYWN0aW9uLCBnZXRUcmFuc2FjdGlvblN0YXR1cywgaW50ZXJhY3Rpb24sIGludmFyaWFudCwgaXNCYWQsIGlzR2V0QWNjb3VudCwgaXNHZXRCbG9jaywgaXNHZXRCbG9ja0hlYWRlciwgaXNHZXRDb2xsZWN0aW9uLCBpc0dldEV2ZW50cywgaXNHZXROZXR3b3JrUGFyYW1ldGVycywgaXNHZXRUcmFuc2FjdGlvbiwgaXNHZXRUcmFuc2FjdGlvblN0YXR1cywgaXNPaywgaXNQaW5nLCBpc1NjcmlwdCwgaXNUcmFuc2FjdGlvbiwgaXNVbmtub3duLCBsaW1pdCwgcGFyYW0sIHBhcmFtcywgcGF5ZXIsIHBpbmcsIHBpcGUsIHByb3Bvc2VyLCBwdXQsIHJlZiwgcmVzb2x2ZSwgcmVzb2x2ZUFjY291bnRzLCByZXNvbHZlQXJndW1lbnRzLCByZXNvbHZlQ2FkZW5jZSwgcmVzb2x2ZUZpbmFsTm9ybWFsaXphdGlvbiwgcmVzb2x2ZVByb3Bvc2VyU2VxdWVuY2VOdW1iZXIsIHJlc29sdmVSZWZCbG9ja0lkLCByZXNvbHZlU2lnbmF0dXJlcywgcmVzb2x2ZVZhbGlkYXRvcnMsIHJlc29sdmVWb3VjaGVySW50ZXJjZXB0LCByZXNwb25zZSwgc2NyaXB0LCBzZW5kLCB0cmFuc2FjdGlvbiwgdXBkYXRlLCB2YWxpZGF0b3IsIHZvdWNoZXJJbnRlcmNlcHQsIHZvdWNoZXJUb1R4SWQsIHdoeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2RrLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@onflow/sdk/dist/sdk.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/transport-http/dist/sdk-send-http.module.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@onflow/transport-http/dist/sdk-send-http.module.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   sendExecuteScript: function() { return /* binding */ sendExecuteScript; },\n/* harmony export */   sendGetAccount: function() { return /* binding */ sendGetAccount; },\n/* harmony export */   sendGetBlock: function() { return /* binding */ sendGetBlock; },\n/* harmony export */   sendGetBlockHeader: function() { return /* binding */ sendGetBlockHeader; },\n/* harmony export */   sendGetCollection: function() { return /* binding */ sendGetCollection; },\n/* harmony export */   sendGetEvents: function() { return /* binding */ sendGetEvents; },\n/* harmony export */   sendGetNetworkParameters: function() { return /* binding */ sendGetNetworkParameters; },\n/* harmony export */   sendGetTransaction: function() { return /* binding */ sendGetTransaction; },\n/* harmony export */   sendGetTransactionStatus: function() { return /* binding */ sendGetTransactionStatus; },\n/* harmony export */   sendPing: function() { return /* binding */ sendPing; },\n/* harmony export */   sendTransaction: function() { return /* binding */ sendTransaction; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-invariant */ \"./node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/rlp */ \"./node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-logger */ \"./node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/util-address */ \"./node_modules/@onflow/util-address/dist/util-address.module.js\");\n\n\n\n\n\n\nconst AbortController = globalThis.AbortController || __webpack_require__(/*! abort-controller */ \"./node_modules/abort-controller/browser.js\");\nclass HTTPRequestError extends Error {\n  constructor(_ref) {\n    let {\n      error,\n      hostname,\n      path,\n      method,\n      requestBody,\n      responseBody,\n      responseStatusText,\n      statusCode\n    } = _ref;\n    const msg = `\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      ${error ? `error=${error}` : \"\"}\n      ${hostname ? `hostname=${hostname}` : \"\"}\n      ${path ? `path=${path}` : \"\"}\n      ${method ? `method=${method}` : \"\"}\n      ${requestBody ? `requestBody=${requestBody}` : \"\"}\n      ${responseBody ? `responseBody=${responseBody}` : \"\"}\n      ${responseStatusText ? `responseStatusText=${responseStatusText}` : \"\"}\n      ${statusCode ? `statusCode=${statusCode}` : \"\"}\n    `;\n    super(msg);\n    this.name = \"HTTP Request Error\";\n    this.statusCode = statusCode;\n    this.errorMessage = error;\n  }\n}\n\n/**\n * Creates an HTTP Request to be sent to a REST Access API via Fetch API.\n *\n * @param {object} options - Options for the HTTP Request\n * @param {String} options.hostname - Access API Hostname\n * @param {String} options.path - Path to the resource on the Access API\n * @param {String} options.method - HTTP Method\n * @param {object} options.body - HTTP Request Body\n * @param {object} [options.headers] - HTTP Request Headers\n * @param {boolean} [options.enableRequestLogging=true] - Enable/Disable request logging\n * @param {number} [options.retryLimit=5] - Number of times to retry request\n * @param {number} [options.retryIntervalMs=1000] - Time in milliseconds to wait before retrying request\n * @param {number} [options.timeoutLimit=30000] - Time in milliseconds to wait before timing out request\n *\n * @returns JSON object response from Access API.\n */\nasync function httpRequest(_ref2) {\n  let {\n    hostname,\n    path,\n    method,\n    body,\n    headers,\n    retryLimit = 5,\n    retryIntervalMs = 1000,\n    timeoutLimit = 30000,\n    enableRequestLogging = true\n  } = _ref2;\n  const bodyJSON = body ? JSON.stringify(body) : null;\n  function makeRequest() {\n    const controller = new AbortController();\n    const fetchTimeout = setTimeout(() => {\n      controller.abort();\n    }, timeoutLimit);\n    return cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(`${hostname}${path}`, {\n      method: method,\n      body: bodyJSON,\n      headers,\n      signal: controller.signal\n    }).then(async res => {\n      if (res.ok) {\n        return res.json();\n      }\n      const responseText = await res.text().catch(() => null);\n      const response = safeParseJSON(responseText);\n      throw new HTTPRequestError({\n        error: response?.message,\n        hostname,\n        path,\n        method,\n        requestBody: bodyJSON,\n        responseBody: responseText,\n        responseStatusText: res.statusText,\n        statusCode: res.status\n      });\n    }).catch(async e => {\n      if (e instanceof HTTPRequestError) {\n        throw e;\n      }\n      if (e.name === \"AbortError\") {\n        throw e;\n      }\n\n      // Show AN error for all network errors\n      if (enableRequestLogging) {\n        await _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__.log({\n          title: \"Access Node Error\",\n          message: `The provided access node ${hostname} does not appear to be a valid REST/HTTP access node.\n  Please verify that you are not unintentionally using a GRPC access node.\n  See more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__.LEVELS.error\n        });\n      }\n      throw new HTTPRequestError({\n        error: e?.message,\n        hostname,\n        path,\n        method,\n        requestBody: bodyJSON\n      });\n    }).finally(() => {\n      clearTimeout(fetchTimeout);\n    });\n  }\n  async function requestLoop() {\n    let retryAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    try {\n      const resp = await makeRequest();\n      return resp;\n    } catch (error) {\n      const retryStatusCodes = [408, 429, 500, 502, 503, 504];\n      if (error.name === \"AbortError\" || retryStatusCodes.includes(error.statusCode)) {\n        return await new Promise((resolve, reject) => {\n          if (retryAttempt < retryLimit) {\n            if (enableRequestLogging) {\n              console.warn(`Access node unavailable, retrying in ${retryIntervalMs} ms...`);\n            }\n            setTimeout(() => {\n              resolve(requestLoop(retryAttempt + 1));\n            }, retryIntervalMs);\n          } else {\n            reject(error);\n          }\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  // Keep retrying request until server available or max attempts exceeded\n  return await requestLoop();\n}\nfunction safeParseJSON(data) {\n  try {\n    return JSON.parse(data);\n  } catch {\n    return null;\n  }\n}\n\nasync function sendExecuteScriptAtBlockIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_id=${ix.block.id}`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nasync function sendExecuteScriptAtBlockHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_height=${ix.block.height}`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nasync function sendExecuteScriptAtLatestBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_height=sealed`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nfunction constructResponse$4(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.encodedData = JSON.parse(context.Buffer.from(res, \"base64\").toString());\n  return ret;\n}\nasync function sendExecuteScript(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Execute Script Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Execute Script Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Execute Script Error: context.Buffer must be defined.`);\n  ix = await ix;\n  if (ix.block.id) {\n    return await sendExecuteScriptAtBlockIDRequest(ix, context, opts);\n  } else if (ix.block.height) {\n    return await sendExecuteScriptAtBlockHeightRequest(ix, context, opts);\n  } else {\n    return await sendExecuteScriptAtLatestBlockRequest(ix, context, opts);\n  }\n}\n\nconst HashAlgorithmIDs = {\n  SHA2_256: 1,\n  SHA2_384: 2,\n  SHA3_256: 3,\n  SHA3_384: 4,\n  KMAC128_BLS_BLS12_381: 5\n};\nconst SignatureAlgorithmIDs = {\n  ECDSA_P256: 1,\n  ECDSA_secp256k1: 2,\n  BLS_BLS12_381: 3\n};\nasync function sendGetAccountAtBlockHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/accounts/${ix.account.addr}?block_height=${ix.block.height}&expand=contracts,keys`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$3(ix, context, res);\n}\nasync function sendGetAccountAtLatestBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/accounts/${ix.account.addr}?block_height=sealed&expand=contracts,keys`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$3(ix, context, res);\n}\nfunction constructResponse$3(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  const unwrapContracts = contracts => {\n    const c = {};\n    if (!contracts) return c;\n    for (let key of Object.keys(contracts)) {\n      c[key] = context.Buffer.from(contracts[key], \"base64\").toString();\n    }\n    return c;\n  };\n  ret.account = {\n    address: res.address,\n    balance: Number(res.balance),\n    code: \"\",\n    contracts: unwrapContracts(res.contracts),\n    keys: res.keys?.map(key => ({\n      index: Number(key.index),\n      publicKey: key.public_key.replace(/^0x/, \"\"),\n      signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],\n      signAlgoString: key.signing_algorithm,\n      hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],\n      hashAlgoString: key.hashing_algorithm,\n      sequenceNumber: Number(key.sequence_number),\n      weight: Number(key.weight),\n      revoked: key.revoked\n    })) ?? []\n  };\n  return ret;\n}\nasync function sendGetAccount(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Account Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Account Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Account Error: context.Buffer must be defined.`);\n  ix = await ix;\n  if (ix.block.height !== null) {\n    return await sendGetAccountAtBlockHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetAccountAtLatestBlockRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetBlockHeaderByIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks/${ix.block.id}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nasync function sendGetBlockHeaderByHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${ix.block.height}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nasync function sendGetLatestBlockHeaderRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const height = ix.block?.isSealed ? \"sealed\" : \"final\";\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${height}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nfunction constructResponse$2(ix, context, res) {\n  const block = res.length ? res[0] : null;\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.blockHeader = {\n    id: block.header.id,\n    parentId: block.header.parent_id,\n    height: Number(block.header.height),\n    timestamp: block.header.timestamp\n  };\n  return ret;\n}\nasync function sendGetBlockHeader(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Block Header Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Block Header Error: context.response must be defined.`);\n  ix = await ix;\n  const interactionHasBlockID = ix.block.id !== null;\n  const interactionHasBlockHeight = ix.block.height !== null;\n  if (interactionHasBlockID) {\n    return await sendGetBlockHeaderByIDRequest(ix, context, opts);\n  } else if (interactionHasBlockHeight) {\n    return await sendGetBlockHeaderByHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetLatestBlockHeaderRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetBlockByIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks/${ix.block.id}?expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nasync function sendGetBlockByHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${ix.block.height}&expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nasync function sendGetBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const height = ix.block?.isSealed ? \"sealed\" : \"final\";\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${height}&expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nfunction constructResponse$1(ix, context, res) {\n  const block = res.length ? res[0] : null;\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.block = {\n    id: block.header.id,\n    parentId: block.header.parent_id,\n    height: Number(block.header.height),\n    timestamp: block.header.timestamp,\n    collectionGuarantees: block.payload.collection_guarantees.map(collectionGuarantee => ({\n      collectionId: collectionGuarantee.collection_id,\n      signerIds: collectionGuarantee.signer_ids\n    })),\n    blockSeals: block.payload.block_seals.map(blockSeal => ({\n      blockId: blockSeal.block_id,\n      executionReceiptId: blockSeal.result_id\n    }))\n  };\n  return ret;\n}\nasync function sendGetBlock(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Block Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Block Error: context.response must be defined.`);\n  ix = await ix;\n  const interactionHasBlockID = ix.block.id !== null;\n  const interactionHasBlockHeight = ix.block.height !== null;\n  if (interactionHasBlockID) {\n    return await sendGetBlockByIDRequest(ix, context, opts);\n  } else if (interactionHasBlockHeight) {\n    return await sendGetBlockByHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetBlockRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetCollection(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Collection Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Collection Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/collections/${ix.collection.id}?expand=transactions`,\n    method: \"GET\",\n    body: null\n  });\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.collection = {\n    id: res.id,\n    transactionIds: res.transactions.map(transaction => transaction.id)\n  };\n  return ret;\n}\n\nasync function sendGetEventsForHeightRangeRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/events?type=${ix.events.eventType}&start_height=${ix.events.start}&end_height=${ix.events.end}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse(ix, context, res);\n}\nasync function sendGetEventsForBlockIDsRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/events?type=${ix.events.eventType}&block_ids=${ix.events.blockIds.join(\",\")}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse(ix, context, res);\n}\nfunction constructResponse(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.events = [];\n  res.forEach(block => block.events ? block.events.forEach(event => ret.events.push({\n    blockId: block.block_id,\n    blockHeight: Number(block.block_height),\n    blockTimestamp: block.block_timestamp,\n    type: event.type,\n    transactionId: event.transaction_id,\n    transactionIndex: Number(event.transaction_index),\n    eventIndex: Number(event.event_index),\n    payload: JSON.parse(context.Buffer.from(event.payload, \"base64\").toString())\n  })) : null);\n  return ret;\n}\nasync function sendGetEvents(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Events Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Events Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Events Error: context.Buffer must be defined.`);\n  ix = await ix;\n  const interactionContainsBlockHeightRange = ix.events.start !== null;\n  const interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, \"SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.\");\n  if (interactionContainsBlockHeightRange) {\n    return await sendGetEventsForHeightRangeRequest(ix, context, opts);\n  } else {\n    return await sendGetEventsForBlockIDsRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetTransaction(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Transaction Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Transaction Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Transaction Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transactions/${ix.transaction.id}`,\n    method: \"GET\",\n    body: null\n  });\n  const unwrapKey = key => ({\n    address: key.address,\n    keyId: Number(key.key_id),\n    sequenceNumber: Number(key.sequence_number)\n  });\n  const unwrapSignature = sig => ({\n    address: sig.address,\n    keyId: Number(sig.key_index),\n    signature: sig.signature\n  });\n  const unwrapArg = arg => JSON.parse(context.Buffer.from(arg, \"base64\").toString());\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transaction = {\n    script: context.Buffer.from(res.script, \"base64\").toString(),\n    args: [...res.arguments.map(unwrapArg)],\n    referenceBlockId: res.reference_block_id,\n    gasLimit: Number(res.gas_limit),\n    payer: res.payer,\n    proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,\n    authorizers: res.authorizers,\n    payloadSignatures: [...res.payload_signatures.map(unwrapSignature)],\n    envelopeSignatures: [...res.envelope_signatures.map(unwrapSignature)]\n  };\n  return ret;\n}\n\nconst STATUS_MAP = {\n  UNKNOWN: 0,\n  PENDING: 1,\n  FINALIZED: 2,\n  EXECUTED: 3,\n  SEALED: 4,\n  EXPIRED: 5\n};\nasync function sendGetTransactionStatus(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Transaction Status Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Transaction Status Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Transaction Status Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transaction_results/${ix.transaction.id}`,\n    method: \"GET\",\n    body: null\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transactionStatus = {\n    blockId: res.block_id,\n    status: STATUS_MAP[res.status.toUpperCase()] || \"\",\n    statusString: res.status.toUpperCase(),\n    statusCode: res.status_code,\n    errorMessage: res.error_message,\n    events: res.events.map(event => ({\n      type: event.type,\n      transactionId: event.transaction_id,\n      transactionIndex: Number(event.transaction_index),\n      eventIndex: Number(event.event_index),\n      payload: JSON.parse(context.Buffer.from(event.payload, \"base64\").toString())\n    }))\n  };\n  return ret;\n}\n\nasync function sendPing(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Ping Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Ping Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  await httpRequest$1({\n    hostname: opts.node,\n    path: \"/v1/blocks?height=sealed\",\n    method: \"GET\",\n    body: null\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  return ret;\n}\n\nconst idof = acct => `${withPrefix(acct.addr)}-${acct.keyId}`;\nasync function sendTransaction(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Transaction Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Transaction Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Transaction Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n\n  // Apply Non Payer Signatures to Payload Signatures\n  let payloadSignatures = [];\n  for (let acct of Object.values(ix.accounts)) {\n    try {\n      if (!acct.role.payer && acct.signature != null) {\n        payloadSignatures.push({\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(acct.addr),\n          key_index: String(acct.keyId),\n          signature: context.Buffer.from(acct.signature, \"hex\").toString(\"base64\")\n        });\n      }\n    } catch (error) {\n      console.error(\"SDK HTTP Send Error: Trouble applying payload signature\", {\n        acct,\n        ix\n      });\n      throw error;\n    }\n  }\n\n  // Apply Payer Signatures to Envelope Signatures\n  let envelopeSignatures = {};\n  for (let acct of Object.values(ix.accounts)) {\n    try {\n      if (acct.role.payer && acct.signature != null) {\n        let id = acct.tempId || idof(acct);\n        envelopeSignatures[id] = envelopeSignatures[id] || {\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(acct.addr),\n          key_index: String(acct.keyId),\n          signature: context.Buffer.from(acct.signature, \"hex\").toString(\"base64\")\n        };\n      }\n    } catch (error) {\n      console.error(\"SDK HTTP Send Error: Trouble applying envelope signature\", {\n        acct,\n        ix\n      });\n      throw error;\n    }\n  }\n  envelopeSignatures = Object.values(envelopeSignatures);\n  var t1 = Date.now();\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transactions`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: [...ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))],\n      reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,\n      gas_limit: String(ix.message.computeLimit),\n      payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),\n      proposal_key: {\n        address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(ix.accounts[ix.proposer].addr),\n        key_index: String(ix.accounts[ix.proposer].keyId),\n        sequence_number: String(ix.accounts[ix.proposer].sequenceNum)\n      },\n      authorizers: ix.authorizations.map(tempId => ix.accounts[tempId].addr).reduce((prev, current) => {\n        return prev.find(item => item === current) ? prev : [...prev, current];\n      }, []).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix),\n      payload_signatures: payloadSignatures,\n      envelope_signatures: envelopeSignatures\n    }\n  });\n  var t2 = Date.now();\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transactionId = res.id;\n  if (typeof window !== \"undefined\" && typeof CustomEvent !== \"undefined\") {\n    window.dispatchEvent(new CustomEvent(\"FLOW::TX\", {\n      detail: {\n        txId: ret.transactionId,\n        delta: t2 - t1\n      }\n    }));\n  }\n  return ret;\n}\n\nasync function sendGetNetworkParameters(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Network Parameters Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Network Parameters Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/network/parameters`,\n    method: \"GET\",\n    body: null,\n    enableRequestLogging: opts.enableRequestLogging ?? true\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.networkParameters = {\n    chainId: res.chain_id\n  };\n  return ret;\n}\n\nconst send = async function (ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Error: Either opts.node or \"accessNode.api\" in config must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.ix, `SDK Send Error: context.ix must be defined.`);\n  ix = await ix;\n\n  // prettier-ignore\n  switch (true) {\n    case context.ix.isTransaction(ix):\n      return opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts);\n    case context.ix.isGetTransactionStatus(ix):\n      return opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts);\n    case context.ix.isGetTransaction(ix):\n      return opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts);\n    case context.ix.isScript(ix):\n      return opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts);\n    case context.ix.isGetAccount(ix):\n      return opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts);\n    case context.ix.isGetEvents(ix):\n      return opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts);\n    case context.ix.isGetBlock(ix):\n      return opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts);\n    case context.ix.isGetBlockHeader(ix):\n      return opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts);\n    case context.ix.isGetCollection(ix):\n      return opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts);\n    case context.ix.isPing(ix):\n      return opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts);\n    case context.ix.isGetNetworkParameters(ix):\n      return opts.sendGetNetworkParameters ? opts.sendGetNetworkParameters(ix, context, opts) : sendGetNetworkParameters(ix, context, opts);\n    default:\n      return ix;\n  }\n};\n\n\n//# sourceMappingURL=sdk-send-http.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy90cmFuc3BvcnQtaHR0cC9kaXN0L3Nkay1zZW5kLWh0dHAubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUM5QjtBQUN5QjtBQUNMO0FBQ1M7O0FBRWxELHNEQUFzRCxtQkFBTyxDQUFDLG9FQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQixNQUFNO0FBQy9CLFFBQVEsdUJBQXVCLFNBQVM7QUFDeEMsUUFBUSxlQUFlLEtBQUs7QUFDNUIsUUFBUSxtQkFBbUIsT0FBTztBQUNsQyxRQUFRLDZCQUE2QixZQUFZO0FBQ2pELFFBQVEsK0JBQStCLGFBQWE7QUFDcEQsUUFBUSwyQ0FBMkMsbUJBQW1CO0FBQ3RFLFFBQVEsMkJBQTJCLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLGtEQUFjLElBQUksU0FBUyxFQUFFLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFVO0FBQ3ZCO0FBQ0EsaUJBQWlCLGdFQUFVO0FBQzNCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sVUFBVSw0REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaUVBQVM7QUFDWCxFQUFFLGlFQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlFQUFTO0FBQ1gsRUFBRSxpRUFBUztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwTjtBQUMxTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG9uZmxvdy90cmFuc3BvcnQtaHR0cC9kaXN0L3Nkay1zZW5kLWh0dHAubW9kdWxlLmpzPzg0Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnQG9uZmxvdy91dGlsLWludmFyaWFudCc7XG5pbXBvcnQgJ0BvbmZsb3cvcmxwJztcbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICdAb25mbG93L3V0aWwtbG9nZ2VyJztcbmltcG9ydCBmZXRjaFRyYW5zcG9ydCBmcm9tICdjcm9zcy1mZXRjaCc7XG5pbXBvcnQgeyBzYW5zUHJlZml4IH0gZnJvbSAnQG9uZmxvdy91dGlsLWFkZHJlc3MnO1xuXG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCByZXF1aXJlKFwiYWJvcnQtY29udHJvbGxlclwiKTtcbmNsYXNzIEhUVFBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgZXJyb3IsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBhdGgsXG4gICAgICBtZXRob2QsXG4gICAgICByZXF1ZXN0Qm9keSxcbiAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgIHJlc3BvbnNlU3RhdHVzVGV4dCxcbiAgICAgIHN0YXR1c0NvZGVcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBtc2cgPSBgXG4gICAgICBIVFRQIFJlcXVlc3QgRXJyb3I6IEFuIGVycm9yIG9jY3VycmVkIHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQWNjZXNzIEFQSS5cbiAgICAgICR7ZXJyb3IgPyBgZXJyb3I9JHtlcnJvcn1gIDogXCJcIn1cbiAgICAgICR7aG9zdG5hbWUgPyBgaG9zdG5hbWU9JHtob3N0bmFtZX1gIDogXCJcIn1cbiAgICAgICR7cGF0aCA/IGBwYXRoPSR7cGF0aH1gIDogXCJcIn1cbiAgICAgICR7bWV0aG9kID8gYG1ldGhvZD0ke21ldGhvZH1gIDogXCJcIn1cbiAgICAgICR7cmVxdWVzdEJvZHkgPyBgcmVxdWVzdEJvZHk9JHtyZXF1ZXN0Qm9keX1gIDogXCJcIn1cbiAgICAgICR7cmVzcG9uc2VCb2R5ID8gYHJlc3BvbnNlQm9keT0ke3Jlc3BvbnNlQm9keX1gIDogXCJcIn1cbiAgICAgICR7cmVzcG9uc2VTdGF0dXNUZXh0ID8gYHJlc3BvbnNlU3RhdHVzVGV4dD0ke3Jlc3BvbnNlU3RhdHVzVGV4dH1gIDogXCJcIn1cbiAgICAgICR7c3RhdHVzQ29kZSA/IGBzdGF0dXNDb2RlPSR7c3RhdHVzQ29kZX1gIDogXCJcIn1cbiAgICBgO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy5uYW1lID0gXCJIVFRQIFJlcXVlc3QgRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUVFAgUmVxdWVzdCB0byBiZSBzZW50IHRvIGEgUkVTVCBBY2Nlc3MgQVBJIHZpYSBGZXRjaCBBUEkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgSFRUUCBSZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3N0bmFtZSAtIEFjY2VzcyBBUEkgSG9zdG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnBhdGggLSBQYXRoIHRvIHRoZSByZXNvdXJjZSBvbiB0aGUgQWNjZXNzIEFQSVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubWV0aG9kIC0gSFRUUCBNZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmJvZHkgLSBIVFRQIFJlcXVlc3QgQm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIC0gSFRUUCBSZXF1ZXN0IEhlYWRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmVxdWVzdExvZ2dpbmc9dHJ1ZV0gLSBFbmFibGUvRGlzYWJsZSByZXF1ZXN0IGxvZ2dpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXRyeUxpbWl0PTVdIC0gTnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IHJlcXVlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXRyeUludGVydmFsTXM9MTAwMF0gLSBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGltZW91dExpbWl0PTMwMDAwXSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWluZyBvdXQgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIEpTT04gb2JqZWN0IHJlc3BvbnNlIGZyb20gQWNjZXNzIEFQSS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaHR0cFJlcXVlc3QoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBob3N0bmFtZSxcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcmV0cnlMaW1pdCA9IDUsXG4gICAgcmV0cnlJbnRlcnZhbE1zID0gMTAwMCxcbiAgICB0aW1lb3V0TGltaXQgPSAzMDAwMCxcbiAgICBlbmFibGVSZXF1ZXN0TG9nZ2luZyA9IHRydWVcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBib2R5SlNPTiA9IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IG51bGw7XG4gIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgZmV0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgdGltZW91dExpbWl0KTtcbiAgICByZXR1cm4gZmV0Y2hUcmFuc3BvcnQoYCR7aG9zdG5hbWV9JHtwYXRofWAsIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgYm9keTogYm9keUpTT04sXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLnRoZW4oYXN5bmMgcmVzID0+IHtcbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBzYWZlUGFyc2VKU09OKHJlc3BvbnNlVGV4dCk7XG4gICAgICB0aHJvdyBuZXcgSFRUUFJlcXVlc3RFcnJvcih7XG4gICAgICAgIGVycm9yOiByZXNwb25zZT8ubWVzc2FnZSxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlKU09OLFxuICAgICAgICByZXNwb25zZUJvZHk6IHJlc3BvbnNlVGV4dCxcbiAgICAgICAgcmVzcG9uc2VTdGF0dXNUZXh0OiByZXMuc3RhdHVzVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goYXN5bmMgZSA9PiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEhUVFBSZXF1ZXN0RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChlLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3cgQU4gZXJyb3IgZm9yIGFsbCBuZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVuYWJsZVJlcXVlc3RMb2dnaW5nKSB7XG4gICAgICAgIGF3YWl0IGxvZ2dlci5sb2coe1xuICAgICAgICAgIHRpdGxlOiBcIkFjY2VzcyBOb2RlIEVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogYFRoZSBwcm92aWRlZCBhY2Nlc3Mgbm9kZSAke2hvc3RuYW1lfSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBSRVNUL0hUVFAgYWNjZXNzIG5vZGUuXG4gIFBsZWFzZSB2ZXJpZnkgdGhhdCB5b3UgYXJlIG5vdCB1bmludGVudGlvbmFsbHkgdXNpbmcgYSBHUlBDIGFjY2VzcyBub2RlLlxuICBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9mY2wvcmVmZXJlbmNlL3Nkay1ndWlkZWxpbmVzLyNjb25uZWN0YCxcbiAgICAgICAgICBsZXZlbDogbG9nZ2VyLkxFVkVMUy5lcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBIVFRQUmVxdWVzdEVycm9yKHtcbiAgICAgICAgZXJyb3I6IGU/Lm1lc3NhZ2UsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlcXVlc3RCb2R5OiBib2R5SlNPTlxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoZmV0Y2hUaW1lb3V0KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXF1ZXN0TG9vcCgpIHtcbiAgICBsZXQgcmV0cnlBdHRlbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgbWFrZVJlcXVlc3QoKTtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXRyeVN0YXR1c0NvZGVzID0gWzQwOCwgNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDRdO1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IHJldHJ5U3RhdHVzQ29kZXMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAocmV0cnlBdHRlbXB0IDwgcmV0cnlMaW1pdCkge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVJlcXVlc3RMb2dnaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWNjZXNzIG5vZGUgdW5hdmFpbGFibGUsIHJldHJ5aW5nIGluICR7cmV0cnlJbnRlcnZhbE1zfSBtcy4uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdExvb3AocmV0cnlBdHRlbXB0ICsgMSkpO1xuICAgICAgICAgICAgfSwgcmV0cnlJbnRlcnZhbE1zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gS2VlcCByZXRyeWluZyByZXF1ZXN0IHVudGlsIHNlcnZlciBhdmFpbGFibGUgb3IgbWF4IGF0dGVtcHRzIGV4Y2VlZGVkXG4gIHJldHVybiBhd2FpdCByZXF1ZXN0TG9vcCgpO1xufVxuZnVuY3Rpb24gc2FmZVBhcnNlSlNPTihkYXRhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFeGVjdXRlU2NyaXB0QXRCbG9ja0lEUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL3NjcmlwdHM/YmxvY2tfaWQ9JHtpeC5ibG9jay5pZH1gLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keToge1xuICAgICAgc2NyaXB0OiBjb250ZXh0LkJ1ZmZlci5mcm9tKGl4Lm1lc3NhZ2UuY2FkZW5jZSkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICBhcmd1bWVudHM6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChhcmcgPT4gY29udGV4dC5CdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShpeC5hcmd1bWVudHNbYXJnXS5hc0FyZ3VtZW50KSkudG9TdHJpbmcoXCJiYXNlNjRcIikpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDQoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kRXhlY3V0ZVNjcmlwdEF0QmxvY2tIZWlnaHRSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvc2NyaXB0cz9ibG9ja19oZWlnaHQ9JHtpeC5ibG9jay5oZWlnaHR9YCxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IHtcbiAgICAgIHNjcmlwdDogY29udGV4dC5CdWZmZXIuZnJvbShpeC5tZXNzYWdlLmNhZGVuY2UpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgICAgYXJndW1lbnRzOiBpeC5tZXNzYWdlLmFyZ3VtZW50cy5tYXAoYXJnID0+IGNvbnRleHQuQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoaXguYXJndW1lbnRzW2FyZ10uYXNBcmd1bWVudCkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQ0KGl4LCBjb250ZXh0LCByZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEV4ZWN1dGVTY3JpcHRBdExhdGVzdEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL3NjcmlwdHM/YmxvY2tfaGVpZ2h0PXNlYWxlZGAsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiB7XG4gICAgICBzY3JpcHQ6IGNvbnRleHQuQnVmZmVyLmZyb20oaXgubWVzc2FnZS5jYWRlbmNlKS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgIGFyZ3VtZW50czogaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGFyZyA9PiBjb250ZXh0LkJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGl4LmFyZ3VtZW50c1thcmddLmFzQXJndW1lbnQpKS50b1N0cmluZyhcImJhc2U2NFwiKSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkNChpeCwgY29udGV4dCwgcmVzKTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc3BvbnNlJDQoaXgsIGNvbnRleHQsIHJlcykge1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQuZW5jb2RlZERhdGEgPSBKU09OLnBhcnNlKGNvbnRleHQuQnVmZmVyLmZyb20ocmVzLCBcImJhc2U2NFwiKS50b1N0cmluZygpKTtcbiAgcmV0dXJuIHJldDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFeGVjdXRlU2NyaXB0KGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgRXhlY3V0ZSBTY3JpcHQgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgRXhlY3V0ZSBTY3JpcHQgRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5CdWZmZXIsIGBTREsgU2VuZCBFeGVjdXRlIFNjcmlwdCBFcnJvcjogY29udGV4dC5CdWZmZXIgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpeCA9IGF3YWl0IGl4O1xuICBpZiAoaXguYmxvY2suaWQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEV4ZWN1dGVTY3JpcHRBdEJsb2NrSURSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIGlmIChpeC5ibG9jay5oZWlnaHQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEV4ZWN1dGVTY3JpcHRBdEJsb2NrSGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRFeGVjdXRlU2NyaXB0QXRMYXRlc3RCbG9ja1JlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9XG59XG5cbmNvbnN0IEhhc2hBbGdvcml0aG1JRHMgPSB7XG4gIFNIQTJfMjU2OiAxLFxuICBTSEEyXzM4NDogMixcbiAgU0hBM18yNTY6IDMsXG4gIFNIQTNfMzg0OiA0LFxuICBLTUFDMTI4X0JMU19CTFMxMl8zODE6IDVcbn07XG5jb25zdCBTaWduYXR1cmVBbGdvcml0aG1JRHMgPSB7XG4gIEVDRFNBX1AyNTY6IDEsXG4gIEVDRFNBX3NlY3AyNTZrMTogMixcbiAgQkxTX0JMUzEyXzM4MTogM1xufTtcbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRBY2NvdW50QXRCbG9ja0hlaWdodFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9hY2NvdW50cy8ke2l4LmFjY291bnQuYWRkcn0/YmxvY2tfaGVpZ2h0PSR7aXguYmxvY2suaGVpZ2h0fSZleHBhbmQ9Y29udHJhY3RzLGtleXNgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMyhpeCwgY29udGV4dCwgcmVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRBY2NvdW50QXRMYXRlc3RCbG9ja1JlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9hY2NvdW50cy8ke2l4LmFjY291bnQuYWRkcn0/YmxvY2tfaGVpZ2h0PXNlYWxlZCZleHBhbmQ9Y29udHJhY3RzLGtleXNgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMyhpeCwgY29udGV4dCwgcmVzKTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc3BvbnNlJDMoaXgsIGNvbnRleHQsIHJlcykge1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICBjb25zdCB1bndyYXBDb250cmFjdHMgPSBjb250cmFjdHMgPT4ge1xuICAgIGNvbnN0IGMgPSB7fTtcbiAgICBpZiAoIWNvbnRyYWN0cykgcmV0dXJuIGM7XG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbnRyYWN0cykpIHtcbiAgICAgIGNba2V5XSA9IGNvbnRleHQuQnVmZmVyLmZyb20oY29udHJhY3RzW2tleV0sIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9O1xuICByZXQuYWNjb3VudCA9IHtcbiAgICBhZGRyZXNzOiByZXMuYWRkcmVzcyxcbiAgICBiYWxhbmNlOiBOdW1iZXIocmVzLmJhbGFuY2UpLFxuICAgIGNvZGU6IFwiXCIsXG4gICAgY29udHJhY3RzOiB1bndyYXBDb250cmFjdHMocmVzLmNvbnRyYWN0cyksXG4gICAga2V5czogcmVzLmtleXM/Lm1hcChrZXkgPT4gKHtcbiAgICAgIGluZGV4OiBOdW1iZXIoa2V5LmluZGV4KSxcbiAgICAgIHB1YmxpY0tleToga2V5LnB1YmxpY19rZXkucmVwbGFjZSgvXjB4LywgXCJcIiksXG4gICAgICBzaWduQWxnbzogU2lnbmF0dXJlQWxnb3JpdGhtSURzW2tleS5zaWduaW5nX2FsZ29yaXRobV0sXG4gICAgICBzaWduQWxnb1N0cmluZzoga2V5LnNpZ25pbmdfYWxnb3JpdGhtLFxuICAgICAgaGFzaEFsZ286IEhhc2hBbGdvcml0aG1JRHNba2V5Lmhhc2hpbmdfYWxnb3JpdGhtXSxcbiAgICAgIGhhc2hBbGdvU3RyaW5nOiBrZXkuaGFzaGluZ19hbGdvcml0aG0sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogTnVtYmVyKGtleS5zZXF1ZW5jZV9udW1iZXIpLFxuICAgICAgd2VpZ2h0OiBOdW1iZXIoa2V5LndlaWdodCksXG4gICAgICByZXZva2VkOiBrZXkucmV2b2tlZFxuICAgIH0pKSA/PyBbXVxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEFjY291bnQoaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBHZXQgQWNjb3VudCBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgQWNjb3VudCBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LkJ1ZmZlciwgYFNESyBTZW5kIEdldCBBY2NvdW50IEVycm9yOiBjb250ZXh0LkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGl4ID0gYXdhaXQgaXg7XG4gIGlmIChpeC5ibG9jay5oZWlnaHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEFjY291bnRBdEJsb2NrSGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRHZXRBY2NvdW50QXRMYXRlc3RCbG9ja1JlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9ja0hlYWRlckJ5SURSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvYmxvY2tzLyR7aXguYmxvY2suaWR9YCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDIoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0QmxvY2tIZWFkZXJCeUhlaWdodFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9ibG9ja3M/aGVpZ2h0PSR7aXguYmxvY2suaGVpZ2h0fWAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQyKGl4LCBjb250ZXh0LCByZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldExhdGVzdEJsb2NrSGVhZGVyUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgaGVpZ2h0ID0gaXguYmxvY2s/LmlzU2VhbGVkID8gXCJzZWFsZWRcIiA6IFwiZmluYWxcIjtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2Jsb2Nrcz9oZWlnaHQ9JHtoZWlnaHR9YCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDIoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RSZXNwb25zZSQyKGl4LCBjb250ZXh0LCByZXMpIHtcbiAgY29uc3QgYmxvY2sgPSByZXMubGVuZ3RoID8gcmVzWzBdIDogbnVsbDtcbiAgY29uc3QgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQuYmxvY2tIZWFkZXIgPSB7XG4gICAgaWQ6IGJsb2NrLmhlYWRlci5pZCxcbiAgICBwYXJlbnRJZDogYmxvY2suaGVhZGVyLnBhcmVudF9pZCxcbiAgICBoZWlnaHQ6IE51bWJlcihibG9jay5oZWFkZXIuaGVpZ2h0KSxcbiAgICB0aW1lc3RhbXA6IGJsb2NrLmhlYWRlci50aW1lc3RhbXBcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9ja0hlYWRlcihpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBCbG9jayBIZWFkZXIgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgR2V0IEJsb2NrIEhlYWRlciBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGl4ID0gYXdhaXQgaXg7XG4gIGNvbnN0IGludGVyYWN0aW9uSGFzQmxvY2tJRCA9IGl4LmJsb2NrLmlkICE9PSBudWxsO1xuICBjb25zdCBpbnRlcmFjdGlvbkhhc0Jsb2NrSGVpZ2h0ID0gaXguYmxvY2suaGVpZ2h0ICE9PSBudWxsO1xuICBpZiAoaW50ZXJhY3Rpb25IYXNCbG9ja0lEKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRHZXRCbG9ja0hlYWRlckJ5SURSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbkhhc0Jsb2NrSGVpZ2h0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRHZXRCbG9ja0hlYWRlckJ5SGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRHZXRMYXRlc3RCbG9ja0hlYWRlclJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9ja0J5SURSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvYmxvY2tzLyR7aXguYmxvY2suaWR9P2V4cGFuZD1wYXlsb2FkYCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDEoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0QmxvY2tCeUhlaWdodFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9ibG9ja3M/aGVpZ2h0PSR7aXguYmxvY2suaGVpZ2h0fSZleHBhbmQ9cGF5bG9hZGAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQxKGl4LCBjb250ZXh0LCByZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgaGVpZ2h0ID0gaXguYmxvY2s/LmlzU2VhbGVkID8gXCJzZWFsZWRcIiA6IFwiZmluYWxcIjtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2Jsb2Nrcz9oZWlnaHQ9JHtoZWlnaHR9JmV4cGFuZD1wYXlsb2FkYCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDEoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RSZXNwb25zZSQxKGl4LCBjb250ZXh0LCByZXMpIHtcbiAgY29uc3QgYmxvY2sgPSByZXMubGVuZ3RoID8gcmVzWzBdIDogbnVsbDtcbiAgY29uc3QgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQuYmxvY2sgPSB7XG4gICAgaWQ6IGJsb2NrLmhlYWRlci5pZCxcbiAgICBwYXJlbnRJZDogYmxvY2suaGVhZGVyLnBhcmVudF9pZCxcbiAgICBoZWlnaHQ6IE51bWJlcihibG9jay5oZWFkZXIuaGVpZ2h0KSxcbiAgICB0aW1lc3RhbXA6IGJsb2NrLmhlYWRlci50aW1lc3RhbXAsXG4gICAgY29sbGVjdGlvbkd1YXJhbnRlZXM6IGJsb2NrLnBheWxvYWQuY29sbGVjdGlvbl9ndWFyYW50ZWVzLm1hcChjb2xsZWN0aW9uR3VhcmFudGVlID0+ICh7XG4gICAgICBjb2xsZWN0aW9uSWQ6IGNvbGxlY3Rpb25HdWFyYW50ZWUuY29sbGVjdGlvbl9pZCxcbiAgICAgIHNpZ25lcklkczogY29sbGVjdGlvbkd1YXJhbnRlZS5zaWduZXJfaWRzXG4gICAgfSkpLFxuICAgIGJsb2NrU2VhbHM6IGJsb2NrLnBheWxvYWQuYmxvY2tfc2VhbHMubWFwKGJsb2NrU2VhbCA9PiAoe1xuICAgICAgYmxvY2tJZDogYmxvY2tTZWFsLmJsb2NrX2lkLFxuICAgICAgZXhlY3V0aW9uUmVjZWlwdElkOiBibG9ja1NlYWwucmVzdWx0X2lkXG4gICAgfSkpXG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0QmxvY2soaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBHZXQgQmxvY2sgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgR2V0IEJsb2NrIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaXggPSBhd2FpdCBpeDtcbiAgY29uc3QgaW50ZXJhY3Rpb25IYXNCbG9ja0lEID0gaXguYmxvY2suaWQgIT09IG51bGw7XG4gIGNvbnN0IGludGVyYWN0aW9uSGFzQmxvY2tIZWlnaHQgPSBpeC5ibG9jay5oZWlnaHQgIT09IG51bGw7XG4gIGlmIChpbnRlcmFjdGlvbkhhc0Jsb2NrSUQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEJsb2NrQnlJRFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9IGVsc2UgaWYgKGludGVyYWN0aW9uSGFzQmxvY2tIZWlnaHQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEJsb2NrQnlIZWlnaHRSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldENvbGxlY3Rpb24oaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBHZXQgQ29sbGVjdGlvbiBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgQ29sbGVjdGlvbiBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvY29sbGVjdGlvbnMvJHtpeC5jb2xsZWN0aW9uLmlkfT9leHBhbmQ9dHJhbnNhY3Rpb25zYCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgY29uc3QgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQuY29sbGVjdGlvbiA9IHtcbiAgICBpZDogcmVzLmlkLFxuICAgIHRyYW5zYWN0aW9uSWRzOiByZXMudHJhbnNhY3Rpb25zLm1hcCh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5pZClcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEV2ZW50c0ZvckhlaWdodFJhbmdlUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2V2ZW50cz90eXBlPSR7aXguZXZlbnRzLmV2ZW50VHlwZX0mc3RhcnRfaGVpZ2h0PSR7aXguZXZlbnRzLnN0YXJ0fSZlbmRfaGVpZ2h0PSR7aXguZXZlbnRzLmVuZH1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0RXZlbnRzRm9yQmxvY2tJRHNSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvZXZlbnRzP3R5cGU9JHtpeC5ldmVudHMuZXZlbnRUeXBlfSZibG9ja19pZHM9JHtpeC5ldmVudHMuYmxvY2tJZHMuam9pbihcIixcIil9YCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlKGl4LCBjb250ZXh0LCByZXMpO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UmVzcG9uc2UoaXgsIGNvbnRleHQsIHJlcykge1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQuZXZlbnRzID0gW107XG4gIHJlcy5mb3JFYWNoKGJsb2NrID0+IGJsb2NrLmV2ZW50cyA/IGJsb2NrLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHJldC5ldmVudHMucHVzaCh7XG4gICAgYmxvY2tJZDogYmxvY2suYmxvY2tfaWQsXG4gICAgYmxvY2tIZWlnaHQ6IE51bWJlcihibG9jay5ibG9ja19oZWlnaHQpLFxuICAgIGJsb2NrVGltZXN0YW1wOiBibG9jay5ibG9ja190aW1lc3RhbXAsXG4gICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICB0cmFuc2FjdGlvbklkOiBldmVudC50cmFuc2FjdGlvbl9pZCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBOdW1iZXIoZXZlbnQudHJhbnNhY3Rpb25faW5kZXgpLFxuICAgIGV2ZW50SW5kZXg6IE51bWJlcihldmVudC5ldmVudF9pbmRleCksXG4gICAgcGF5bG9hZDogSlNPTi5wYXJzZShjb250ZXh0LkJ1ZmZlci5mcm9tKGV2ZW50LnBheWxvYWQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpXG4gIH0pKSA6IG51bGwpO1xuICByZXR1cm4gcmV0O1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEV2ZW50cyhpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBFdmVudHMgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgR2V0IEV2ZW50cyBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LkJ1ZmZlciwgYFNESyBTZW5kIEdldCBFdmVudHMgRXJyb3I6IGNvbnRleHQuQnVmZmVyIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaXggPSBhd2FpdCBpeDtcbiAgY29uc3QgaW50ZXJhY3Rpb25Db250YWluc0Jsb2NrSGVpZ2h0UmFuZ2UgPSBpeC5ldmVudHMuc3RhcnQgIT09IG51bGw7XG4gIGNvbnN0IGludGVyYWN0aW9uQ29udGFpbnNCbG9ja0lEc0xpc3QgPSBBcnJheS5pc0FycmF5KGl4LmV2ZW50cy5ibG9ja0lkcykgJiYgaXguZXZlbnRzLmJsb2NrSWRzLmxlbmd0aCA+IDA7XG4gIGludmFyaWFudChpbnRlcmFjdGlvbkNvbnRhaW5zQmxvY2tIZWlnaHRSYW5nZSB8fCBpbnRlcmFjdGlvbkNvbnRhaW5zQmxvY2tJRHNMaXN0LCBcIlNlbmRHZXRFdmVudHNFcnJvcjogVW5hYmxlIHRvIGRldGVybWluZSB3aGljaCBnZXQgZXZlbnRzIHJlcXVlc3QgdG8gc2VuZC4gRWl0aGVyIGEgYmxvY2sgaGVpZ2h0IHJhbmdlLCBvciBibG9jayBJRHMgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICBpZiAoaW50ZXJhY3Rpb25Db250YWluc0Jsb2NrSGVpZ2h0UmFuZ2UpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEV2ZW50c0ZvckhlaWdodFJhbmdlUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlbmRHZXRFdmVudHNGb3JCbG9ja0lEc1JlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRUcmFuc2FjdGlvbihpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBUcmFuc2FjdGlvbiBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgVHJhbnNhY3Rpb24gRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5CdWZmZXIsIGBTREsgU2VuZCBHZXQgVHJhbnNhY3Rpb24gRXJyb3I6IGNvbnRleHQuQnVmZmVyIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGl4ID0gYXdhaXQgaXg7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS90cmFuc2FjdGlvbnMvJHtpeC50cmFuc2FjdGlvbi5pZH1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICBjb25zdCB1bndyYXBLZXkgPSBrZXkgPT4gKHtcbiAgICBhZGRyZXNzOiBrZXkuYWRkcmVzcyxcbiAgICBrZXlJZDogTnVtYmVyKGtleS5rZXlfaWQpLFxuICAgIHNlcXVlbmNlTnVtYmVyOiBOdW1iZXIoa2V5LnNlcXVlbmNlX251bWJlcilcbiAgfSk7XG4gIGNvbnN0IHVud3JhcFNpZ25hdHVyZSA9IHNpZyA9PiAoe1xuICAgIGFkZHJlc3M6IHNpZy5hZGRyZXNzLFxuICAgIGtleUlkOiBOdW1iZXIoc2lnLmtleV9pbmRleCksXG4gICAgc2lnbmF0dXJlOiBzaWcuc2lnbmF0dXJlXG4gIH0pO1xuICBjb25zdCB1bndyYXBBcmcgPSBhcmcgPT4gSlNPTi5wYXJzZShjb250ZXh0LkJ1ZmZlci5mcm9tKGFyZywgXCJiYXNlNjRcIikudG9TdHJpbmcoKSk7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC50cmFuc2FjdGlvbiA9IHtcbiAgICBzY3JpcHQ6IGNvbnRleHQuQnVmZmVyLmZyb20ocmVzLnNjcmlwdCwgXCJiYXNlNjRcIikudG9TdHJpbmcoKSxcbiAgICBhcmdzOiBbLi4ucmVzLmFyZ3VtZW50cy5tYXAodW53cmFwQXJnKV0sXG4gICAgcmVmZXJlbmNlQmxvY2tJZDogcmVzLnJlZmVyZW5jZV9ibG9ja19pZCxcbiAgICBnYXNMaW1pdDogTnVtYmVyKHJlcy5nYXNfbGltaXQpLFxuICAgIHBheWVyOiByZXMucGF5ZXIsXG4gICAgcHJvcG9zYWxLZXk6IHJlcy5wcm9wb3NhbF9rZXkgPyB1bndyYXBLZXkocmVzLnByb3Bvc2FsX2tleSkgOiByZXMucHJvcG9zYWxfa2V5LFxuICAgIGF1dGhvcml6ZXJzOiByZXMuYXV0aG9yaXplcnMsXG4gICAgcGF5bG9hZFNpZ25hdHVyZXM6IFsuLi5yZXMucGF5bG9hZF9zaWduYXR1cmVzLm1hcCh1bndyYXBTaWduYXR1cmUpXSxcbiAgICBlbnZlbG9wZVNpZ25hdHVyZXM6IFsuLi5yZXMuZW52ZWxvcGVfc2lnbmF0dXJlcy5tYXAodW53cmFwU2lnbmF0dXJlKV1cbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgU1RBVFVTX01BUCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgUEVORElORzogMSxcbiAgRklOQUxJWkVEOiAyLFxuICBFWEVDVVRFRDogMyxcbiAgU0VBTEVEOiA0LFxuICBFWFBJUkVEOiA1XG59O1xuYXN5bmMgZnVuY3Rpb24gc2VuZEdldFRyYW5zYWN0aW9uU3RhdHVzKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgR2V0IFRyYW5zYWN0aW9uIFN0YXR1cyBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgVHJhbnNhY3Rpb24gU3RhdHVzIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQuQnVmZmVyLCBgU0RLIFNlbmQgR2V0IFRyYW5zYWN0aW9uIFN0YXR1cyBFcnJvcjogY29udGV4dC5CdWZmZXIgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgaXggPSBhd2FpdCBpeDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL3RyYW5zYWN0aW9uX3Jlc3VsdHMvJHtpeC50cmFuc2FjdGlvbi5pZH1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQudHJhbnNhY3Rpb25TdGF0dXMgPSB7XG4gICAgYmxvY2tJZDogcmVzLmJsb2NrX2lkLFxuICAgIHN0YXR1czogU1RBVFVTX01BUFtyZXMuc3RhdHVzLnRvVXBwZXJDYXNlKCldIHx8IFwiXCIsXG4gICAgc3RhdHVzU3RyaW5nOiByZXMuc3RhdHVzLnRvVXBwZXJDYXNlKCksXG4gICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c19jb2RlLFxuICAgIGVycm9yTWVzc2FnZTogcmVzLmVycm9yX21lc3NhZ2UsXG4gICAgZXZlbnRzOiByZXMuZXZlbnRzLm1hcChldmVudCA9PiAoe1xuICAgICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICAgIHRyYW5zYWN0aW9uSWQ6IGV2ZW50LnRyYW5zYWN0aW9uX2lkLFxuICAgICAgdHJhbnNhY3Rpb25JbmRleDogTnVtYmVyKGV2ZW50LnRyYW5zYWN0aW9uX2luZGV4KSxcbiAgICAgIGV2ZW50SW5kZXg6IE51bWJlcihldmVudC5ldmVudF9pbmRleCksXG4gICAgICBwYXlsb2FkOiBKU09OLnBhcnNlKGNvbnRleHQuQnVmZmVyLmZyb20oZXZlbnQucGF5bG9hZCwgXCJiYXNlNjRcIikudG9TdHJpbmcoKSlcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZFBpbmcoaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBQaW5nIEVycm9yOiBvcHRzLm5vZGUgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5yZXNwb25zZSwgYFNESyBTZW5kIFBpbmcgRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBcIi92MS9ibG9ja3M/aGVpZ2h0PXNlYWxlZFwiLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBpZG9mID0gYWNjdCA9PiBgJHt3aXRoUHJlZml4KGFjY3QuYWRkcil9LSR7YWNjdC5rZXlJZH1gO1xuYXN5bmMgZnVuY3Rpb24gc2VuZFRyYW5zYWN0aW9uKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgVHJhbnNhY3Rpb24gRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgVHJhbnNhY3Rpb24gRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5CdWZmZXIsIGBTREsgU2VuZCBUcmFuc2FjdGlvbiBFcnJvcjogY29udGV4dC5CdWZmZXIgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgaXggPSBhd2FpdCBpeDtcblxuICAvLyBBcHBseSBOb24gUGF5ZXIgU2lnbmF0dXJlcyB0byBQYXlsb2FkIFNpZ25hdHVyZXNcbiAgbGV0IHBheWxvYWRTaWduYXR1cmVzID0gW107XG4gIGZvciAobGV0IGFjY3Qgb2YgT2JqZWN0LnZhbHVlcyhpeC5hY2NvdW50cykpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhY2N0LnJvbGUucGF5ZXIgJiYgYWNjdC5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBwYXlsb2FkU2lnbmF0dXJlcy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBzYW5zUHJlZml4KGFjY3QuYWRkciksXG4gICAgICAgICAga2V5X2luZGV4OiBTdHJpbmcoYWNjdC5rZXlJZCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBjb250ZXh0LkJ1ZmZlci5mcm9tKGFjY3Quc2lnbmF0dXJlLCBcImhleFwiKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNESyBIVFRQIFNlbmQgRXJyb3I6IFRyb3VibGUgYXBwbHlpbmcgcGF5bG9hZCBzaWduYXR1cmVcIiwge1xuICAgICAgICBhY2N0LFxuICAgICAgICBpeFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBseSBQYXllciBTaWduYXR1cmVzIHRvIEVudmVsb3BlIFNpZ25hdHVyZXNcbiAgbGV0IGVudmVsb3BlU2lnbmF0dXJlcyA9IHt9O1xuICBmb3IgKGxldCBhY2N0IG9mIE9iamVjdC52YWx1ZXMoaXguYWNjb3VudHMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhY2N0LnJvbGUucGF5ZXIgJiYgYWNjdC5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBsZXQgaWQgPSBhY2N0LnRlbXBJZCB8fCBpZG9mKGFjY3QpO1xuICAgICAgICBlbnZlbG9wZVNpZ25hdHVyZXNbaWRdID0gZW52ZWxvcGVTaWduYXR1cmVzW2lkXSB8fCB7XG4gICAgICAgICAgYWRkcmVzczogc2Fuc1ByZWZpeChhY2N0LmFkZHIpLFxuICAgICAgICAgIGtleV9pbmRleDogU3RyaW5nKGFjY3Qua2V5SWQpLFxuICAgICAgICAgIHNpZ25hdHVyZTogY29udGV4dC5CdWZmZXIuZnJvbShhY2N0LnNpZ25hdHVyZSwgXCJoZXhcIikudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNESyBIVFRQIFNlbmQgRXJyb3I6IFRyb3VibGUgYXBwbHlpbmcgZW52ZWxvcGUgc2lnbmF0dXJlXCIsIHtcbiAgICAgICAgYWNjdCxcbiAgICAgICAgaXhcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGVudmVsb3BlU2lnbmF0dXJlcyA9IE9iamVjdC52YWx1ZXMoZW52ZWxvcGVTaWduYXR1cmVzKTtcbiAgdmFyIHQxID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL3RyYW5zYWN0aW9uc2AsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiB7XG4gICAgICBzY3JpcHQ6IGNvbnRleHQuQnVmZmVyLmZyb20oaXgubWVzc2FnZS5jYWRlbmNlKS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgIGFyZ3VtZW50czogWy4uLml4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChhcmcgPT4gY29udGV4dC5CdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShpeC5hcmd1bWVudHNbYXJnXS5hc0FyZ3VtZW50KSkudG9TdHJpbmcoXCJiYXNlNjRcIikpXSxcbiAgICAgIHJlZmVyZW5jZV9ibG9ja19pZDogaXgubWVzc2FnZS5yZWZCbG9jayA/IGl4Lm1lc3NhZ2UucmVmQmxvY2sgOiBudWxsLFxuICAgICAgZ2FzX2xpbWl0OiBTdHJpbmcoaXgubWVzc2FnZS5jb21wdXRlTGltaXQpLFxuICAgICAgcGF5ZXI6IHNhbnNQcmVmaXgoaXguYWNjb3VudHNbQXJyYXkuaXNBcnJheShpeC5wYXllcikgPyBpeC5wYXllclswXSA6IGl4LnBheWVyXS5hZGRyKSxcbiAgICAgIHByb3Bvc2FsX2tleToge1xuICAgICAgICBhZGRyZXNzOiBzYW5zUHJlZml4KGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5hZGRyKSxcbiAgICAgICAga2V5X2luZGV4OiBTdHJpbmcoaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmtleUlkKSxcbiAgICAgICAgc2VxdWVuY2VfbnVtYmVyOiBTdHJpbmcoaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLnNlcXVlbmNlTnVtKVxuICAgICAgfSxcbiAgICAgIGF1dGhvcml6ZXJzOiBpeC5hdXRob3JpemF0aW9ucy5tYXAodGVtcElkID0+IGl4LmFjY291bnRzW3RlbXBJZF0uYWRkcikucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBwcmV2LmZpbmQoaXRlbSA9PiBpdGVtID09PSBjdXJyZW50KSA/IHByZXYgOiBbLi4ucHJldiwgY3VycmVudF07XG4gICAgICB9LCBbXSkubWFwKHNhbnNQcmVmaXgpLFxuICAgICAgcGF5bG9hZF9zaWduYXR1cmVzOiBwYXlsb2FkU2lnbmF0dXJlcyxcbiAgICAgIGVudmVsb3BlX3NpZ25hdHVyZXM6IGVudmVsb3BlU2lnbmF0dXJlc1xuICAgIH1cbiAgfSk7XG4gIHZhciB0MiA9IERhdGUubm93KCk7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC50cmFuc2FjdGlvbklkID0gcmVzLmlkO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgQ3VzdG9tRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJGTE9XOjpUWFwiLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgdHhJZDogcmV0LnRyYW5zYWN0aW9uSWQsXG4gICAgICAgIGRlbHRhOiB0MiAtIHQxXG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXROZXR3b3JrUGFyYW1ldGVycyhpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBOZXR3b3JrIFBhcmFtZXRlcnMgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgR2V0IE5ldHdvcmsgUGFyYW1ldGVycyBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBpeCA9IGF3YWl0IGl4O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvbmV0d29yay9wYXJhbWV0ZXJzYCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbCxcbiAgICBlbmFibGVSZXF1ZXN0TG9nZ2luZzogb3B0cy5lbmFibGVSZXF1ZXN0TG9nZ2luZyA/PyB0cnVlXG4gIH0pO1xuICBsZXQgcmV0ID0gY29udGV4dC5yZXNwb25zZSgpO1xuICByZXQudGFnID0gaXgudGFnO1xuICByZXQubmV0d29ya1BhcmFtZXRlcnMgPSB7XG4gICAgY2hhaW5JZDogcmVzLmNoYWluX2lkXG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBFcnJvcjogRWl0aGVyIG9wdHMubm9kZSBvciBcImFjY2Vzc05vZGUuYXBpXCIgaW4gY29uZmlnIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQuaXgsIGBTREsgU2VuZCBFcnJvcjogY29udGV4dC5peCBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGl4ID0gYXdhaXQgaXg7XG5cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgY29udGV4dC5peC5pc1RyYW5zYWN0aW9uKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRUcmFuc2FjdGlvbiA/IG9wdHMuc2VuZFRyYW5zYWN0aW9uKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRUcmFuc2FjdGlvbihpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzR2V0VHJhbnNhY3Rpb25TdGF0dXMoaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZEdldFRyYW5zYWN0aW9uU3RhdHVzID8gb3B0cy5zZW5kR2V0VHJhbnNhY3Rpb25TdGF0dXMoaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZEdldFRyYW5zYWN0aW9uU3RhdHVzKGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXRUcmFuc2FjdGlvbihpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0VHJhbnNhY3Rpb24gPyBvcHRzLnNlbmRHZXRUcmFuc2FjdGlvbihpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0VHJhbnNhY3Rpb24oaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc1NjcmlwdChpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kRXhlY3V0ZVNjcmlwdCA/IG9wdHMuc2VuZEV4ZWN1dGVTY3JpcHQoaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZEV4ZWN1dGVTY3JpcHQoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldEFjY291bnQoaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZEdldEFjY291bnQgPyBvcHRzLnNlbmRHZXRBY2NvdW50KGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXRBY2NvdW50KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXRFdmVudHMoaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZEdldEV2ZW50cyA/IG9wdHMuc2VuZEdldEV2ZW50cyhpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0RXZlbnRzKGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXRCbG9jayhpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0QmxvY2sgPyBvcHRzLnNlbmRHZXRCbG9jayhpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0QmxvY2soaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldEJsb2NrSGVhZGVyKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRHZXRCbG9ja0hlYWRlciA/IG9wdHMuc2VuZEdldEJsb2NrSGVhZGVyKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXRCbG9ja0hlYWRlcihpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzR2V0Q29sbGVjdGlvbihpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0Q29sbGVjdGlvbiA/IG9wdHMuc2VuZEdldENvbGxlY3Rpb24oaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZEdldENvbGxlY3Rpb24oaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc1BpbmcoaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZFBpbmcgPyBvcHRzLnNlbmRQaW5nKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRQaW5nKGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXROZXR3b3JrUGFyYW1ldGVycyhpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0TmV0d29ya1BhcmFtZXRlcnMgPyBvcHRzLnNlbmRHZXROZXR3b3JrUGFyYW1ldGVycyhpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0TmV0d29ya1BhcmFtZXRlcnMoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaXg7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHNlbmQsIHNlbmRFeGVjdXRlU2NyaXB0LCBzZW5kR2V0QWNjb3VudCwgc2VuZEdldEJsb2NrLCBzZW5kR2V0QmxvY2tIZWFkZXIsIHNlbmRHZXRDb2xsZWN0aW9uLCBzZW5kR2V0RXZlbnRzLCBzZW5kR2V0TmV0d29ya1BhcmFtZXRlcnMsIHNlbmRHZXRUcmFuc2FjdGlvbiwgc2VuZEdldFRyYW5zYWN0aW9uU3RhdHVzLCBzZW5kUGluZywgc2VuZFRyYW5zYWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZGstc2VuZC1odHRwLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@onflow/transport-http/dist/sdk-send-http.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/types/dist/types.module.js":
/*!*********************************************************!*\
  !*** ./node_modules/@onflow/types/dist/types.module.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: function() { return /* binding */ Address; },\n/* harmony export */   Array: function() { return /* binding */ _Array; },\n/* harmony export */   Bool: function() { return /* binding */ Bool; },\n/* harmony export */   Character: function() { return /* binding */ Character; },\n/* harmony export */   Dictionary: function() { return /* binding */ Dictionary; },\n/* harmony export */   Enum: function() { return /* binding */ Enum; },\n/* harmony export */   Event: function() { return /* binding */ Event; },\n/* harmony export */   Fix64: function() { return /* binding */ Fix64; },\n/* harmony export */   Identity: function() { return /* binding */ Identity; },\n/* harmony export */   Int: function() { return /* binding */ Int; },\n/* harmony export */   Int128: function() { return /* binding */ Int128; },\n/* harmony export */   Int16: function() { return /* binding */ Int16; },\n/* harmony export */   Int256: function() { return /* binding */ Int256; },\n/* harmony export */   Int32: function() { return /* binding */ Int32; },\n/* harmony export */   Int64: function() { return /* binding */ Int64; },\n/* harmony export */   Int8: function() { return /* binding */ Int8; },\n/* harmony export */   Optional: function() { return /* binding */ Optional; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   Reference: function() { return /* binding */ Reference; },\n/* harmony export */   Resource: function() { return /* binding */ Resource; },\n/* harmony export */   String: function() { return /* binding */ String; },\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   UFix64: function() { return /* binding */ UFix64; },\n/* harmony export */   UInt: function() { return /* binding */ UInt; },\n/* harmony export */   UInt128: function() { return /* binding */ UInt128; },\n/* harmony export */   UInt16: function() { return /* binding */ UInt16; },\n/* harmony export */   UInt256: function() { return /* binding */ UInt256; },\n/* harmony export */   UInt32: function() { return /* binding */ UInt32; },\n/* harmony export */   UInt64: function() { return /* binding */ UInt64; },\n/* harmony export */   UInt8: function() { return /* binding */ UInt8; },\n/* harmony export */   Void: function() { return /* binding */ Void; },\n/* harmony export */   Word16: function() { return /* binding */ Word16; },\n/* harmony export */   Word32: function() { return /* binding */ Word32; },\n/* harmony export */   Word64: function() { return /* binding */ Word64; },\n/* harmony export */   Word8: function() { return /* binding */ Word8; },\n/* harmony export */   _Array: function() { return /* binding */ _Array; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED$1 = \"UPDATED\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED$1);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS.warn : LEVELS.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\nconst type = (label, asArgument, asInjection) => ({\n  label,\n  asArgument,\n  asInjection\n});\nconst isArray = d => Array.isArray(d);\nconst isObj = d => typeof d === \"object\";\nconst isNull = d => d == null;\nconst isBoolean = d => typeof d === \"boolean\";\nconst isNumber = d => typeof d === \"number\";\nconst isInteger = d => Number.isInteger(d);\nconst isString = d => typeof d === \"string\";\nconst throwTypeError = msg => {\n  throw new Error(\"Type Error: \" + msg);\n};\nconst numberValuesDeprecationNotice = type => {\n  log.deprecate({\n    pkg: \"@onflow/types\",\n    subject: `Passing in Number as value for ${type}`,\n    message: `Going forward, use String as value for ${type}.`,\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number\"\n  });\n};\nconst Identity = type(\"Identity\", v => v, v => v);\nconst UInt = type(\"UInt\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt\");\n    return {\n      type: \"UInt\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected Positive Integer for type Unsigned Int\");\n}, v => v);\nconst Int = type(\"Int\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int\");\n    return {\n      type: \"Int\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected Integer for type Int\");\n}, v => v);\nconst UInt8 = type(\"UInt8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt8\");\n    return {\n      type: \"UInt8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt8\");\n}, v => v);\nconst Int8 = type(\"Int8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int8\");\n    return {\n      type: \"Int8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int8\");\n}, v => v);\nconst UInt16 = type(\"UInt16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt16\");\n    return {\n      type: \"UInt16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt16\");\n}, v => v);\nconst Int16 = type(\"Int16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int16\");\n    return {\n      type: \"Int16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int16\");\n}, v => v);\nconst UInt32 = type(\"UInt32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt32\");\n    return {\n      type: \"UInt32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt32\");\n}, v => v);\nconst Int32 = type(\"Int32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int32\");\n    return {\n      type: \"Int32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int32\");\n}, v => v);\nconst UInt64 = type(\"UInt64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt64\");\n    return {\n      type: \"UInt64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt64\");\n}, v => v);\nconst Int64 = type(\"Int64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int64\");\n    return {\n      type: \"Int64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int64\");\n}, v => v);\nconst UInt128 = type(\"UInt128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt128\");\n    return {\n      type: \"UInt128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt128\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt128\");\n}, v => v);\nconst Int128 = type(\"Int128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int128\");\n    return {\n      type: \"Int128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int128\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int128\");\n}, v => v);\nconst UInt256 = type(\"UInt256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt256\");\n    return {\n      type: \"UInt256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt256\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt256\");\n}, v => v);\nconst Int256 = type(\"Int256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int256\");\n    return {\n      type: \"Int256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int256\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for Int256\");\n}, v => v);\nconst Word8 = type(\"Word8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word8\");\n    return {\n      type: \"Word8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word8\");\n}, v => v);\nconst Word16 = type(\"Word16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word16\");\n    return {\n      type: \"Word16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word16\");\n}, v => v);\nconst Word32 = type(\"Word32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word32\");\n    return {\n      type: \"Word32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word32\");\n}, v => v);\nconst Word64 = type(\"Word64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word64\");\n    return {\n      type: \"Word64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word64\");\n}, v => v);\nconst UFix64AndFix64NumberDeprecationNotice = () => {\n  log.deprecate({\n    subject: \"Passing in Numbers as values for Fix64 and UFix64 types\",\n    pkg: \"@onflow/types\",\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\"\n  });\n};\nconst UFix64 = type(\"UFix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"UFix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"UFix64\",\n      value: v.toString()\n    };\n  }\n  throwTypeError(\"Expected String for UFix64\");\n}, v => v);\nconst Fix64 = type(\"Fix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"Fix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"Fix64\",\n      value: v.toString()\n    };\n  }\n  throwTypeError(\"Expected String for Fix64\");\n}, v => v);\nconst String = type(\"String\", v => {\n  if (isString(v)) return {\n    type: \"String\",\n    value: v\n  };\n  throwTypeError(\"Expected String for type String\");\n}, v => v);\nconst Character = type(\"Character\", v => {\n  if (isString(v)) return {\n    type: \"Character\",\n    value: v\n  };\n  throwTypeError(\"Expected Character for type Character\");\n}, v => v);\nconst Bool = type(\"Bool\", v => {\n  if (isBoolean(v)) return {\n    type: \"Bool\",\n    value: v\n  };\n  throwTypeError(\"Expected Boolean for type Bool\");\n}, v => v);\nconst Address = type(\"Address\", v => {\n  if (isString(v)) return {\n    type: \"Address\",\n    value: v\n  };\n  throwTypeError(\"Expected Address for type Address\");\n}, v => v);\nconst Void = type(\"Void\", v => {\n  if (!v || isNull(v)) return {\n    type: \"Void\"\n  };\n  throwTypeError(\"Expected Void for type Void\");\n}, v => v);\nconst Optional = children => type(\"Optional\", v => ({\n  type: \"Optional\",\n  value: isNull(v) ? null : children.asArgument(v)\n}), v => v);\nconst Reference = type(\"Reference\", v => {\n  if (isObj(v)) return {\n    type: \"Reference\",\n    value: v\n  };\n  throwTypeError(\"Expected Object for type Reference\");\n}, v => v);\nconst _Array = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return type(\"Array\", v => {\n    return {\n      type: \"Array\",\n      value: isArray(children) ? children.map((c, i) => c.asArgument(v[i])) : v.map(x => children.asArgument(x))\n    };\n  }, v => v);\n};\nconst Dictionary = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return type(\"Dictionary\", v => {\n    if (isObj(v)) return {\n      type: \"Dictionary\",\n      value: isArray(children) ? children.map((c, i) => ({\n        key: c.key.asArgument(v[i].key),\n        value: c.value.asArgument(v[i].value)\n      })) : isArray(v) ? v.map(x => ({\n        key: children.key.asArgument(x.key),\n        value: children.value.asArgument(x.value)\n      })) : [{\n        key: children.key.asArgument(v.key),\n        value: children.value.asArgument(v.value)\n      }]\n    };\n    throwTypeError(\"Expected Object for type Dictionary\");\n  }, v => v);\n};\nconst Event = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Event\", v => {\n    if (isObj(v)) return {\n      type: \"Event\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Event\");\n  }, v => v);\n};\nconst Resource = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Resource\", v => {\n    if (isObj(v)) return {\n      type: \"Resource\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Resource\");\n  }, v => v);\n};\nconst Struct = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Struct\", v => {\n    if (isObj(v)) return {\n      type: \"Struct\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Struct\");\n  }, v => v);\n};\nconst Enum = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Enum\", v => {\n    if (isObj(v)) return {\n      type: \"Enum\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Enum\");\n  }, v => v);\n};\nconst Path = type(\"Path\", v => {\n  if (isObj(v)) {\n    if (!isString(v.domain)) {\n      throwTypeError(`Expected a string for the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    if (!(v.domain === \"storage\" || v.domain === \"private\" || v.domain === \"public\")) {\n      throwTypeError(`Expected either \"storage\", \"private\" or \"public\" as the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    if (!isString(v.identifier)) {\n      throwTypeError(`Expected a string for the Path identifier but found ${v.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    return {\n      type: \"Path\",\n      value: {\n        domain: v.domain,\n        identifier: v.identifier\n      }\n    };\n  }\n  throwTypeError(\"Expected Object for type Path\");\n}, v => v);\n\n\n//# sourceMappingURL=types.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy90eXBlcy9kaXN0L3R5cGVzLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzSEFBc0gscUJBQU0sbUJBQW1CLHFCQUFNOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHFCQUFNLGlCQUFpQixxQkFBTSxZQUFZLHFCQUFNLElBQUkscUJBQU07QUFDdkksbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxRQUFRO0FBQ1IseUJBQXlCLFlBQVk7QUFDckMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0EsZ0lBQWdJLGtCQUFrQjtBQUNsSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQSxnSUFBZ0ksa0JBQWtCO0FBQ2xKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsU0FBUztBQUNqRjtBQUNBO0FBQ0Esc0dBQXNHLFNBQVM7QUFDL0c7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFK1M7QUFDaFQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdHlwZXMvZGlzdC90eXBlcy5tb2R1bGUuanM/YmE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2U7XG52YXIgcXVldWVNaWNyb3Rhc2tfMSA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBjb21tb25qc0dsb2JhbClcbi8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbjogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpLnRoZW4oY2IpLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgdGhyb3cgZXJyO1xufSwgMCkpO1xuXG5jb25zdCBtYWlsYm94ID0gKCkgPT4ge1xuICBjb25zdCBxdWV1ZSA9IFtdO1xuICB2YXIgbmV4dDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBkZWxpdmVyKG1zZykge1xuICAgICAgcXVldWUucHVzaChtc2cpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dChxdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlY2VpdmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gaW5uZXJSZWNlaXZlKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgbXNnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG1zZykgcmV0dXJuIHJlc29sdmUobXNnKTtcbiAgICAgICAgbmV4dCA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgSU5JVCA9IFwiSU5JVFwiO1xuY29uc3QgU1VCU0NSSUJFID0gXCJTVUJTQ1JJQkVcIjtcbmNvbnN0IFVOU1VCU0NSSUJFID0gXCJVTlNVQlNDUklCRVwiO1xuY29uc3QgVVBEQVRFRCQxID0gXCJVUERBVEVEXCI7XG5jb25zdCBFWElUID0gXCJFWElUXCI7XG5jb25zdCBURVJNSU5BVEUgPSBcIlRFUk1JTkFURVwiO1xuY29uc3Qgcm9vdCA9IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fCB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvdyAmJiB3aW5kb3c7XG5yb290LkZDTF9SRUdJU1RSWSA9IHJvb3QuRkNMX1JFR0lTVFJZID09IG51bGwgPyB7fSA6IHJvb3QuRkNMX1JFR0lTVFJZO1xudmFyIHBpZCA9IDBiMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBzZW5kID0gZnVuY3Rpb24gKGFkZHIsIHRhZywgZGF0YSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVwbHksIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGV4cGVjdFJlcGx5ID0gb3B0cy5leHBlY3RSZXBseSB8fCBmYWxzZTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0cy50aW1lb3V0ICE9IG51bGwgPyBvcHRzLnRpbWVvdXQgOiBERUZBVUxUX1RJTUVPVVQ7XG4gICAgaWYgKGV4cGVjdFJlcGx5ICYmIHRpbWVvdXQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dDogJHt0aW1lb3V0fW1zIHBhc3NlZCB3aXRob3V0IGEgcmVzcG9uc2UuYCkpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHRvOiBhZGRyLFxuICAgICAgZnJvbTogb3B0cy5mcm9tLFxuICAgICAgdGFnLFxuICAgICAgZGF0YSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICByZXBseSxcbiAgICAgIHJlamVjdFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLm1haWxib3guZGVsaXZlcihwYXlsb2FkKTtcbiAgICAgIGlmICghZXhwZWN0UmVwbHkpIHJlcGx5KHRydWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRkNMLkFjdG9yIC0tIENvdWxkIE5vdCBEZWxpdmVyIE1lc3NhZ2VcIiwgcGF5bG9hZCwgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0sIGVycm9yKTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGtpbGwgPSBhZGRyID0+IHtcbiAgZGVsZXRlIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdO1xufTtcbmNvbnN0IGZyb21IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGhhbmRsZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGFzeW5jIGN0eCA9PiB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyc1tJTklUXSA9PT0gXCJmdW5jdGlvblwiKSBhd2FpdCBoYW5kbGVyc1tJTklUXShjdHgpO1xuICAgIF9fbG9vcDogd2hpbGUgKDEpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGF3YWl0IGN0eC5yZWNlaXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobGV0dGVyLnRhZyA9PT0gRVhJVCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlcnNbVEVSTUlOQVRFXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyc1tURVJNSU5BVEVdKGN0eCwgbGV0dGVyLCBsZXR0ZXIuZGF0YSB8fCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrIF9fbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBoYW5kbGVyc1tsZXR0ZXIudGFnXShjdHgsIGxldHRlciwgbGV0dGVyLmRhdGEgfHwge30pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgJHtjdHguc2VsZigpfSBFcnJvcmAsIGxldHRlciwgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29udGludWUgX19sb29wO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBzcGF3biA9IGZ1bmN0aW9uIChmbikge1xuICBsZXQgYWRkciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgaWYgKGFkZHIgPT0gbnVsbCkgYWRkciA9ICsrcGlkO1xuICBpZiAocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gIT0gbnVsbCkgcmV0dXJuIGFkZHI7XG4gIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdID0ge1xuICAgIGFkZHIsXG4gICAgbWFpbGJveDogbWFpbGJveCgpLFxuICAgIHN1YnM6IG5ldyBTZXQoKSxcbiAgICBrdnM6IHt9LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBzZWxmOiAoKSA9PiBhZGRyLFxuICAgIHJlY2VpdmU6ICgpID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLm1haWxib3gucmVjZWl2ZSgpLFxuICAgIHNlbmQ6IGZ1bmN0aW9uICh0bywgdGFnLCBkYXRhKSB7XG4gICAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICBvcHRzLmZyb20gPSBhZGRyO1xuICAgICAgcmV0dXJuIHNlbmQodG8sIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBzZW5kU2VsZjogKHRhZywgZGF0YSwgb3B0cykgPT4ge1xuICAgICAgaWYgKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdKSBzZW5kKGFkZHIsIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIG9wdHMuZnJvbSA9IGFkZHI7XG4gICAgICBmb3IgKGxldCB0byBvZiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzKSBzZW5kKHRvLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBzdWIgPT4gc3ViICE9IG51bGwgJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5hZGQoc3ViKSxcbiAgICB1bnN1YnNjcmliZTogc3ViID0+IHN1YiAhPSBudWxsICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuZGVsZXRlKHN1YiksXG4gICAgc3Vic2NyaWJlckNvdW50OiAoKSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLnNpemUsXG4gICAgaGFzU3ViczogKCkgPT4gISFyb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLnNpemUsXG4gICAgcHV0OiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiAoa2V5LCBmYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gZmFsbGJhY2sgOiB2YWx1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZToga2V5ID0+IHtcbiAgICAgIGRlbGV0ZSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XTtcbiAgICB9LFxuICAgIHVwZGF0ZTogKGtleSwgZm4pID0+IHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSBmbihyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSk7XG4gICAgfSxcbiAgICBrZXlzOiAoKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzKTtcbiAgICB9LFxuICAgIGFsbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cztcbiAgICB9LFxuICAgIHdoZXJlOiBwYXR0ZXJuID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChrZXkpID8ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBba2V5XTogcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV1cbiAgICAgICAgfSA6IGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IGRhdGFba2V5XSk7XG4gICAgfSxcbiAgICBmYXRhbEVycm9yOiBlcnJvciA9PiB7XG4gICAgICByb290LkZDTF9SRUdJU1RSWVthZGRyXS5lcnJvciA9IGVycm9yO1xuICAgICAgZm9yIChsZXQgdG8gb2Ygcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicykgc2VuZCh0bywgVVBEQVRFRCQxKTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgZm4gPT09IFwib2JqZWN0XCIpIGZuID0gZnJvbUhhbmRsZXJzKGZuKTtcbiAgcXVldWVNaWNyb3Rhc2tfMShhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZm4oY3R4KTtcbiAgICBraWxsKGFkZHIpO1xuICB9KTtcbiAgcmV0dXJuIGFkZHI7XG59O1xuXG4vLyBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4vLyBBIFNVQlNDUklCRSBoYW5kbGVyIHdpbGwgbmVlZCB0byBiZSBjcmVhdGVkIHRvIGhhbmRsZSB0aGUgc3Vic2NyaXB0aW9uIGV2ZW50XG4vL1xuLy8gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbi8vICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pXG4vLyAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCwgY3R4LmFsbCgpKVxuLy8gIH1cbi8vXG5mdW5jdGlvbiBzdWJzY3JpYmVyKGFkZHJlc3MsIHNwYXduRm4sIGNhbGxiYWNrKSB7XG4gIHNwYXduRm4oYWRkcmVzcyk7XG4gIGNvbnN0IEVYSVQgPSBcIkBFWElUXCI7XG4gIGNvbnN0IHNlbGYgPSBzcGF3bihhc3luYyBjdHggPT4ge1xuICAgIGN0eC5zZW5kKGFkZHJlc3MsIFNVQlNDUklCRSk7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGF3YWl0IGN0eC5yZWNlaXZlKCk7XG4gICAgICBjb25zdCBlcnJvciA9IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJlc3NdLmVycm9yO1xuICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgY3R4LnNlbmQoYWRkcmVzcywgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZXJyb3IpO1xuICAgICAgICBjdHguc2VuZChhZGRyZXNzLCBVTlNVQlNDUklCRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGxldHRlci5kYXRhLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gc2VuZChzZWxmLCBFWElUKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIGZhY3QgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yIHdpdGggaW52YXJpYW50IG1lc3NhZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZmFjdFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICogQHBhcmFtIHtBcnJheX0gcmVzdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudChmYWN0LCBtc2cpIHtcbiAgaWYgKCFmYWN0KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYElOVkFSSUFOVCAke21zZ31gKTtcbiAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihkID0+ICEvYXQgaW52YXJpYW50Ly50ZXN0KGQpKS5qb2luKFwiXFxuXCIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHJlc3RbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKFwiXFxuXFxuLS0tXFxuXFxuXCIsIGVycm9yLCBcIlxcblxcblwiLCAuLi5yZXN0LCBcIlxcblxcbi0tLVxcblxcblwiKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuY29uc3QgcGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiB2ID0+IHtcbiAgICByZXR1cm4gZnVuY3MucmVkdWNlKChyZXMsIGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiBmdW5jKHJlcyk7XG4gICAgfSwgdik7XG4gIH07XG59O1xuXG4vKioqXG4gKiBNZXJnZSBtdWx0aXBsZSBmdW5jdGlvbnMgcmV0dXJuaW5nIG9iamVjdHMgaW50byBvbmUgb2JqZWN0LlxuICogQHBhcmFtIHsuLi5mdW5jdGlvbigqKTogb2JqZWN0fSBmdW5jcyAtIEZ1bmN0aW9ucyB0byBtZXJnZVxuICogQHJldHVybiB7b2JqZWN0fSAtIE1lcmdlZCBvYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIC4uLmZ1bmModilcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gT2JqZWN0IGNoZWNrXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIG9iamVjdCBzdGF0dXNcbiAqL1xuY29uc3QgaXNPYmplY3QgPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHsuLi5vYmplY3RbXX0gc291cmNlcyAtIFNvdXJjZSBvYmplY3RzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBvYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VEZWVwID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNvdXJjZXNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIGlmICghdGFyZ2V0W2tleV0pIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG4gICAgICAgICAgW2tleV06IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG4gICAgICAgICAgW2tleV06IHNvdXJjZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VEZWVwKHRhcmdldCwgLi4uc291cmNlcyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIEZsb3cgSlNPTi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBGbG93IEpTT05cbiAqL1xuY29uc3QgbWVyZ2VGbG93SlNPTnMgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG1lcmdlRGVlcCh7fSwgLi4udmFsdWUpIDogdmFsdWU7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZpbHRlciBvdXQgY29udHJhY3RzIHNlY3Rpb24gb2YgZmxvdy5qc29uLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IG9iaiAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0cyBzZWN0aW9uIG9mIEZsb3cgSlNPTlxuICovXG5jb25zdCBmaWx0ZXJDb250cmFjdHMgPSBvYmogPT4gb2JqLmNvbnRyYWN0cyA/IG9iai5jb250cmFjdHMgOiB7fTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2F0aGVycyBjb250cmFjdCBhZGRyZXNzZXMgYnkgbmV0d29ya1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGdhdGhlciBhZGRyZXNzZXMgZm9yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0IG5hbWVzIGJ5IGFkZHJlc3NlcyBtYXBwaW5nIGUuZyB7IFwiSGVsbG9Xb3JsZFwiOiBcIjB4MTIzXCIgfVxuICovXG5jb25zdCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzID0gbmV0d29yayA9PiBjb250cmFjdHMgPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY29udHJhY3RzKS5yZWR1Y2UoKGMsIF9yZWYpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJhY3RBbGlhcyA9IHZhbHVlPy5hbGlhc2VzPy5bbmV0d29ya107XG4gICAgaWYgKG5ldHdvcmtDb250cmFjdEFsaWFzKSB7XG4gICAgICBjW2tleV0gPSBuZXR3b3JrQ29udHJhY3RBbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sIHt9KTtcbn07XG5jb25zdCBtYXBEZXBsb3ltZW50c1RvTmV0d29ya0FkZHJlc3MgPSBuZXR3b3JrID0+IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBkZXBsb3ltZW50cyA9IHt9LFxuICAgIGFjY291bnRzID0ge31cbiAgfSA9IF9yZWYyO1xuICBjb25zdCBuZXR3b3JrRGVwbG95bWVudCA9IGRlcGxveW1lbnRzPy5bbmV0d29ya107XG4gIGlmICghbmV0d29ya0RlcGxveW1lbnQpIHJldHVybiB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG5ldHdvcmtEZXBsb3ltZW50KS5yZWR1Y2UoKGMsIF9yZWYzKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYzO1xuICAgIC8vIFJlc29sdmUgYWNjb3VudCBhZGRyZXNzXG4gICAgY29uc3QgYWNjb3VudEFkZHJlc3MgPSBhY2NvdW50c1trZXldPy5hZGRyZXNzO1xuICAgIGlmICghYWNjb3VudEFkZHJlc3MpIHJldHVybiBjO1xuXG4gICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBhc3NpZ25pbmcgdGhlIGFkZHJlc3MgdG8gdGhlIGNvbnRyYWN0IG5hbWUuXG4gICAgcmV0dXJuIHZhbHVlLnJlZHVjZSgoYywgY29udHJhY3QpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIFtjb250cmFjdF06IGFjY291bnRBZGRyZXNzXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBpbiBmbG93Lmpzb24gZmlsZXMgYW5kIHJldHVybiBjb250cmFjdCB0byBhZGRyZXNzIG1hcHBpbmcgYnkgbmV0d29ya1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGpzb25zIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBnYXRoZXIgYWRkcmVzc2VzIGZvclxuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdCBuYW1lcyBieSBhZGRyZXNzZXMgbWFwcGluZyBlLmcgeyBcIkhlbGxvV29ybGRcIjogXCIweDEyM1wiIH1cbiAqL1xuY29uc3QgZ2V0Q29udHJhY3RzID0gKGpzb25zLCBuZXR3b3JrKSA9PiB7XG4gIHJldHVybiBwaXBlKG1lcmdlRmxvd0pTT05zLCBtZXJnZVBpcGUobWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzKG5ldHdvcmspLCBwaXBlKGZpbHRlckNvbnRyYWN0cywgbWFwQ29udHJhY3RBbGlhc2VzVG9OZXR3b3JrQWRkcmVzcyhuZXR3b3JrKSkpKShqc29ucyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgc3RyaW5nIGlzIGhleGlkZWNpbWFsXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBJcyBoZXhpZGVjaW1hbCBzdGF0dXNcbiAqL1xuY29uc3QgaXNIZXhpZGVjaW1hbCA9IHN0ciA9PiB7XG4gIC8vIENoZWNrIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIC9eWzAtOUEtRmEtZl0rJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGZsb3cuanNvbiBmaWxlIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBmbG93SlNPTiAtIEZsb3cgSlNPTlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgaGFzUHJpdmF0ZUtleXMgPSBmbG93SlNPTiA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmbG93SlNPTj8uYWNjb3VudHMpLnJlZHVjZSgoaGFzUHJpdmF0ZUtleSwgX3JlZjQpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjQ7XG4gICAgaWYgKGhhc1ByaXZhdGVLZXkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB2YWx1ZT8uaGFzT3duUHJvcGVydHkoXCJrZXlcIikgJiYgaXNIZXhpZGVjaW1hbCh2YWx1ZT8ua2V5KTtcbiAgfSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjaGVja3MgZm9yIHByaXZhdGUga2V5c1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHZhbHVlIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhhcyBwcml2YXRlIGtleXMgc3RhdHVzXG4gKi9cbmNvbnN0IGFueUhhc1ByaXZhdGVLZXlzID0gdmFsdWUgPT4ge1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSByZXR1cm4gaGFzUHJpdmF0ZUtleXModmFsdWUpO1xuICByZXR1cm4gdmFsdWUuc29tZShoYXNQcml2YXRlS2V5cyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGb3JtYXQgbmV0d29yayB0byBhbHdheXMgYmUgJ2VtdWxhdG9yJywgJ3Rlc3RuZXQnLCBvciAnbWFpbm5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBmb3JtYXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRm9ybWF0dGVkIG5ldHdvcmsgbmFtZSAoZWl0aGVyICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnKVxuICovXG5jb25zdCBjbGVhbk5ldHdvcmsgPSBuZXR3b3JrID0+IG5ldHdvcms/LnRvTG93ZXJDYXNlKCkgPT09IFwibG9jYWxcIiA/IFwiZW11bGF0b3JcIiA6IG5ldHdvcms/LnRvTG93ZXJDYXNlKCk7XG5jb25zdCBOQU1FID0gXCJjb25maWdcIjtcbmNvbnN0IFBVVCA9IFwiUFVUX0NPTkZJR1wiO1xuY29uc3QgR0VUID0gXCJHRVRfQ09ORklHXCI7XG5jb25zdCBHRVRfQUxMID0gXCJHRVRfQUxMX0NPTkZJR1wiO1xuY29uc3QgVVBEQVRFID0gXCJVUERBVEVfQ09ORklHXCI7XG5jb25zdCBERUxFVEUgPSBcIkRFTEVURV9DT05GSUdcIjtcbmNvbnN0IENMRUFSID0gXCJDTEVBUl9DT05GSUdcIjtcbmNvbnN0IFdIRVJFID0gXCJXSEVSRV9DT05GSUdcIjtcbmNvbnN0IFVQREFURUQgPSBcIkNPTkZJRy9VUERBVEVEXCI7XG5jb25zdCBpZGVudGl0eSA9IHYgPT4gdjtcbmNvbnN0IEhBTkRMRVJTID0ge1xuICBbUFVUXTogKGN0eCwgX2xldHRlciwgX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZVxuICAgIH0gPSBfcmVmO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL3B1dC5cIik7XG4gICAgY3R4LnB1dChrZXksIHZhbHVlKTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbR0VUXTogKGN0eCwgbGV0dGVyLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmYWxsYmFja1xuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9nZXRcIik7XG4gICAgbGV0dGVyLnJlcGx5KGN0eC5nZXQoa2V5LCBmYWxsYmFjaykpO1xuICB9LFxuICBbR0VUX0FMTF06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldHRlci5yZXBseSh7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VQREFURV06IChjdHgsIGxldHRlciwgX3JlZjMpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgZm5cbiAgICB9ID0gX3JlZjM7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvdXBkYXRlXCIpO1xuICAgIGN0eC51cGRhdGUoa2V5LCBmbiB8fCBpZGVudGl0eSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0RFTEVURV06IChjdHgsIGxldHRlciwgX3JlZjQpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5XG4gICAgfSA9IF9yZWY0O1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL2RlbGV0ZVwiKTtcbiAgICBjdHguZGVsZXRlKGtleSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0NMRUFSXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhjdHguYWxsKCkpO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSBjdHguZGVsZXRlKGtleSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1dIRVJFXTogKGN0eCwgbGV0dGVyLCBfcmVmNSkgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXR0ZXJuXG4gICAgfSA9IF9yZWY1O1xuICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ3BhdHRlcm4nIGZvciBjb25maWcvd2hlcmVcIik7XG4gICAgbGV0dGVyLnJlcGx5KGN0eC53aGVyZShwYXR0ZXJuKSk7XG4gIH0sXG4gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC51bnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gIH1cbn07XG5zcGF3bihIQU5ETEVSUywgTkFNRSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEFkZHMgYSBrZXktdmFsdWUgcGFpciB0byB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYWRkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICBzZW5kKE5BTUUsIFBVVCwge1xuICAgIGtleSxcbiAgICB2YWx1ZVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZygpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIGEga2V5LXZhbHVlIHBhaXIgd2l0aCBhIGZhbGxiYWNrIGZyb20gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0geyp9IFtmYWxsYmFja10gLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgR0VULCB7XG4gICAga2V5LFxuICAgIGZhbGxiYWNrXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgZmlyc3Qgbm9uIG51bGwgY29uZmlnIHZhbHVlIG9yIHRoZSBmYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmdbXX0gd2FudHMgLSBUaGUga2V5cyB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0geyp9IGZhbGxiYWNrIC0gVGhlIGZhbGxiYWNrIHZhbHVlIHRvIHJldHVybiBpZiBrZXkgaXMgbm90IGZvdW5kXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBUaGUgdmFsdWUgZm91bmQgYXQga2V5IG9yIGZhbGxiYWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpcnN0KCkge1xuICBsZXQgd2FudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgaWYgKCF3YW50cy5sZW5ndGgpIHJldHVybiBmYWxsYmFjaztcbiAgY29uc3QgW2hlYWQsIC4uLnJlc3RdID0gd2FudHM7XG4gIGNvbnN0IHJldCA9IGF3YWl0IGdldChoZWFkKTtcbiAgaWYgKHJldCA9PSBudWxsKSByZXR1cm4gZmlyc3QocmVzdCwgZmFsbGJhY2spO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZ1xuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsKCkge1xuICByZXR1cm4gc2VuZChOQU1FLCBHRVRfQUxMLCBudWxsLCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKGtleSkge1xuICBsZXQgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkZW50aXR5O1xuICBzZW5kKE5BTUUsIFVQREFURSwge1xuICAgIGtleSxcbiAgICBmblxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZygpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWxldGVzIGEga2V5LXZhbHVlIHBhaXIgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBkZWxldGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gIHNlbmQoTkFNRSwgREVMRVRFLCB7XG4gICAga2V5XG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIGNvbmZpZyBiYXNlZCBvbiBhIHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2gga2V5cyBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBzdWJzZXQgb2YgdGhlIGNvbmZpZ1xuICovXG5mdW5jdGlvbiB3aGVyZShwYXR0ZXJuKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIFdIRVJFLCB7XG4gICAgcGF0dGVyblxuICB9LCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFN1YnNjcmliZXMgdG8gY29uZmlnIHVwZGF0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBjb25maWcgaXMgdXBkYXRlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIFRoZSB1bnN1YnNjcmliZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHN1YnNjcmliZXIoTkFNRSwgKCkgPT4gc3Bhd24oSEFORExFUlMsIE5BTUUpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENsZWFycyB0aGUgY29uZmlnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gY2xlYXJDb25maWcoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIENMRUFSKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmVzZXRzIHRoZSBjb25maWcgdG8gYSBwcmV2aW91cyBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9sZENvbmZpZyAtIFRoZSBwcmV2aW91cyBjb25maWcgc3RhdGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHJlc2V0Q29uZmlnKG9sZENvbmZpZykge1xuICByZXR1cm4gY2xlYXJDb25maWcoKS50aGVuKGNvbmZpZyhvbGRDb25maWcpKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZXMgaW4gZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlcyBhbmQgY3JlYXRlcyBjb250cmFjdCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBkYXRhIC0gVGhlIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkKGRhdGEpIHtcbiAgY29uc3QgbmV0d29yayA9IGF3YWl0IGdldChcImZsb3cubmV0d29ya1wiKTtcbiAgY29uc3QgY2xlYW5lZE5ldHdvcmsgPSBjbGVhbk5ldHdvcmsobmV0d29yayk7XG4gIGNvbnN0IHtcbiAgICBmbG93SlNPTlxuICB9ID0gZGF0YTtcbiAgaW52YXJpYW50KEJvb2xlYW4oZmxvd0pTT04pLCBcImNvbmZpZy5sb2FkIC0tICdmbG93SlNPTicgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQoY2xlYW5lZE5ldHdvcmssIGBGbG93IE5ldHdvcmsgUmVxdWlyZWQgLS0gSW4gb3JkZXIgZm9yIEZDTCB0byBsb2FkIHlvdXIgY29udHJhY3RzIHBsZWFzZSBkZWZpbmUgXCJmbG93Lm5ldHdvcmtcIiB0byBcImVtdWxhdG9yXCIsIFwibG9jYWxcIiwgXCJ0ZXN0bmV0XCIsIG9yIFwibWFpbm5ldFwiIGluIHlvdXIgY29uZmlnLiBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3BlcnMuZmxvdy5jb20vdG9vbHMvZmNsLWpzL3JlZmVyZW5jZS9jb25maWd1cmUtZmNsYCk7XG4gIGlmIChhbnlIYXNQcml2YXRlS2V5cyhmbG93SlNPTikpIHtcbiAgICBjb25zdCBpc0VtdWxhdG9yID0gY2xlYW5lZE5ldHdvcmsgPT09IFwiZW11bGF0b3JcIjtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6IFwiUHJpdmF0ZSBLZXlzIERldGVjdGVkXCIsXG4gICAgICBtZXNzYWdlOiBgUHJpdmF0ZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBmbG93Lmpzb24gZmlsZSBmb3Igc2VjdXJpdHkuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mbG93LWNsaS9zZWN1cml0eWAsXG4gICAgICBsZXZlbDogaXNFbXVsYXRvciA/IExFVkVMUy53YXJuIDogTEVWRUxTLmVycm9yXG4gICAgfSk7XG4gICAgaWYgKCFpc0VtdWxhdG9yKSByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZ2V0Q29udHJhY3RzKGZsb3dKU09OLCBjbGVhbmVkTmV0d29yaykpKSB7XG4gICAgY29uc3QgY29udHJhY3RDb25maWdLZXkgPSBgMHgke2tleX1gO1xuICAgIGNvbnN0IGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgPSBhd2FpdCBnZXQoY29udHJhY3RDb25maWdLZXkpO1xuICAgIGlmIChleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ICYmIGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgIT09IHZhbHVlKSB7XG4gICAgICBsb2coe1xuICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBDb25mbGljdCBEZXRlY3RlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQSBnZW5lcmF0ZWQgY29udHJhY3QgcGxhY2Vob2xkZXIgZnJvbSBjb25maWcubG9hZCBjb25mbGljdHMgd2l0aCBhIHBsYWNlaG9sZGVyIHlvdSd2ZSBzZXQgbWFudWFsbHkgaW4gY29uZmlnIGhhdmUgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICBsZXZlbDogTEVWRUxTLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoY29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtQ29udHJhY3RDb25maWdLZXkgPSBgc3lzdGVtLmNvbnRyYWN0cy4ke2tleX1gO1xuICAgIGNvbnN0IHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSA9IGF3YWl0IGdldChzeXN0ZW1Db250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAmJiBzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBsb2coe1xuICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBDb25mbGljdCBEZXRlY3RlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQSBnZW5lcmF0ZWQgY29udHJhY3QgcGxhY2Vob2xkZXIgZnJvbSBjb25maWcubG9hZCBjb25mbGljdHMgd2l0aCBhIHBsYWNlaG9sZGVyIHlvdSd2ZSBzZXQgbWFudWFsbHkgaW4gY29uZmlnIGhhdmUgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICBsZXZlbDogTEVWRUxTLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoc3lzdGVtQ29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtcmV0dXJuc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc10gLSBUaGUgdmFsdWVzIHRvIHNldFxuICovXG5mdW5jdGlvbiBjb25maWcodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZCA9PiBwdXQoZCwgdmFsdWVzW2RdKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdXQsXG4gICAgZ2V0LFxuICAgIGFsbCxcbiAgICBmaXJzdCxcbiAgICB1cGRhdGUsXG4gICAgZGVsZXRlOiBfZGVsZXRlLFxuICAgIHdoZXJlLFxuICAgIHN1YnNjcmliZSxcbiAgICBvdmVybG9hZCxcbiAgICBsb2FkXG4gIH07XG59XG5jb25maWcucHV0ID0gcHV0O1xuY29uZmlnLmdldCA9IGdldDtcbmNvbmZpZy5hbGwgPSBhbGw7XG5jb25maWcuZmlyc3QgPSBmaXJzdDtcbmNvbmZpZy51cGRhdGUgPSB1cGRhdGU7XG5jb25maWcuZGVsZXRlID0gX2RlbGV0ZTtcbmNvbmZpZy53aGVyZSA9IHdoZXJlO1xuY29uZmlnLnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbmNvbmZpZy5vdmVybG9hZCA9IG92ZXJsb2FkO1xuY29uZmlnLmxvYWQgPSBsb2FkO1xuY29uc3Qgbm9vcCA9IHYgPT4gdjtcbmZ1bmN0aW9uIG92ZXJsb2FkKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbGRDb25maWcgPSBhd2FpdCBhbGwoKTtcbiAgICB0cnkge1xuICAgICAgY29uZmlnKG9wdHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGF3YWl0IGFsbCgpKTtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGxldmVscyBvZiB0aGUgbG9nZ2VyXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExFVkVMU1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlYnVnIC0gVGhlIGRlYnVnIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5mbyAtIFRoZSBpbmZvIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG9nIC0gVGhlIGxvZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdhcm4gLSBUaGUgd2FybiBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVycm9yIC0gVGhlIGVycm9yIGxldmVsXG4gKiBcbiAqL1xuY29uc3QgTEVWRUxTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGRlYnVnOiA1LFxuICBpbmZvOiA0LFxuICBsb2c6IDMsXG4gIHdhcm46IDIsXG4gIGVycm9yOiAxXG59KTtcblxuLyoqXG4gKiBCdWlsZHMgYSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IC0gVGhlIG1lc3NhZ2UgZm9ybWF0dGVkIGZvciB0aGUgbG9nZ2VyXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIgfSlcbiAqL1xuY29uc3QgYnVpbGRMb2dnZXJNZXNzYWdlQXJncyA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbYFxuICAgICVjJHt0aXRsZX1cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAke21lc3NhZ2V9XG5cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgYC5yZXBsYWNlKC9cXG5bXlxcU1xcclxcbl0rL2csIFwiXFxuXCIpLnRyaW0oKSwsIFwiZm9udC13ZWlnaHQ6Ym9sZDtmb250LWZhbWlseTptb25vc3BhY2U7XCJdO1xufTtcblxuLyoqXG4gKiBMb2dzIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGxldmVsIHNldCBpbiB0aGUgY29uZmlnXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYWx3YXlzIC0gV2hldGhlciB0byBhbHdheXMgc2hvdyB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGFsd2F5czogZmFsc2UgfSlcbiAqIFxuICovXG5jb25zdCBsb2cgPSBhc3luYyBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZSxcbiAgICBsZXZlbCxcbiAgICBhbHdheXMgPSBmYWxzZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IGNvbmZpZ0xvZ2dlckxldmVsID0gYXdhaXQgY29uZmlnLmdldChcImxvZ2dlci5sZXZlbFwiLCBMRVZFTFMud2Fybik7XG5cbiAgLy8gSWYgY29uZmlnIGxldmVsIGlzIGJlbG93IG1lc3NhZ2UgbGV2ZWwgdGhlbiBkb24ndCBzaG93IGl0XG4gIGlmICghYWx3YXlzICYmIGNvbmZpZ0xvZ2dlckxldmVsIDwgbGV2ZWwpIHJldHVybjtcbiAgY29uc3QgbG9nZ2VyTWVzc2FnZUFyZ3MgPSBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlXG4gIH0pO1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBMRVZFTFMuZGVidWc6XG4gICAgICBjb25zb2xlLmRlYnVnKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLmluZm86XG4gICAgICBjb25zb2xlLmluZm8oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMud2FybjpcbiAgICAgIGNvbnNvbGUud2FybiguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy5lcnJvcjpcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUubG9nKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGEgZGVwcmVjYXRpb24gbm90aWNlXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBrZyAtIFRoZSBwYWNrYWdlIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdCAtIFRoZSBzdWJqZWN0IG9mIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHJhbnNpdGlvbiAtIFRoZSB0cmFuc2l0aW9uIHBhdGggZm9yIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBhZnRlciB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZy5kZXByZWNhdGUoeyBwa2c6IFwiQG9uZmxvdy9mY2xcIiwgc3ViamVjdDogXCJTb21lIGl0ZW1cIiwgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrXCIsIG1lc3NhZ2U6IFwiRGVzY3JpcHRpdmUgbWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGNhbGxiYWNrOiAoKSA9PiB7fSB9KVxuICogXG4gKi9cbmxvZy5kZXByZWNhdGUgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgcGtnLFxuICAgIHN1YmplY3QsXG4gICAgdHJhbnNpdGlvbixcbiAgICBsZXZlbCA9IExFVkVMUy53YXJuLFxuICAgIG1lc3NhZ2UgPSBcIlwiLFxuICAgIGNhbGxiYWNrID0gbnVsbFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgfTtcbiAgY29uc3QgbG9nTWVzc2FnZSA9ICgpID0+IGxvZyh7XG4gICAgdGl0bGU6IGAke3BrZyA/IHBrZyArIFwiIFwiIDogXCJcIn1EZXByZWNhdGlvbiBOb3RpY2VgLFxuICAgIG1lc3NhZ2U6IGBcbiAgICAgICR7c3ViamVjdCA/IGAke2NhcGl0YWxpemVGaXJzdExldHRlcihzdWJqZWN0KX0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBjZWFzZSB0byB3b3JrIGluIGZ1dHVyZSByZWxlYXNlcyR7cGtnID8gXCIgb2YgXCIgKyBwa2cgOiBcIlwifS5gIDogXCJcIn0ke21lc3NhZ2UgPyBcIlxcblwiICsgbWVzc2FnZSA6IFwiXCJ9JHt0cmFuc2l0aW9uID8gYFxcbllvdSBjYW4gbGVhcm4gbW9yZSAoaW5jbHVkaW5nIGEgZ3VpZGUgb24gY29tbW9uIHRyYW5zaXRpb24gcGF0aHMpIGhlcmU6ICR7dHJhbnNpdGlvbn1gIDogXCJcIn1cbiAgICBgLnRyaW0oKSxcbiAgICBsZXZlbFxuICB9KTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGxvZ01lc3NhZ2UoKTtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayguLi5hcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGxvZ01lc3NhZ2UoKTtcbn07XG5cbmNvbnN0IHR5cGUgPSAobGFiZWwsIGFzQXJndW1lbnQsIGFzSW5qZWN0aW9uKSA9PiAoe1xuICBsYWJlbCxcbiAgYXNBcmd1bWVudCxcbiAgYXNJbmplY3Rpb25cbn0pO1xuY29uc3QgaXNBcnJheSA9IGQgPT4gQXJyYXkuaXNBcnJheShkKTtcbmNvbnN0IGlzT2JqID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzTnVsbCA9IGQgPT4gZCA9PSBudWxsO1xuY29uc3QgaXNCb29sZWFuID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJib29sZWFuXCI7XG5jb25zdCBpc051bWJlciA9IGQgPT4gdHlwZW9mIGQgPT09IFwibnVtYmVyXCI7XG5jb25zdCBpc0ludGVnZXIgPSBkID0+IE51bWJlci5pc0ludGVnZXIoZCk7XG5jb25zdCBpc1N0cmluZyA9IGQgPT4gdHlwZW9mIGQgPT09IFwic3RyaW5nXCI7XG5jb25zdCB0aHJvd1R5cGVFcnJvciA9IG1zZyA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIlR5cGUgRXJyb3I6IFwiICsgbXNnKTtcbn07XG5jb25zdCBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZSA9IHR5cGUgPT4ge1xuICBsb2cuZGVwcmVjYXRlKHtcbiAgICBwa2c6IFwiQG9uZmxvdy90eXBlc1wiLFxuICAgIHN1YmplY3Q6IGBQYXNzaW5nIGluIE51bWJlciBhcyB2YWx1ZSBmb3IgJHt0eXBlfWAsXG4gICAgbWVzc2FnZTogYEdvaW5nIGZvcndhcmQsIHVzZSBTdHJpbmcgYXMgdmFsdWUgZm9yICR7dHlwZX0uYCxcbiAgICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvdHlwZXMvV0FSTklOR1MubWQjMDAwMi1bVV1JbnQqLWFuZC1Xb3JkKi1hcy1OdW1iZXJcIlxuICB9KTtcbn07XG5jb25zdCBJZGVudGl0eSA9IHR5cGUoXCJJZGVudGl0eVwiLCB2ID0+IHYsIHYgPT4gdik7XG5jb25zdCBVSW50ID0gdHlwZShcIlVJbnRcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgUG9zaXRpdmUgSW50ZWdlciBmb3IgdHlwZSBVbnNpZ25lZCBJbnRcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgSW50ID0gdHlwZShcIkludFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiSW50XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBJbnRlZ2VyIGZvciB0eXBlIEludFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50OCA9IHR5cGUoXCJVSW50OFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiVUludDhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDhcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVJbnQ4XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnRlZ2VyIGZvciBVSW50OFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQ4ID0gdHlwZShcIkludDhcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIkludDhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50OFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50OFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlciBmb3IgSW50OFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50MTYgPSB0eXBlKFwiVUludDE2XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJVSW50MTZcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDE2XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MTZcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIGludGVnZXIgZm9yIFVJbnQxNlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQxNiA9IHR5cGUoXCJJbnQxNlwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiSW50MTZcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyIGZvciBJbnQxNlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50MzIgPSB0eXBlKFwiVUludDMyXCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJVSW50MzJcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDMyXCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MzJcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIGludGVnZXIgZm9yIFVJbnQzMlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQzMiA9IHR5cGUoXCJJbnQzMlwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiSW50MzJcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MzJcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludDMyXCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyIGZvciBJbnQzMlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50NjQgPSB0eXBlKFwiVUludDY0XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJVSW50NjRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDY0XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50NjRcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIGludGVnZXIgZm9yIFVJbnQ2NFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQ2NCA9IHR5cGUoXCJJbnQ2NFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiSW50NjRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50NjRcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludDY0XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyIGZvciBJbnQ2NFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50MTI4ID0gdHlwZShcIlVJbnQxMjhcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnQxMjhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDEyOFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDEyOFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgVUludDEyOFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQxMjggPSB0eXBlKFwiSW50MTI4XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnQxMjhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MTI4XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQxMjhcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgZm9yIEludDEyOFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBVSW50MjU2ID0gdHlwZShcIlVJbnQyNTZcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnQyNTZcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDI1NlwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDI1NlwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgVUludDI1NlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQyNTYgPSB0eXBlKFwiSW50MjU2XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnQyNTZcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MjU2XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQyNTZcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIGludGVnZXIgZm9yIEludDI1NlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBXb3JkOCA9IHR5cGUoXCJXb3JkOFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiV29yZDhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDhcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIldvcmQ4XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIgZm9yIFdvcmQ4XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFdvcmQxNiA9IHR5cGUoXCJXb3JkMTZcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIldvcmQxNlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJXb3JkMTZcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIldvcmQxNlwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyIGZvciBXb3JkMTZcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgV29yZDMyID0gdHlwZShcIldvcmQzMlwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiV29yZDMyXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIldvcmQzMlwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDMyXCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIgZm9yIFdvcmQzMlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBXb3JkNjQgPSB0eXBlKFwiV29yZDY0XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJXb3JkNjRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDY0XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJXb3JkNjRcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciBmb3IgV29yZDY0XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVGaXg2NEFuZEZpeDY0TnVtYmVyRGVwcmVjYXRpb25Ob3RpY2UgPSAoKSA9PiB7XG4gIGxvZy5kZXByZWNhdGUoe1xuICAgIHN1YmplY3Q6IFwiUGFzc2luZyBpbiBOdW1iZXJzIGFzIHZhbHVlcyBmb3IgRml4NjQgYW5kIFVGaXg2NCB0eXBlc1wiLFxuICAgIHBrZzogXCJAb25mbG93L3R5cGVzXCIsXG4gICAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3R5cGVzL1dBUk5JTkdTLm1kIzAwMDEtW1VdRml4NjQtYXMtTnVtYmVyXCJcbiAgfSk7XG59O1xuY29uc3QgVUZpeDY0ID0gdHlwZShcIlVGaXg2NFwiLCB2ID0+IHtcbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgY29uc3QgdlBhcnRzID0gdi5zcGxpdChcIi5cIik7XG4gICAgaWYgKHZQYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBvbmUgZGVjaW1hbCBidXQgZm91bmQgJHt2UGFydHMubGVuZ3RofSBpbiB0aGUgW1VdRml4NjQgdmFsdWUuIEZpbmQgb3V0IG1vcmUgYWJvdXQgW1VdRml4NjQgdHlwZXMgaGVyZTogaHR0cHM6Ly9kb2NzLm9uZmxvdy5vcmcvY2FkZW5jZS9qc29uLWNhZGVuY2Utc3BlYy8jZml4ZWQtcG9pbnQtbnVtYmVyc2ApO1xuICAgIH1cbiAgICBpZiAodlBhcnRzWzFdLmxlbmd0aCA9PSAwIHx8IHZQYXJ0c1sxXS5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvd1R5cGVFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGRpZ2l0LCBhbmQgYXQgbW9zdCA4IGRpZ2l0cyBmb2xsb3dpbmcgdGhlIGRlY2ltYWwgb2YgdGhlIFtVXUZpeDY0IHZhbHVlIGJ1dCBmb3VuZCAke3ZQYXJ0c1sxXS5sZW5ndGh9IGRpZ2l0cy4gRmluZCBvdXQgbW9yZSBhYm91dCBbVV1GaXg2NCB0eXBlcyBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNmaXhlZC1wb2ludC1udW1iZXJzYCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBudW1iZXIgaXMgZXh0ZW5kZWQgdG8gOCBkZWNpbWFsIHBsYWNlcyBzbyBpdCBtYXRjaGVzIGNhZGVuY2UgZW5jb2Rpbmcgb2YgVUZpeCB2YWx1ZXNcbiAgICB2UGFydHNbMV0gPSB2UGFydHNbMV0ucGFkRW5kKDgsIFwiMFwiKTtcbiAgICB2ID0gdlBhcnRzLmpvaW4oXCIuXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVGaXg2NFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKHYpKSB7XG4gICAgVUZpeDY0QW5kRml4NjROdW1iZXJEZXByZWNhdGlvbk5vdGljZSgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVGaXg2NFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmcgZm9yIFVGaXg2NFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBGaXg2NCA9IHR5cGUoXCJGaXg2NFwiLCB2ID0+IHtcbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgY29uc3QgdlBhcnRzID0gdi5zcGxpdChcIi5cIik7XG4gICAgaWYgKHZQYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBvbmUgZGVjaW1hbCBidXQgZm91bmQgJHt2UGFydHMubGVuZ3RofSBpbiB0aGUgW1VdRml4NjQgdmFsdWUuIEZpbmQgb3V0IG1vcmUgYWJvdXQgW1VdRml4NjQgdHlwZXMgaGVyZTogaHR0cHM6Ly9kb2NzLm9uZmxvdy5vcmcvY2FkZW5jZS9qc29uLWNhZGVuY2Utc3BlYy8jZml4ZWQtcG9pbnQtbnVtYmVyc2ApO1xuICAgIH1cbiAgICBpZiAodlBhcnRzWzFdLmxlbmd0aCA9PSAwIHx8IHZQYXJ0c1sxXS5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvd1R5cGVFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGRpZ2l0LCBhbmQgYXQgbW9zdCA4IGRpZ2l0cyBmb2xsb3dpbmcgdGhlIGRlY2ltYWwgb2YgdGhlIFtVXUZpeDY0IHZhbHVlIGJ1dCBmb3VuZCAke3ZQYXJ0c1sxXS5sZW5ndGh9IGRpZ2l0cy4gRmluZCBvdXQgbW9yZSBhYm91dCBbVV1GaXg2NCB0eXBlcyBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNmaXhlZC1wb2ludC1udW1iZXJzYCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBudW1iZXIgaXMgZXh0ZW5kZWQgdG8gOCBkZWNpbWFsIHBsYWNlcyBzbyBpdCBtYXRjaGVzIGNhZGVuY2UgZW5jb2Rpbmcgb2YgRml4NjQgdmFsdWVzXG4gICAgdlBhcnRzWzFdID0gdlBhcnRzWzFdLnBhZEVuZCg4LCBcIjBcIik7XG4gICAgdiA9IHZQYXJ0cy5qb2luKFwiLlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGaXg2NFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKHYpKSB7XG4gICAgVUZpeDY0QW5kRml4NjROdW1iZXJEZXByZWNhdGlvbk5vdGljZSgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZpeDY0XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZyBmb3IgRml4NjRcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgU3RyaW5nID0gdHlwZShcIlN0cmluZ1wiLCB2ID0+IHtcbiAgaWYgKGlzU3RyaW5nKHYpKSByZXR1cm4ge1xuICAgIHR5cGU6IFwiU3RyaW5nXCIsXG4gICAgdmFsdWU6IHZcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmcgZm9yIHR5cGUgU3RyaW5nXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IENoYXJhY3RlciA9IHR5cGUoXCJDaGFyYWN0ZXJcIiwgdiA9PiB7XG4gIGlmIChpc1N0cmluZyh2KSkgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkNoYXJhY3RlclwiLFxuICAgIHZhbHVlOiB2XG4gIH07XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgQ2hhcmFjdGVyIGZvciB0eXBlIENoYXJhY3RlclwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBCb29sID0gdHlwZShcIkJvb2xcIiwgdiA9PiB7XG4gIGlmIChpc0Jvb2xlYW4odikpIHJldHVybiB7XG4gICAgdHlwZTogXCJCb29sXCIsXG4gICAgdmFsdWU6IHZcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBCb29sZWFuIGZvciB0eXBlIEJvb2xcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgQWRkcmVzcyA9IHR5cGUoXCJBZGRyZXNzXCIsIHYgPT4ge1xuICBpZiAoaXNTdHJpbmcodikpIHJldHVybiB7XG4gICAgdHlwZTogXCJBZGRyZXNzXCIsXG4gICAgdmFsdWU6IHZcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBBZGRyZXNzIGZvciB0eXBlIEFkZHJlc3NcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgVm9pZCA9IHR5cGUoXCJWb2lkXCIsIHYgPT4ge1xuICBpZiAoIXYgfHwgaXNOdWxsKHYpKSByZXR1cm4ge1xuICAgIHR5cGU6IFwiVm9pZFwiXG4gIH07XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgVm9pZCBmb3IgdHlwZSBWb2lkXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IE9wdGlvbmFsID0gY2hpbGRyZW4gPT4gdHlwZShcIk9wdGlvbmFsXCIsIHYgPT4gKHtcbiAgdHlwZTogXCJPcHRpb25hbFwiLFxuICB2YWx1ZTogaXNOdWxsKHYpID8gbnVsbCA6IGNoaWxkcmVuLmFzQXJndW1lbnQodilcbn0pLCB2ID0+IHYpO1xuY29uc3QgUmVmZXJlbmNlID0gdHlwZShcIlJlZmVyZW5jZVwiLCB2ID0+IHtcbiAgaWYgKGlzT2JqKHYpKSByZXR1cm4ge1xuICAgIHR5cGU6IFwiUmVmZXJlbmNlXCIsXG4gICAgdmFsdWU6IHZcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgUmVmZXJlbmNlXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IF9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGNoaWxkcmVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJBcnJheVwiLCB2ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgdmFsdWU6IGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKChjLCBpKSA9PiBjLmFzQXJndW1lbnQodltpXSkpIDogdi5tYXAoeCA9PiBjaGlsZHJlbi5hc0FyZ3VtZW50KHgpKVxuICAgIH07XG4gIH0sIHYgPT4gdik7XG59O1xuY29uc3QgRGljdGlvbmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGNoaWxkcmVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJEaWN0aW9uYXJ5XCIsIHYgPT4ge1xuICAgIGlmIChpc09iaih2KSkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgdmFsdWU6IGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICBrZXk6IGMua2V5LmFzQXJndW1lbnQodltpXS5rZXkpLFxuICAgICAgICB2YWx1ZTogYy52YWx1ZS5hc0FyZ3VtZW50KHZbaV0udmFsdWUpXG4gICAgICB9KSkgOiBpc0FycmF5KHYpID8gdi5tYXAoeCA9PiAoe1xuICAgICAgICBrZXk6IGNoaWxkcmVuLmtleS5hc0FyZ3VtZW50KHgua2V5KSxcbiAgICAgICAgdmFsdWU6IGNoaWxkcmVuLnZhbHVlLmFzQXJndW1lbnQoeC52YWx1ZSlcbiAgICAgIH0pKSA6IFt7XG4gICAgICAgIGtleTogY2hpbGRyZW4ua2V5LmFzQXJndW1lbnQodi5rZXkpLFxuICAgICAgICB2YWx1ZTogY2hpbGRyZW4udmFsdWUuYXNBcmd1bWVudCh2LnZhbHVlKVxuICAgICAgfV1cbiAgICB9O1xuICAgIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgT2JqZWN0IGZvciB0eXBlIERpY3Rpb25hcnlcIik7XG4gIH0sIHYgPT4gdik7XG59O1xuY29uc3QgRXZlbnQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgbGV0IGZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHJldHVybiB0eXBlKFwiRXZlbnRcIiwgdiA9PiB7XG4gICAgaWYgKGlzT2JqKHYpKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJFdmVudFwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmaWVsZHM6IGlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcy5tYXAoKGMsIGkpID0+ICh7XG4gICAgICAgICAgbmFtZTogdi5maWVsZHNbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogYy52YWx1ZS5hc0FyZ3VtZW50KHYuZmllbGRzW2ldLnZhbHVlKVxuICAgICAgICB9KSkgOiB2LmZpZWxkcy5tYXAoeCA9PiAoe1xuICAgICAgICAgIG5hbWU6IHgubmFtZSxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzLnZhbHVlLmFzQXJndW1lbnQoeC52YWx1ZSlcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfTtcbiAgICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIE9iamVjdCBmb3IgdHlwZSBFdmVudFwiKTtcbiAgfSwgdiA9PiB2KTtcbn07XG5jb25zdCBSZXNvdXJjZSA9IGZ1bmN0aW9uIChpZCkge1xuICBsZXQgZmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJSZXNvdXJjZVwiLCB2ID0+IHtcbiAgICBpZiAoaXNPYmoodikpIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlJlc291cmNlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGZpZWxkczogaXNBcnJheShmaWVsZHMpID8gZmllbGRzLm1hcCgoYywgaSkgPT4gKHtcbiAgICAgICAgICBuYW1lOiB2LmZpZWxkc1tpXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBjLnZhbHVlLmFzQXJndW1lbnQodi5maWVsZHNbaV0udmFsdWUpXG4gICAgICAgIH0pKSA6IHYuZmllbGRzLm1hcCh4ID0+ICh7XG4gICAgICAgICAgbmFtZTogeC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMudmFsdWUuYXNBcmd1bWVudCh4LnZhbHVlKVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgT2JqZWN0IGZvciB0eXBlIFJlc291cmNlXCIpO1xuICB9LCB2ID0+IHYpO1xufTtcbmNvbnN0IFN0cnVjdCA9IGZ1bmN0aW9uIChpZCkge1xuICBsZXQgZmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJTdHJ1Y3RcIiwgdiA9PiB7XG4gICAgaWYgKGlzT2JqKHYpKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJTdHJ1Y3RcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZmllbGRzOiBpc0FycmF5KGZpZWxkcykgPyBmaWVsZHMubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IHYuZmllbGRzW2ldLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGMudmFsdWUuYXNBcmd1bWVudCh2LmZpZWxkc1tpXS52YWx1ZSlcbiAgICAgICAgfSkpIDogdi5maWVsZHMubWFwKHggPT4gKHtcbiAgICAgICAgICBuYW1lOiB4Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcy52YWx1ZS5hc0FyZ3VtZW50KHgudmFsdWUpXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH07XG4gICAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgU3RydWN0XCIpO1xuICB9LCB2ID0+IHYpO1xufTtcbmNvbnN0IEVudW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgbGV0IGZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHJldHVybiB0eXBlKFwiRW51bVwiLCB2ID0+IHtcbiAgICBpZiAoaXNPYmoodikpIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkVudW1cIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZmllbGRzOiBpc0FycmF5KGZpZWxkcykgPyBmaWVsZHMubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IHYuZmllbGRzW2ldLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGMudmFsdWUuYXNBcmd1bWVudCh2LmZpZWxkc1tpXS52YWx1ZSlcbiAgICAgICAgfSkpIDogdi5maWVsZHMubWFwKHggPT4gKHtcbiAgICAgICAgICBuYW1lOiB4Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcy52YWx1ZS5hc0FyZ3VtZW50KHgudmFsdWUpXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH07XG4gICAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgRW51bVwiKTtcbiAgfSwgdiA9PiB2KTtcbn07XG5jb25zdCBQYXRoID0gdHlwZShcIlBhdGhcIiwgdiA9PiB7XG4gIGlmIChpc09iaih2KSkge1xuICAgIGlmICghaXNTdHJpbmcodi5kb21haW4pKSB7XG4gICAgICB0aHJvd1R5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yIHRoZSBQYXRoIGRvbWFpbiBidXQgZm91bmQgJHt2LmRvbWFpbn0uIEZpbmQgb3V0IG1vcmUgYWJvdXQgdGhlIFBhdGggdHlwZSBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNwYXRoYCk7XG4gICAgfVxuICAgIGlmICghKHYuZG9tYWluID09PSBcInN0b3JhZ2VcIiB8fCB2LmRvbWFpbiA9PT0gXCJwcml2YXRlXCIgfHwgdi5kb21haW4gPT09IFwicHVibGljXCIpKSB7XG4gICAgICB0aHJvd1R5cGVFcnJvcihgRXhwZWN0ZWQgZWl0aGVyIFwic3RvcmFnZVwiLCBcInByaXZhdGVcIiBvciBcInB1YmxpY1wiIGFzIHRoZSBQYXRoIGRvbWFpbiBidXQgZm91bmQgJHt2LmRvbWFpbn0uIEZpbmQgb3V0IG1vcmUgYWJvdXQgdGhlIFBhdGggdHlwZSBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNwYXRoYCk7XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmcodi5pZGVudGlmaWVyKSkge1xuICAgICAgdGhyb3dUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGZvciB0aGUgUGF0aCBpZGVudGlmaWVyIGJ1dCBmb3VuZCAke3YuaWRlbnRpZmllcn0uIEZpbmQgb3V0IG1vcmUgYWJvdXQgdGhlIFBhdGggdHlwZSBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNwYXRoYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhdGhcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGRvbWFpbjogdi5kb21haW4sXG4gICAgICAgIGlkZW50aWZpZXI6IHYuaWRlbnRpZmllclxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgUGF0aFwiKTtcbn0sIHYgPT4gdik7XG5cbmV4cG9ydCB7IEFkZHJlc3MsIF9BcnJheSBhcyBBcnJheSwgQm9vbCwgQ2hhcmFjdGVyLCBEaWN0aW9uYXJ5LCBFbnVtLCBFdmVudCwgRml4NjQsIElkZW50aXR5LCBJbnQsIEludDEyOCwgSW50MTYsIEludDI1NiwgSW50MzIsIEludDY0LCBJbnQ4LCBPcHRpb25hbCwgUGF0aCwgUmVmZXJlbmNlLCBSZXNvdXJjZSwgU3RyaW5nLCBTdHJ1Y3QsIFVGaXg2NCwgVUludCwgVUludDEyOCwgVUludDE2LCBVSW50MjU2LCBVSW50MzIsIFVJbnQ2NCwgVUludDgsIFZvaWQsIFdvcmQxNiwgV29yZDMyLCBXb3JkNjQsIFdvcmQ4LCBfQXJyYXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@onflow/types/dist/types.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-actor/dist/actor.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/@onflow/util-actor/dist/actor.module.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXIT: function() { return /* binding */ EXIT; },\n/* harmony export */   INIT: function() { return /* binding */ INIT; },\n/* harmony export */   SNAPSHOT: function() { return /* binding */ SNAPSHOT; },\n/* harmony export */   SUBSCRIBE: function() { return /* binding */ SUBSCRIBE; },\n/* harmony export */   TERMINATE: function() { return /* binding */ TERMINATE; },\n/* harmony export */   UNSUBSCRIBE: function() { return /* binding */ UNSUBSCRIBE; },\n/* harmony export */   UPDATED: function() { return /* binding */ UPDATED; },\n/* harmony export */   kill: function() { return /* binding */ kill; },\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   snapshoter: function() { return /* binding */ snapshoter; },\n/* harmony export */   spawn: function() { return /* binding */ spawn; },\n/* harmony export */   subscriber: function() { return /* binding */ subscriber; }\n/* harmony export */ });\n/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! queue-microtask */ \"./node_modules/queue-microtask/index.js\");\n/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(queue_microtask__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\n\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED = \"UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queue_microtask__WEBPACK_IMPORTED_MODULE_0___default()(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nfunction snapshoter(address, spawnFn) {\n  spawnFn(address);\n  return send(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\n\n\n//# sourceMappingURL=actor.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWFjdG9yL2Rpc3QvYWN0b3IubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBTSxpQkFBaUIscUJBQU0sWUFBWSxxQkFBTSxJQUFJLHFCQUFNO0FBQ3ZJLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsUUFBUTtBQUNSLHlCQUF5QixZQUFZO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQWM7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFdUg7QUFDdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1hY3Rvci9kaXN0L2FjdG9yLm1vZHVsZS5qcz8xYTU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBxdWV1ZU1pY3JvdGFzayBmcm9tICdxdWV1ZS1taWNyb3Rhc2snO1xuXG5jb25zdCBtYWlsYm94ID0gKCkgPT4ge1xuICBjb25zdCBxdWV1ZSA9IFtdO1xuICB2YXIgbmV4dDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBkZWxpdmVyKG1zZykge1xuICAgICAgcXVldWUucHVzaChtc2cpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dChxdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlY2VpdmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gaW5uZXJSZWNlaXZlKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgbXNnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG1zZykgcmV0dXJuIHJlc29sdmUobXNnKTtcbiAgICAgICAgbmV4dCA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBJTklUID0gXCJJTklUXCI7XG5jb25zdCBTVUJTQ1JJQkUgPSBcIlNVQlNDUklCRVwiO1xuY29uc3QgVU5TVUJTQ1JJQkUgPSBcIlVOU1VCU0NSSUJFXCI7XG5jb25zdCBVUERBVEVEID0gXCJVUERBVEVEXCI7XG5jb25zdCBTTkFQU0hPVCA9IFwiU05BUFNIT1RcIjtcbmNvbnN0IEVYSVQgPSBcIkVYSVRcIjtcbmNvbnN0IFRFUk1JTkFURSA9IFwiVEVSTUlOQVRFXCI7XG5jb25zdCByb290ID0gdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHwgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvdztcbnJvb3QuRkNMX1JFR0lTVFJZID0gcm9vdC5GQ0xfUkVHSVNUUlkgPT0gbnVsbCA/IHt9IDogcm9vdC5GQ0xfUkVHSVNUUlk7XG52YXIgcGlkID0gMGIwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IHNlbmQgPSBmdW5jdGlvbiAoYWRkciwgdGFnLCBkYXRhKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXBseSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZXhwZWN0UmVwbHkgPSBvcHRzLmV4cGVjdFJlcGx5IHx8IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgIT0gbnVsbCA/IG9wdHMudGltZW91dCA6IERFRkFVTFRfVElNRU9VVDtcbiAgICBpZiAoZXhwZWN0UmVwbHkgJiYgdGltZW91dCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0OiAke3RpbWVvdXR9bXMgcGFzc2VkIHdpdGhvdXQgYSByZXNwb25zZS5gKSksIHRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgdG86IGFkZHIsXG4gICAgICBmcm9tOiBvcHRzLmZyb20sXG4gICAgICB0YWcsXG4gICAgICBkYXRhLFxuICAgICAgdGltZW91dCxcbiAgICAgIHJlcGx5LFxuICAgICAgcmVqZWN0XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ubWFpbGJveC5kZWxpdmVyKHBheWxvYWQpO1xuICAgICAgaWYgKCFleHBlY3RSZXBseSkgcmVwbHkodHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGQ0wuQWN0b3IgLS0gQ291bGQgTm90IERlbGl2ZXIgTWVzc2FnZVwiLCBwYXlsb2FkLCByb290LkZDTF9SRUdJU1RSWVthZGRyXSwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3Qga2lsbCA9IGFkZHIgPT4ge1xuICBkZWxldGUgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl07XG59O1xuY29uc3QgZnJvbUhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICBsZXQgaGFuZGxlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gYXN5bmMgY3R4ID0+IHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXJzW0lOSVRdID09PSBcImZ1bmN0aW9uXCIpIGF3YWl0IGhhbmRsZXJzW0lOSVRdKGN0eCk7XG4gICAgX19sb29wOiB3aGlsZSAoMSkge1xuICAgICAgY29uc3QgbGV0dGVyID0gYXdhaXQgY3R4LnJlY2VpdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChsZXR0ZXIudGFnID09PSBFWElUKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyc1tURVJNSU5BVEVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXJzW1RFUk1JTkFURV0oY3R4LCBsZXR0ZXIsIGxldHRlci5kYXRhIHx8IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWsgX19sb29wO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZXJzW2xldHRlci50YWddKGN0eCwgbGV0dGVyLCBsZXR0ZXIuZGF0YSB8fCB7fSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2N0eC5zZWxmKCl9IEVycm9yYCwgbGV0dGVyLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250aW51ZSBfX2xvb3A7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IHNwYXduID0gZnVuY3Rpb24gKGZuKSB7XG4gIGxldCBhZGRyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICBpZiAoYWRkciA9PSBudWxsKSBhZGRyID0gKytwaWQ7XG4gIGlmIChyb290LkZDTF9SRUdJU1RSWVthZGRyXSAhPSBudWxsKSByZXR1cm4gYWRkcjtcbiAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gPSB7XG4gICAgYWRkcixcbiAgICBtYWlsYm94OiBtYWlsYm94KCksXG4gICAgc3ViczogbmV3IFNldCgpLFxuICAgIGt2czoge30sXG4gICAgZXJyb3I6IG51bGxcbiAgfTtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHNlbGY6ICgpID0+IGFkZHIsXG4gICAgcmVjZWl2ZTogKCkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ubWFpbGJveC5yZWNlaXZlKCksXG4gICAgc2VuZDogZnVuY3Rpb24gKHRvLCB0YWcsIGRhdGEpIHtcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIG9wdHMuZnJvbSA9IGFkZHI7XG4gICAgICByZXR1cm4gc2VuZCh0bywgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIHNlbmRTZWxmOiAodGFnLCBkYXRhLCBvcHRzKSA9PiB7XG4gICAgICBpZiAocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0pIHNlbmQoYWRkciwgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgb3B0cy5mcm9tID0gYWRkcjtcbiAgICAgIGZvciAobGV0IHRvIG9mIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMpIHNlbmQodG8sIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IHN1YiA9PiBzdWIgIT0gbnVsbCAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLmFkZChzdWIpLFxuICAgIHVuc3Vic2NyaWJlOiBzdWIgPT4gc3ViICE9IG51bGwgJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5kZWxldGUoc3ViKSxcbiAgICBzdWJzY3JpYmVyQ291bnQ6ICgpID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuc2l6ZSxcbiAgICBoYXNTdWJzOiAoKSA9PiAhIXJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuc2l6ZSxcbiAgICBwdXQ6IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IChrZXksIGZhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldO1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBmYWxsYmFjayA6IHZhbHVlO1xuICAgIH0sXG4gICAgZGVsZXRlOiBrZXkgPT4ge1xuICAgICAgZGVsZXRlIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoa2V5LCBmbikgPT4ge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IGZuKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldKTtcbiAgICB9LFxuICAgIGtleXM6ICgpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnMpO1xuICAgIH0sXG4gICAgYWxsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzO1xuICAgIH0sXG4gICAgd2hlcmU6IHBhdHRlcm4gPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KGtleSkgPyB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtrZXldOiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XVxuICAgICAgICB9IDogYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gZGF0YVtrZXldKTtcbiAgICB9LFxuICAgIGZhdGFsRXJyb3I6IGVycm9yID0+IHtcbiAgICAgIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmVycm9yID0gZXJyb3I7XG4gICAgICBmb3IgKGxldCB0byBvZiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzKSBzZW5kKHRvLCBVUERBVEVEKTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgZm4gPT09IFwib2JqZWN0XCIpIGZuID0gZnJvbUhhbmRsZXJzKGZuKTtcbiAgcXVldWVNaWNyb3Rhc2soYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZuKGN0eCk7XG4gICAga2lsbChhZGRyKTtcbiAgfSk7XG4gIHJldHVybiBhZGRyO1xufTtcblxuLy8gUmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvblxuLy8gQSBTVUJTQ1JJQkUgaGFuZGxlciB3aWxsIG5lZWQgdG8gYmUgY3JlYXRlZCB0byBoYW5kbGUgdGhlIHN1YnNjcmlwdGlvbiBldmVudFxuLy9cbi8vICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4vLyAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKVxuLy8gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQsIGN0eC5hbGwoKSlcbi8vICB9XG4vL1xuZnVuY3Rpb24gc3Vic2NyaWJlcihhZGRyZXNzLCBzcGF3bkZuLCBjYWxsYmFjaykge1xuICBzcGF3bkZuKGFkZHJlc3MpO1xuICBjb25zdCBFWElUID0gXCJARVhJVFwiO1xuICBjb25zdCBzZWxmID0gc3Bhd24oYXN5bmMgY3R4ID0+IHtcbiAgICBjdHguc2VuZChhZGRyZXNzLCBTVUJTQ1JJQkUpO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb25zdCBsZXR0ZXIgPSBhd2FpdCBjdHgucmVjZWl2ZSgpO1xuICAgICAgY29uc3QgZXJyb3IgPSByb290LkZDTF9SRUdJU1RSWVthZGRyZXNzXS5lcnJvcjtcbiAgICAgIGlmIChsZXR0ZXIudGFnID09PSBFWElUKSB7XG4gICAgICAgIGN0eC5zZW5kKGFkZHJlc3MsIFVOU1VCU0NSSUJFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgY3R4LnNlbmQoYWRkcmVzcywgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhsZXR0ZXIuZGF0YSwgbnVsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHNlbmQoc2VsZiwgRVhJVCk7XG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmV0dXJucyBhIHJlc3VsdFxuLy8gQSBTTkFQU0hPVCBoYW5kbGVyIHdpbGwgbmVlZCB0byBiZSBjcmVhdGVkIHRvIGhhbmRsZSB0aGUgc25hcHNob3QgZXZlbnRcbi8vXG4vLyAgW1NOQVBTSE9UXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4vLyAgICBsZXR0ZXIucmVwbHkoY3R4LmFsbCgpKVxuLy8gIH1cbi8vXG5mdW5jdGlvbiBzbmFwc2hvdGVyKGFkZHJlc3MsIHNwYXduRm4pIHtcbiAgc3Bhd25GbihhZGRyZXNzKTtcbiAgcmV0dXJuIHNlbmQoYWRkcmVzcywgU05BUFNIT1QsIG51bGwsIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAwXG4gIH0pO1xufVxuXG5leHBvcnQgeyBFWElULCBJTklULCBTTkFQU0hPVCwgU1VCU0NSSUJFLCBURVJNSU5BVEUsIFVOU1VCU0NSSUJFLCBVUERBVEVELCBraWxsLCBzZW5kLCBzbmFwc2hvdGVyLCBzcGF3biwgc3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0b3IubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-actor/dist/actor.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-address/dist/util-address.module.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@onflow/util-address/dist/util-address.module.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   display: function() { return /* binding */ display; },\n/* harmony export */   sansPrefix: function() { return /* binding */ sansPrefix; },\n/* harmony export */   withPrefix: function() { return /* binding */ withPrefix; }\n/* harmony export */ });\n/**\n * @description Removes 0x from address if present\n * @param {string} address - Flow address\n * @returns {string} - Flow address without 0x prefix\n */\nfunction sansPrefix(address) {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\").replace(/^Fx/, \"\");\n}\n\n/**\n * @description Adds 0x to address if not already present\n * @param {string} address - Flow address\n * @returns {string} - Flow address with 0x prefix\n */\nfunction withPrefix(address) {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n}\n\n/**\n * @description Adds 0x to address if not already present\n * @param {string} address - Flow address\n * @returns {string} - Flow address with 0x prefix\n */\nfunction display(address) {\n  return withPrefix(address);\n}\n\n\n//# sourceMappingURL=util-address.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWFkZHJlc3MvZGlzdC91dGlsLWFkZHJlc3MubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1hZGRyZXNzL2Rpc3QvdXRpbC1hZGRyZXNzLm1vZHVsZS5qcz9kOTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgMHggZnJvbSBhZGRyZXNzIGlmIHByZXNlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gRmxvdyBhZGRyZXNzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZsb3cgYWRkcmVzcyB3aXRob3V0IDB4IHByZWZpeFxuICovXG5mdW5jdGlvbiBzYW5zUHJlZml4KGFkZHJlc3MpIHtcbiAgaWYgKGFkZHJlc3MgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoL14weC8sIFwiXCIpLnJlcGxhY2UoL15GeC8sIFwiXCIpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBZGRzIDB4IHRvIGFkZHJlc3MgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBGbG93IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRmxvdyBhZGRyZXNzIHdpdGggMHggcHJlZml4XG4gKi9cbmZ1bmN0aW9uIHdpdGhQcmVmaXgoYWRkcmVzcykge1xuICBpZiAoYWRkcmVzcyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFwiMHhcIiArIHNhbnNQcmVmaXgoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEFkZHMgMHggdG8gYWRkcmVzcyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEZsb3cgYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ30gLSBGbG93IGFkZHJlc3Mgd2l0aCAweCBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gZGlzcGxheShhZGRyZXNzKSB7XG4gIHJldHVybiB3aXRoUHJlZml4KGFkZHJlc3MpO1xufVxuXG5leHBvcnQgeyBkaXNwbGF5LCBzYW5zUHJlZml4LCB3aXRoUHJlZml4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLWFkZHJlc3MubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-address/dist/util-address.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-invariant/dist/util-invariant.module.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@onflow/util-invariant/dist/util-invariant.module.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   invariant: function() { return /* binding */ invariant; }\n/* harmony export */ });\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\n\n\n//# sourceMappingURL=util-invariant.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWludmFyaWFudC9kaXN0L3V0aWwtaW52YXJpYW50Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLDJGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1pbnZhcmlhbnQvZGlzdC91dGlsLWludmFyaWFudC5tb2R1bGUuanM/OTQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc2VydHMgZmFjdCBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3Igd2l0aCBpbnZhcmlhbnQgbWVzc2FnZVxuICogQHBhcmFtIHtib29sZWFufSBmYWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKiBAcGFyYW0ge0FycmF5fSByZXN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW52YXJpYW50KGZhY3QsIG1zZykge1xuICBpZiAoIWZhY3QpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSU5WQVJJQU5UICR7bXNnfWApO1xuICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGQgPT4gIS9hdCBpbnZhcmlhbnQvLnRlc3QoZCkpLmpvaW4oXCJcXG5cIik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJcXG5cXG4tLS1cXG5cXG5cIiwgZXJyb3IsIFwiXFxuXFxuXCIsIC4uLnJlc3QsIFwiXFxuXFxuLS0tXFxuXFxuXCIpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCB7IGludmFyaWFudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC1pbnZhcmlhbnQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-invariant/dist/util-invariant.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-logger/dist/util-logger.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@onflow/util-logger/dist/util-logger.module.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LEVELS: function() { return /* binding */ LEVELS; },\n/* harmony export */   log: function() { return /* binding */ log; },\n/* harmony export */   setConfig: function() { return /* binding */ setConfig; }\n/* harmony export */ });\n// Config dependency injected into logger to break circular dependency\nlet config = null;\nconst setConfig = _config => {\n  config = _config;\n};\n\n/**\n * The levels of the logger\n *\n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n *\n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n *\n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n *\n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n *\n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n *\n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n *\n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = (await config?.()?.get(\"logger.level\")) ?? LEVELS.warn;\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n *\n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n *\n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n *\n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\n\n//# sourceMappingURL=util-logger.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWxvZ2dlci9kaXN0L3V0aWwtbG9nZ2VyLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSOztBQUVBLE1BQU07O0FBRU47QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLDZFQUE2RTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsdUtBQXVLO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxRQUFRLGFBQWEsZ0NBQWdDLHlEQUF5RCx3QkFBd0IsUUFBUSxFQUFFLDhCQUE4QixFQUFFLDBGQUEwRixXQUFXO0FBQ3JSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1sb2dnZXIvZGlzdC91dGlsLWxvZ2dlci5tb2R1bGUuanM/NzU5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb25maWcgZGVwZW5kZW5jeSBpbmplY3RlZCBpbnRvIGxvZ2dlciB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5XG5sZXQgY29uZmlnID0gbnVsbDtcbmNvbnN0IHNldENvbmZpZyA9IF9jb25maWcgPT4ge1xuICBjb25maWcgPSBfY29uZmlnO1xufTtcblxuLyoqXG4gKiBUaGUgbGV2ZWxzIG9mIHRoZSBsb2dnZXJcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMRVZFTFNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWJ1ZyAtIFRoZSBkZWJ1ZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZm8gLSBUaGUgaW5mbyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvZyAtIFRoZSBsb2cgbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3YXJuIC0gVGhlIHdhcm4gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcnJvciAtIFRoZSBlcnJvciBsZXZlbFxuICpcbiAqL1xuY29uc3QgTEVWRUxTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGRlYnVnOiA1LFxuICBpbmZvOiA0LFxuICBsb2c6IDMsXG4gIHdhcm46IDIsXG4gIGVycm9yOiAxXG59KTtcblxuLyoqXG4gKiBCdWlsZHMgYSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSBUaGUgbWVzc2FnZSBmb3JtYXR0ZWQgZm9yIHRoZSBsb2dnZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogYnVpbGRMb2dnZXJNZXNzYWdlQXJncyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiIH0pXG4gKi9cbmNvbnN0IGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3MgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gW2BcbiAgICAlYyR7dGl0bGV9XG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgJHttZXNzYWdlfVxuXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGAucmVwbGFjZSgvXFxuW15cXFNcXHJcXG5dKy9nLCBcIlxcblwiKS50cmltKCksLCBcImZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO1wiXTtcbn07XG5cbi8qKlxuICogTG9ncyBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgbGV2ZWwgb2YgdGhlIG1lc3NhZ2UgYW5kIHRoZSBsZXZlbCBzZXQgaW4gdGhlIGNvbmZpZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYWx3YXlzIC0gV2hldGhlciB0byBhbHdheXMgc2hvdyB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqXG4gKiBAZXhhbXBsZVxuICogbG9nKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIsIGxldmVsOiBMRVZFTFMud2FybiwgYWx3YXlzOiBmYWxzZSB9KVxuICpcbiAqL1xuY29uc3QgbG9nID0gYXN5bmMgX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwsXG4gICAgYWx3YXlzID0gZmFsc2VcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBjb25maWdMb2dnZXJMZXZlbCA9IChhd2FpdCBjb25maWc/LigpPy5nZXQoXCJsb2dnZXIubGV2ZWxcIikpID8/IExFVkVMUy53YXJuO1xuXG4gIC8vIElmIGNvbmZpZyBsZXZlbCBpcyBiZWxvdyBtZXNzYWdlIGxldmVsIHRoZW4gZG9uJ3Qgc2hvdyBpdFxuICBpZiAoIWFsd2F5cyAmJiBjb25maWdMb2dnZXJMZXZlbCA8IGxldmVsKSByZXR1cm47XG4gIGNvbnN0IGxvZ2dlck1lc3NhZ2VBcmdzID0gYnVpbGRMb2dnZXJNZXNzYWdlQXJncyh7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZVxuICB9KTtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgTEVWRUxTLmRlYnVnOlxuICAgICAgY29uc29sZS5kZWJ1ZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy5pbmZvOlxuICAgICAgY29uc29sZS5pbmZvKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLndhcm46XG4gICAgICBjb25zb2xlLndhcm4oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMuZXJyb3I6XG4gICAgICBjb25zb2xlLmVycm9yKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLmxvZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogTG9ncyBhIGRlcHJlY2F0aW9uIG5vdGljZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBrZyAtIFRoZSBwYWNrYWdlIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdCAtIFRoZSBzdWJqZWN0IG9mIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHJhbnNpdGlvbiAtIFRoZSB0cmFuc2l0aW9uIHBhdGggZm9yIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBhZnRlciB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqXG4gKiBAZXhhbXBsZVxuICogbG9nLmRlcHJlY2F0ZSh7IHBrZzogXCJAb25mbG93L2ZjbFwiLCBzdWJqZWN0OiBcIlNvbWUgaXRlbVwiLCB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGtcIiwgbWVzc2FnZTogXCJEZXNjcmlwdGl2ZSBtZXNzYWdlXCIsIGxldmVsOiBMRVZFTFMud2FybiwgY2FsbGJhY2s6ICgpID0+IHt9IH0pXG4gKlxuICovXG5sb2cuZGVwcmVjYXRlID0gX3JlZjMgPT4ge1xuICBsZXQge1xuICAgIHBrZyxcbiAgICBzdWJqZWN0LFxuICAgIHRyYW5zaXRpb24sXG4gICAgbGV2ZWwgPSBMRVZFTFMud2FybixcbiAgICBtZXNzYWdlID0gXCJcIixcbiAgICBjYWxsYmFjayA9IG51bGxcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH07XG4gIGNvbnN0IGxvZ01lc3NhZ2UgPSAoKSA9PiBsb2coe1xuICAgIHRpdGxlOiBgJHtwa2cgPyBwa2cgKyBcIiBcIiA6IFwiXCJ9RGVwcmVjYXRpb24gTm90aWNlYCxcbiAgICBtZXNzYWdlOiBgXG4gICAgICAke3N1YmplY3QgPyBgJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3ViamVjdCl9IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgY2Vhc2UgdG8gd29yayBpbiBmdXR1cmUgcmVsZWFzZXMke3BrZyA/IFwiIG9mIFwiICsgcGtnIDogXCJcIn0uYCA6IFwiXCJ9JHttZXNzYWdlID8gXCJcXG5cIiArIG1lc3NhZ2UgOiBcIlwifSR7dHJhbnNpdGlvbiA/IGBcXG5Zb3UgY2FuIGxlYXJuIG1vcmUgKGluY2x1ZGluZyBhIGd1aWRlIG9uIGNvbW1vbiB0cmFuc2l0aW9uIHBhdGhzKSBoZXJlOiAke3RyYW5zaXRpb259YCA6IFwiXCJ9XG4gICAgYC50cmltKCksXG4gICAgbGV2ZWxcbiAgfSk7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBhd2FpdCBsb2dNZXNzYWdlKCk7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2soLi4uYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBsb2dNZXNzYWdlKCk7XG59O1xuXG5leHBvcnQgeyBMRVZFTFMsIGxvZywgc2V0Q29uZmlnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLWxvZ2dlci5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-logger/dist/util-logger.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-template/dist/template.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/@onflow/util-template/dist/template.module.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   interleave: function() { return /* binding */ interleave; },\n/* harmony export */   template: function() { return /* binding */ template; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED$2 = \"UPDATED\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED$2);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant$1(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe$1 = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe$1 = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject$1 = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep$1 = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject$1(target) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep$1(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep$1(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs$1 = value => Array.isArray(value) ? mergeDeep$1({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts$1 = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress$1 = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress$1 = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts$1 = (jsons, network) => {\n  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal$1 = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys$1 = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal$1(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys$1 = value => {\n  if (isObject$1(value)) return hasPrivateKeys$1(value);\n  return value.some(hasPrivateKeys$1);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork$1 = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME$1 = \"config\";\nconst PUT$1 = \"PUT_CONFIG\";\nconst GET$1 = \"GET_CONFIG\";\nconst GET_ALL$1 = \"GET_ALL_CONFIG\";\nconst UPDATE$1 = \"UPDATE_CONFIG\";\nconst DELETE$1 = \"DELETE_CONFIG\";\nconst CLEAR$1 = \"CLEAR_CONFIG\";\nconst WHERE$1 = \"WHERE_CONFIG\";\nconst UPDATED$1 = \"CONFIG/UPDATED\";\nconst identity$1 = v => v;\nconst HANDLERS$1 = {\n  [PUT$1]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [GET$1]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL$1]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE$1]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity$1);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [DELETE$1]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR$1]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [WHERE$1]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS$1, NAME$1);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put$1(key, value) {\n  send(NAME$1, PUT$1, {\n    key,\n    value\n  });\n  return config$1();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get$1(key, fallback) {\n  return send(NAME$1, GET$1, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first$1() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get$1(head);\n  if (ret == null) return first$1(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all$1() {\n  return send(NAME$1, GET_ALL$1, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update$1(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  send(NAME$1, UPDATE$1, {\n    key,\n    fn\n  });\n  return config$1();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete$1(key) {\n  send(NAME$1, DELETE$1, {\n    key\n  });\n  return config$1();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where$1(pattern) {\n  return send(NAME$1, WHERE$1, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe$1(callback) {\n  return subscriber(NAME$1, () => spawn(HANDLERS$1, NAME$1), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig$1() {\n  return send(NAME$1, CLEAR$1);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig$1(oldConfig) {\n  return clearConfig$1().then(config$1(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load$1(data) {\n  const network = await get$1(\"flow.network\");\n  const cleanedNetwork = cleanNetwork$1(network);\n  const {\n    flowJSON\n  } = data;\n  invariant$1(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant$1(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys$1(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts$1(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get$1(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get$1(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config$1(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put$1(d, values[d]));\n  }\n  return {\n    put: put$1,\n    get: get$1,\n    all: all$1,\n    first: first$1,\n    update: update$1,\n    delete: _delete$1,\n    where: where$1,\n    subscribe: subscribe$1,\n    overload: overload$1,\n    load: load$1\n  };\n}\nconfig$1.put = put$1;\nconfig$1.get = get$1;\nconfig$1.all = all$1;\nconfig$1.first = first$1;\nconfig$1.update = update$1;\nconfig$1.delete = _delete$1;\nconfig$1.where = where$1;\nconfig$1.subscribe = subscribe$1;\nconfig$1.overload = overload$1;\nconfig$1.load = load$1;\nconst noop$1 = v => v;\nfunction overload$1() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all$1();\n    try {\n      config$1(opts);\n      var result = await callback(await all$1());\n      await resetConfig$1(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig$1(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS$1 = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs$1 = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log$1 = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config$1.get(\"logger.level\", LEVELS$1.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs$1({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS$1.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS$1.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS$1.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS$1.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog$1.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS$1.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log$1({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\nfunction interleave() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!a.length && !b.length) return c;\n  if (!a.length) return c;\n  if (!b.length) return [...c, a[0]];\n  const [aHead, ...aRest] = a;\n  const [bHead, ...bRest] = b;\n  if (aHead !== undefined) c.push(aHead);\n  if (bHead !== undefined) c.push(bHead);\n  return interleave(aRest, bRest, c);\n}\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\"\n      });\n      return recApply(d)(arg1(d));\n    }\n    return String(arg1);\n  };\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nfunction template(head) {\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n  if (typeof head === \"string\") return () => head;\n  if (Array.isArray(head)) {\n    return d => interleave(head, rest.map(recApply(d))).join(\"\").trim();\n  }\n  return head;\n}\n\n\n//# sourceMappingURL=template.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLXRlbXBsYXRlL2Rpc3QvdGVtcGxhdGUubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsc0hBQXNILHFCQUFNLG1CQUFtQixxQkFBTTs7QUFFcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBTSxpQkFBaUIscUJBQU0sWUFBWSxxQkFBTSxJQUFJLHFCQUFNO0FBQ3ZJLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsUUFBUTtBQUNSLHlCQUF5QixZQUFZO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnR0FBZ0csZUFBZTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUSw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNOztBQUVOO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyw2RUFBNkU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUJBQW1CLHVLQUF1SztBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsUUFBUSxhQUFhLGdDQUFnQyx5REFBeUQsd0JBQXdCLFFBQVEsRUFBRSw4QkFBOEIsRUFBRSwwRkFBMEYsV0FBVztBQUNyUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLDJGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdHQUFnRyxlQUFlO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVEsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsUUFBUTtBQUNSOztBQUVBLE1BQU07O0FBRU47QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLDZFQUE2RTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsdUtBQXVLO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxRQUFRLGFBQWEsZ0NBQWdDLHlEQUF5RCx3QkFBd0IsUUFBUSxFQUFFLDhCQUE4QixFQUFFLDBGQUEwRixXQUFXO0FBQ3JSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFdBQVc7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLXRlbXBsYXRlL2Rpc3QvdGVtcGxhdGUubW9kdWxlLmpzPzk3MjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbi8qISBxdWV1ZS1taWNyb3Rhc2suIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmxldCBwcm9taXNlO1xudmFyIHF1ZXVlTWljcm90YXNrXzEgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogY29tbW9uanNHbG9iYWwpXG4vLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG46IGNiID0+IChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChlcnIgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gIHRocm93IGVycjtcbn0sIDApKTtcblxuY29uc3QgbWFpbGJveCA9ICgpID0+IHtcbiAgY29uc3QgcXVldWUgPSBbXTtcbiAgdmFyIG5leHQ7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgZGVsaXZlcihtc2cpIHtcbiAgICAgIHF1ZXVlLnB1c2gobXNnKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIG5leHQocXVldWUuc2hpZnQoKSk7XG4gICAgICAgIG5leHQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWNlaXZlKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGlubmVyUmVjZWl2ZShyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChtc2cpIHJldHVybiByZXNvbHZlKG1zZyk7XG4gICAgICAgIG5leHQgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IElOSVQgPSBcIklOSVRcIjtcbmNvbnN0IFNVQlNDUklCRSA9IFwiU1VCU0NSSUJFXCI7XG5jb25zdCBVTlNVQlNDUklCRSA9IFwiVU5TVUJTQ1JJQkVcIjtcbmNvbnN0IFVQREFURUQkMiA9IFwiVVBEQVRFRFwiO1xuY29uc3QgRVhJVCA9IFwiRVhJVFwiO1xuY29uc3QgVEVSTUlOQVRFID0gXCJURVJNSU5BVEVcIjtcbmNvbnN0IHJvb3QgPSB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fCB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3cgJiYgd2luZG93O1xucm9vdC5GQ0xfUkVHSVNUUlkgPSByb290LkZDTF9SRUdJU1RSWSA9PSBudWxsID8ge30gOiByb290LkZDTF9SRUdJU1RSWTtcbnZhciBwaWQgPSAwYjA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA1MDAwO1xuY29uc3Qgc2VuZCA9IGZ1bmN0aW9uIChhZGRyLCB0YWcsIGRhdGEpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcGx5LCByZWplY3QpID0+IHtcbiAgICBjb25zdCBleHBlY3RSZXBseSA9IG9wdHMuZXhwZWN0UmVwbHkgfHwgZmFsc2U7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdHMudGltZW91dCAhPSBudWxsID8gb3B0cy50aW1lb3V0IDogREVGQVVMVF9USU1FT1VUO1xuICAgIGlmIChleHBlY3RSZXBseSAmJiB0aW1lb3V0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQ6ICR7dGltZW91dH1tcyBwYXNzZWQgd2l0aG91dCBhIHJlc3BvbnNlLmApKSwgdGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0bzogYWRkcixcbiAgICAgIGZyb206IG9wdHMuZnJvbSxcbiAgICAgIHRhZyxcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lb3V0LFxuICAgICAgcmVwbHksXG4gICAgICByZWplY3RcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByb290LkZDTF9SRUdJU1RSWVthZGRyXSAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5tYWlsYm94LmRlbGl2ZXIocGF5bG9hZCk7XG4gICAgICBpZiAoIWV4cGVjdFJlcGx5KSByZXBseSh0cnVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZDTC5BY3RvciAtLSBDb3VsZCBOb3QgRGVsaXZlciBNZXNzYWdlXCIsIHBheWxvYWQsIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLCBlcnJvcik7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBraWxsID0gYWRkciA9PiB7XG4gIGRlbGV0ZSByb290LkZDTF9SRUdJU1RSWVthZGRyXTtcbn07XG5jb25zdCBmcm9tSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBoYW5kbGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBhc3luYyBjdHggPT4ge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlcnNbSU5JVF0gPT09IFwiZnVuY3Rpb25cIikgYXdhaXQgaGFuZGxlcnNbSU5JVF0oY3R4KTtcbiAgICBfX2xvb3A6IHdoaWxlICgxKSB7XG4gICAgICBjb25zdCBsZXR0ZXIgPSBhd2FpdCBjdHgucmVjZWl2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJzW1RFUk1JTkFURV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlcnNbVEVSTUlOQVRFXShjdHgsIGxldHRlciwgbGV0dGVyLmRhdGEgfHwge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhayBfX2xvb3A7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaGFuZGxlcnNbbGV0dGVyLnRhZ10oY3R4LCBsZXR0ZXIsIGxldHRlci5kYXRhIHx8IHt9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7Y3R4LnNlbGYoKX0gRXJyb3JgLCBsZXR0ZXIsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRpbnVlIF9fbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuY29uc3Qgc3Bhd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgbGV0IGFkZHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGlmIChhZGRyID09IG51bGwpIGFkZHIgPSArK3BpZDtcbiAgaWYgKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdICE9IG51bGwpIHJldHVybiBhZGRyO1xuICByb290LkZDTF9SRUdJU1RSWVthZGRyXSA9IHtcbiAgICBhZGRyLFxuICAgIG1haWxib3g6IG1haWxib3goKSxcbiAgICBzdWJzOiBuZXcgU2V0KCksXG4gICAga3ZzOiB7fSxcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuICBjb25zdCBjdHggPSB7XG4gICAgc2VsZjogKCkgPT4gYWRkcixcbiAgICByZWNlaXZlOiAoKSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5tYWlsYm94LnJlY2VpdmUoKSxcbiAgICBzZW5kOiBmdW5jdGlvbiAodG8sIHRhZywgZGF0YSkge1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgb3B0cy5mcm9tID0gYWRkcjtcbiAgICAgIHJldHVybiBzZW5kKHRvLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgc2VuZFNlbGY6ICh0YWcsIGRhdGEsIG9wdHMpID0+IHtcbiAgICAgIGlmIChyb290LkZDTF9SRUdJU1RSWVthZGRyXSkgc2VuZChhZGRyLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgYnJvYWRjYXN0OiBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICBvcHRzLmZyb20gPSBhZGRyO1xuICAgICAgZm9yIChsZXQgdG8gb2Ygcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicykgc2VuZCh0bywgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogc3ViID0+IHN1YiAhPSBudWxsICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuYWRkKHN1YiksXG4gICAgdW5zdWJzY3JpYmU6IHN1YiA9PiBzdWIgIT0gbnVsbCAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLmRlbGV0ZShzdWIpLFxuICAgIHN1YnNjcmliZXJDb3VudDogKCkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5zaXplLFxuICAgIGhhc1N1YnM6ICgpID0+ICEhcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5zaXplLFxuICAgIHB1dDogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogKGtleSwgZmFsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV07XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IGZhbGxiYWNrIDogdmFsdWU7XG4gICAgfSxcbiAgICBkZWxldGU6IGtleSA9PiB7XG4gICAgICBkZWxldGUgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV07XG4gICAgfSxcbiAgICB1cGRhdGU6IChrZXksIGZuKSA9PiB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gZm4ocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0pO1xuICAgIH0sXG4gICAga2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cyk7XG4gICAgfSxcbiAgICBhbGw6ICgpID0+IHtcbiAgICAgIHJldHVybiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnM7XG4gICAgfSxcbiAgICB3aGVyZTogcGF0dGVybiA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoa2V5KSA/IHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW2tleV06IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldXG4gICAgICAgIH0gOiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSxcbiAgICBtZXJnZTogZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSBkYXRhW2tleV0pO1xuICAgIH0sXG4gICAgZmF0YWxFcnJvcjogZXJyb3IgPT4ge1xuICAgICAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uZXJyb3IgPSBlcnJvcjtcbiAgICAgIGZvciAobGV0IHRvIG9mIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMpIHNlbmQodG8sIFVQREFURUQkMik7XG4gICAgfVxuICB9O1xuICBpZiAodHlwZW9mIGZuID09PSBcIm9iamVjdFwiKSBmbiA9IGZyb21IYW5kbGVycyhmbik7XG4gIHF1ZXVlTWljcm90YXNrXzEoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZuKGN0eCk7XG4gICAga2lsbChhZGRyKTtcbiAgfSk7XG4gIHJldHVybiBhZGRyO1xufTtcblxuLy8gUmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvblxuLy8gQSBTVUJTQ1JJQkUgaGFuZGxlciB3aWxsIG5lZWQgdG8gYmUgY3JlYXRlZCB0byBoYW5kbGUgdGhlIHN1YnNjcmlwdGlvbiBldmVudFxuLy9cbi8vICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4vLyAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKVxuLy8gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQsIGN0eC5hbGwoKSlcbi8vICB9XG4vL1xuZnVuY3Rpb24gc3Vic2NyaWJlcihhZGRyZXNzLCBzcGF3bkZuLCBjYWxsYmFjaykge1xuICBzcGF3bkZuKGFkZHJlc3MpO1xuICBjb25zdCBFWElUID0gXCJARVhJVFwiO1xuICBjb25zdCBzZWxmID0gc3Bhd24oYXN5bmMgY3R4ID0+IHtcbiAgICBjdHguc2VuZChhZGRyZXNzLCBTVUJTQ1JJQkUpO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb25zdCBsZXR0ZXIgPSBhd2FpdCBjdHgucmVjZWl2ZSgpO1xuICAgICAgY29uc3QgZXJyb3IgPSByb290LkZDTF9SRUdJU1RSWVthZGRyZXNzXS5lcnJvcjtcbiAgICAgIGlmIChsZXR0ZXIudGFnID09PSBFWElUKSB7XG4gICAgICAgIGN0eC5zZW5kKGFkZHJlc3MsIFVOU1VCU0NSSUJFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGVycm9yKTtcbiAgICAgICAgY3R4LnNlbmQoYWRkcmVzcywgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhsZXR0ZXIuZGF0YSwgbnVsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHNlbmQoc2VsZiwgRVhJVCk7XG59XG5cbi8qKlxuICogQXNzZXJ0cyBmYWN0IGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvciB3aXRoIGludmFyaWFudCBtZXNzYWdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbnZhcmlhbnQkMShmYWN0LCBtc2cpIHtcbiAgaWYgKCFmYWN0KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYElOVkFSSUFOVCAke21zZ31gKTtcbiAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihkID0+ICEvYXQgaW52YXJpYW50Ly50ZXN0KGQpKS5qb2luKFwiXFxuXCIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHJlc3RbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKFwiXFxuXFxuLS0tXFxuXFxuXCIsIGVycm9yLCBcIlxcblxcblwiLCAuLi5yZXN0LCBcIlxcblxcbi0tLVxcblxcblwiKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuY29uc3QgcGlwZSQxID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmMocmVzKTtcbiAgICB9LCB2KTtcbiAgfTtcbn07XG5cbi8qKipcbiAqIE1lcmdlIG11bHRpcGxlIGZ1bmN0aW9ucyByZXR1cm5pbmcgb2JqZWN0cyBpbnRvIG9uZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLmZ1bmN0aW9uKCopOiBvYmplY3R9IGZ1bmNzIC0gRnVuY3Rpb25zIHRvIG1lcmdlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZVBpcGUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGZ1bmNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICAuLi5mdW5jKHYpXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBjaGVja1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBJcyBvYmplY3Qgc3RhdHVzXG4gKi9cbmNvbnN0IGlzT2JqZWN0JDEgPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHsuLi5vYmplY3RbXX0gc291cmNlcyAtIFNvdXJjZSBvYmplY3RzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBvYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VEZWVwJDEgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc291cmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICBpZiAoIXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gIGlmIChpc09iamVjdCQxKHRhcmdldCkgJiYgaXNPYmplY3QkMShzb3VyY2UpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaXNPYmplY3QkMShzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XToge31cbiAgICAgICAgfSk7XG4gICAgICAgIG1lcmdlRGVlcCQxKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiBzb3VyY2Vba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlRGVlcCQxKHRhcmdldCwgLi4uc291cmNlcyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIEZsb3cgSlNPTi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBGbG93IEpTT05cbiAqL1xuY29uc3QgbWVyZ2VGbG93SlNPTnMkMSA9IHZhbHVlID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gbWVyZ2VEZWVwJDEoe30sIC4uLnZhbHVlKSA6IHZhbHVlO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGaWx0ZXIgb3V0IGNvbnRyYWN0cyBzZWN0aW9uIG9mIGZsb3cuanNvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBvYmogLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdHMgc2VjdGlvbiBvZiBGbG93IEpTT05cbiAqL1xuY29uc3QgZmlsdGVyQ29udHJhY3RzJDEgPSBvYmogPT4gb2JqLmNvbnRyYWN0cyA/IG9iai5jb250cmFjdHMgOiB7fTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2F0aGVycyBjb250cmFjdCBhZGRyZXNzZXMgYnkgbmV0d29ya1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGdhdGhlciBhZGRyZXNzZXMgZm9yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0IG5hbWVzIGJ5IGFkZHJlc3NlcyBtYXBwaW5nIGUuZyB7IFwiSGVsbG9Xb3JsZFwiOiBcIjB4MTIzXCIgfVxuICovXG5jb25zdCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzJDEgPSBuZXR3b3JrID0+IGNvbnRyYWN0cyA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjb250cmFjdHMpLnJlZHVjZSgoYywgX3JlZikgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgIGNvbnN0IG5ldHdvcmtDb250cmFjdEFsaWFzID0gdmFsdWU/LmFsaWFzZXM/LltuZXR3b3JrXTtcbiAgICBpZiAobmV0d29ya0NvbnRyYWN0QWxpYXMpIHtcbiAgICAgIGNba2V5XSA9IG5ldHdvcmtDb250cmFjdEFsaWFzO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwge30pO1xufTtcbmNvbnN0IG1hcERlcGxveW1lbnRzVG9OZXR3b3JrQWRkcmVzcyQxID0gbmV0d29yayA9PiBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgZGVwbG95bWVudHMgPSB7fSxcbiAgICBhY2NvdW50cyA9IHt9XG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgbmV0d29ya0RlcGxveW1lbnQgPSBkZXBsb3ltZW50cz8uW25ldHdvcmtdO1xuICBpZiAoIW5ldHdvcmtEZXBsb3ltZW50KSByZXR1cm4ge307XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhuZXR3b3JrRGVwbG95bWVudCkucmVkdWNlKChjLCBfcmVmMykgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMztcbiAgICAvLyBSZXNvbHZlIGFjY291bnQgYWRkcmVzc1xuICAgIGNvbnN0IGFjY291bnRBZGRyZXNzID0gYWNjb3VudHNba2V5XT8uYWRkcmVzcztcbiAgICBpZiAoIWFjY291bnRBZGRyZXNzKSByZXR1cm4gYztcblxuICAgIC8vIENyZWF0ZSBhbiBvYmplY3QgYXNzaWduaW5nIHRoZSBhZGRyZXNzIHRvIHRoZSBjb250cmFjdCBuYW1lLlxuICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoKGMsIGNvbnRyYWN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jLFxuICAgICAgICBbY29udHJhY3RdOiBhY2NvdW50QWRkcmVzc1xuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIGZpbGVzIGFuZCByZXR1cm4gY29udHJhY3QgdG8gYWRkcmVzcyBtYXBwaW5nIGJ5IG5ldHdvcmtcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBqc29ucyAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IGdldENvbnRyYWN0cyQxID0gKGpzb25zLCBuZXR3b3JrKSA9PiB7XG4gIHJldHVybiBwaXBlJDEobWVyZ2VGbG93SlNPTnMkMSwgbWVyZ2VQaXBlJDEobWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzJDEobmV0d29yayksIHBpcGUkMShmaWx0ZXJDb250cmFjdHMkMSwgbWFwQ29udHJhY3RBbGlhc2VzVG9OZXR3b3JrQWRkcmVzcyQxKG5ldHdvcmspKSkpKGpzb25zKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiBzdHJpbmcgaXMgaGV4aWRlY2ltYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIGhleGlkZWNpbWFsIHN0YXR1c1xuICovXG5jb25zdCBpc0hleGlkZWNpbWFsJDEgPSBzdHIgPT4ge1xuICAvLyBDaGVjayB0aGF0IGl0IGlzIGEgc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvXlswLTlBLUZhLWZdKyQvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBmbG93Lmpzb24gZmlsZSBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdH0gZmxvd0pTT04gLSBGbG93IEpTT05cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhhcyBwcml2YXRlIGtleXMgc3RhdHVzXG4gKi9cbmNvbnN0IGhhc1ByaXZhdGVLZXlzJDEgPSBmbG93SlNPTiA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmbG93SlNPTj8uYWNjb3VudHMpLnJlZHVjZSgoaGFzUHJpdmF0ZUtleSwgX3JlZjQpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjQ7XG4gICAgaWYgKGhhc1ByaXZhdGVLZXkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB2YWx1ZT8uaGFzT3duUHJvcGVydHkoXCJrZXlcIikgJiYgaXNIZXhpZGVjaW1hbCQxKHZhbHVlPy5rZXkpO1xuICB9LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNoZWNrcyBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gdmFsdWUgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgYW55SGFzUHJpdmF0ZUtleXMkMSA9IHZhbHVlID0+IHtcbiAgaWYgKGlzT2JqZWN0JDEodmFsdWUpKSByZXR1cm4gaGFzUHJpdmF0ZUtleXMkMSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZS5zb21lKGhhc1ByaXZhdGVLZXlzJDEpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRm9ybWF0IG5ldHdvcmsgdG8gYWx3YXlzIGJlICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZvcm1hdHRlZCBuZXR3b3JrIG5hbWUgKGVpdGhlciAnZW11bGF0b3InLCAndGVzdG5ldCcsIG9yICdtYWlubmV0JylcbiAqL1xuY29uc3QgY2xlYW5OZXR3b3JrJDEgPSBuZXR3b3JrID0+IG5ldHdvcms/LnRvTG93ZXJDYXNlKCkgPT09IFwibG9jYWxcIiA/IFwiZW11bGF0b3JcIiA6IG5ldHdvcms/LnRvTG93ZXJDYXNlKCk7XG5jb25zdCBOQU1FJDEgPSBcImNvbmZpZ1wiO1xuY29uc3QgUFVUJDEgPSBcIlBVVF9DT05GSUdcIjtcbmNvbnN0IEdFVCQxID0gXCJHRVRfQ09ORklHXCI7XG5jb25zdCBHRVRfQUxMJDEgPSBcIkdFVF9BTExfQ09ORklHXCI7XG5jb25zdCBVUERBVEUkMSA9IFwiVVBEQVRFX0NPTkZJR1wiO1xuY29uc3QgREVMRVRFJDEgPSBcIkRFTEVURV9DT05GSUdcIjtcbmNvbnN0IENMRUFSJDEgPSBcIkNMRUFSX0NPTkZJR1wiO1xuY29uc3QgV0hFUkUkMSA9IFwiV0hFUkVfQ09ORklHXCI7XG5jb25zdCBVUERBVEVEJDEgPSBcIkNPTkZJRy9VUERBVEVEXCI7XG5jb25zdCBpZGVudGl0eSQxID0gdiA9PiB2O1xuY29uc3QgSEFORExFUlMkMSA9IHtcbiAgW1BVVCQxXTogKGN0eCwgX2xldHRlciwgX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZVxuICAgIH0gPSBfcmVmO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL3B1dC5cIik7XG4gICAgY3R4LnB1dChrZXksIHZhbHVlKTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQkMSwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtHRVQkMV06IChjdHgsIGxldHRlciwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZ2V0XCIpO1xuICAgIGxldHRlci5yZXBseShjdHguZ2V0KGtleSwgZmFsbGJhY2spKTtcbiAgfSxcbiAgW0dFVF9BTEwkMV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldHRlci5yZXBseSh7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VQREFURSQxXTogKGN0eCwgbGV0dGVyLCBfcmVmMykgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmblxuICAgIH0gPSBfcmVmMztcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy91cGRhdGVcIik7XG4gICAgY3R4LnVwZGF0ZShrZXksIGZuIHx8IGlkZW50aXR5JDEpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCQxLCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0RFTEVURSQxXTogKGN0eCwgbGV0dGVyLCBfcmVmNCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlcbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZGVsZXRlXCIpO1xuICAgIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQkMSwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtDTEVBUiQxXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhjdHguYWxsKCkpO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSBjdHguZGVsZXRlKGtleSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVEJDEsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbV0hFUkUkMV06IChjdHgsIGxldHRlciwgX3JlZjUpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0dGVyblxuICAgIH0gPSBfcmVmNTtcbiAgICBpZiAocGF0dGVybiA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdwYXR0ZXJuJyBmb3IgY29uZmlnL3doZXJlXCIpO1xuICAgIGxldHRlci5yZXBseShjdHgud2hlcmUocGF0dGVybikpO1xuICB9LFxuICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQkMSwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC51bnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gIH1cbn07XG5zcGF3bihIQU5ETEVSUyQxLCBOQU1FJDEpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBZGRzIGEga2V5LXZhbHVlIHBhaXIgdG8gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFkZFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcHV0JDEoa2V5LCB2YWx1ZSkge1xuICBzZW5kKE5BTUUkMSwgUFVUJDEsIHtcbiAgICBrZXksXG4gICAgdmFsdWVcbiAgfSk7XG4gIHJldHVybiBjb25maWckMSgpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIGEga2V5LXZhbHVlIHBhaXIgd2l0aCBhIGZhbGxiYWNrIGZyb20gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0geyp9IFtmYWxsYmFja10gLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0JDEoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gc2VuZChOQU1FJDEsIEdFVCQxLCB7XG4gICAga2V5LFxuICAgIGZhbGxiYWNrXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgZmlyc3Qgbm9uIG51bGwgY29uZmlnIHZhbHVlIG9yIHRoZSBmYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmdbXX0gd2FudHMgLSBUaGUga2V5cyB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0geyp9IGZhbGxiYWNrIC0gVGhlIGZhbGxiYWNrIHZhbHVlIHRvIHJldHVybiBpZiBrZXkgaXMgbm90IGZvdW5kXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBUaGUgdmFsdWUgZm91bmQgYXQga2V5IG9yIGZhbGxiYWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpcnN0JDEoKSB7XG4gIGxldCB3YW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIXdhbnRzLmxlbmd0aCkgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCBbaGVhZCwgLi4ucmVzdF0gPSB3YW50cztcbiAgY29uc3QgcmV0ID0gYXdhaXQgZ2V0JDEoaGVhZCk7XG4gIGlmIChyZXQgPT0gbnVsbCkgcmV0dXJuIGZpcnN0JDEocmVzdCwgZmFsbGJhY2spO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZ1xuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gYWxsJDEoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUkMSwgR0VUX0FMTCQxLCBudWxsLCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gdXBkYXRlJDEoa2V5KSB7XG4gIGxldCBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWRlbnRpdHkkMTtcbiAgc2VuZChOQU1FJDEsIFVQREFURSQxLCB7XG4gICAga2V5LFxuICAgIGZuXG4gIH0pO1xuICByZXR1cm4gY29uZmlnJDEoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVsZXRlcyBhIGtleS12YWx1ZSBwYWlyIGZyb20gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gZGVsZXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBfZGVsZXRlJDEoa2V5KSB7XG4gIHNlbmQoTkFNRSQxLCBERUxFVEUkMSwge1xuICAgIGtleVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZyQxKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIGNvbmZpZyBiYXNlZCBvbiBhIHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2gga2V5cyBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBzdWJzZXQgb2YgdGhlIGNvbmZpZ1xuICovXG5mdW5jdGlvbiB3aGVyZSQxKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSQxLCBXSEVSRSQxLCB7XG4gICAgcGF0dGVyblxuICB9LCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFN1YnNjcmliZXMgdG8gY29uZmlnIHVwZGF0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiBjb25maWcgaXMgdXBkYXRlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIFRoZSB1bnN1YnNjcmliZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzdWJzY3JpYmUkMShjYWxsYmFjaykge1xuICByZXR1cm4gc3Vic2NyaWJlcihOQU1FJDEsICgpID0+IHNwYXduKEhBTkRMRVJTJDEsIE5BTUUkMSksIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2xlYXJzIHRoZSBjb25maWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjbGVhckNvbmZpZyQxKCkge1xuICByZXR1cm4gc2VuZChOQU1FJDEsIENMRUFSJDEpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIGNvbmZpZyB0byBhIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkQ29uZmlnIC0gVGhlIHByZXZpb3VzIGNvbmZpZyBzdGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb25maWckMShvbGRDb25maWcpIHtcbiAgcmV0dXJuIGNsZWFyQ29uZmlnJDEoKS50aGVuKGNvbmZpZyQxKG9sZENvbmZpZykpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlcyBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjcmVhdGVzIGNvbnRyYWN0IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgLSBUaGUgZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWQkMShkYXRhKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBnZXQkMShcImZsb3cubmV0d29ya1wiKTtcbiAgY29uc3QgY2xlYW5lZE5ldHdvcmsgPSBjbGVhbk5ldHdvcmskMShuZXR3b3JrKTtcbiAgY29uc3Qge1xuICAgIGZsb3dKU09OXG4gIH0gPSBkYXRhO1xuICBpbnZhcmlhbnQkMShCb29sZWFuKGZsb3dKU09OKSwgXCJjb25maWcubG9hZCAtLSAnZmxvd0pTT04nIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEoY2xlYW5lZE5ldHdvcmssIGBGbG93IE5ldHdvcmsgUmVxdWlyZWQgLS0gSW4gb3JkZXIgZm9yIEZDTCB0byBsb2FkIHlvdXIgY29udHJhY3RzIHBsZWFzZSBkZWZpbmUgXCJmbG93Lm5ldHdvcmtcIiB0byBcImVtdWxhdG9yXCIsIFwibG9jYWxcIiwgXCJ0ZXN0bmV0XCIsIG9yIFwibWFpbm5ldFwiIGluIHlvdXIgY29uZmlnLiBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3BlcnMuZmxvdy5jb20vdG9vbHMvZmNsLWpzL3JlZmVyZW5jZS9jb25maWd1cmUtZmNsYCk7XG4gIGlmIChhbnlIYXNQcml2YXRlS2V5cyQxKGZsb3dKU09OKSkge1xuICAgIGNvbnN0IGlzRW11bGF0b3IgPSBjbGVhbmVkTmV0d29yayA9PT0gXCJlbXVsYXRvclwiO1xuICAgIGxvZyQxKHtcbiAgICAgIHRpdGxlOiBcIlByaXZhdGUgS2V5cyBEZXRlY3RlZFwiLFxuICAgICAgbWVzc2FnZTogYFByaXZhdGUga2V5cyBzaG91bGQgYmUgc3RvcmVkIGluIGEgc2VwYXJhdGUgZmxvdy5qc29uIGZpbGUgZm9yIHNlY3VyaXR5LiBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3BlcnMuZmxvdy5jb20vdG9vbHMvZmxvdy1jbGkvc2VjdXJpdHlgLFxuICAgICAgbGV2ZWw6IGlzRW11bGF0b3IgPyBMRVZFTFMkMS53YXJuIDogTEVWRUxTJDEuZXJyb3JcbiAgICB9KTtcbiAgICBpZiAoIWlzRW11bGF0b3IpIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnZXRDb250cmFjdHMkMShmbG93SlNPTiwgY2xlYW5lZE5ldHdvcmspKSkge1xuICAgIGNvbnN0IGNvbnRyYWN0Q29uZmlnS2V5ID0gYDB4JHtrZXl9YDtcbiAgICBjb25zdCBleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ID0gYXdhaXQgZ2V0JDEoY29udHJhY3RDb25maWdLZXkpO1xuICAgIGlmIChleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ICYmIGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgIT09IHZhbHVlKSB7XG4gICAgICBsb2ckMSh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBMRVZFTFMkMS53YXJuXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHV0JDEoY29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtQ29udHJhY3RDb25maWdLZXkgPSBgc3lzdGVtLmNvbnRyYWN0cy4ke2tleX1gO1xuICAgIGNvbnN0IHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSA9IGF3YWl0IGdldCQxKHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5KTtcbiAgICBpZiAoc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlICYmIHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyQxKHtcbiAgICAgICAgdGl0bGU6IFwiQ29udHJhY3QgUGxhY2Vob2xkZXIgQ29uZmxpY3QgRGV0ZWN0ZWRcIixcbiAgICAgICAgbWVzc2FnZTogYEEgZ2VuZXJhdGVkIGNvbnRyYWN0IHBsYWNlaG9sZGVyIGZyb20gY29uZmlnLmxvYWQgY29uZmxpY3RzIHdpdGggYSBwbGFjZWhvbGRlciB5b3UndmUgc2V0IG1hbnVhbGx5IGluIGNvbmZpZyBoYXZlIHRoZSBzYW1lIG5hbWUuYCxcbiAgICAgICAgbGV2ZWw6IExFVkVMUyQxLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQkMShzeXN0ZW1Db250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1yZXR1cm5zXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXSAtIFRoZSB2YWx1ZXMgdG8gc2V0XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZyQxKHZhbHVlcykge1xuICBpZiAodmFsdWVzICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIikge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykubWFwKGQgPT4gcHV0JDEoZCwgdmFsdWVzW2RdKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdXQ6IHB1dCQxLFxuICAgIGdldDogZ2V0JDEsXG4gICAgYWxsOiBhbGwkMSxcbiAgICBmaXJzdDogZmlyc3QkMSxcbiAgICB1cGRhdGU6IHVwZGF0ZSQxLFxuICAgIGRlbGV0ZTogX2RlbGV0ZSQxLFxuICAgIHdoZXJlOiB3aGVyZSQxLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlJDEsXG4gICAgb3ZlcmxvYWQ6IG92ZXJsb2FkJDEsXG4gICAgbG9hZDogbG9hZCQxXG4gIH07XG59XG5jb25maWckMS5wdXQgPSBwdXQkMTtcbmNvbmZpZyQxLmdldCA9IGdldCQxO1xuY29uZmlnJDEuYWxsID0gYWxsJDE7XG5jb25maWckMS5maXJzdCA9IGZpcnN0JDE7XG5jb25maWckMS51cGRhdGUgPSB1cGRhdGUkMTtcbmNvbmZpZyQxLmRlbGV0ZSA9IF9kZWxldGUkMTtcbmNvbmZpZyQxLndoZXJlID0gd2hlcmUkMTtcbmNvbmZpZyQxLnN1YnNjcmliZSA9IHN1YnNjcmliZSQxO1xuY29uZmlnJDEub3ZlcmxvYWQgPSBvdmVybG9hZCQxO1xuY29uZmlnJDEubG9hZCA9IGxvYWQkMTtcbmNvbnN0IG5vb3AkMSA9IHYgPT4gdjtcbmZ1bmN0aW9uIG92ZXJsb2FkJDEoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wJDE7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgb2xkQ29uZmlnID0gYXdhaXQgYWxsJDEoKTtcbiAgICB0cnkge1xuICAgICAgY29uZmlnJDEob3B0cyk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soYXdhaXQgYWxsJDEoKSk7XG4gICAgICBhd2FpdCByZXNldENvbmZpZyQxKG9sZENvbmZpZyk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnJDEob2xkQ29uZmlnKTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgbGV2ZWxzIG9mIHRoZSBsb2dnZXJcbiAqIFxuICogQHR5cGVkZWYge09iamVjdH0gTEVWRUxTXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVidWcgLSBUaGUgZGVidWcgbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmZvIC0gVGhlIGluZm8gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb2cgLSBUaGUgbG9nIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2FybiAtIFRoZSB3YXJuIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXJyb3IgLSBUaGUgZXJyb3IgbGV2ZWxcbiAqIFxuICovXG5jb25zdCBMRVZFTFMkMSA9IE9iamVjdC5mcmVlemUoe1xuICBkZWJ1ZzogNSxcbiAgaW5mbzogNCxcbiAgbG9nOiAzLFxuICB3YXJuOiAyLFxuICBlcnJvcjogMVxufSk7XG5cbi8qKlxuICogQnVpbGRzIGEgbWVzc2FnZSBmb3JtYXR0ZWQgZm9yIHRoZSBsb2dnZXJcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIFRoZSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICogXG4gKiBAZXhhbXBsZVxuICogYnVpbGRMb2dnZXJNZXNzYWdlQXJncyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiIH0pXG4gKi9cbmNvbnN0IGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3MkMSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbYFxuICAgICVjJHt0aXRsZX1cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAke21lc3NhZ2V9XG5cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgYC5yZXBsYWNlKC9cXG5bXlxcU1xcclxcbl0rL2csIFwiXFxuXCIpLnRyaW0oKSwsIFwiZm9udC13ZWlnaHQ6Ym9sZDtmb250LWZhbWlseTptb25vc3BhY2U7XCJdO1xufTtcblxuLyoqXG4gKiBMb2dzIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGxldmVsIHNldCBpbiB0aGUgY29uZmlnXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYWx3YXlzIC0gV2hldGhlciB0byBhbHdheXMgc2hvdyB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGFsd2F5czogZmFsc2UgfSlcbiAqIFxuICovXG5jb25zdCBsb2ckMSA9IGFzeW5jIF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlLFxuICAgIGxldmVsLFxuICAgIGFsd2F5cyA9IGZhbHNlXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgY29uZmlnTG9nZ2VyTGV2ZWwgPSBhd2FpdCBjb25maWckMS5nZXQoXCJsb2dnZXIubGV2ZWxcIiwgTEVWRUxTJDEud2Fybik7XG5cbiAgLy8gSWYgY29uZmlnIGxldmVsIGlzIGJlbG93IG1lc3NhZ2UgbGV2ZWwgdGhlbiBkb24ndCBzaG93IGl0XG4gIGlmICghYWx3YXlzICYmIGNvbmZpZ0xvZ2dlckxldmVsIDwgbGV2ZWwpIHJldHVybjtcbiAgY29uc3QgbG9nZ2VyTWVzc2FnZUFyZ3MgPSBidWlsZExvZ2dlck1lc3NhZ2VBcmdzJDEoe1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSk7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIExFVkVMUyQxLmRlYnVnOlxuICAgICAgY29uc29sZS5kZWJ1ZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUyQxLmluZm86XG4gICAgICBjb25zb2xlLmluZm8oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMkMS53YXJuOlxuICAgICAgY29uc29sZS53YXJuKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTJDEuZXJyb3I6XG4gICAgICBjb25zb2xlLmVycm9yKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLmxvZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogTG9ncyBhIGRlcHJlY2F0aW9uIG5vdGljZVxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wa2cgLSBUaGUgcGFja2FnZSB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YmplY3QgLSBUaGUgc3ViamVjdCBvZiB0aGUgZGVwcmVjYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRyYW5zaXRpb24gLSBUaGUgdHJhbnNpdGlvbiBwYXRoIGZvciB0aGUgZGVwcmVjYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBydW4gYWZ0ZXIgdGhlIGxvZ1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsb2cuZGVwcmVjYXRlKHsgcGtnOiBcIkBvbmZsb3cvZmNsXCIsIHN1YmplY3Q6IFwiU29tZSBpdGVtXCIsIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNka1wiLCBtZXNzYWdlOiBcIkRlc2NyaXB0aXZlIG1lc3NhZ2VcIiwgbGV2ZWw6IExFVkVMUy53YXJuLCBjYWxsYmFjazogKCkgPT4ge30gfSlcbiAqIFxuICovXG5sb2ckMS5kZXByZWNhdGUgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgcGtnLFxuICAgIHN1YmplY3QsXG4gICAgdHJhbnNpdGlvbixcbiAgICBsZXZlbCA9IExFVkVMUyQxLndhcm4sXG4gICAgbWVzc2FnZSA9IFwiXCIsXG4gICAgY2FsbGJhY2sgPSBudWxsXG4gIH0gPSBfcmVmMztcbiAgY29uc3QgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gc3RyaW5nID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9O1xuICBjb25zdCBsb2dNZXNzYWdlID0gKCkgPT4gbG9nJDEoe1xuICAgIHRpdGxlOiBgJHtwa2cgPyBwa2cgKyBcIiBcIiA6IFwiXCJ9RGVwcmVjYXRpb24gTm90aWNlYCxcbiAgICBtZXNzYWdlOiBgXG4gICAgICAke3N1YmplY3QgPyBgJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3ViamVjdCl9IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgY2Vhc2UgdG8gd29yayBpbiBmdXR1cmUgcmVsZWFzZXMke3BrZyA/IFwiIG9mIFwiICsgcGtnIDogXCJcIn0uYCA6IFwiXCJ9JHttZXNzYWdlID8gXCJcXG5cIiArIG1lc3NhZ2UgOiBcIlwifSR7dHJhbnNpdGlvbiA/IGBcXG5Zb3UgY2FuIGxlYXJuIG1vcmUgKGluY2x1ZGluZyBhIGd1aWRlIG9uIGNvbW1vbiB0cmFuc2l0aW9uIHBhdGhzKSBoZXJlOiAke3RyYW5zaXRpb259YCA6IFwiXCJ9XG4gICAgYC50cmltKCksXG4gICAgbGV2ZWxcbiAgfSk7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBhd2FpdCBsb2dNZXNzYWdlKCk7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2soLi4uYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBsb2dNZXNzYWdlKCk7XG59O1xuXG4vKipcbiAqIEFzc2VydHMgZmFjdCBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3Igd2l0aCBpbnZhcmlhbnQgbWVzc2FnZVxuICogQHBhcmFtIHtib29sZWFufSBmYWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKiBAcGFyYW0ge0FycmF5fSByZXN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW52YXJpYW50KGZhY3QsIG1zZykge1xuICBpZiAoIWZhY3QpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSU5WQVJJQU5UICR7bXNnfWApO1xuICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGQgPT4gIS9hdCBpbnZhcmlhbnQvLnRlc3QoZCkpLmpvaW4oXCJcXG5cIik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJcXG5cXG4tLS1cXG5cXG5cIiwgZXJyb3IsIFwiXFxuXFxuXCIsIC4uLnJlc3QsIFwiXFxuXFxuLS0tXFxuXFxuXCIpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5jb25zdCBwaXBlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmMocmVzKTtcbiAgICB9LCB2KTtcbiAgfTtcbn07XG5cbi8qKipcbiAqIE1lcmdlIG11bHRpcGxlIGZ1bmN0aW9ucyByZXR1cm5pbmcgb2JqZWN0cyBpbnRvIG9uZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLmZ1bmN0aW9uKCopOiBvYmplY3R9IGZ1bmNzIC0gRnVuY3Rpb25zIHRvIG1lcmdlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBmdW5jc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIHJldHVybiB2ID0+IHtcbiAgICByZXR1cm4gZnVuY3MucmVkdWNlKChyZXMsIGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlcyxcbiAgICAgICAgLi4uZnVuYyh2KVxuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBPYmplY3QgY2hlY2tcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSXMgb2JqZWN0IHN0YXR1c1xuICovXG5jb25zdCBpc09iamVjdCA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gey4uLm9iamVjdFtdfSBzb3VyY2VzIC0gU291cmNlIG9iamVjdHNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZURlZXAgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc291cmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICBpZiAoIXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XToge31cbiAgICAgICAgfSk7XG4gICAgICAgIG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XTogc291cmNlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZURlZXAodGFyZ2V0LCAuLi5zb3VyY2VzKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgRmxvdyBKU09OLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHZhbHVlIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIEZsb3cgSlNPTlxuICovXG5jb25zdCBtZXJnZUZsb3dKU09OcyA9IHZhbHVlID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gbWVyZ2VEZWVwKHt9LCAuLi52YWx1ZSkgOiB2YWx1ZTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRmlsdGVyIG91dCBjb250cmFjdHMgc2VjdGlvbiBvZiBmbG93Lmpzb24uXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gb2JqIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3RzIHNlY3Rpb24gb2YgRmxvdyBKU09OXG4gKi9cbmNvbnN0IGZpbHRlckNvbnRyYWN0cyA9IG9iaiA9PiBvYmouY29udHJhY3RzID8gb2JqLmNvbnRyYWN0cyA6IHt9O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHYXRoZXJzIGNvbnRyYWN0IGFkZHJlc3NlcyBieSBuZXR3b3JrXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IG1hcENvbnRyYWN0QWxpYXNlc1RvTmV0d29ya0FkZHJlc3MgPSBuZXR3b3JrID0+IGNvbnRyYWN0cyA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjb250cmFjdHMpLnJlZHVjZSgoYywgX3JlZikgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgIGNvbnN0IG5ldHdvcmtDb250cmFjdEFsaWFzID0gdmFsdWU/LmFsaWFzZXM/LltuZXR3b3JrXTtcbiAgICBpZiAobmV0d29ya0NvbnRyYWN0QWxpYXMpIHtcbiAgICAgIGNba2V5XSA9IG5ldHdvcmtDb250cmFjdEFsaWFzO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwge30pO1xufTtcbmNvbnN0IG1hcERlcGxveW1lbnRzVG9OZXR3b3JrQWRkcmVzcyA9IG5ldHdvcmsgPT4gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGRlcGxveW1lbnRzID0ge30sXG4gICAgYWNjb3VudHMgPSB7fVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IG5ldHdvcmtEZXBsb3ltZW50ID0gZGVwbG95bWVudHM/LltuZXR3b3JrXTtcbiAgaWYgKCFuZXR3b3JrRGVwbG95bWVudCkgcmV0dXJuIHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobmV0d29ya0RlcGxveW1lbnQpLnJlZHVjZSgoYywgX3JlZjMpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgLy8gUmVzb2x2ZSBhY2NvdW50IGFkZHJlc3NcbiAgICBjb25zdCBhY2NvdW50QWRkcmVzcyA9IGFjY291bnRzW2tleV0/LmFkZHJlc3M7XG4gICAgaWYgKCFhY2NvdW50QWRkcmVzcykgcmV0dXJuIGM7XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IGFzc2lnbmluZyB0aGUgYWRkcmVzcyB0byB0aGUgY29udHJhY3QgbmFtZS5cbiAgICByZXR1cm4gdmFsdWUucmVkdWNlKChjLCBjb250cmFjdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgW2NvbnRyYWN0XTogYWNjb3VudEFkZHJlc3NcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGluIGZsb3cuanNvbiBmaWxlcyBhbmQgcmV0dXJuIGNvbnRyYWN0IHRvIGFkZHJlc3MgbWFwcGluZyBieSBuZXR3b3JrXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0ganNvbnMgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGdhdGhlciBhZGRyZXNzZXMgZm9yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0IG5hbWVzIGJ5IGFkZHJlc3NlcyBtYXBwaW5nIGUuZyB7IFwiSGVsbG9Xb3JsZFwiOiBcIjB4MTIzXCIgfVxuICovXG5jb25zdCBnZXRDb250cmFjdHMgPSAoanNvbnMsIG5ldHdvcmspID0+IHtcbiAgcmV0dXJuIHBpcGUobWVyZ2VGbG93SlNPTnMsIG1lcmdlUGlwZShtYXBEZXBsb3ltZW50c1RvTmV0d29ya0FkZHJlc3MobmV0d29yayksIHBpcGUoZmlsdGVyQ29udHJhY3RzLCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzKG5ldHdvcmspKSkpKGpzb25zKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiBzdHJpbmcgaXMgaGV4aWRlY2ltYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIGhleGlkZWNpbWFsIHN0YXR1c1xuICovXG5jb25zdCBpc0hleGlkZWNpbWFsID0gc3RyID0+IHtcbiAgLy8gQ2hlY2sgdGhhdCBpdCBpcyBhIHN0cmluZ1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gL15bMC05QS1GYS1mXSskLy50ZXN0KHN0cik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgZmxvdy5qc29uIGZpbGUgZm9yIHByaXZhdGUga2V5c1xuICogQHBhcmFtIHtvYmplY3R9IGZsb3dKU09OIC0gRmxvdyBKU09OXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBIYXMgcHJpdmF0ZSBrZXlzIHN0YXR1c1xuICovXG5jb25zdCBoYXNQcml2YXRlS2V5cyA9IGZsb3dKU09OID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZsb3dKU09OPy5hY2NvdW50cykucmVkdWNlKChoYXNQcml2YXRlS2V5LCBfcmVmNCkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmNDtcbiAgICBpZiAoaGFzUHJpdmF0ZUtleSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHZhbHVlPy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSAmJiBpc0hleGlkZWNpbWFsKHZhbHVlPy5rZXkpO1xuICB9LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNoZWNrcyBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gdmFsdWUgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgYW55SGFzUHJpdmF0ZUtleXMgPSB2YWx1ZSA9PiB7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHJldHVybiBoYXNQcml2YXRlS2V5cyh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZS5zb21lKGhhc1ByaXZhdGVLZXlzKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZvcm1hdCBuZXR3b3JrIHRvIGFsd2F5cyBiZSAnZW11bGF0b3InLCAndGVzdG5ldCcsIG9yICdtYWlubmV0J1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGZvcm1hdFxuICogQHJldHVybnMge3N0cmluZ30gLSBGb3JtYXR0ZWQgbmV0d29yayBuYW1lIChlaXRoZXIgJ2VtdWxhdG9yJywgJ3Rlc3RuZXQnLCBvciAnbWFpbm5ldCcpXG4gKi9cbmNvbnN0IGNsZWFuTmV0d29yayA9IG5ldHdvcmsgPT4gbmV0d29yaz8udG9Mb3dlckNhc2UoKSA9PT0gXCJsb2NhbFwiID8gXCJlbXVsYXRvclwiIDogbmV0d29yaz8udG9Mb3dlckNhc2UoKTtcbmNvbnN0IE5BTUUgPSBcImNvbmZpZ1wiO1xuY29uc3QgUFVUID0gXCJQVVRfQ09ORklHXCI7XG5jb25zdCBHRVQgPSBcIkdFVF9DT05GSUdcIjtcbmNvbnN0IEdFVF9BTEwgPSBcIkdFVF9BTExfQ09ORklHXCI7XG5jb25zdCBVUERBVEUgPSBcIlVQREFURV9DT05GSUdcIjtcbmNvbnN0IERFTEVURSA9IFwiREVMRVRFX0NPTkZJR1wiO1xuY29uc3QgQ0xFQVIgPSBcIkNMRUFSX0NPTkZJR1wiO1xuY29uc3QgV0hFUkUgPSBcIldIRVJFX0NPTkZJR1wiO1xuY29uc3QgVVBEQVRFRCA9IFwiQ09ORklHL1VQREFURURcIjtcbmNvbnN0IGlkZW50aXR5ID0gdiA9PiB2O1xuY29uc3QgSEFORExFUlMgPSB7XG4gIFtQVVRdOiAoY3R4LCBfbGV0dGVyLCBfcmVmKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvcHV0LlwiKTtcbiAgICBjdHgucHV0KGtleSwgdmFsdWUpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtHRVRdOiAoY3R4LCBsZXR0ZXIsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZhbGxiYWNrXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL2dldFwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LmdldChrZXksIGZhbGxiYWNrKSk7XG4gIH0sXG4gIFtHRVRfQUxMXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0dGVyLnJlcGx5KHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVVBEQVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmMykgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmblxuICAgIH0gPSBfcmVmMztcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy91cGRhdGVcIik7XG4gICAgY3R4LnVwZGF0ZShrZXksIGZuIHx8IGlkZW50aXR5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbREVMRVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmNCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlcbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZGVsZXRlXCIpO1xuICAgIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbQ0xFQVJdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGN0eC5hbGwoKSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbV0hFUkVdOiAoY3R4LCBsZXR0ZXIsIF9yZWY1KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdHRlcm5cbiAgICB9ID0gX3JlZjU7XG4gICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAncGF0dGVybicgZm9yIGNvbmZpZy93aGVyZVwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LndoZXJlKHBhdHRlcm4pKTtcbiAgfSxcbiAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VOU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnVuc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgfVxufTtcbnNwYXduKEhBTkRMRVJTLCBOQU1FKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQWRkcyBhIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGRcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gIHNlbmQoTkFNRSwgUFVULCB7XG4gICAga2V5LFxuICAgIHZhbHVlXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgYSBrZXktdmFsdWUgcGFpciB3aXRoIGEgZmFsbGJhY2sgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gW2ZhbGxiYWNrXSAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXQoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gc2VuZChOQU1FLCBHRVQsIHtcbiAgICBrZXksXG4gICAgZmFsbGJhY2tcbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCBjb25maWcgdmFsdWUgb3IgdGhlIGZhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YW50cyAtIFRoZSBrZXlzIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7Kn0gZmFsbGJhY2sgLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGxldCB3YW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIXdhbnRzLmxlbmd0aCkgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCBbaGVhZCwgLi4ucmVzdF0gPSB3YW50cztcbiAgY29uc3QgcmV0ID0gYXdhaXQgZ2V0KGhlYWQpO1xuICBpZiAocmV0ID09IG51bGwpIHJldHVybiBmaXJzdChyZXN0LCBmYWxsYmFjayk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGwoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIEdFVF9BTEwsIG51bGwsIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVXBkYXRlcyBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWx1ZSB3aXRoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiB1cGRhdGUoa2V5KSB7XG4gIGxldCBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWRlbnRpdHk7XG4gIHNlbmQoTkFNRSwgVVBEQVRFLCB7XG4gICAga2V5LFxuICAgIGZuXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlbGV0ZXMgYSBrZXktdmFsdWUgcGFpciBmcm9tIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGRlbGV0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgc2VuZChOQU1FLCBERUxFVEUsIHtcbiAgICBrZXlcbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgY29uZmlnIGJhc2VkIG9uIGEgcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCBrZXlzIGFnYWluc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIHN1YnNldCBvZiB0aGUgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHdoZXJlKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgV0hFUkUsIHtcbiAgICBwYXR0ZXJuXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gU3Vic2NyaWJlcyB0byBjb25maWcgdXBkYXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGNvbmZpZyBpcyB1cGRhdGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICByZXR1cm4gc3Vic2NyaWJlcihOQU1FLCAoKSA9PiBzcGF3bihIQU5ETEVSUywgTkFNRSksIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2xlYXJzIHRoZSBjb25maWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjbGVhckNvbmZpZygpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgQ0xFQVIpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIGNvbmZpZyB0byBhIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkQ29uZmlnIC0gVGhlIHByZXZpb3VzIGNvbmZpZyBzdGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb25maWcob2xkQ29uZmlnKSB7XG4gIHJldHVybiBjbGVhckNvbmZpZygpLnRoZW4oY29uZmlnKG9sZENvbmZpZykpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlcyBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjcmVhdGVzIGNvbnRyYWN0IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgLSBUaGUgZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWQoZGF0YSkge1xuICBjb25zdCBuZXR3b3JrID0gYXdhaXQgZ2V0KFwiZmxvdy5uZXR3b3JrXCIpO1xuICBjb25zdCBjbGVhbmVkTmV0d29yayA9IGNsZWFuTmV0d29yayhuZXR3b3JrKTtcbiAgY29uc3Qge1xuICAgIGZsb3dKU09OXG4gIH0gPSBkYXRhO1xuICBpbnZhcmlhbnQoQm9vbGVhbihmbG93SlNPTiksIFwiY29uZmlnLmxvYWQgLS0gJ2Zsb3dKU09OJyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudChjbGVhbmVkTmV0d29yaywgYEZsb3cgTmV0d29yayBSZXF1aXJlZCAtLSBJbiBvcmRlciBmb3IgRkNMIHRvIGxvYWQgeW91ciBjb250cmFjdHMgcGxlYXNlIGRlZmluZSBcImZsb3cubmV0d29ya1wiIHRvIFwiZW11bGF0b3JcIiwgXCJsb2NhbFwiLCBcInRlc3RuZXRcIiwgb3IgXCJtYWlubmV0XCIgaW4geW91ciBjb25maWcuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mY2wtanMvcmVmZXJlbmNlL2NvbmZpZ3VyZS1mY2xgKTtcbiAgaWYgKGFueUhhc1ByaXZhdGVLZXlzKGZsb3dKU09OKSkge1xuICAgIGNvbnN0IGlzRW11bGF0b3IgPSBjbGVhbmVkTmV0d29yayA9PT0gXCJlbXVsYXRvclwiO1xuICAgIGxvZyQxKHtcbiAgICAgIHRpdGxlOiBcIlByaXZhdGUgS2V5cyBEZXRlY3RlZFwiLFxuICAgICAgbWVzc2FnZTogYFByaXZhdGUga2V5cyBzaG91bGQgYmUgc3RvcmVkIGluIGEgc2VwYXJhdGUgZmxvdy5qc29uIGZpbGUgZm9yIHNlY3VyaXR5LiBTZWUgbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3BlcnMuZmxvdy5jb20vdG9vbHMvZmxvdy1jbGkvc2VjdXJpdHlgLFxuICAgICAgbGV2ZWw6IGlzRW11bGF0b3IgPyBMRVZFTFMkMS53YXJuIDogTEVWRUxTJDEuZXJyb3JcbiAgICB9KTtcbiAgICBpZiAoIWlzRW11bGF0b3IpIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnZXRDb250cmFjdHMoZmxvd0pTT04sIGNsZWFuZWROZXR3b3JrKSkpIHtcbiAgICBjb25zdCBjb250cmFjdENvbmZpZ0tleSA9IGAweCR7a2V5fWA7XG4gICAgY29uc3QgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSA9IGF3YWl0IGdldChjb250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgJiYgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyQxKHtcbiAgICAgICAgdGl0bGU6IFwiQ29udHJhY3QgUGxhY2Vob2xkZXIgQ29uZmxpY3QgRGV0ZWN0ZWRcIixcbiAgICAgICAgbWVzc2FnZTogYEEgZ2VuZXJhdGVkIGNvbnRyYWN0IHBsYWNlaG9sZGVyIGZyb20gY29uZmlnLmxvYWQgY29uZmxpY3RzIHdpdGggYSBwbGFjZWhvbGRlciB5b3UndmUgc2V0IG1hbnVhbGx5IGluIGNvbmZpZyBoYXZlIHRoZSBzYW1lIG5hbWUuYCxcbiAgICAgICAgbGV2ZWw6IExFVkVMUyQxLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoY29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtQ29udHJhY3RDb25maWdLZXkgPSBgc3lzdGVtLmNvbnRyYWN0cy4ke2tleX1gO1xuICAgIGNvbnN0IHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSA9IGF3YWl0IGdldChzeXN0ZW1Db250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAmJiBzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBsb2ckMSh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBMRVZFTFMkMS53YXJuXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHV0KHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLXJldHVybnNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdIC0gVGhlIHZhbHVlcyB0byBzZXRcbiAqL1xuZnVuY3Rpb24gY29uZmlnKHZhbHVlcykge1xuICBpZiAodmFsdWVzICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlcyA9PT0gXCJvYmplY3RcIikge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykubWFwKGQgPT4gcHV0KGQsIHZhbHVlc1tkXSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHV0LFxuICAgIGdldCxcbiAgICBhbGwsXG4gICAgZmlyc3QsXG4gICAgdXBkYXRlLFxuICAgIGRlbGV0ZTogX2RlbGV0ZSxcbiAgICB3aGVyZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgb3ZlcmxvYWQsXG4gICAgbG9hZFxuICB9O1xufVxuY29uZmlnLnB1dCA9IHB1dDtcbmNvbmZpZy5nZXQgPSBnZXQ7XG5jb25maWcuYWxsID0gYWxsO1xuY29uZmlnLmZpcnN0ID0gZmlyc3Q7XG5jb25maWcudXBkYXRlID0gdXBkYXRlO1xuY29uZmlnLmRlbGV0ZSA9IF9kZWxldGU7XG5jb25maWcud2hlcmUgPSB3aGVyZTtcbmNvbmZpZy5zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG5jb25maWcub3ZlcmxvYWQgPSBvdmVybG9hZDtcbmNvbmZpZy5sb2FkID0gbG9hZDtcbmNvbnN0IG5vb3AgPSB2ID0+IHY7XG5mdW5jdGlvbiBvdmVybG9hZCgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgb2xkQ29uZmlnID0gYXdhaXQgYWxsKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyhvcHRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhd2FpdCBjYWxsYmFjayhhd2FpdCBhbGwoKSk7XG4gICAgICBhd2FpdCByZXNldENvbmZpZyhvbGRDb25maWcpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCByZXNldENvbmZpZyhvbGRDb25maWcpO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBsZXZlbHMgb2YgdGhlIGxvZ2dlclxuICogXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMRVZFTFNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWJ1ZyAtIFRoZSBkZWJ1ZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZm8gLSBUaGUgaW5mbyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvZyAtIFRoZSBsb2cgbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3YXJuIC0gVGhlIHdhcm4gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcnJvciAtIFRoZSBlcnJvciBsZXZlbFxuICogXG4gKi9cbmNvbnN0IExFVkVMUyA9IE9iamVjdC5mcmVlemUoe1xuICBkZWJ1ZzogNSxcbiAgaW5mbzogNCxcbiAgbG9nOiAzLFxuICB3YXJuOiAyLFxuICBlcnJvcjogMVxufSk7XG5cbi8qKlxuICogQnVpbGRzIGEgbWVzc2FnZSBmb3JtYXR0ZWQgZm9yIHRoZSBsb2dnZXJcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIFRoZSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICogXG4gKiBAZXhhbXBsZVxuICogYnVpbGRMb2dnZXJNZXNzYWdlQXJncyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiIH0pXG4gKi9cbmNvbnN0IGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3MgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gW2BcbiAgICAlYyR7dGl0bGV9XG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgJHttZXNzYWdlfVxuXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGAucmVwbGFjZSgvXFxuW15cXFNcXHJcXG5dKy9nLCBcIlxcblwiKS50cmltKCksLCBcImZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO1wiXTtcbn07XG5cbi8qKlxuICogTG9ncyBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgbGV2ZWwgb2YgdGhlIG1lc3NhZ2UgYW5kIHRoZSBsZXZlbCBzZXQgaW4gdGhlIGNvbmZpZ1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFsd2F5cyAtIFdoZXRoZXIgdG8gYWx3YXlzIHNob3cgdGhlIGxvZ1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsb2coeyB0aXRsZTogXCJNeSBUaXRsZVwiLCBtZXNzYWdlOiBcIk15IE1lc3NhZ2VcIiwgbGV2ZWw6IExFVkVMUy53YXJuLCBhbHdheXM6IGZhbHNlIH0pXG4gKiBcbiAqL1xuY29uc3QgbG9nID0gYXN5bmMgX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwsXG4gICAgYWx3YXlzID0gZmFsc2VcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBjb25maWdMb2dnZXJMZXZlbCA9IGF3YWl0IGNvbmZpZy5nZXQoXCJsb2dnZXIubGV2ZWxcIiwgTEVWRUxTLndhcm4pO1xuXG4gIC8vIElmIGNvbmZpZyBsZXZlbCBpcyBiZWxvdyBtZXNzYWdlIGxldmVsIHRoZW4gZG9uJ3Qgc2hvdyBpdFxuICBpZiAoIWFsd2F5cyAmJiBjb25maWdMb2dnZXJMZXZlbCA8IGxldmVsKSByZXR1cm47XG4gIGNvbnN0IGxvZ2dlck1lc3NhZ2VBcmdzID0gYnVpbGRMb2dnZXJNZXNzYWdlQXJncyh7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZVxuICB9KTtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgTEVWRUxTLmRlYnVnOlxuICAgICAgY29uc29sZS5kZWJ1ZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy5pbmZvOlxuICAgICAgY29uc29sZS5pbmZvKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLndhcm46XG4gICAgICBjb25zb2xlLndhcm4oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMuZXJyb3I6XG4gICAgICBjb25zb2xlLmVycm9yKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLmxvZyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogTG9ncyBhIGRlcHJlY2F0aW9uIG5vdGljZVxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wa2cgLSBUaGUgcGFja2FnZSB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YmplY3QgLSBUaGUgc3ViamVjdCBvZiB0aGUgZGVwcmVjYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRyYW5zaXRpb24gLSBUaGUgdHJhbnNpdGlvbiBwYXRoIGZvciB0aGUgZGVwcmVjYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBydW4gYWZ0ZXIgdGhlIGxvZ1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsb2cuZGVwcmVjYXRlKHsgcGtnOiBcIkBvbmZsb3cvZmNsXCIsIHN1YmplY3Q6IFwiU29tZSBpdGVtXCIsIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNka1wiLCBtZXNzYWdlOiBcIkRlc2NyaXB0aXZlIG1lc3NhZ2VcIiwgbGV2ZWw6IExFVkVMUy53YXJuLCBjYWxsYmFjazogKCkgPT4ge30gfSlcbiAqIFxuICovXG5sb2cuZGVwcmVjYXRlID0gX3JlZjMgPT4ge1xuICBsZXQge1xuICAgIHBrZyxcbiAgICBzdWJqZWN0LFxuICAgIHRyYW5zaXRpb24sXG4gICAgbGV2ZWwgPSBMRVZFTFMud2FybixcbiAgICBtZXNzYWdlID0gXCJcIixcbiAgICBjYWxsYmFjayA9IG51bGxcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH07XG4gIGNvbnN0IGxvZ01lc3NhZ2UgPSAoKSA9PiBsb2coe1xuICAgIHRpdGxlOiBgJHtwa2cgPyBwa2cgKyBcIiBcIiA6IFwiXCJ9RGVwcmVjYXRpb24gTm90aWNlYCxcbiAgICBtZXNzYWdlOiBgXG4gICAgICAke3N1YmplY3QgPyBgJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3ViamVjdCl9IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgY2Vhc2UgdG8gd29yayBpbiBmdXR1cmUgcmVsZWFzZXMke3BrZyA/IFwiIG9mIFwiICsgcGtnIDogXCJcIn0uYCA6IFwiXCJ9JHttZXNzYWdlID8gXCJcXG5cIiArIG1lc3NhZ2UgOiBcIlwifSR7dHJhbnNpdGlvbiA/IGBcXG5Zb3UgY2FuIGxlYXJuIG1vcmUgKGluY2x1ZGluZyBhIGd1aWRlIG9uIGNvbW1vbiB0cmFuc2l0aW9uIHBhdGhzKSBoZXJlOiAke3RyYW5zaXRpb259YCA6IFwiXCJ9XG4gICAgYC50cmltKCksXG4gICAgbGV2ZWxcbiAgfSk7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBhd2FpdCBsb2dNZXNzYWdlKCk7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2soLi4uYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBsb2dNZXNzYWdlKCk7XG59O1xuXG5mdW5jdGlvbiBpbnRlcmxlYXZlKCkge1xuICBsZXQgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgbGV0IGMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICBpZiAoIWEubGVuZ3RoICYmICFiLmxlbmd0aCkgcmV0dXJuIGM7XG4gIGlmICghYS5sZW5ndGgpIHJldHVybiBjO1xuICBpZiAoIWIubGVuZ3RoKSByZXR1cm4gWy4uLmMsIGFbMF1dO1xuICBjb25zdCBbYUhlYWQsIC4uLmFSZXN0XSA9IGE7XG4gIGNvbnN0IFtiSGVhZCwgLi4uYlJlc3RdID0gYjtcbiAgaWYgKGFIZWFkICE9PSB1bmRlZmluZWQpIGMucHVzaChhSGVhZCk7XG4gIGlmIChiSGVhZCAhPT0gdW5kZWZpbmVkKSBjLnB1c2goYkhlYWQpO1xuICByZXR1cm4gaW50ZXJsZWF2ZShhUmVzdCwgYlJlc3QsIGMpO1xufVxuZnVuY3Rpb24gcmVjQXBwbHkoZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbG9nLmRlcHJlY2F0ZSh7XG4gICAgICAgIHBrZzogXCJGQ0wvU0RLXCIsXG4gICAgICAgIHN1YmplY3Q6IFwiSW50ZXJvcG9sYXRpb24gb2YgZnVuY3Rpb25zIGludG8gdGVtcGxhdGUgbGl0ZXJhbHNcIixcbiAgICAgICAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9UUkFOU0lUSU9OUy5tZCMwMDAxLWRlcHJlY2F0ZS1wYXJhbXNcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjQXBwbHkoZCkoYXJnMShkKSk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYXJnMSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nfEFycmF5LjwqPil9IGhlYWRcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSByZXN0XG4gKiBAcmV0dXJucyB7e2Z1bmN0aW9uKCk6IHN0cmluZ319XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKGhlYWQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmICh0eXBlb2YgaGVhZCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuICgpID0+IGhlYWQ7XG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWQpKSB7XG4gICAgcmV0dXJuIGQgPT4gaW50ZXJsZWF2ZShoZWFkLCByZXN0Lm1hcChyZWNBcHBseShkKSkpLmpvaW4oXCJcIikudHJpbSgpO1xuICB9XG4gIHJldHVybiBoZWFkO1xufVxuXG5leHBvcnQgeyBpbnRlcmxlYXZlLCB0ZW1wbGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-template/dist/template.module.js\n"));

/***/ }),

/***/ "./node_modules/@onflow/util-uid/dist/util-uid.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/@onflow/util-uid/dist/util-uid.module.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uid: function() { return /* binding */ uid; }\n/* harmony export */ });\n/**\n * Generates a unique identifier\n * @returns {string}\n */\nvar HEX = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nvar T = HEX.length;\nfunction uid() {\n  var str = \"\",\n    num = 32;\n  while (num--) str += HEX[Math.random() * T | 0];\n  return str;\n}\n\n\n//# sourceMappingURL=util-uid.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLXVpZC9kaXN0L3V0aWwtdWlkLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLXVpZC9kaXN0L3V0aWwtdWlkLm1vZHVsZS5qcz8yZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIGlkZW50aWZpZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnZhciBIRVggPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5XCI7XG52YXIgVCA9IEhFWC5sZW5ndGg7XG5mdW5jdGlvbiB1aWQoKSB7XG4gIHZhciBzdHIgPSBcIlwiLFxuICAgIG51bSA9IDMyO1xuICB3aGlsZSAobnVtLS0pIHN0ciArPSBIRVhbTWF0aC5yYW5kb20oKSAqIFQgfCAwXTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IHsgdWlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLXVpZC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@onflow/util-uid/dist/util-uid.module.js\n"));

/***/ }),

/***/ "./node_modules/abort-controller/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/abort-controller/browser.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*globals self, window */\n\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports[\"default\"] = AbortController\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ1k7O0FBRVo7QUFDQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Fib3J0LWNvbnRyb2xsZXIvYnJvd3Nlci5qcz8xN2ViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFscyBzZWxmLCB3aW5kb3cgKi9cblwidXNlIHN0cmljdFwiXG5cbi8qZXNsaW50LWRpc2FibGUgQG15c3RpY2F0ZWEvcHJldHRpZXIgKi9cbmNvbnN0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9ID1cbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIC8qIG90aGVyd2lzZSAqLyB1bmRlZmluZWRcbi8qZXNsaW50LWVuYWJsZSBAbXlzdGljYXRlYS9wcmV0dGllciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFib3J0Q29udHJvbGxlclxubW9kdWxlLmV4cG9ydHMuQWJvcnRTaWduYWwgPSBBYm9ydFNpZ25hbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFib3J0Q29udHJvbGxlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/abort-controller/browser.js\n"));

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFD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Q047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/OTAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RDs7QUFFQSxDQUFDLElBQUk7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFlO0FBQ2YsYUFBYSxtQ0FBbUMsT0FBTztBQUN2RCxlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzP2ViZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzO1xudmFyIF9fc2VsZl9fID0gKGZ1bmN0aW9uICgpIHtcbmZ1bmN0aW9uIEYoKSB7XG50aGlzLmZldGNoID0gZmFsc2U7XG50aGlzLkRPTUV4Y2VwdGlvbiA9IGdsb2JhbC5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gZ2xvYmFsO1xucmV0dXJuIG5ldyBGKCk7XG59KSgpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxudmFyIGlycmVsZXZhbnQgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgICAnQmxvYicgaW4gc2VsZiAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghc2VsZi5mZXRjaCkge1xuICAgIHNlbGYuZmV0Y2ggPSBmZXRjaDtcbiAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSkoe30pO1xufSkoX19zZWxmX18pO1xuX19zZWxmX18uZmV0Y2gucG9ueWZpbGwgPSB0cnVlO1xuLy8gUmVtb3ZlIFwicG9seWZpbGxcIiBwcm9wZXJ0eSBhZGRlZCBieSB3aGF0d2ctZmV0Y2hcbmRlbGV0ZSBfX3NlbGZfXy5mZXRjaC5wb2x5ZmlsbDtcbi8vIENob29zZSBiZXR3ZWVuIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiAoZ2xvYmFsKSBvciBjdXN0b20gaW1wbGVtZW50YXRpb24gKF9fc2VsZl9fKVxuLy8gdmFyIGN0eCA9IGdsb2JhbC5mZXRjaCA/IGdsb2JhbCA6IF9fc2VsZl9fO1xudmFyIGN0eCA9IF9fc2VsZl9fOyAvLyB0aGlzIGxpbmUgZGlzYWJsZSBzZXJ2aWNlIHdvcmtlciBzdXBwb3J0IHRlbXBvcmFyaWx5XG5leHBvcnRzID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5kZWZhdWx0ID0gY3R4LmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQge2ZldGNofSBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuSGVhZGVycyA9IGN0eC5IZWFkZXJzXG5leHBvcnRzLlJlcXVlc3QgPSBjdHguUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IGN0eC5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cross-fetch/dist/browser-ponyfill.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanM/ZWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-feature-settings: inherit; /* 1 */\\n  font-variation-settings: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nReset default styling for dialogs.\\n*/\\ndialog {\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n.container {\\n  width: 100%;\\n}\\n@media (min-width: 640px) {\\n\\n  .container {\\n    max-width: 640px;\\n  }\\n}\\n@media (min-width: 768px) {\\n\\n  .container {\\n    max-width: 768px;\\n  }\\n}\\n@media (min-width: 1024px) {\\n\\n  .container {\\n    max-width: 1024px;\\n  }\\n}\\n@media (min-width: 1280px) {\\n\\n  .container {\\n    max-width: 1280px;\\n  }\\n}\\n@media (min-width: 1536px) {\\n\\n  .container {\\n    max-width: 1536px;\\n  }\\n}\\n.fixed {\\n  position: fixed;\\n}\\n.absolute {\\n  position: absolute;\\n}\\n.relative {\\n  position: relative;\\n}\\n.sticky {\\n  position: sticky;\\n}\\n.inset-0 {\\n  inset: 0px;\\n}\\n.-top-1 {\\n  top: -0.25rem;\\n}\\n.left-0 {\\n  left: 0px;\\n}\\n.right-0 {\\n  right: 0px;\\n}\\n.right-\\\\[16px\\\\] {\\n  right: 16px;\\n}\\n.top-0 {\\n  top: 0px;\\n}\\n.top-1 {\\n  top: 0.25rem;\\n}\\n.z-20 {\\n  z-index: 20;\\n}\\n.z-\\\\[-1\\\\] {\\n  z-index: -1;\\n}\\n.float-right {\\n  float: right;\\n}\\n.float-left {\\n  float: left;\\n}\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.my-0 {\\n  margin-top: 0px;\\n  margin-bottom: 0px;\\n}\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\n.-ml-1 {\\n  margin-left: -0.25rem;\\n}\\n.-mt-2 {\\n  margin-top: -0.5rem;\\n}\\n.-mt-3 {\\n  margin-top: -0.75rem;\\n}\\n.-mt-\\\\[4px\\\\] {\\n  margin-top: -4px;\\n}\\n.mb-1 {\\n  margin-bottom: 0.25rem;\\n}\\n.mb-10 {\\n  margin-bottom: 2.5rem;\\n}\\n.mb-3 {\\n  margin-bottom: 0.75rem;\\n}\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\n.mb-6 {\\n  margin-bottom: 1.5rem;\\n}\\n.mb-\\\\[20px\\\\] {\\n  margin-bottom: 20px;\\n}\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\n.ml-4 {\\n  margin-left: 1rem;\\n}\\n.ml-40 {\\n  margin-left: 10rem;\\n}\\n.mr-1 {\\n  margin-right: 0.25rem;\\n}\\n.mr-2 {\\n  margin-right: 0.5rem;\\n}\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\n.mt-0 {\\n  margin-top: 0px;\\n}\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\n.mt-6 {\\n  margin-top: 1.5rem;\\n}\\n.mt-8 {\\n  margin-top: 2rem;\\n}\\n.mt-96 {\\n  margin-top: 24rem;\\n}\\n.line-clamp-2 {\\n  overflow: hidden;\\n  display: -webkit-box;\\n  -webkit-box-orient: vertical;\\n  -webkit-line-clamp: 2;\\n}\\n.block {\\n  display: block;\\n}\\n.inline-block {\\n  display: inline-block;\\n}\\n.inline {\\n  display: inline;\\n}\\n.flex {\\n  display: flex;\\n}\\n.hidden {\\n  display: none;\\n}\\n.h-3 {\\n  height: 0.75rem;\\n}\\n.h-\\\\[26px\\\\] {\\n  height: 26px;\\n}\\n.h-\\\\[40px\\\\] {\\n  height: 40px;\\n}\\n.h-full {\\n  height: 100%;\\n}\\n.h-screen {\\n  height: 100vh;\\n}\\n.max-h-64 {\\n  max-height: 16rem;\\n}\\n.w-full {\\n  width: 100%;\\n}\\n.min-w-full {\\n  min-width: 100%;\\n}\\n.max-w-6xl {\\n  max-width: 72rem;\\n}\\n.max-w-\\\\[1012px\\\\] {\\n  max-width: 1012px;\\n}\\n.cursor-help {\\n  cursor: help;\\n}\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\n.flex-col {\\n  flex-direction: column;\\n}\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\n.flex-nowrap {\\n  flex-wrap: nowrap;\\n}\\n.place-items-center {\\n  place-items: center;\\n}\\n.items-start {\\n  align-items: flex-start;\\n}\\n.items-center {\\n  align-items: center;\\n}\\n.justify-end {\\n  justify-content: flex-end;\\n}\\n.justify-center {\\n  justify-content: center;\\n}\\n.justify-between {\\n  justify-content: space-between;\\n}\\n.gap-1 {\\n  gap: 0.25rem;\\n}\\n.gap-2 {\\n  gap: 0.5rem;\\n}\\n.gap-x-3 {\\n  -moz-column-gap: 0.75rem;\\n       column-gap: 0.75rem;\\n}\\n.gap-y-\\\\[10px\\\\] {\\n  row-gap: 10px;\\n}\\n.space-x-1 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-y-3 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));\\n}\\n.self-center {\\n  align-self: center;\\n}\\n.overflow-y-auto {\\n  overflow-y: auto;\\n}\\n.overflow-x-hidden {\\n  overflow-x: hidden;\\n}\\n.truncate {\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\n.break-words {\\n  overflow-wrap: break-word;\\n}\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\n.border {\\n  border-width: 1px;\\n}\\n.border-y {\\n  border-top-width: 1px;\\n  border-bottom-width: 1px;\\n}\\n.\\\\!border-t-0 {\\n  border-top-width: 0px !important;\\n}\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\n.border-b-2 {\\n  border-bottom-width: 2px;\\n}\\n.border-b-4 {\\n  border-bottom-width: 4px;\\n}\\n.border-l-4 {\\n  border-left-width: 4px;\\n}\\n.border-black {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(0 0 0 / var(--tw-border-opacity));\\n}\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.border-gray-400 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\n}\\n.border-gray-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(75 85 99 / var(--tw-border-opacity));\\n}\\n.border-transparent {\\n  border-color: transparent;\\n}\\n.border-yellow-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(202 138 4 / var(--tw-border-opacity));\\n}\\n.bg-gray-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\n.bg-gray-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity));\\n}\\n.bg-teal-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(45 212 191 / var(--tw-bg-opacity));\\n}\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.bg-white\\\\/30 {\\n  background-color: rgb(255 255 255 / 0.3);\\n}\\n.bg-gradient-to-b {\\n  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));\\n}\\n.from-zinc-200 {\\n  --tw-gradient-from: #e4e4e7 var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(228 228 231 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n.fill-current {\\n  fill: currentColor;\\n}\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\n.p-2 {\\n  padding: 0.5rem;\\n}\\n.p-3 {\\n  padding: 0.75rem;\\n}\\n.p-4 {\\n  padding: 1rem;\\n}\\n.p-8 {\\n  padding: 2rem;\\n}\\n.p-\\\\[6px\\\\] {\\n  padding: 6px;\\n}\\n.px-0 {\\n  padding-left: 0px;\\n  padding-right: 0px;\\n}\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\n.px-6 {\\n  padding-left: 1.5rem;\\n  padding-right: 1.5rem;\\n}\\n.px-\\\\[20px\\\\] {\\n  padding-left: 20px;\\n  padding-right: 20px;\\n}\\n.px-\\\\[22px\\\\] {\\n  padding-left: 22px;\\n  padding-right: 22px;\\n}\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\n.pb-1 {\\n  padding-bottom: 0.25rem;\\n}\\n.pb-6 {\\n  padding-bottom: 1.5rem;\\n}\\n.pl-0 {\\n  padding-left: 0px;\\n}\\n.pl-3 {\\n  padding-left: 0.75rem;\\n}\\n.pl-4 {\\n  padding-left: 1rem;\\n}\\n.pr-0 {\\n  padding-right: 0px;\\n}\\n.pr-2 {\\n  padding-right: 0.5rem;\\n}\\n.pr-4 {\\n  padding-right: 1rem;\\n}\\n.pr-\\\\[80px\\\\] {\\n  padding-right: 80px;\\n}\\n.pt-2 {\\n  padding-top: 0.5rem;\\n}\\n.pt-4 {\\n  padding-top: 1rem;\\n}\\n.text-left {\\n  text-align: left;\\n}\\n.text-center {\\n  text-align: center;\\n}\\n.align-middle {\\n  vertical-align: middle;\\n}\\n.font-mono {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace;\\n}\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\n.text-5xl {\\n  font-size: 3rem;\\n  line-height: 1;\\n}\\n.text-\\\\[17px\\\\] {\\n  font-size: 17px;\\n}\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\n.font-bold {\\n  font-weight: 700;\\n}\\n.font-extrabold {\\n  font-weight: 800;\\n}\\n.font-semibold {\\n  font-weight: 600;\\n}\\n.font-thin {\\n  font-weight: 100;\\n}\\n.leading-5 {\\n  line-height: 1.25rem;\\n}\\n.leading-\\\\[32px\\\\] {\\n  line-height: 32px;\\n}\\n.leading-\\\\[40px\\\\] {\\n  line-height: 40px;\\n}\\n.leading-\\\\[43px\\\\] {\\n  line-height: 43px;\\n}\\n.leading-\\\\[44px\\\\] {\\n  line-height: 44px;\\n}\\n.leading-normal {\\n  line-height: 1.5;\\n}\\n.text-gray-100 {\\n  --tw-text-opacity: 1;\\n  color: rgb(243 244 246 / var(--tw-text-opacity));\\n}\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\n.text-gray-800 {\\n  --tw-text-opacity: 1;\\n  color: rgb(31 41 55 / var(--tw-text-opacity));\\n}\\n.text-teal-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(45 212 191 / var(--tw-text-opacity));\\n}\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n.underline {\\n  text-decoration-line: underline;\\n}\\n.no-underline {\\n  text-decoration-line: none;\\n}\\n.shadow {\\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.backdrop-blur-2xl {\\n  --tw-backdrop-blur: blur(40px);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n.backdrop-blur-md {\\n  --tw-backdrop-blur: blur(12px);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n.transition-colors {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.duration-200 {\\n  transition-duration: 200ms;\\n}\\n\\n:root {\\n  --foreground-rgb: 0, 0, 0;\\n  --background-start-rgb: 214, 219, 220;\\n  --background-end-rgb: 255, 255, 255;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  :root {\\n    --foreground-rgb: 255, 255, 255;\\n    --background-start-rgb: 0, 0, 0;\\n    --background-end-rgb: 0, 0, 0;\\n  }\\n}\\n\\nbody {\\n  color: rgb(var(--foreground-rgb));\\n  background: linear-gradient(\\n      to bottom,\\n      transparent,\\n      rgb(var(--background-end-rgb))\\n    )\\n    rgb(var(--background-start-rgb));\\n}\\n\\n.before\\\\:absolute::before {\\n  content: var(--tw-content);\\n  position: absolute;\\n}\\n\\n.before\\\\:h-\\\\[300px\\\\]::before {\\n  content: var(--tw-content);\\n  height: 300px;\\n}\\n\\n.before\\\\:w-\\\\[480px\\\\]::before {\\n  content: var(--tw-content);\\n  width: 480px;\\n}\\n\\n.before\\\\:-translate-x-1\\\\/2::before {\\n  content: var(--tw-content);\\n  --tw-translate-x: -50%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.before\\\\:rounded-full::before {\\n  content: var(--tw-content);\\n  border-radius: 9999px;\\n}\\n\\n.before\\\\:bg-gradient-radial::before {\\n  content: var(--tw-content);\\n  background-image: radial-gradient(var(--tw-gradient-stops));\\n}\\n\\n.before\\\\:from-white::before {\\n  content: var(--tw-content);\\n  --tw-gradient-from: #fff var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n\\n.before\\\\:to-transparent::before {\\n  content: var(--tw-content);\\n  --tw-gradient-to: transparent var(--tw-gradient-to-position);\\n}\\n\\n.before\\\\:blur-2xl::before {\\n  content: var(--tw-content);\\n  --tw-blur: blur(40px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n\\n.before\\\\:content-\\\\[\\\\'\\\\'\\\\]::before {\\n  --tw-content: '';\\n  content: var(--tw-content);\\n}\\n\\n.after\\\\:absolute::after {\\n  content: var(--tw-content);\\n  position: absolute;\\n}\\n\\n.after\\\\:-z-20::after {\\n  content: var(--tw-content);\\n  z-index: -20;\\n}\\n\\n.after\\\\:h-\\\\[180px\\\\]::after {\\n  content: var(--tw-content);\\n  height: 180px;\\n}\\n\\n.after\\\\:w-\\\\[240px\\\\]::after {\\n  content: var(--tw-content);\\n  width: 240px;\\n}\\n\\n.after\\\\:translate-x-1\\\\/3::after {\\n  content: var(--tw-content);\\n  --tw-translate-x: 33.333333%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.after\\\\:bg-gradient-conic::after {\\n  content: var(--tw-content);\\n  background-image: conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops));\\n}\\n\\n.after\\\\:from-sky-200::after {\\n  content: var(--tw-content);\\n  --tw-gradient-from: #bae6fd var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(186 230 253 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n\\n.after\\\\:via-blue-200::after {\\n  content: var(--tw-content);\\n  --tw-gradient-to: rgb(191 219 254 / 0)  var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), #bfdbfe var(--tw-gradient-via-position), var(--tw-gradient-to);\\n}\\n\\n.after\\\\:blur-2xl::after {\\n  content: var(--tw-content);\\n  --tw-blur: blur(40px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n\\n.after\\\\:content-\\\\[\\\\'\\\\'\\\\]::after {\\n  --tw-content: '';\\n  content: var(--tw-content);\\n}\\n\\n.hover\\\\:whitespace-break-spaces:hover {\\n  white-space: break-spaces;\\n}\\n\\n.hover\\\\:border-yellow-600:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(202 138 4 / var(--tw-border-opacity));\\n}\\n\\n.hover\\\\:bg-gray-300:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-teal-300:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(94 234 212 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-teal-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-yellow-100:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(254 249 195 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-yellow-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:text-yellow-600:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(202 138 4 / var(--tw-text-opacity));\\n}\\n\\n.focus\\\\:bg-gray-100:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\n}\\n\\n.focus\\\\:bg-white:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n\\n  .dark\\\\:border-neutral-800 {\\n    --tw-border-opacity: 1;\\n    border-color: rgb(38 38 38 / var(--tw-border-opacity));\\n  }\\n\\n  .dark\\\\:bg-zinc-800\\\\/30 {\\n    background-color: rgb(39 39 42 / 0.3);\\n  }\\n\\n  .dark\\\\:from-inherit {\\n    --tw-gradient-from: inherit var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .dark\\\\:drop-shadow-\\\\[0_0_0\\\\.3rem_\\\\#ffffff70\\\\] {\\n    --tw-drop-shadow: drop-shadow(0 0 0.3rem #ffffff70);\\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n  }\\n\\n  .dark\\\\:invert {\\n    --tw-invert: invert(100%);\\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n  }\\n\\n  .before\\\\:dark\\\\:bg-gradient-to-br::before {\\n    content: var(--tw-content);\\n    background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));\\n  }\\n\\n  .before\\\\:dark\\\\:from-transparent::before {\\n    content: var(--tw-content);\\n    --tw-gradient-from: transparent var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .before\\\\:dark\\\\:to-blue-700::before {\\n    content: var(--tw-content);\\n    --tw-gradient-to: #1d4ed8 var(--tw-gradient-to-position);\\n  }\\n\\n  .before\\\\:dark\\\\:opacity-10::before {\\n    content: var(--tw-content);\\n    opacity: 0.1;\\n  }\\n\\n  .after\\\\:dark\\\\:from-sky-900::after {\\n    content: var(--tw-content);\\n    --tw-gradient-from: #0c4a6e var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(12 74 110 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .after\\\\:dark\\\\:via-\\\\[\\\\#0141ff\\\\]::after {\\n    content: var(--tw-content);\\n    --tw-gradient-to: rgb(1 65 255 / 0)  var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), #0141ff var(--tw-gradient-via-position), var(--tw-gradient-to);\\n  }\\n\\n  .after\\\\:dark\\\\:opacity-40::after {\\n    content: var(--tw-content);\\n    opacity: 0.4;\\n  }\\n}\\n\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .sm\\\\:w-auto {\\n    width: auto;\\n  }\\n\\n  .sm\\\\:flex-row {\\n    flex-direction: row;\\n  }\\n\\n  .sm\\\\:p-4 {\\n    padding: 1rem;\\n  }\\n\\n  .sm\\\\:leading-6 {\\n    line-height: 1.5rem;\\n  }\\n}\\n\\n@media (min-width: 768px) {\\n\\n  .md\\\\:right-\\\\[12px\\\\] {\\n    right: 12px;\\n  }\\n\\n  .md\\\\:top-\\\\[10px\\\\] {\\n    top: 10px;\\n  }\\n\\n  .md\\\\:my-2 {\\n    margin-top: 0.5rem;\\n    margin-bottom: 0.5rem;\\n  }\\n\\n  .md\\\\:mb-0 {\\n    margin-bottom: 0px;\\n  }\\n\\n  .md\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .md\\\\:flex {\\n    display: flex;\\n  }\\n\\n  .md\\\\:w-1\\\\/3 {\\n    width: 33.333333%;\\n  }\\n\\n  .md\\\\:w-2\\\\/3 {\\n    width: 66.666667%;\\n  }\\n\\n  .md\\\\:max-w-\\\\[340px\\\\] {\\n    max-width: 340px;\\n  }\\n\\n  .md\\\\:items-center {\\n    align-items: center;\\n  }\\n\\n  .md\\\\:rounded-xl {\\n    border-radius: 0.75rem;\\n  }\\n\\n  .md\\\\:border {\\n    border-width: 1px;\\n  }\\n\\n  .md\\\\:border-4 {\\n    border-width: 4px;\\n  }\\n\\n  .md\\\\:\\\\!border-t {\\n    border-top-width: 1px !important;\\n  }\\n\\n  .md\\\\:px-0 {\\n    padding-left: 0px;\\n    padding-right: 0px;\\n  }\\n\\n  .md\\\\:px-3 {\\n    padding-left: 0.75rem;\\n    padding-right: 0.75rem;\\n  }\\n\\n  .md\\\\:px-4 {\\n    padding-left: 1rem;\\n    padding-right: 1rem;\\n  }\\n\\n  .md\\\\:py-0 {\\n    padding-top: 0px;\\n    padding-bottom: 0px;\\n  }\\n\\n  .md\\\\:pb-0 {\\n    padding-bottom: 0px;\\n  }\\n\\n  .md\\\\:pt-3 {\\n    padding-top: 0.75rem;\\n  }\\n\\n  .md\\\\:text-left {\\n    text-align: left;\\n  }\\n}\\n\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:static {\\n    position: static;\\n  }\\n\\n  .lg\\\\:fixed {\\n    position: fixed;\\n  }\\n\\n  .lg\\\\:right-\\\\[10px\\\\] {\\n    right: 10px;\\n  }\\n\\n  .lg\\\\:my-0 {\\n    margin-top: 0px;\\n    margin-bottom: 0px;\\n  }\\n\\n  .lg\\\\:my-3 {\\n    margin-top: 0.75rem;\\n    margin-bottom: 0.75rem;\\n  }\\n\\n  .lg\\\\:mb-0 {\\n    margin-bottom: 0px;\\n  }\\n\\n  .lg\\\\:mb-3 {\\n    margin-bottom: 0.75rem;\\n  }\\n\\n  .lg\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .lg\\\\:mt-72 {\\n    margin-top: 18rem;\\n  }\\n\\n  .lg\\\\:mt-8 {\\n    margin-top: 2rem;\\n  }\\n\\n  .lg\\\\:block {\\n    display: block;\\n  }\\n\\n  .lg\\\\:flex {\\n    display: flex;\\n  }\\n\\n  .lg\\\\:hidden {\\n    display: none;\\n  }\\n\\n  .lg\\\\:h-auto {\\n    height: auto;\\n  }\\n\\n  .lg\\\\:max-h-\\\\[calc\\\\(100vh-120px\\\\)\\\\] {\\n    max-height: calc(100vh - 120px);\\n  }\\n\\n  .lg\\\\:w-1\\\\/4 {\\n    width: 25%;\\n  }\\n\\n  .lg\\\\:w-1\\\\/5 {\\n    width: 20%;\\n  }\\n\\n  .lg\\\\:w-3\\\\/4 {\\n    width: 75%;\\n  }\\n\\n  .lg\\\\:w-4\\\\/5 {\\n    width: 80%;\\n  }\\n\\n  .lg\\\\:w-\\\\[240px\\\\] {\\n    width: 240px;\\n  }\\n\\n  .lg\\\\:w-auto {\\n    width: auto;\\n  }\\n\\n  .lg\\\\:justify-normal {\\n    justify-content: normal;\\n  }\\n\\n  .lg\\\\:overflow-y-hidden {\\n    overflow-y: hidden;\\n  }\\n\\n  .lg\\\\:rounded-xl {\\n    border-radius: 0.75rem;\\n  }\\n\\n  .lg\\\\:border {\\n    border-width: 1px;\\n  }\\n\\n  .lg\\\\:border-transparent {\\n    border-color: transparent;\\n  }\\n\\n  .lg\\\\:bg-gray-200 {\\n    --tw-bg-opacity: 1;\\n    background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n  }\\n\\n  .lg\\\\:bg-transparent {\\n    background-color: transparent;\\n  }\\n\\n  .lg\\\\:bg-none {\\n    background-image: none;\\n  }\\n\\n  .lg\\\\:px-3 {\\n    padding-left: 0.75rem;\\n    padding-right: 0.75rem;\\n  }\\n\\n  .lg\\\\:pb-6 {\\n    padding-bottom: 1.5rem;\\n  }\\n\\n  .lg\\\\:pb-\\\\[24px\\\\] {\\n    padding-bottom: 24px;\\n  }\\n\\n  .lg\\\\:pl-5 {\\n    padding-left: 1.25rem;\\n  }\\n\\n  .lg\\\\:text-9xl {\\n    font-size: 8rem;\\n    line-height: 1;\\n  }\\n\\n  .lg\\\\:text-lg {\\n    font-size: 1.125rem;\\n    line-height: 1.75rem;\\n  }\\n\\n  .lg\\\\:text-xl {\\n    font-size: 1.25rem;\\n    line-height: 1.75rem;\\n  }\\n\\n  .lg\\\\:shadow-none {\\n    --tw-shadow: 0 0 #0000;\\n    --tw-shadow-colored: 0 0 #0000;\\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n  }\\n\\n  .before\\\\:lg\\\\:h-\\\\[360px\\\\]::before {\\n    content: var(--tw-content);\\n    height: 360px;\\n  }\\n\\n  .lg\\\\:hover\\\\:bg-transparent:hover {\\n    background-color: transparent;\\n  }\\n\\n  @media (prefers-color-scheme: dark) {\\n\\n    .lg\\\\:dark\\\\:bg-zinc-800\\\\/30 {\\n      background-color: rgb(39 39 42 / 0.3);\\n    }\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/globals.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n:root {\\n  --foreground-rgb: 0, 0, 0;\\n  --background-start-rgb: 214, 219, 220;\\n  --background-end-rgb: 255, 255, 255;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  :root {\\n    --foreground-rgb: 255, 255, 255;\\n    --background-start-rgb: 0, 0, 0;\\n    --background-end-rgb: 0, 0, 0;\\n  }\\n}\\n\\nbody {\\n  color: rgb(var(--foreground-rgb));\\n  background: linear-gradient(\\n      to bottom,\\n      transparent,\\n      rgb(var(--background-end-rgb))\\n    )\\n    rgb(var(--background-start-rgb));\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMl0hLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQzJIO0FBQzNILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFZQUFxWSxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCwwQ0FBMEMsNENBQTRDLFVBQVUsZ0tBQWdLLGVBQWUsaUNBQWlDLFVBQVUsMk5BQTJOLGVBQWUsMkJBQTJCLGtDQUFrQyxVQUFVLGlHQUFpRyw4Q0FBOEMsOENBQThDLEdBQUcsa0dBQWtHLHVCQUF1Qix5QkFBeUIsR0FBRyxpRkFBaUYsbUJBQW1CLDZCQUE2QixHQUFHLDJFQUEyRSx3QkFBd0IsR0FBRywwSkFBMEoseUhBQXlILDJCQUEyQixVQUFVLGlFQUFpRSxtQkFBbUIsR0FBRywyR0FBMkcsbUJBQW1CLG1CQUFtQix1QkFBdUIsNkJBQTZCLEdBQUcsU0FBUyxvQkFBb0IsR0FBRyxTQUFTLGdCQUFnQixHQUFHLGdiQUFnYixvQkFBb0Isa0NBQWtDLHNDQUFzQyxVQUFVLGtNQUFrTSwwQkFBMEIsMkNBQTJDLDZDQUE2Qyw0QkFBNEIsaUNBQWlDLGlDQUFpQywyQkFBMkIsc0JBQXNCLHVCQUF1QixVQUFVLDhGQUE4Rix5QkFBeUIsR0FBRyxtTEFBbUwsZ0NBQWdDLDBDQUEwQyxtQ0FBbUMsVUFBVSwrRkFBK0Ysa0JBQWtCLEdB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TSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sT0FBTyxNQUFNLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIsb0JBQW9CLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxpQkFBaUIsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sT0FBTyxXQUFXLFVBQVUsVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUssb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sb0JBQW9CLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLFlBQVksb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsVUFBVSxNQUFNLFdBQVcsS0FBSyxVQUFVLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxLQUFLLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxLQUFLLFlBQVksVUFBVSxPQUFPLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sT0FBTyxLQUFLLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxXQUFXLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLHdDQUF3Qyx1QkFBdUIsc0JBQXNCLFdBQVcsOEJBQThCLDBDQUEwQyx3Q0FBd0MsR0FBRyx5Q0FBeUMsV0FBVyxzQ0FBc0Msc0NBQXNDLG9DQUFvQyxLQUFLLEdBQUcsVUFBVSxzQ0FBc0MsMEpBQTBKLEdBQUcscUJBQXFCO0FBQzk2MkM7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzPzYyNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qXFxuISB0YWlsd2luZGNzcyB2My4zLjMgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tXFxuKi8vKlxcbjEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzQpXFxuMi4gQWxsb3cgYWRkaW5nIGEgYm9yZGVyIHRvIGFuIGVsZW1lbnQgYnkganVzdCBhZGRpbmcgYSBib3JkZXItd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRjc3MvdGFpbHdpbmRjc3MvcHVsbC8xMTYpXFxuKi9cXG5cXG4qLFxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgYm9yZGVyLXdpZHRoOiAwOyAvKiAyICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyAvKiAyICovXFxuICBib3JkZXItY29sb3I6ICNlNWU3ZWI7IC8qIDIgKi9cXG59XFxuXFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSBhIGNvbnNpc3RlbnQgc2Vuc2libGUgbGluZS1oZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbjMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXFxuNC4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cXG41LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG42LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS41OyAvKiAxICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi9cXG4gIC1tb3otdGFiLXNpemU6IDQ7IC8qIDMgKi9cXG4gIC1vLXRhYi1zaXplOiA0O1xcbiAgICAgdGFiLXNpemU6IDQ7IC8qIDMgKi9cXG4gIGZvbnQtZmFtaWx5OiB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgXFxcIk5vdG8gU2Fuc1xcXCIsIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7IC8qIDQgKi9cXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogbm9ybWFsOyAvKiA1ICovXFxuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogbm9ybWFsOyAvKiA2ICovXFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbjIuIEluaGVyaXQgbGluZS1oZWlnaHQgZnJvbSBgaHRtbGAgc28gdXNlcnMgY2FuIHNldCB0aGVtIGFzIGEgY2xhc3MgZGlyZWN0bHkgb24gdGhlIGBodG1sYCBlbGVtZW50LlxcbiovXFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qXFxuMS4gQWRkIHRoZSBjb3JyZWN0IGhlaWdodCBpbiBGaXJlZm94LlxcbjIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxcbjMuIEVuc3VyZSBob3Jpem9udGFsIHJ1bGVzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5ociB7XFxuICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IC8qIDMgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmFiYnI6d2hlcmUoW3RpdGxlXSkge1xcbiAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGRlZmF1bHQgZm9udCBzaXplIGFuZCB3ZWlnaHQgZm9yIGhlYWRpbmdzLlxcbiovXFxuXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYge1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuUmVzZXQgbGlua3MgdG8gb3B0aW1pemUgZm9yIG9wdC1pbiBzdHlsaW5nIGluc3RlYWQgb2Ygb3B0LW91dC5cXG4qL1xcblxcbmEge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIEVkZ2UgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qXFxuMS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgbW9ub2AgZm9udCBmYW1pbHkgYnkgZGVmYXVsdC5cXG4yLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5jb2RlLFxcbmtiZCxcXG5zYW1wLFxcbnByZSB7XFxuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLypcXG5QcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcXG4yLiBDb3JyZWN0IHRhYmxlIGJvcmRlciBjb2xvciBpbmhlcml0YW5jZSBpbiBhbGwgQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MzU3MjksIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTUwMTYpXFxuMy4gUmVtb3ZlIGdhcHMgYmV0d2VlbiB0YWJsZSBib3JkZXJzIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50YWJsZSB7XFxuICB0ZXh0LWluZGVudDogMDsgLyogMSAqL1xcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyAvKiAzICovXFxufVxcblxcbi8qXFxuMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbjMuIFJlbW92ZSBkZWZhdWx0IHBhZGRpbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBmb250LXdlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXFxuKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gUmVtb3ZlIGRlZmF1bHQgYnV0dG9uIHN0eWxlcy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bdHlwZT0nYnV0dG9uJ10sXFxuW3R5cGU9J3Jlc2V0J10sXFxuW3R5cGU9J3N1Ym1pdCddIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgLyogMiAqL1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcblVzZSB0aGUgbW9kZXJuIEZpcmVmb3ggZm9jdXMgc3R5bGUgZm9yIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXFxuKi9cXG5cXG46LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogYXV0bztcXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgYDppbnZhbGlkYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxcbiovXFxuXFxuOi1tb3otdWktaW52YWxpZCB7XFxuICBib3gtc2hhZG93OiBub25lO1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxcbiovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4vKlxcbkNvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIFNhZmFyaS5cXG4qL1xcblxcbjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG46Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbjIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiovXFxuXFxuW3R5cGU9J3NlYXJjaCddIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4qL1xcblxcbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG59XFxuXFxuLypcXG5SZW1vdmVzIHRoZSBkZWZhdWx0IHNwYWNpbmcgYW5kIGJvcmRlciBmb3IgYXBwcm9wcmlhdGUgZWxlbWVudHMuXFxuKi9cXG5cXG5ibG9ja3F1b3RlLFxcbmRsLFxcbmRkLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbmhyLFxcbmZpZ3VyZSxcXG5wLFxcbnByZSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbmZpZWxkc2V0IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbmxlZ2VuZCB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5vbCxcXG51bCxcXG5tZW51IHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKlxcblJlc2V0IGRlZmF1bHQgc3R5bGluZyBmb3IgZGlhbG9ncy5cXG4qL1xcbmRpYWxvZyB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKlxcblByZXZlbnQgcmVzaXppbmcgdGV4dGFyZWFzIGhvcml6b250YWxseSBieSBkZWZhdWx0LlxcbiovXFxuXFxudGV4dGFyZWEge1xcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcXG59XFxuXFxuLypcXG4xLiBSZXNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBvcGFjaXR5IGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2lzc3Vlcy8zMzAwKVxcbjIuIFNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBjb2xvciB0byB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgZ3JheSA0MDAgY29sb3IuXFxuKi9cXG5cXG5pbnB1dDo6LW1vei1wbGFjZWhvbGRlciwgdGV4dGFyZWE6Oi1tb3otcGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuaW5wdXQ6OnBsYWNlaG9sZGVyLFxcbnRleHRhcmVhOjpwbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcbn1cXG5cXG4vKlxcblNldCB0aGUgZGVmYXVsdCBjdXJzb3IgZm9yIGJ1dHRvbnMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3JvbGU9XFxcImJ1dHRvblxcXCJdIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLypcXG5NYWtlIHN1cmUgZGlzYWJsZWQgYnV0dG9ucyBkb24ndCBnZXQgdGhlIHBvaW50ZXIgY3Vyc29yLlxcbiovXFxuOmRpc2FibGVkIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuLypcXG4xLiBNYWtlIHJlcGxhY2VkIGVsZW1lbnRzIGBkaXNwbGF5OiBibG9ja2AgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuMi4gQWRkIGB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlYCB0byBhbGlnbiByZXBsYWNlZCBlbGVtZW50cyBtb3JlIHNlbnNpYmx5IGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vamVuc2ltbW9ucy9jc3NyZW1lZHkvaXNzdWVzLzE0I2lzc3VlY29tbWVudC02MzQ5MzQyMTApXFxuICAgVGhpcyBjYW4gdHJpZ2dlciBhIHBvb3JseSBjb25zaWRlcmVkIGxpbnQgZXJyb3IgaW4gc29tZSB0b29scyBidXQgaXMgaW5jbHVkZWQgYnkgZGVzaWduLlxcbiovXFxuXFxuaW1nLFxcbnN2ZyxcXG52aWRlbyxcXG5jYW52YXMsXFxuYXVkaW8sXFxuaWZyYW1lLFxcbmVtYmVkLFxcbm9iamVjdCB7XFxuICBkaXNwbGF5OiBibG9jazsgLyogMSAqL1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkNvbnN0cmFpbiBpbWFnZXMgYW5kIHZpZGVvcyB0byB0aGUgcGFyZW50IHdpZHRoIGFuZCBwcmVzZXJ2ZSB0aGVpciBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4qL1xcblxcbmltZyxcXG52aWRlbyB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qIE1ha2UgZWxlbWVudHMgd2l0aCB0aGUgSFRNTCBoaWRkZW4gYXR0cmlidXRlIHN0YXkgaGlkZGVuIGJ5IGRlZmF1bHQgKi9cXG5baGlkZGVuXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4qLCA6OmJlZm9yZSwgOjphZnRlciB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXG5cXG46OmJhY2tkcm9wIHtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogIDtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxufVxcbi5jb250YWluZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA2NDBweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNjQwcHg7XFxuICB9XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNzY4cHg7XFxuICB9XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDEwMjRweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogMTI4MHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogMTUzNnB4KSB7XFxuXFxuICAuY29udGFpbmVyIHtcXG4gICAgbWF4LXdpZHRoOiAxNTM2cHg7XFxuICB9XFxufVxcbi5maXhlZCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcbi5hYnNvbHV0ZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5yZWxhdGl2ZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5zdGlja3kge1xcbiAgcG9zaXRpb246IHN0aWNreTtcXG59XFxuLmluc2V0LTAge1xcbiAgaW5zZXQ6IDBweDtcXG59XFxuLi10b3AtMSB7XFxuICB0b3A6IC0wLjI1cmVtO1xcbn1cXG4ubGVmdC0wIHtcXG4gIGxlZnQ6IDBweDtcXG59XFxuLnJpZ2h0LTAge1xcbiAgcmlnaHQ6IDBweDtcXG59XFxuLnJpZ2h0LVxcXFxbMTZweFxcXFxdIHtcXG4gIHJpZ2h0OiAxNnB4O1xcbn1cXG4udG9wLTAge1xcbiAgdG9wOiAwcHg7XFxufVxcbi50b3AtMSB7XFxuICB0b3A6IDAuMjVyZW07XFxufVxcbi56LTIwIHtcXG4gIHotaW5kZXg6IDIwO1xcbn1cXG4uei1cXFxcWy0xXFxcXF0ge1xcbiAgei1pbmRleDogLTE7XFxufVxcbi5mbG9hdC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5mbG9hdC1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG4ubXgtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG59XFxuLm15LTAge1xcbiAgbWFyZ2luLXRvcDogMHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMHB4O1xcbn1cXG4ubXktMiB7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxufVxcbi4tbWwtMSB7XFxuICBtYXJnaW4tbGVmdDogLTAuMjVyZW07XFxufVxcbi4tbXQtMiB7XFxuICBtYXJnaW4tdG9wOiAtMC41cmVtO1xcbn1cXG4uLW10LTMge1xcbiAgbWFyZ2luLXRvcDogLTAuNzVyZW07XFxufVxcbi4tbXQtXFxcXFs0cHhcXFxcXSB7XFxuICBtYXJnaW4tdG9wOiAtNHB4O1xcbn1cXG4ubWItMSB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjI1cmVtO1xcbn1cXG4ubWItMTAge1xcbiAgbWFyZ2luLWJvdHRvbTogMi41cmVtO1xcbn1cXG4ubWItMyB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjc1cmVtO1xcbn1cXG4ubWItNCB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbn1cXG4ubWItNSB7XFxuICBtYXJnaW4tYm90dG9tOiAxLjI1cmVtO1xcbn1cXG4ubWItNiB7XFxuICBtYXJnaW4tYm90dG9tOiAxLjVyZW07XFxufVxcbi5tYi1cXFxcWzIwcHhcXFxcXSB7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbn1cXG4ubWwtMyB7XFxuICBtYXJnaW4tbGVmdDogMC43NXJlbTtcXG59XFxuLm1sLTQge1xcbiAgbWFyZ2luLWxlZnQ6IDFyZW07XFxufVxcbi5tbC00MCB7XFxuICBtYXJnaW4tbGVmdDogMTByZW07XFxufVxcbi5tci0xIHtcXG4gIG1hcmdpbi1yaWdodDogMC4yNXJlbTtcXG59XFxuLm1yLTIge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxufVxcbi5tci0zIHtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxuLm10LTAge1xcbiAgbWFyZ2luLXRvcDogMHB4O1xcbn1cXG4ubXQtMSB7XFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcbn1cXG4ubXQtMiB7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxufVxcbi5tdC0zIHtcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxufVxcbi5tdC00IHtcXG4gIG1hcmdpbi10b3A6IDFyZW07XFxufVxcbi5tdC02IHtcXG4gIG1hcmdpbi10b3A6IDEuNXJlbTtcXG59XFxuLm10LTgge1xcbiAgbWFyZ2luLXRvcDogMnJlbTtcXG59XFxuLm10LTk2IHtcXG4gIG1hcmdpbi10b3A6IDI0cmVtO1xcbn1cXG4ubGluZS1jbGFtcC0yIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWxpbmUtY2xhbXA6IDI7XFxufVxcbi5ibG9jayB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmlubGluZS1ibG9jayB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5pbmxpbmUge1xcbiAgZGlzcGxheTogaW5saW5lO1xcbn1cXG4uZmxleCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4uaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5oLTMge1xcbiAgaGVpZ2h0OiAwLjc1cmVtO1xcbn1cXG4uaC1cXFxcWzI2cHhcXFxcXSB7XFxuICBoZWlnaHQ6IDI2cHg7XFxufVxcbi5oLVxcXFxbNDBweFxcXFxdIHtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuLmgtZnVsbCB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcbi5oLXNjcmVlbiB7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbn1cXG4ubWF4LWgtNjQge1xcbiAgbWF4LWhlaWdodDogMTZyZW07XFxufVxcbi53LWZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5taW4tdy1mdWxsIHtcXG4gIG1pbi13aWR0aDogMTAwJTtcXG59XFxuLm1heC13LTZ4bCB7XFxuICBtYXgtd2lkdGg6IDcycmVtO1xcbn1cXG4ubWF4LXctXFxcXFsxMDEycHhcXFxcXSB7XFxuICBtYXgtd2lkdGg6IDEwMTJweDtcXG59XFxuLmN1cnNvci1oZWxwIHtcXG4gIGN1cnNvcjogaGVscDtcXG59XFxuLmN1cnNvci1wb2ludGVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFwcGVhcmFuY2Utbm9uZSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi5mbGV4LWNvbCB7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uZmxleC13cmFwIHtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuLmZsZXgtbm93cmFwIHtcXG4gIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG4ucGxhY2UtaXRlbXMtY2VudGVyIHtcXG4gIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5pdGVtcy1zdGFydCB7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG59XFxuLml0ZW1zLWNlbnRlciB7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4uanVzdGlmeS1lbmQge1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG59XFxuLmp1c3RpZnktY2VudGVyIHtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4uanVzdGlmeS1iZXR3ZWVuIHtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxuLmdhcC0xIHtcXG4gIGdhcDogMC4yNXJlbTtcXG59XFxuLmdhcC0yIHtcXG4gIGdhcDogMC41cmVtO1xcbn1cXG4uZ2FwLXgtMyB7XFxuICAtbW96LWNvbHVtbi1nYXA6IDAuNzVyZW07XFxuICAgICAgIGNvbHVtbi1nYXA6IDAuNzVyZW07XFxufVxcbi5nYXAteS1cXFxcWzEwcHhcXFxcXSB7XFxuICByb3ctZ2FwOiAxMHB4O1xcbn1cXG4uc3BhY2UteC0xID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygwLjI1cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygwLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXG4uc3BhY2UteC0yID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygwLjVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXG59XFxuLnNwYWNlLXgtNSA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS14LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IGNhbGMoMS4yNXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMS4yNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKTtcXG59XFxuLnNwYWNlLXktMyA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tdG9wOiBjYWxjKDAuNzVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSk7XFxuICBtYXJnaW4tYm90dG9tOiBjYWxjKDAuNzVyZW0gKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXG59XFxuLnNlbGYtY2VudGVyIHtcXG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcXG59XFxuLm92ZXJmbG93LXktYXV0byB7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG4ub3ZlcmZsb3cteC1oaWRkZW4ge1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbn1cXG4udHJ1bmNhdGUge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLndoaXRlc3BhY2Utbm93cmFwIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5icmVhay13b3JkcyB7XFxuICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xcbn1cXG4ucm91bmRlZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbn1cXG4ucm91bmRlZC1mdWxsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG59XFxuLnJvdW5kZWQtbWQge1xcbiAgYm9yZGVyLXJhZGl1czogMC4zNzVyZW07XFxufVxcbi5ib3JkZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXIteSB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxufVxcbi5cXFxcIWJvcmRlci10LTAge1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5ib3JkZXItYiB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXItYi0yIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDJweDtcXG59XFxuLmJvcmRlci1iLTQge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogNHB4O1xcbn1cXG4uYm9yZGVyLWwtNCB7XFxuICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xcbn1cXG4uYm9yZGVyLWJsYWNrIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItZ3JheS0zMDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmJvcmRlci1ncmF5LTQwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYm9yZGVyLWdyYXktNjAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYig3NSA4NSA5OSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItdHJhbnNwYXJlbnQge1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLmJvcmRlci15ZWxsb3ctNjAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMDIgMTM4IDQgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYmctZ3JheS0yMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyOSAyMzEgMjM1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctZ3JheS0zMDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIwOSAyMTMgMjE5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctdGVhbC00MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDQ1IDIxMiAxOTEgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy13aGl0ZSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy13aGl0ZVxcXFwvMzAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gMC4zKTtcXG59XFxuLmJnLWdyYWRpZW50LXRvLWIge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKTtcXG59XFxuLmZyb20temluYy0yMDAge1xcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjZTRlNGU3IHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDIyOCAyMjggMjMxIC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXG59XFxuLmZpbGwtY3VycmVudCB7XFxuICBmaWxsOiBjdXJyZW50Q29sb3I7XFxufVxcbi5vYmplY3QtY292ZXIge1xcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XFxuICAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG59XFxuLnAtMiB7XFxuICBwYWRkaW5nOiAwLjVyZW07XFxufVxcbi5wLTMge1xcbiAgcGFkZGluZzogMC43NXJlbTtcXG59XFxuLnAtNCB7XFxuICBwYWRkaW5nOiAxcmVtO1xcbn1cXG4ucC04IHtcXG4gIHBhZGRpbmc6IDJyZW07XFxufVxcbi5wLVxcXFxbNnB4XFxcXF0ge1xcbiAgcGFkZGluZzogNnB4O1xcbn1cXG4ucHgtMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDBweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDBweDtcXG59XFxuLnB4LTIge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVyZW07XFxufVxcbi5weC0zIHtcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxufVxcbi5weC00IHtcXG4gIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDFyZW07XFxufVxcbi5weC02IHtcXG4gIHBhZGRpbmctbGVmdDogMS41cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMS41cmVtO1xcbn1cXG4ucHgtXFxcXFsyMHB4XFxcXF0ge1xcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgcGFkZGluZy1yaWdodDogMjBweDtcXG59XFxuLnB4LVxcXFxbMjJweFxcXFxdIHtcXG4gIHBhZGRpbmctbGVmdDogMjJweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDIycHg7XFxufVxcbi5weS0xIHtcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxufVxcbi5weS0yIHtcXG4gIHBhZGRpbmctdG9wOiAwLjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ucHktMyB7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcbn1cXG4ucGItMSB7XFxuICBwYWRkaW5nLWJvdHRvbTogMC4yNXJlbTtcXG59XFxuLnBiLTYge1xcbiAgcGFkZGluZy1ib3R0b206IDEuNXJlbTtcXG59XFxuLnBsLTAge1xcbiAgcGFkZGluZy1sZWZ0OiAwcHg7XFxufVxcbi5wbC0zIHtcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXG59XFxuLnBsLTQge1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbn1cXG4ucHItMCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwcHg7XFxufVxcbi5wci0yIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXG59XFxuLnByLTQge1xcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXG59XFxuLnByLVxcXFxbODBweFxcXFxdIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDgwcHg7XFxufVxcbi5wdC0yIHtcXG4gIHBhZGRpbmctdG9wOiAwLjVyZW07XFxufVxcbi5wdC00IHtcXG4gIHBhZGRpbmctdG9wOiAxcmVtO1xcbn1cXG4udGV4dC1sZWZ0IHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi50ZXh0LWNlbnRlciB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5hbGlnbi1taWRkbGUge1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLmZvbnQtbW9ubyB7XFxuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7XFxufVxcbi50ZXh0LTJ4bCB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAycmVtO1xcbn1cXG4udGV4dC0zeGwge1xcbiAgZm9udC1zaXplOiAxLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAyLjI1cmVtO1xcbn1cXG4udGV4dC01eGwge1xcbiAgZm9udC1zaXplOiAzcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxufVxcbi50ZXh0LVxcXFxbMTdweFxcXFxdIHtcXG4gIGZvbnQtc2l6ZTogMTdweDtcXG59XFxuLnRleHQtYmFzZSB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBsaW5lLWhlaWdodDogMS41cmVtO1xcbn1cXG4udGV4dC1sZyB7XFxuICBmb250LXNpemU6IDEuMTI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcbi50ZXh0LXNtIHtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXG59XFxuLnRleHQteGwge1xcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcbi50ZXh0LXhzIHtcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxcmVtO1xcbn1cXG4uZm9udC1ib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi5mb250LWV4dHJhYm9sZCB7XFxuICBmb250LXdlaWdodDogODAwO1xcbn1cXG4uZm9udC1zZW1pYm9sZCB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXG4uZm9udC10aGluIHtcXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XFxufVxcbi5sZWFkaW5nLTUge1xcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XFxufVxcbi5sZWFkaW5nLVxcXFxbMzJweFxcXFxdIHtcXG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xcbn1cXG4ubGVhZGluZy1cXFxcWzQwcHhcXFxcXSB7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG59XFxuLmxlYWRpbmctXFxcXFs0M3B4XFxcXF0ge1xcbiAgbGluZS1oZWlnaHQ6IDQzcHg7XFxufVxcbi5sZWFkaW5nLVxcXFxbNDRweFxcXFxdIHtcXG4gIGxpbmUtaGVpZ2h0OiA0NHB4O1xcbn1cXG4ubGVhZGluZy1ub3JtYWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuLnRleHQtZ3JheS0xMDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI0MyAyNDQgMjQ2IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWdyYXktNjAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig3NSA4NSA5OSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1ncmF5LTcwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS04MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDMxIDQxIDU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LXRlYWwtNDAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig0NSAyMTIgMTkxIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LXdoaXRlIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udW5kZXJsaW5lIHtcXG4gIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxufVxcbi5uby11bmRlcmxpbmUge1xcbiAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IG5vbmU7XFxufVxcbi5zaGFkb3cge1xcbiAgLS10dy1zaGFkb3c6IDAgMXB4IDNweCAwIHJnYigwIDAgMCAvIDAuMSksIDAgMXB4IDJweCAtMXB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDFweCAzcHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDFweCAycHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxuLmJhY2tkcm9wLWJsdXItMnhsIHtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cig0MHB4KTtcXG4gIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxuICAgICAgICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1cikgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcykgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0KSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5KSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEpO1xcbn1cXG4uYmFja2Ryb3AtYmx1ci1tZCB7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6IGJsdXIoMTJweCk7XFxuICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1cikgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcykgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0KSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5KSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEpO1xcbiAgICAgICAgICBiYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKTtcXG59XFxuLnRyYW5zaXRpb24tY29sb3JzIHtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmR1cmF0aW9uLTIwMCB7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAyMDBtcztcXG59XFxuXFxuOnJvb3Qge1xcbiAgLS1mb3JlZ3JvdW5kLXJnYjogMCwgMCwgMDtcXG4gIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDIxNCwgMjE5LCAyMjA7XFxuICAtLWJhY2tncm91bmQtZW5kLXJnYjogMjU1LCAyNTUsIDI1NTtcXG59XFxuXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcbiAgOnJvb3Qge1xcbiAgICAtLWZvcmVncm91bmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcbiAgICAtLWJhY2tncm91bmQtc3RhcnQtcmdiOiAwLCAwLCAwO1xcbiAgICAtLWJhY2tncm91bmQtZW5kLXJnYjogMCwgMCwgMDtcXG4gIH1cXG59XFxuXFxuYm9keSB7XFxuICBjb2xvcjogcmdiKHZhcigtLWZvcmVncm91bmQtcmdiKSk7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgICAgdG8gYm90dG9tLFxcbiAgICAgIHRyYW5zcGFyZW50LFxcbiAgICAgIHJnYih2YXIoLS1iYWNrZ3JvdW5kLWVuZC1yZ2IpKVxcbiAgICApXFxuICAgIHJnYih2YXIoLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYikpO1xcbn1cXG5cXG4uYmVmb3JlXFxcXDphYnNvbHV0ZTo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4uYmVmb3JlXFxcXDpoLVxcXFxbMzAwcHhcXFxcXTo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgaGVpZ2h0OiAzMDBweDtcXG59XFxuXFxuLmJlZm9yZVxcXFw6dy1cXFxcWzQ4MHB4XFxcXF06OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIHdpZHRoOiA0ODBweDtcXG59XFxuXFxuLmJlZm9yZVxcXFw6LXRyYW5zbGF0ZS14LTFcXFxcLzI6OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IC01MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxuXFxuLmJlZm9yZVxcXFw6cm91bmRlZC1mdWxsOjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxufVxcblxcbi5iZWZvcmVcXFxcOmJnLWdyYWRpZW50LXJhZGlhbDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogcmFkaWFsLWdyYWRpZW50KHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSk7XFxufVxcblxcbi5iZWZvcmVcXFxcOmZyb20td2hpdGU6OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogI2ZmZiB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigyNTUgMjU1IDI1NSAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxufVxcblxcbi5iZWZvcmVcXFxcOnRvLXRyYW5zcGFyZW50OjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAtLXR3LWdyYWRpZW50LXRvOiB0cmFuc3BhcmVudCB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxufVxcblxcbi5iZWZvcmVcXFxcOmJsdXItMnhsOjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAtLXR3LWJsdXI6IGJsdXIoNDBweCk7XFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxufVxcblxcbi5iZWZvcmVcXFxcOmNvbnRlbnQtXFxcXFtcXFxcJ1xcXFwnXFxcXF06OmJlZm9yZSB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxufVxcblxcbi5hZnRlclxcXFw6YWJzb2x1dGU6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOi16LTIwOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIHotaW5kZXg6IC0yMDtcXG59XFxuXFxuLmFmdGVyXFxcXDpoLVxcXFxbMTgwcHhcXFxcXTo6YWZ0ZXIge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBoZWlnaHQ6IDE4MHB4O1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOnctXFxcXFsyNDBweFxcXFxdOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIHdpZHRoOiAyNDBweDtcXG59XFxuXFxuLmFmdGVyXFxcXDp0cmFuc2xhdGUteC0xXFxcXC8zOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDMzLjMzMzMzMyU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxuXFxuLmFmdGVyXFxcXDpiZy1ncmFkaWVudC1jb25pYzo6YWZ0ZXIge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBjb25pYy1ncmFkaWVudChmcm9tIDE4MGRlZyBhdCA1MCUgNTAlLCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOmZyb20tc2t5LTIwMDo6YWZ0ZXIge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAtLXR3LWdyYWRpZW50LWZyb206ICNiYWU2ZmQgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMTg2IDIzMCAyNTMgLyAwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxuICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOnZpYS1ibHVlLTIwMDo6YWZ0ZXIge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMTkxIDIxOSAyNTQgLyAwKSAgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksICNiZmRiZmUgdmFyKC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOmJsdXItMnhsOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctYmx1cjogYmx1cig0MHB4KTtcXG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXG59XFxuXFxuLmFmdGVyXFxcXDpjb250ZW50LVxcXFxbXFxcXCdcXFxcJ1xcXFxdOjphZnRlciB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxufVxcblxcbi5ob3ZlclxcXFw6d2hpdGVzcGFjZS1icmVhay1zcGFjZXM6aG92ZXIge1xcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcXG59XFxuXFxuLmhvdmVyXFxcXDpib3JkZXIteWVsbG93LTYwMDpob3ZlciB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjAyIDEzOCA0IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ncmF5LTMwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctdGVhbC0zMDA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDk0IDIzNCAyMTIgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctdGVhbC01MDA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIwIDE4NCAxNjYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmcteWVsbG93LTEwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU0IDI0OSAxOTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmcteWVsbG93LTUwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjM0IDE3OSA4IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOnRleHQteWVsbG93LTYwMDpob3ZlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjAyIDEzOCA0IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctZ3JheS0xMDA6Zm9jdXMge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MyAyNDQgMjQ2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXdoaXRlOmZvY3VzIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpvdXRsaW5lLW5vbmU6Zm9jdXMge1xcbiAgb3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgb3V0bGluZS1vZmZzZXQ6IDJweDtcXG59XFxuXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcblxcbiAgLmRhcmtcXFxcOmJvcmRlci1uZXV0cmFsLTgwMCB7XFxuICAgIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiKDM4IDM4IDM4IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG4gIH1cXG5cXG4gIC5kYXJrXFxcXDpiZy16aW5jLTgwMFxcXFwvMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzkgMzkgNDIgLyAwLjMpO1xcbiAgfVxcblxcbiAgLmRhcmtcXFxcOmZyb20taW5oZXJpdCB7XFxuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogaW5oZXJpdCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC10bzogcmdiKDI1NSAyNTUgMjU1IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbiAgfVxcblxcbiAgLmRhcmtcXFxcOmRyb3Atc2hhZG93LVxcXFxbMF8wXzBcXFxcLjNyZW1fXFxcXCNmZmZmZmY3MFxcXFxdIHtcXG4gICAgLS10dy1kcm9wLXNoYWRvdzogZHJvcC1zaGFkb3coMCAwIDAuM3JlbSAjZmZmZmZmNzApO1xcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxuICB9XFxuXFxuICAuZGFya1xcXFw6aW52ZXJ0IHtcXG4gICAgLS10dy1pbnZlcnQ6IGludmVydCgxMDAlKTtcXG4gICAgZmlsdGVyOiB2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpO1xcbiAgfVxcblxcbiAgLmJlZm9yZVxcXFw6ZGFya1xcXFw6YmctZ3JhZGllbnQtdG8tYnI6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpO1xcbiAgfVxcblxcbiAgLmJlZm9yZVxcXFw6ZGFya1xcXFw6ZnJvbS10cmFuc3BhcmVudDo6YmVmb3JlIHtcXG4gICAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogdHJhbnNwYXJlbnQgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxuICAgIC0tdHctZ3JhZGllbnQtdG86IHJnYigwIDAgMCAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXG4gIH1cXG5cXG4gIC5iZWZvcmVcXFxcOmRhcmtcXFxcOnRvLWJsdWUtNzAwOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgLS10dy1ncmFkaWVudC10bzogIzFkNGVkOCB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxuICB9XFxuXFxuICAuYmVmb3JlXFxcXDpkYXJrXFxcXDpvcGFjaXR5LTEwOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgb3BhY2l0eTogMC4xO1xcbiAgfVxcblxcbiAgLmFmdGVyXFxcXDpkYXJrXFxcXDpmcm9tLXNreS05MDA6OmFmdGVyIHtcXG4gICAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogIzBjNGE2ZSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC10bzogcmdiKDEyIDc0IDExMCAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXG4gIH1cXG5cXG4gIC5hZnRlclxcXFw6ZGFya1xcXFw6dmlhLVxcXFxbXFxcXCMwMTQxZmZcXFxcXTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgLS10dy1ncmFkaWVudC10bzogcmdiKDEgNjUgMjU1IC8gMCkgIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksICMwMTQxZmYgdmFyKC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbiAgfVxcblxcbiAgLmFmdGVyXFxcXDpkYXJrXFxcXDpvcGFjaXR5LTQwOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA2NDBweCkge1xcblxcbiAgLnNtXFxcXDptdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LWF1dG8ge1xcbiAgICB3aWR0aDogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleC1yb3cge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwLTQge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpsZWFkaW5nLTYge1xcbiAgICBsaW5lLWhlaWdodDogMS41cmVtO1xcbiAgfVxcbn1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG5cXG4gIC5tZFxcXFw6cmlnaHQtXFxcXFsxMnB4XFxcXF0ge1xcbiAgICByaWdodDogMTJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dG9wLVxcXFxbMTBweFxcXFxdIHtcXG4gICAgdG9wOiAxMHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS0yIHtcXG4gICAgbWFyZ2luLXRvcDogMC41cmVtO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTAge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LTFcXFxcLzMge1xcbiAgICB3aWR0aDogMzMuMzMzMzMzJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0yXFxcXC8zIHtcXG4gICAgd2lkdGg6IDY2LjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LVxcXFxbMzQwcHhcXFxcXSB7XFxuICAgIG1heC13aWR0aDogMzQwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOml0ZW1zLWNlbnRlciB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQteGwge1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXIge1xcbiAgICBib3JkZXItd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLTQge1xcbiAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6XFxcXCFib3JkZXItdCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweCAhaW1wb3J0YW50O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC0wIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHgtMyB7XFxuICAgIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHgtNCB7XFxuICAgIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogMXJlbTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHktMCB7XFxuICAgIHBhZGRpbmctdG9wOiAwcHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLTAge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwdC0zIHtcXG4gICAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtbGVmdCB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcXG5cXG4gIC5sZ1xcXFw6c3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zml4ZWQge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuXFxuICAubGdcXFxcOnJpZ2h0LVxcXFxbMTBweFxcXFxdIHtcXG4gICAgcmlnaHQ6IDEwcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDBweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktMyB7XFxuICAgIG1hcmdpbi10b3A6IDAuNzVyZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNzVyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTAge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTMge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwLjc1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC03MiB7XFxuICAgIG1hcmdpbi10b3A6IDE4cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC04IHtcXG4gICAgbWFyZ2luLXRvcDogMnJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmxvY2sge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuXFxuICAubGdcXFxcOmhpZGRlbiB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtYXV0byB7XFxuICAgIGhlaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtXFxcXFtjYWxjXFxcXCgxMDB2aC0xMjBweFxcXFwpXFxcXF0ge1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gMTIwcHgpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTFcXFxcLzQge1xcbiAgICB3aWR0aDogMjUlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTFcXFxcLzUge1xcbiAgICB3aWR0aDogMjAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTNcXFxcLzQge1xcbiAgICB3aWR0aDogNzUlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTRcXFxcLzUge1xcbiAgICB3aWR0aDogODAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LVxcXFxbMjQwcHhcXFxcXSB7XFxuICAgIHdpZHRoOiAyNDBweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy1hdXRvIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOmp1c3RpZnktbm9ybWFsIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBub3JtYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOm92ZXJmbG93LXktaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXhsIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMC43NXJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci10cmFuc3BhcmVudCB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWdyYXktMjAwIHtcXG4gICAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIzMSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLXRyYW5zcGFyZW50IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLW5vbmUge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi02IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDEuNXJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItXFxcXFsyNHB4XFxcXF0ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtNSB7XFxuICAgIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGV4dC05eGwge1xcbiAgICBmb250LXNpemU6IDhyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAxO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LWxnIHtcXG4gICAgZm9udC1zaXplOiAxLjEyNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQteGwge1xcbiAgICBmb250LXNpemU6IDEuMjVyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzaGFkb3ctbm9uZSB7XFxuICAgIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAgIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG4gIH1cXG5cXG4gIC5iZWZvcmVcXFxcOmxnXFxcXDpoLVxcXFxbMzYwcHhcXFxcXTo6YmVmb3JlIHtcXG4gICAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAgIGhlaWdodDogMzYwcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy10cmFuc3BhcmVudDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcblxcbiAgICAubGdcXFxcOmRhcmtcXFxcOmJnLXppbmMtODAwXFxcXC8zMCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDM5IDM5IDQyIC8gMC4zKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL3N0eWxlcy9nbG9iYWxzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Q0FBYyxDQUFkOzs7Q0FBYzs7QUFBZDs7O0VBQUEsc0JBQWMsRUFBZCxNQUFjO0VBQWQsZUFBYyxFQUFkLE1BQWM7RUFBZCxtQkFBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCwrQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsK0dB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QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxlQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZ0JBQW1CO0VBQW5CLG9CQUFtQjtFQUFuQiw0QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0tBQW5CLHFCQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7T0FBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsc0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQiwrREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkIsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixxRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxlQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwwRUFBbUI7RUFBbkIsOEZBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsOEJBQW1CO0VBQW5CLCtRQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDhCQUFtQjtFQUFuQiwrUUFBbUI7VUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwrRkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7O0FBRW5CO0VBQ0UseUJBQXlCO0VBQ3pCLHFDQUFxQztFQUNyQyxtQ0FBbUM7QUFDckM7O0FBRUE7RUFDRTtJQUNFLCtCQUErQjtJQUMvQiwrQkFBK0I7SUFDL0IsNkJBQTZCO0VBQy9CO0FBQ0Y7O0FBRUE7RUFDRSxpQ0FBaUM7RUFDakM7Ozs7O29DQUtrQztBQUNwQzs7QUExQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsc0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBLHlEQTJCQTtFQTNCQSxxRUEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQSxxQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsZ0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsNEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsNERBMkJBO0VBM0JBLHFFQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsc0VBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQSxxQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsZ0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBO0FBMkJBOztBQTNCQTtFQUFBLHNCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLGtCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLG9CQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDhCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7O0VBQUE7SUFBQSxzQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsNERBMkJBO0lBM0JBLHFFQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxtREEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEseUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSwwQkEyQkE7SUEzQkEsZ0VBMkJBO0lBM0JBLCtEQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSwwQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsMEJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQSw0REEyQkE7SUEzQkEsbUVBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQSxtRUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsMEJBMkJBO0lBM0JBO0VBMkJBO0FBQUE7O0FBM0JBOztFQUFBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7QUFBQTs7QUEzQkE7O0VBQUE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQSxrQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsaUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLHFCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxrQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsZ0JBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBO0FBQUE7O0FBM0JBOztFQUFBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsZUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsbUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBLGtCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQSxxQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsZUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsbUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLGtCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxzQkEyQkE7SUEzQkEsOEJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7O0lBQUE7TUFBQTtJQTJCQTtFQUFBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQHRhaWx3aW5kIGJhc2U7XFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXG5cXG46cm9vdCB7XFxuICAtLWZvcmVncm91bmQtcmdiOiAwLCAwLCAwO1xcbiAgLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYjogMjE0LCAyMTksIDIyMDtcXG4gIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcbn1cXG5cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuICA6cm9vdCB7XFxuICAgIC0tZm9yZWdyb3VuZC1yZ2I6IDI1NSwgMjU1LCAyNTU7XFxuICAgIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDAsIDAsIDA7XFxuICAgIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAwLCAwLCAwO1xcbiAgfVxcbn1cXG5cXG5ib2R5IHtcXG4gIGNvbG9yOiByZ2IodmFyKC0tZm9yZWdyb3VuZC1yZ2IpKTtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgICB0byBib3R0b20sXFxuICAgICAgdHJhbnNwYXJlbnQsXFxuICAgICAgcmdiKHZhcigtLWJhY2tncm91bmQtZW5kLXJnYikpXFxuICAgIClcXG4gICAgcmdiKHZhcigtLWJhY2tncm91bmQtc3RhcnQtcmdiKSk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qLyAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./src/pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./src/styles/globals.css":
/*!********************************!*\
  !*** ./src/styles/globals.css ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyx1TkFBMkc7QUFDN0gsMEJBQTBCLG1CQUFPLENBQUMscWZBQXVQOztBQUV6Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0scWZBQXVQO0FBQzdQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscWZBQXVQOztBQUVqUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzPzE1MDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./src/contexts/AuthContext.js":
/*!*************************************!*\
  !*** ./src/contexts/AuthContext.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: function() { return /* binding */ AuthContext; },\n/* harmony export */   \"default\": function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/fcl */ \"./node_modules/@onflow/fcl/dist/fcl.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n// import { checkIsInitialized, IS_INITIALIZED } from \"../flow/scripts\";\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({});\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    // Create a state variable to keep track of the currentUser\n    const [currentUser, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        loggedIn: false,\n        addr: undefined\n    });\n    // Create a state variable to represent if a user's account\n    // has been initialized or not\n    // const [isInitialized, setIsInitialized] = useState(false);\n    // Use FCL to subscribe to changes in the user (login, logout, etc)\n    // Tell FCL to call `setUser` and update our state variables\n    // if anything changes\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>_onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.currentUser.subscribe(setUser), []);\n    // If currentUser is set, i.e. user is logged in\n    // check whether their account is initialized or not\n    // useEffect(() => {\n    //   if (currentUser.addr) {\n    //     checkInit();\n    //   }\n    // }, [currentUser]);\n    // Helper function to log the user out of the dApp\n    const logOut = async ()=>{\n        _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.unauthenticate();\n        setUser({\n            loggedIn: false,\n            addr: undefined\n        });\n    };\n    // Helper function to log the user in to the dApp\n    // p.s. this feels even easier than RainbowKit, eh?\n    const logIn = ()=>{\n        _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.logIn();\n    };\n    // Use the `checkIsInitialized` script we wrote earlier\n    // and update the state variable as necessary\n    // const checkInit = async () => {\n    //   const isInit = await checkIsInitialized(currentUser.addr);\n    //   setIsInitialized(isInit);\n    // };\n    // Build the object of everything we want to expose through \n    // the context\n    const value = {\n        currentUser,\n        logOut,\n        logIn\n    };\n    // Return the Context Provider with the value set\n    // Render all children of the component inside of it\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\contexts\\\\AuthContext.js\",\n        lineNumber: 62,\n        columnNumber: 12\n    }, this);\n}\n_s1(AuthProvider, \"Ev2DadeV8F2jO9FfDWbkAI6wwYo=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGV4dHMvQXV0aENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNvQztBQUN2RSx3RUFBd0U7QUFFakUsTUFBTUssNEJBQWNKLG9EQUFhQSxDQUFDLENBQUMsR0FBRztBQUV0QyxNQUFNSyxVQUFVOztJQUFNSixPQUFBQSxpREFBVUEsQ0FBQ0c7QUFBVyxFQUFFO0dBQXhDQztBQUVFLFNBQVNDLGFBQWEsS0FBWTtRQUFaLEVBQUVDLFFBQVEsRUFBRSxHQUFaOztJQUVqQywyREFBMkQ7SUFDM0QsTUFBTSxDQUFDQyxhQUFhQyxRQUFRLEdBQUdOLCtDQUFRQSxDQUFDO1FBQ3RDTyxVQUFVO1FBQ1ZDLE1BQU1DO0lBQ1I7SUFDQSwyREFBMkQ7SUFDM0QsOEJBQThCO0lBQzlCLDZEQUE2RDtJQUU3RCxtRUFBbUU7SUFDbkUsNERBQTREO0lBQzVELHNCQUFzQjtJQUN0QlYsZ0RBQVNBLENBQUMsSUFBTUgsb0RBQWUsQ0FBQ2MsU0FBUyxDQUFDSixVQUFVLEVBQUU7SUFFdEQsZ0RBQWdEO0lBQ2hELG9EQUFvRDtJQUNwRCxvQkFBb0I7SUFDcEIsNEJBQTRCO0lBQzVCLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04scUJBQXFCO0lBRXJCLGtEQUFrRDtJQUNsRCxNQUFNSyxTQUFTO1FBQ2JmLHVEQUFrQjtRQUNsQlUsUUFBUTtZQUFFQyxVQUFVO1lBQU9DLE1BQU1DO1FBQVU7SUFDN0M7SUFFQSxpREFBaUQ7SUFDakQsbURBQW1EO0lBQ25ELE1BQU1JLFFBQVE7UUFDWmpCLDhDQUFTO0lBQ1g7SUFFQSx1REFBdUQ7SUFDdkQsNkNBQTZDO0lBQzdDLGtDQUFrQztJQUNsQywrREFBK0Q7SUFDL0QsOEJBQThCO0lBQzlCLEtBQUs7SUFFTCw0REFBNEQ7SUFDNUQsY0FBYztJQUNkLE1BQU1rQixRQUFRO1FBQ1pUO1FBQ0FNO1FBQ0FFO0lBQ0Y7SUFFQSxpREFBaUQ7SUFDakQsb0RBQW9EO0lBQ3BELHFCQUFPLDhEQUFDWixZQUFZYyxRQUFRO1FBQUNELE9BQU9BO2tCQUFRVjs7Ozs7O0FBQzlDO0lBdERzQkQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL0F1dGhDb250ZXh0LmpzPzc4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZmNsIGZyb20gXCJAb25mbG93L2ZjbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IGNoZWNrSXNJbml0aWFsaXplZCwgSVNfSU5JVElBTElaRUQgfSBmcm9tIFwiLi4vZmxvdy9zY3JpcHRzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCkgPT4gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgc3RhdGUgdmFyaWFibGUgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudFVzZXJcclxuICAgIGNvbnN0IFtjdXJyZW50VXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZSh7XHJcbiAgICAgIGxvZ2dlZEluOiBmYWxzZSxcclxuICAgICAgYWRkcjogdW5kZWZpbmVkLFxyXG4gICAgfSk7XHJcbiAgICAvLyBDcmVhdGUgYSBzdGF0ZSB2YXJpYWJsZSB0byByZXByZXNlbnQgaWYgYSB1c2VyJ3MgYWNjb3VudFxyXG4gICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb3Igbm90XHJcbiAgICAvLyBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgXHJcbiAgICAvLyBVc2UgRkNMIHRvIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSB1c2VyIChsb2dpbiwgbG9nb3V0LCBldGMpXHJcbiAgICAvLyBUZWxsIEZDTCB0byBjYWxsIGBzZXRVc2VyYCBhbmQgdXBkYXRlIG91ciBzdGF0ZSB2YXJpYWJsZXNcclxuICAgIC8vIGlmIGFueXRoaW5nIGNoYW5nZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiBmY2wuY3VycmVudFVzZXIuc3Vic2NyaWJlKHNldFVzZXIpLCBbXSk7XHJcbiAgXHJcbiAgICAvLyBJZiBjdXJyZW50VXNlciBpcyBzZXQsIGkuZS4gdXNlciBpcyBsb2dnZWQgaW5cclxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlaXIgYWNjb3VudCBpcyBpbml0aWFsaXplZCBvciBub3RcclxuICAgIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyAgIGlmIChjdXJyZW50VXNlci5hZGRyKSB7XHJcbiAgICAvLyAgICAgY2hlY2tJbml0KCk7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH0sIFtjdXJyZW50VXNlcl0pO1xyXG4gIFxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGxvZyB0aGUgdXNlciBvdXQgb2YgdGhlIGRBcHBcclxuICAgIGNvbnN0IGxvZ091dCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgZmNsLnVuYXV0aGVudGljYXRlKCk7XHJcbiAgICAgIHNldFVzZXIoeyBsb2dnZWRJbjogZmFsc2UsIGFkZHI6IHVuZGVmaW5lZCB9KTtcclxuICAgIH07XHJcbiAgXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gbG9nIHRoZSB1c2VyIGluIHRvIHRoZSBkQXBwXHJcbiAgICAvLyBwLnMuIHRoaXMgZmVlbHMgZXZlbiBlYXNpZXIgdGhhbiBSYWluYm93S2l0LCBlaD9cclxuICAgIGNvbnN0IGxvZ0luID0gKCkgPT4ge1xyXG4gICAgICBmY2wubG9nSW4oKTtcclxuICAgIH07XHJcbiAgXHJcbiAgICAvLyBVc2UgdGhlIGBjaGVja0lzSW5pdGlhbGl6ZWRgIHNjcmlwdCB3ZSB3cm90ZSBlYXJsaWVyXHJcbiAgICAvLyBhbmQgdXBkYXRlIHRoZSBzdGF0ZSB2YXJpYWJsZSBhcyBuZWNlc3NhcnlcclxuICAgIC8vIGNvbnN0IGNoZWNrSW5pdCA9IGFzeW5jICgpID0+IHtcclxuICAgIC8vICAgY29uc3QgaXNJbml0ID0gYXdhaXQgY2hlY2tJc0luaXRpYWxpemVkKGN1cnJlbnRVc2VyLmFkZHIpO1xyXG4gICAgLy8gICBzZXRJc0luaXRpYWxpemVkKGlzSW5pdCk7XHJcbiAgICAvLyB9O1xyXG4gIFxyXG4gICAgLy8gQnVpbGQgdGhlIG9iamVjdCBvZiBldmVyeXRoaW5nIHdlIHdhbnQgdG8gZXhwb3NlIHRocm91Z2ggXHJcbiAgICAvLyB0aGUgY29udGV4dFxyXG4gICAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICAgIGN1cnJlbnRVc2VyLFxyXG4gICAgICBsb2dPdXQsXHJcbiAgICAgIGxvZ0luLFxyXG4gICAgfTtcclxuICBcclxuICAgIC8vIFJldHVybiB0aGUgQ29udGV4dCBQcm92aWRlciB3aXRoIHRoZSB2YWx1ZSBzZXRcclxuICAgIC8vIFJlbmRlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudCBpbnNpZGUgb2YgaXRcclxuICAgIHJldHVybiA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT57Y2hpbGRyZW59PC9BdXRoQ29udGV4dC5Qcm92aWRlcj47XHJcbiAgfSJdLCJuYW1lcyI6WyJmY2wiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQXV0aENvbnRleHQiLCJ1c2VBdXRoIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50VXNlciIsInNldFVzZXIiLCJsb2dnZWRJbiIsImFkZHIiLCJ1bmRlZmluZWQiLCJzdWJzY3JpYmUiLCJsb2dPdXQiLCJ1bmF1dGhlbnRpY2F0ZSIsImxvZ0luIiwidmFsdWUiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/AuthContext.js\n"));

/***/ }),

/***/ "./src/pages/_app.js":
/*!***************************!*\
  !*** ./src/pages/_app.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contexts/AuthContext */ \"./src/contexts/AuthContext.js\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/styles/globals.css */ \"./src/styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction App(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n            ...pageProps\n        }, void 0, false, {\n            fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\pages\\\\_app.js\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\pages\\\\_app.js\",\n        lineNumber: 6,\n        columnNumber: 5\n    }, this);\n}\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1EO0FBQ3RCO0FBRWQsU0FBU0MsSUFBSSxLQUF3QjtRQUF4QixFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRSxHQUF4QjtJQUMxQixxQkFDRSw4REFBQ0gsNkRBQVlBO2tCQUNYLDRFQUFDRTtZQUFXLEdBQUdDLFNBQVM7Ozs7Ozs7Ozs7O0FBRzlCO0tBTndCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvX2FwcC5qcz84ZmRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBdXRoUHJvdmlkZXIgZnJvbSBcIi4uL2NvbnRleHRzL0F1dGhDb250ZXh0XCI7XG5pbXBvcnQgJ0Avc3R5bGVzL2dsb2JhbHMuY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gIHJldHVybiAoXG4gICAgPEF1dGhQcm92aWRlcj5cbiAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cbiAgICA8L0F1dGhQcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkF1dGhQcm92aWRlciIsIkFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/_app.js\n"));

/***/ }),

/***/ "./node_modules/queue-microtask/index.js":
/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXVldWUtbWljcm90YXNrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUscUJBQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcz85YzM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBxdWV1ZS1taWNyb3Rhc2suIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmxldCBwcm9taXNlXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nXG4gID8gcXVldWVNaWNyb3Rhc2suYmluZCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbiAgLy8gcmV1c2UgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIGFsbG9jYXRlIGl0IGxhemlseVxuICA6IGNiID0+IChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKVxuICAgIC50aGVuKGNiKVxuICAgIC5jYXRjaChlcnIgPT4gc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVyciB9LCAwKSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/queue-microtask/index.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/sha3/index.js":
/*!************************************!*\
  !*** ./node_modules/sha3/index.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=exports.SHAKE=exports.SHA3Hash=exports.SHA3=exports.Keccak=void 0;var _buffer=__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");var _sponge=_interopRequireDefault(__webpack_require__(/*! ./sponge */ \"./node_modules/sha3/sponge/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var createHash=function createHash(_ref){var allowedSizes=_ref.allowedSizes,defaultSize=_ref.defaultSize,padding=_ref.padding;return function Hash(){var _this=this;var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultSize;if(!this||this.constructor!==Hash){return new Hash(size)}if(allowedSizes&&!allowedSizes.includes(size)){throw new Error(\"Unsupported hash length\")}var sponge=new _sponge[\"default\"]({capacity:size});this.update=function(input){var encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"utf8\";if(_buffer.Buffer.isBuffer(input)){sponge.absorb(input);return _this}if(typeof input===\"string\"){return _this.update(_buffer.Buffer.from(input,encoding))}throw new TypeError(\"Not a string or buffer\")};this.digest=function(){var formatOrOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:\"binary\";var options=typeof formatOrOptions===\"string\"?{format:formatOrOptions}:formatOrOptions;var buffer=sponge.squeeze({buffer:options.buffer,padding:options.padding||padding});if(options.format&&options.format!==\"binary\"){return buffer.toString(options.format)}return buffer};this.reset=function(){sponge.reset();return _this};return this}};var Keccak=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:1});exports.Keccak=Keccak;var SHA3=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:6});exports.SHA3=SHA3;var SHAKE=createHash({allowedSizes:[128,256],defaultSize:256,padding:31});exports.SHAKE=SHAKE;var SHA3Hash=Keccak;exports.SHA3Hash=SHA3Hash;SHA3.SHA3Hash=SHA3Hash;var _default=SHA3;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLGNBQWMsUUFBUSxZQUFZLG1CQUFPLENBQUMsOENBQVEsRUFBRSxtQ0FBbUMsbUJBQU8sQ0FBQyxxREFBVSxHQUFHLHFDQUFxQyxnQ0FBZ0MsZUFBZSx5Q0FBeUMscUZBQXFGLHVCQUF1QixlQUFlLCtFQUErRSxtQ0FBbUMsc0JBQXNCLCtDQUErQywyQ0FBMkMsbUNBQW1DLGNBQWMsRUFBRSw0QkFBNEIsOEVBQThFLG1DQUFtQyxxQkFBcUIsYUFBYSw0QkFBNEIseURBQXlELCtDQUErQyx1QkFBdUIsdUZBQXVGLCtDQUErQyx1QkFBdUIsaUJBQWlCLDJCQUEyQix1REFBdUQsRUFBRSw4Q0FBOEMsdUNBQXVDLGVBQWUsc0JBQXNCLGVBQWUsY0FBYyxjQUFjLHVCQUF1Qix5REFBeUQsRUFBRSxjQUFjLFFBQVEscUJBQXFCLHlEQUF5RCxFQUFFLFlBQVksTUFBTSxzQkFBc0Isa0RBQWtELEVBQUUsYUFBYSxPQUFPLG9CQUFvQixnQkFBZ0IsVUFBVSx1QkFBdUIsa0JBQWtCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9pbmRleC5qcz8wYzg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09ZXhwb3J0cy5TSEFLRT1leHBvcnRzLlNIQTNIYXNoPWV4cG9ydHMuU0hBMz1leHBvcnRzLktlY2Nhaz12b2lkIDA7dmFyIF9idWZmZXI9cmVxdWlyZShcImJ1ZmZlclwiKTt2YXIgX3Nwb25nZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Nwb25nZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfX12YXIgY3JlYXRlSGFzaD1mdW5jdGlvbiBjcmVhdGVIYXNoKF9yZWYpe3ZhciBhbGxvd2VkU2l6ZXM9X3JlZi5hbGxvd2VkU2l6ZXMsZGVmYXVsdFNpemU9X3JlZi5kZWZhdWx0U2l6ZSxwYWRkaW5nPV9yZWYucGFkZGluZztyZXR1cm4gZnVuY3Rpb24gSGFzaCgpe3ZhciBfdGhpcz10aGlzO3ZhciBzaXplPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpkZWZhdWx0U2l6ZTtpZighdGhpc3x8dGhpcy5jb25zdHJ1Y3RvciE9PUhhc2gpe3JldHVybiBuZXcgSGFzaChzaXplKX1pZihhbGxvd2VkU2l6ZXMmJiFhbGxvd2VkU2l6ZXMuaW5jbHVkZXMoc2l6ZSkpe3Rocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGhhc2ggbGVuZ3RoXCIpfXZhciBzcG9uZ2U9bmV3IF9zcG9uZ2VbXCJkZWZhdWx0XCJdKHtjYXBhY2l0eTpzaXplfSk7dGhpcy51cGRhdGU9ZnVuY3Rpb24oaW5wdXQpe3ZhciBlbmNvZGluZz1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMV06XCJ1dGY4XCI7aWYoX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoaW5wdXQpKXtzcG9uZ2UuYWJzb3JiKGlucHV0KTtyZXR1cm4gX3RoaXN9aWYodHlwZW9mIGlucHV0PT09XCJzdHJpbmdcIil7cmV0dXJuIF90aGlzLnVwZGF0ZShfYnVmZmVyLkJ1ZmZlci5mcm9tKGlucHV0LGVuY29kaW5nKSl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHN0cmluZyBvciBidWZmZXJcIil9O3RoaXMuZGlnZXN0PWZ1bmN0aW9uKCl7dmFyIGZvcm1hdE9yT3B0aW9ucz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06XCJiaW5hcnlcIjt2YXIgb3B0aW9ucz10eXBlb2YgZm9ybWF0T3JPcHRpb25zPT09XCJzdHJpbmdcIj97Zm9ybWF0OmZvcm1hdE9yT3B0aW9uc306Zm9ybWF0T3JPcHRpb25zO3ZhciBidWZmZXI9c3BvbmdlLnNxdWVlemUoe2J1ZmZlcjpvcHRpb25zLmJ1ZmZlcixwYWRkaW5nOm9wdGlvbnMucGFkZGluZ3x8cGFkZGluZ30pO2lmKG9wdGlvbnMuZm9ybWF0JiZvcHRpb25zLmZvcm1hdCE9PVwiYmluYXJ5XCIpe3JldHVybiBidWZmZXIudG9TdHJpbmcob3B0aW9ucy5mb3JtYXQpfXJldHVybiBidWZmZXJ9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKXtzcG9uZ2UucmVzZXQoKTtyZXR1cm4gX3RoaXN9O3JldHVybiB0aGlzfX07dmFyIEtlY2Nhaz1jcmVhdGVIYXNoKHthbGxvd2VkU2l6ZXM6WzIyNCwyNTYsMzg0LDUxMl0sZGVmYXVsdFNpemU6NTEyLHBhZGRpbmc6MX0pO2V4cG9ydHMuS2VjY2FrPUtlY2Nhazt2YXIgU0hBMz1jcmVhdGVIYXNoKHthbGxvd2VkU2l6ZXM6WzIyNCwyNTYsMzg0LDUxMl0sZGVmYXVsdFNpemU6NTEyLHBhZGRpbmc6Nn0pO2V4cG9ydHMuU0hBMz1TSEEzO3ZhciBTSEFLRT1jcmVhdGVIYXNoKHthbGxvd2VkU2l6ZXM6WzEyOCwyNTZdLGRlZmF1bHRTaXplOjI1NixwYWRkaW5nOjMxfSk7ZXhwb3J0cy5TSEFLRT1TSEFLRTt2YXIgU0hBM0hhc2g9S2VjY2FrO2V4cG9ydHMuU0hBM0hhc2g9U0hBM0hhc2g7U0hBMy5TSEEzSGFzaD1TSEEzSGFzaDt2YXIgX2RlZmF1bHQ9U0hBMztleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/index.js":
/*!*******************************************!*\
  !*** ./node_modules/sha3/sponge/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _buffer=__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");var _permute=_interopRequireDefault(__webpack_require__(/*! ./permute */ \"./node_modules/sha3/sponge/permute/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var xorWords=function xorWords(I,O){for(var i=0;i<I.length;i+=8){var o=i/4;O[o]^=I[i+7]<<24|I[i+6]<<16|I[i+5]<<8|I[i+4];O[o+1]^=I[i+3]<<24|I[i+2]<<16|I[i+1]<<8|I[i]}return O};var readWords=function readWords(I,O){for(var o=0;o<O.length;o+=8){var i=o/4;O[o]=I[i+1];O[o+1]=I[i+1]>>>8;O[o+2]=I[i+1]>>>16;O[o+3]=I[i+1]>>>24;O[o+4]=I[i];O[o+5]=I[i]>>>8;O[o+6]=I[i]>>>16;O[o+7]=I[i]>>>24}return O};var Sponge=function Sponge(_ref){var _this=this;var capacity=_ref.capacity,padding=_ref.padding;var keccak=(0,_permute[\"default\"])();var stateSize=200;var blockSize=capacity/8;var queueSize=stateSize-capacity/4;var queueOffset=0;var state=new Uint32Array(stateSize/4);var queue=_buffer.Buffer.allocUnsafe(queueSize);this.absorb=function(buffer){for(var i=0;i<buffer.length;i++){queue[queueOffset]=buffer[i];queueOffset+=1;if(queueOffset>=queueSize){xorWords(queue,state);keccak(state);queueOffset=0}}return _this};this.squeeze=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var output={buffer:options.buffer||_buffer.Buffer.allocUnsafe(blockSize),padding:options.padding||padding,queue:_buffer.Buffer.allocUnsafe(queue.length),state:new Uint32Array(state.length)};queue.copy(output.queue);for(var i=0;i<state.length;i++){output.state[i]=state[i]}output.queue.fill(0,queueOffset);output.queue[queueOffset]|=output.padding;output.queue[queueSize-1]|=128;xorWords(output.queue,output.state);for(var offset=0;offset<output.buffer.length;offset+=queueSize){keccak(output.state);readWords(output.state,output.buffer.slice(offset,offset+queueSize))}return output.buffer};this.reset=function(){queue.fill(0);state.fill(0);queueOffset=0;return _this};return this};var _default=Sponge;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsWUFBWSxtQkFBTyxDQUFDLDhDQUFRLEVBQUUsb0NBQW9DLG1CQUFPLENBQUMsOERBQVcsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUsb0NBQW9DLFlBQVksV0FBVyxNQUFNLFVBQVUsNkNBQTZDLDZDQUE2QyxVQUFVLHNDQUFzQyxZQUFZLFdBQVcsTUFBTSxVQUFVLFlBQVksa0JBQWtCLG1CQUFtQixtQkFBbUIsWUFBWSxnQkFBZ0IsaUJBQWlCLGlCQUFpQixVQUFVLGlDQUFpQyxlQUFlLGdEQUFnRCxxQ0FBcUMsa0JBQWtCLHlCQUF5QixtQ0FBbUMsa0JBQWtCLHVDQUF1QyxnREFBZ0QsNkJBQTZCLFlBQVksZ0JBQWdCLEtBQUssNkJBQTZCLGVBQWUsMkJBQTJCLHNCQUFzQixjQUFjLGVBQWUsY0FBYyx3QkFBd0IseUVBQXlFLFlBQVksa0xBQWtMLHlCQUF5QixZQUFZLGVBQWUsS0FBSyx5QkFBeUIsaUNBQWlDLDBDQUEwQywrQkFBK0Isb0NBQW9DLGlCQUFpQiw0QkFBNEIsbUJBQW1CLHFCQUFxQixxRUFBcUUsc0JBQXNCLHNCQUFzQixjQUFjLGNBQWMsY0FBYyxjQUFjLGFBQWEsb0JBQW9CLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvaW5kZXguanM/ODU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2J1ZmZlcj1yZXF1aXJlKFwiYnVmZmVyXCIpO3ZhciBfcGVybXV0ZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Blcm11dGVcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIHhvcldvcmRzPWZ1bmN0aW9uIHhvcldvcmRzKEksTyl7Zm9yKHZhciBpPTA7aTxJLmxlbmd0aDtpKz04KXt2YXIgbz1pLzQ7T1tvXV49SVtpKzddPDwyNHxJW2krNl08PDE2fElbaSs1XTw8OHxJW2krNF07T1tvKzFdXj1JW2krM108PDI0fElbaSsyXTw8MTZ8SVtpKzFdPDw4fElbaV19cmV0dXJuIE99O3ZhciByZWFkV29yZHM9ZnVuY3Rpb24gcmVhZFdvcmRzKEksTyl7Zm9yKHZhciBvPTA7bzxPLmxlbmd0aDtvKz04KXt2YXIgaT1vLzQ7T1tvXT1JW2krMV07T1tvKzFdPUlbaSsxXT4+Pjg7T1tvKzJdPUlbaSsxXT4+PjE2O09bbyszXT1JW2krMV0+Pj4yNDtPW28rNF09SVtpXTtPW28rNV09SVtpXT4+Pjg7T1tvKzZdPUlbaV0+Pj4xNjtPW28rN109SVtpXT4+PjI0fXJldHVybiBPfTt2YXIgU3BvbmdlPWZ1bmN0aW9uIFNwb25nZShfcmVmKXt2YXIgX3RoaXM9dGhpczt2YXIgY2FwYWNpdHk9X3JlZi5jYXBhY2l0eSxwYWRkaW5nPV9yZWYucGFkZGluZzt2YXIga2VjY2FrPSgwLF9wZXJtdXRlW1wiZGVmYXVsdFwiXSkoKTt2YXIgc3RhdGVTaXplPTIwMDt2YXIgYmxvY2tTaXplPWNhcGFjaXR5Lzg7dmFyIHF1ZXVlU2l6ZT1zdGF0ZVNpemUtY2FwYWNpdHkvNDt2YXIgcXVldWVPZmZzZXQ9MDt2YXIgc3RhdGU9bmV3IFVpbnQzMkFycmF5KHN0YXRlU2l6ZS80KTt2YXIgcXVldWU9X2J1ZmZlci5CdWZmZXIuYWxsb2NVbnNhZmUocXVldWVTaXplKTt0aGlzLmFic29yYj1mdW5jdGlvbihidWZmZXIpe2Zvcih2YXIgaT0wO2k8YnVmZmVyLmxlbmd0aDtpKyspe3F1ZXVlW3F1ZXVlT2Zmc2V0XT1idWZmZXJbaV07cXVldWVPZmZzZXQrPTE7aWYocXVldWVPZmZzZXQ+PXF1ZXVlU2l6ZSl7eG9yV29yZHMocXVldWUsc3RhdGUpO2tlY2NhayhzdGF0ZSk7cXVldWVPZmZzZXQ9MH19cmV0dXJuIF90aGlzfTt0aGlzLnNxdWVlemU9ZnVuY3Rpb24oKXt2YXIgb3B0aW9ucz1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dmFyIG91dHB1dD17YnVmZmVyOm9wdGlvbnMuYnVmZmVyfHxfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja1NpemUpLHBhZGRpbmc6b3B0aW9ucy5wYWRkaW5nfHxwYWRkaW5nLHF1ZXVlOl9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKHF1ZXVlLmxlbmd0aCksc3RhdGU6bmV3IFVpbnQzMkFycmF5KHN0YXRlLmxlbmd0aCl9O3F1ZXVlLmNvcHkob3V0cHV0LnF1ZXVlKTtmb3IodmFyIGk9MDtpPHN0YXRlLmxlbmd0aDtpKyspe291dHB1dC5zdGF0ZVtpXT1zdGF0ZVtpXX1vdXRwdXQucXVldWUuZmlsbCgwLHF1ZXVlT2Zmc2V0KTtvdXRwdXQucXVldWVbcXVldWVPZmZzZXRdfD1vdXRwdXQucGFkZGluZztvdXRwdXQucXVldWVbcXVldWVTaXplLTFdfD0xMjg7eG9yV29yZHMob3V0cHV0LnF1ZXVlLG91dHB1dC5zdGF0ZSk7Zm9yKHZhciBvZmZzZXQ9MDtvZmZzZXQ8b3V0cHV0LmJ1ZmZlci5sZW5ndGg7b2Zmc2V0Kz1xdWV1ZVNpemUpe2tlY2NhayhvdXRwdXQuc3RhdGUpO3JlYWRXb3JkcyhvdXRwdXQuc3RhdGUsb3V0cHV0LmJ1ZmZlci5zbGljZShvZmZzZXQsb2Zmc2V0K3F1ZXVlU2l6ZSkpfXJldHVybiBvdXRwdXQuYnVmZmVyfTt0aGlzLnJlc2V0PWZ1bmN0aW9uKCl7cXVldWUuZmlsbCgwKTtzdGF0ZS5maWxsKDApO3F1ZXVlT2Zmc2V0PTA7cmV0dXJuIF90aGlzfTtyZXR1cm4gdGhpc307dmFyIF9kZWZhdWx0PVNwb25nZTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/chi/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/chi/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"./node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var chi=function chi(_ref){var A=_ref.A,C=_ref.C;for(var y=0;y<25;y+=5){for(var x=0;x<5;x++){(0,_copy[\"default\"])(A,y+x)(C,x)}for(var _x=0;_x<5;_x++){var xy=(y+_x)*2;var x1=(_x+1)%5*2;var x2=(_x+2)%5*2;A[xy]^=~C[x1]&C[x2];A[xy+1]^=~C[x1+1]&C[x2+1]}}};var _default=chi;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9jaGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsaUNBQWlDLG1CQUFPLENBQUMsaUVBQVMsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUsMkJBQTJCLHNCQUFzQixZQUFZLEtBQUssTUFBTSxZQUFZLElBQUksS0FBSyxpQ0FBaUMsYUFBYSxLQUFLLE1BQU0sZ0JBQWdCLGtCQUFrQixrQkFBa0Isb0JBQW9CLDZCQUE2QixpQkFBaUIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL2NoaS9pbmRleC5qcz9jNjQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfY29weT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb3B5XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9fXZhciBjaGk9ZnVuY3Rpb24gY2hpKF9yZWYpe3ZhciBBPV9yZWYuQSxDPV9yZWYuQztmb3IodmFyIHk9MDt5PDI1O3krPTUpe2Zvcih2YXIgeD0wO3g8NTt4KyspeygwLF9jb3B5W1wiZGVmYXVsdFwiXSkoQSx5K3gpKEMseCl9Zm9yKHZhciBfeD0wO194PDU7X3grKyl7dmFyIHh5PSh5K194KSoyO3ZhciB4MT0oX3grMSklNSoyO3ZhciB4Mj0oX3grMiklNSoyO0FbeHldXj1+Q1t4MV0mQ1t4Ml07QVt4eSsxXV49fkNbeDErMV0mQ1t4MisxXX19fTt2YXIgX2RlZmF1bHQ9Y2hpO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/chi/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/copy/index.js":
/*!********************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/copy/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var copy=function copy(I,i){return function(O,o){var oi=o*2;var ii=i*2;O[oi]=I[ii];O[oi+1]=I[ii+1]}};module.exports=copy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9jb3B5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDRCQUE0QixxQkFBcUIsV0FBVyxXQUFXLFlBQVksa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL2NvcHkvaW5kZXguanM/ZjZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjt2YXIgY29weT1mdW5jdGlvbiBjb3B5KEksaSl7cmV0dXJuIGZ1bmN0aW9uKE8sbyl7dmFyIG9pPW8qMjt2YXIgaWk9aSoyO09bb2ldPUlbaWldO09bb2krMV09SVtpaSsxXX19O21vZHVsZS5leHBvcnRzPWNvcHk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/copy/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/index.js":
/*!***************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _chi=_interopRequireDefault(__webpack_require__(/*! ./chi */ \"./node_modules/sha3/sponge/permute/chi/index.js\"));var _iota=_interopRequireDefault(__webpack_require__(/*! ./iota */ \"./node_modules/sha3/sponge/permute/iota/index.js\"));var _rhoPi=_interopRequireDefault(__webpack_require__(/*! ./rho-pi */ \"./node_modules/sha3/sponge/permute/rho-pi/index.js\"));var _theta=_interopRequireDefault(__webpack_require__(/*! ./theta */ \"./node_modules/sha3/sponge/permute/theta/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var permute=function permute(){var C=new Uint32Array(10);var D=new Uint32Array(10);var W=new Uint32Array(2);return function(A){for(var roundIndex=0;roundIndex<24;roundIndex++){(0,_theta[\"default\"])({A:A,C:C,D:D,W:W});(0,_rhoPi[\"default\"])({A:A,C:C,W:W});(0,_chi[\"default\"])({A:A,C:C});(0,_iota[\"default\"])({A:A,roundIndex:roundIndex})}C.fill(0);D.fill(0);W.fill(0)}};var _default=permute;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxrQkFBa0IsUUFBUSxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBTyxHQUFHLGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFRLEdBQUcsa0NBQWtDLG1CQUFPLENBQUMsb0VBQVUsR0FBRyxrQ0FBa0MsbUJBQU8sQ0FBQyxrRUFBUyxHQUFHLHFDQUFxQyxnQ0FBZ0MsZUFBZSwrQkFBK0IsMEJBQTBCLDBCQUEwQix5QkFBeUIsbUJBQW1CLHFCQUFxQixjQUFjLGNBQWMsdUJBQXVCLGdCQUFnQixFQUFFLHVCQUF1QixZQUFZLEVBQUUscUJBQXFCLFFBQVEsRUFBRSxzQkFBc0IsMEJBQTBCLEVBQUUsVUFBVSxVQUFVLFlBQVkscUJBQXFCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pbmRleC5qcz8zY2UxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfY2hpPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2hpXCIpKTt2YXIgX2lvdGE9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pb3RhXCIpKTt2YXIgX3Job1BpPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmhvLXBpXCIpKTt2YXIgX3RoZXRhPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdGhldGFcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIHBlcm11dGU9ZnVuY3Rpb24gcGVybXV0ZSgpe3ZhciBDPW5ldyBVaW50MzJBcnJheSgxMCk7dmFyIEQ9bmV3IFVpbnQzMkFycmF5KDEwKTt2YXIgVz1uZXcgVWludDMyQXJyYXkoMik7cmV0dXJuIGZ1bmN0aW9uKEEpe2Zvcih2YXIgcm91bmRJbmRleD0wO3JvdW5kSW5kZXg8MjQ7cm91bmRJbmRleCsrKXsoMCxfdGhldGFbXCJkZWZhdWx0XCJdKSh7QTpBLEM6QyxEOkQsVzpXfSk7KDAsX3Job1BpW1wiZGVmYXVsdFwiXSkoe0E6QSxDOkMsVzpXfSk7KDAsX2NoaVtcImRlZmF1bHRcIl0pKHtBOkEsQzpDfSk7KDAsX2lvdGFbXCJkZWZhdWx0XCJdKSh7QTpBLHJvdW5kSW5kZXg6cm91bmRJbmRleH0pfUMuZmlsbCgwKTtELmZpbGwoMCk7Vy5maWxsKDApfX07dmFyIF9kZWZhdWx0PXBlcm11dGU7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/iota/index.js":
/*!********************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/iota/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _roundConstants=_interopRequireDefault(__webpack_require__(/*! ./round-constants */ \"./node_modules/sha3/sponge/permute/iota/round-constants/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var iota=function iota(_ref){var A=_ref.A,roundIndex=_ref.roundIndex;var i=roundIndex*2;A[0]^=_roundConstants[\"default\"][i];A[1]^=_roundConstants[\"default\"][i+1]};var _default=iota;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pb3RhL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLDJDQUEyQyxtQkFBTyxDQUFDLDJGQUFtQixHQUFHLHFDQUFxQyxnQ0FBZ0MsZUFBZSw2QkFBNkIsd0NBQXdDLG1CQUFtQixvQ0FBb0MsdUNBQXVDLGtCQUFrQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvaW90YS9pbmRleC5qcz82NjNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfcm91bmRDb25zdGFudHM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3VuZC1jb25zdGFudHNcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIGlvdGE9ZnVuY3Rpb24gaW90YShfcmVmKXt2YXIgQT1fcmVmLkEscm91bmRJbmRleD1fcmVmLnJvdW5kSW5kZXg7dmFyIGk9cm91bmRJbmRleCoyO0FbMF1ePV9yb3VuZENvbnN0YW50c1tcImRlZmF1bHRcIl1baV07QVsxXV49X3JvdW5kQ29uc3RhbnRzW1wiZGVmYXVsdFwiXVtpKzFdfTt2YXIgX2RlZmF1bHQ9aW90YTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/iota/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/iota/round-constants/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/iota/round-constants/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var ROUND_CONSTANTS=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);var _default=ROUND_CONSTANTS;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pb3RhL3JvdW5kLWNvbnN0YW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxrQkFBa0IsUUFBUSxrWUFBa1ksNkJBQTZCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pb3RhL3JvdW5kLWNvbnN0YW50cy9pbmRleC5qcz9lNTVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBST1VORF9DT05TVEFOVFM9bmV3IFVpbnQzMkFycmF5KFswLDEsMCwzMjg5OCwyMTQ3NDgzNjQ4LDMyOTA2LDIxNDc0ODM2NDgsMjE0NzUxNjQxNiwwLDMyOTA3LDAsMjE0NzQ4MzY0OSwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjc3NywwLDEzOCwwLDEzNiwwLDIxNDc1MTY0MjUsMCwyMTQ3NDgzNjU4LDAsMjE0NzUxNjU1NSwyMTQ3NDgzNjQ4LDEzOSwyMTQ3NDgzNjQ4LDMyOTA1LDIxNDc0ODM2NDgsMzI3NzEsMjE0NzQ4MzY0OCwzMjc3MCwyMTQ3NDgzNjQ4LDEyOCwwLDMyNzc4LDIxNDc0ODM2NDgsMjE0NzQ4MzY1OCwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjg5NiwwLDIxNDc0ODM2NDksMjE0NzQ4MzY0OCwyMTQ3NTE2NDI0XSk7dmFyIF9kZWZhdWx0PVJPVU5EX0NPTlNUQU5UUztleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/iota/round-constants/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/rho-pi/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/rho-pi/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _piShuffles=_interopRequireDefault(__webpack_require__(/*! ./pi-shuffles */ \"./node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js\"));var _rhoOffsets=_interopRequireDefault(__webpack_require__(/*! ./rho-offsets */ \"./node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js\"));var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"./node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var rhoPi=function rhoPi(_ref){var A=_ref.A,C=_ref.C,W=_ref.W;(0,_copy[\"default\"])(A,1)(W,0);var H=0;var L=0;var Wi=0;var ri=32;for(var i=0;i<24;i++){var j=_piShuffles[\"default\"][i];var r=_rhoOffsets[\"default\"][i];(0,_copy[\"default\"])(A,j)(C,0);H=W[0];L=W[1];ri=32-r;Wi=r<32?0:1;W[Wi]=H<<r|L>>>ri;W[(Wi+1)%2]=L<<r|H>>>ri;(0,_copy[\"default\"])(W,0)(A,j);(0,_copy[\"default\"])(C,0)(W,0)}};var _default=rhoPi;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsdUNBQXVDLG1CQUFPLENBQUMscUZBQWUsR0FBRyx1Q0FBdUMsbUJBQU8sQ0FBQyxxRkFBZSxHQUFHLGlDQUFpQyxtQkFBTyxDQUFDLGlFQUFTLEdBQUcscUNBQXFDLGdDQUFnQyxlQUFlLCtCQUErQiwrQkFBK0IsK0JBQStCLFFBQVEsUUFBUSxTQUFTLFVBQVUsWUFBWSxLQUFLLEtBQUssZ0NBQWdDLGdDQUFnQywrQkFBK0IsT0FBTyxPQUFPLFFBQVEsWUFBWSxrQkFBa0Isd0JBQXdCLCtCQUErQixpQ0FBaUMsbUJBQW1CLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvaW5kZXguanM/ZDQzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3BpU2h1ZmZsZXM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9waS1zaHVmZmxlc1wiKSk7dmFyIF9yaG9PZmZzZXRzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmhvLW9mZnNldHNcIikpO3ZhciBfY29weT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb3B5XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9fXZhciByaG9QaT1mdW5jdGlvbiByaG9QaShfcmVmKXt2YXIgQT1fcmVmLkEsQz1fcmVmLkMsVz1fcmVmLlc7KDAsX2NvcHlbXCJkZWZhdWx0XCJdKShBLDEpKFcsMCk7dmFyIEg9MDt2YXIgTD0wO3ZhciBXaT0wO3ZhciByaT0zMjtmb3IodmFyIGk9MDtpPDI0O2krKyl7dmFyIGo9X3BpU2h1ZmZsZXNbXCJkZWZhdWx0XCJdW2ldO3ZhciByPV9yaG9PZmZzZXRzW1wiZGVmYXVsdFwiXVtpXTsoMCxfY29weVtcImRlZmF1bHRcIl0pKEEsaikoQywwKTtIPVdbMF07TD1XWzFdO3JpPTMyLXI7V2k9cjwzMj8wOjE7V1tXaV09SDw8cnxMPj4+cmk7V1soV2krMSklMl09TDw8cnxIPj4+cmk7KDAsX2NvcHlbXCJkZWZhdWx0XCJdKShXLDApKEEsaik7KDAsX2NvcHlbXCJkZWZhdWx0XCJdKShDLDApKFcsMCl9fTt2YXIgX2RlZmF1bHQ9cmhvUGk7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/rho-pi/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var PI_SHUFFLES=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1];var _default=PI_SHUFFLES;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvcGktc2h1ZmZsZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsaUZBQWlGLHlCQUF5QixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvcmhvLXBpL3BpLXNodWZmbGVzL2luZGV4LmpzP2E1NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIFBJX1NIVUZGTEVTPVsxMCw3LDExLDE3LDE4LDMsNSwxNiw4LDIxLDI0LDQsMTUsMjMsMTksMTMsMTIsMiwyMCwxNCwyMiw5LDYsMV07dmFyIF9kZWZhdWx0PVBJX1NIVUZGTEVTO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var RHO_OFFSETS=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44];var _default=RHO_OFFSETS;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvcmhvLW9mZnNldHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEscUZBQXFGLHlCQUF5QixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvcmhvLXBpL3Joby1vZmZzZXRzL2luZGV4LmpzPzNkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIFJIT19PRkZTRVRTPVsxLDMsNiwxMCwxNSwyMSwyOCwzNiw0NSw1NSwyLDE0LDI3LDQxLDU2LDgsMjUsNDMsNjIsMTgsMzksNjEsMjAsNDRdO3ZhciBfZGVmYXVsdD1SSE9fT0ZGU0VUUztleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js\n"));

/***/ }),

/***/ "./node_modules/sha3/sponge/permute/theta/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sha3/sponge/permute/theta/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"./node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var theta=function theta(_ref){var A=_ref.A,C=_ref.C,D=_ref.D,W=_ref.W;var H=0;var L=0;for(var x=0;x<5;x++){var x20=x*2;var x21=(x+5)*2;var x22=(x+10)*2;var x23=(x+15)*2;var x24=(x+20)*2;C[x20]=A[x20]^A[x21]^A[x22]^A[x23]^A[x24];C[x20+1]=A[x20+1]^A[x21+1]^A[x22+1]^A[x23+1]^A[x24+1]}for(var _x=0;_x<5;_x++){(0,_copy[\"default\"])(C,(_x+1)%5)(W,0);H=W[0];L=W[1];W[0]=H<<1|L>>>31;W[1]=L<<1|H>>>31;D[_x*2]=C[(_x+4)%5*2]^W[0];D[_x*2+1]=C[(_x+4)%5*2+1]^W[1];for(var y=0;y<25;y+=5){A[(y+_x)*2]^=D[_x*2];A[(y+_x)*2+1]^=D[_x*2+1]}}};var _default=theta;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS90aGV0YS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxrQkFBa0IsUUFBUSxpQ0FBaUMsbUJBQU8sQ0FBQyxpRUFBUyxHQUFHLHFDQUFxQyxnQ0FBZ0MsZUFBZSwrQkFBK0Isd0NBQXdDLFFBQVEsUUFBUSxZQUFZLElBQUksS0FBSyxZQUFZLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQiwwQ0FBMEMsc0RBQXNELGFBQWEsS0FBSyxNQUFNLHNDQUFzQyxPQUFPLE9BQU8saUJBQWlCLGlCQUFpQiwyQkFBMkIsK0JBQStCLFlBQVksS0FBSyxNQUFNLHFCQUFxQiw0QkFBNEIsbUJBQW1CLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS90aGV0YS9pbmRleC5qcz8yNGE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfY29weT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb3B5XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9fXZhciB0aGV0YT1mdW5jdGlvbiB0aGV0YShfcmVmKXt2YXIgQT1fcmVmLkEsQz1fcmVmLkMsRD1fcmVmLkQsVz1fcmVmLlc7dmFyIEg9MDt2YXIgTD0wO2Zvcih2YXIgeD0wO3g8NTt4Kyspe3ZhciB4MjA9eCoyO3ZhciB4MjE9KHgrNSkqMjt2YXIgeDIyPSh4KzEwKSoyO3ZhciB4MjM9KHgrMTUpKjI7dmFyIHgyND0oeCsyMCkqMjtDW3gyMF09QVt4MjBdXkFbeDIxXV5BW3gyMl1eQVt4MjNdXkFbeDI0XTtDW3gyMCsxXT1BW3gyMCsxXV5BW3gyMSsxXV5BW3gyMisxXV5BW3gyMysxXV5BW3gyNCsxXX1mb3IodmFyIF94PTA7X3g8NTtfeCsrKXsoMCxfY29weVtcImRlZmF1bHRcIl0pKEMsKF94KzEpJTUpKFcsMCk7SD1XWzBdO0w9V1sxXTtXWzBdPUg8PDF8TD4+PjMxO1dbMV09TDw8MXxIPj4+MzE7RFtfeCoyXT1DWyhfeCs0KSU1KjJdXldbMF07RFtfeCoyKzFdPUNbKF94KzQpJTUqMisxXV5XWzFdO2Zvcih2YXIgeT0wO3k8MjU7eSs9NSl7QVsoeStfeCkqMl1ePURbX3gqMl07QVsoeStfeCkqMisxXV49RFtfeCoyKzFdfX19O3ZhciBfZGVmYXVsdD10aGV0YTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sha3/sponge/permute/theta/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);