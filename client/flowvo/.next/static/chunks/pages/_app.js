/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-feature-settings: inherit; /* 1 */\\n  font-variation-settings: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nReset default styling for dialogs.\\n*/\\ndialog {\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n.container {\\n  width: 100%;\\n}\\n@media (min-width: 640px) {\\n\\n  .container {\\n    max-width: 640px;\\n  }\\n}\\n@media (min-width: 768px) {\\n\\n  .container {\\n    max-width: 768px;\\n  }\\n}\\n@media (min-width: 1024px) {\\n\\n  .container {\\n    max-width: 1024px;\\n  }\\n}\\n@media (min-width: 1280px) {\\n\\n  .container {\\n    max-width: 1280px;\\n  }\\n}\\n@media (min-width: 1536px) {\\n\\n  .container {\\n    max-width: 1536px;\\n  }\\n}\\n.fixed {\\n  position: fixed;\\n}\\n.absolute {\\n  position: absolute;\\n}\\n.relative {\\n  position: relative;\\n}\\n.sticky {\\n  position: sticky;\\n}\\n.inset-0 {\\n  inset: 0px;\\n}\\n.-top-1 {\\n  top: -0.25rem;\\n}\\n.left-0 {\\n  left: 0px;\\n}\\n.right-0 {\\n  right: 0px;\\n}\\n.right-\\\\[16px\\\\] {\\n  right: 16px;\\n}\\n.top-0 {\\n  top: 0px;\\n}\\n.top-1 {\\n  top: 0.25rem;\\n}\\n.z-20 {\\n  z-index: 20;\\n}\\n.z-\\\\[-1\\\\] {\\n  z-index: -1;\\n}\\n.float-right {\\n  float: right;\\n}\\n.float-left {\\n  float: left;\\n}\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.my-0 {\\n  margin-top: 0px;\\n  margin-bottom: 0px;\\n}\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\n.-ml-1 {\\n  margin-left: -0.25rem;\\n}\\n.-mt-2 {\\n  margin-top: -0.5rem;\\n}\\n.-mt-3 {\\n  margin-top: -0.75rem;\\n}\\n.-mt-\\\\[4px\\\\] {\\n  margin-top: -4px;\\n}\\n.mb-1 {\\n  margin-bottom: 0.25rem;\\n}\\n.mb-10 {\\n  margin-bottom: 2.5rem;\\n}\\n.mb-3 {\\n  margin-bottom: 0.75rem;\\n}\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\n.mb-6 {\\n  margin-bottom: 1.5rem;\\n}\\n.mb-\\\\[20px\\\\] {\\n  margin-bottom: 20px;\\n}\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\n.ml-4 {\\n  margin-left: 1rem;\\n}\\n.ml-40 {\\n  margin-left: 10rem;\\n}\\n.mr-1 {\\n  margin-right: 0.25rem;\\n}\\n.mr-2 {\\n  margin-right: 0.5rem;\\n}\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\n.mt-0 {\\n  margin-top: 0px;\\n}\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\n.mt-6 {\\n  margin-top: 1.5rem;\\n}\\n.mt-8 {\\n  margin-top: 2rem;\\n}\\n.mt-96 {\\n  margin-top: 24rem;\\n}\\n.line-clamp-2 {\\n  overflow: hidden;\\n  display: -webkit-box;\\n  -webkit-box-orient: vertical;\\n  -webkit-line-clamp: 2;\\n}\\n.block {\\n  display: block;\\n}\\n.inline-block {\\n  display: inline-block;\\n}\\n.inline {\\n  display: inline;\\n}\\n.flex {\\n  display: flex;\\n}\\n.hidden {\\n  display: none;\\n}\\n.h-3 {\\n  height: 0.75rem;\\n}\\n.h-\\\\[26px\\\\] {\\n  height: 26px;\\n}\\n.h-\\\\[40px\\\\] {\\n  height: 40px;\\n}\\n.h-full {\\n  height: 100%;\\n}\\n.h-screen {\\n  height: 100vh;\\n}\\n.max-h-64 {\\n  max-height: 16rem;\\n}\\n.w-full {\\n  width: 100%;\\n}\\n.max-w-6xl {\\n  max-width: 72rem;\\n}\\n.max-w-\\\\[1012px\\\\] {\\n  max-width: 1012px;\\n}\\n.cursor-help {\\n  cursor: help;\\n}\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\n.appearance-none {\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n}\\n.flex-col {\\n  flex-direction: column;\\n}\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\n.flex-nowrap {\\n  flex-wrap: nowrap;\\n}\\n.place-items-center {\\n  place-items: center;\\n}\\n.items-start {\\n  align-items: flex-start;\\n}\\n.items-center {\\n  align-items: center;\\n}\\n.justify-end {\\n  justify-content: flex-end;\\n}\\n.justify-center {\\n  justify-content: center;\\n}\\n.justify-between {\\n  justify-content: space-between;\\n}\\n.gap-1 {\\n  gap: 0.25rem;\\n}\\n.gap-2 {\\n  gap: 0.5rem;\\n}\\n.gap-x-3 {\\n  -moz-column-gap: 0.75rem;\\n       column-gap: 0.75rem;\\n}\\n.gap-y-\\\\[10px\\\\] {\\n  row-gap: 10px;\\n}\\n.space-x-1 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(0.5rem * var(--tw-space-x-reverse));\\n  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-x-5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1.25rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1.25rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-y-3 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(0.75rem * var(--tw-space-y-reverse));\\n}\\n.self-center {\\n  align-self: center;\\n}\\n.overflow-y-auto {\\n  overflow-y: auto;\\n}\\n.overflow-x-hidden {\\n  overflow-x: hidden;\\n}\\n.truncate {\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\n.break-words {\\n  overflow-wrap: break-word;\\n}\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\n.border {\\n  border-width: 1px;\\n}\\n.border-y {\\n  border-top-width: 1px;\\n  border-bottom-width: 1px;\\n}\\n.\\\\!border-t-0 {\\n  border-top-width: 0px !important;\\n}\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\n.border-b-2 {\\n  border-bottom-width: 2px;\\n}\\n.border-b-4 {\\n  border-bottom-width: 4px;\\n}\\n.border-l-4 {\\n  border-left-width: 4px;\\n}\\n.border-black {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(0 0 0 / var(--tw-border-opacity));\\n}\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.border-gray-400 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(156 163 175 / var(--tw-border-opacity));\\n}\\n.border-gray-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(75 85 99 / var(--tw-border-opacity));\\n}\\n.border-transparent {\\n  border-color: transparent;\\n}\\n.border-yellow-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(202 138 4 / var(--tw-border-opacity));\\n}\\n.bg-gray-200 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n}\\n.bg-gray-300 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity));\\n}\\n.bg-teal-400 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(45 212 191 / var(--tw-bg-opacity));\\n}\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.bg-white\\\\/30 {\\n  background-color: rgb(255 255 255 / 0.3);\\n}\\n.bg-gradient-to-b {\\n  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));\\n}\\n.from-zinc-200 {\\n  --tw-gradient-from: #e4e4e7 var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(228 228 231 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n.fill-current {\\n  fill: currentColor;\\n}\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\n.p-2 {\\n  padding: 0.5rem;\\n}\\n.p-3 {\\n  padding: 0.75rem;\\n}\\n.p-4 {\\n  padding: 1rem;\\n}\\n.p-8 {\\n  padding: 2rem;\\n}\\n.p-\\\\[6px\\\\] {\\n  padding: 6px;\\n}\\n.px-0 {\\n  padding-left: 0px;\\n  padding-right: 0px;\\n}\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\n.px-6 {\\n  padding-left: 1.5rem;\\n  padding-right: 1.5rem;\\n}\\n.px-\\\\[20px\\\\] {\\n  padding-left: 20px;\\n  padding-right: 20px;\\n}\\n.px-\\\\[22px\\\\] {\\n  padding-left: 22px;\\n  padding-right: 22px;\\n}\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\n.pb-1 {\\n  padding-bottom: 0.25rem;\\n}\\n.pb-6 {\\n  padding-bottom: 1.5rem;\\n}\\n.pl-0 {\\n  padding-left: 0px;\\n}\\n.pl-3 {\\n  padding-left: 0.75rem;\\n}\\n.pl-4 {\\n  padding-left: 1rem;\\n}\\n.pr-0 {\\n  padding-right: 0px;\\n}\\n.pr-2 {\\n  padding-right: 0.5rem;\\n}\\n.pr-4 {\\n  padding-right: 1rem;\\n}\\n.pr-\\\\[80px\\\\] {\\n  padding-right: 80px;\\n}\\n.pt-2 {\\n  padding-top: 0.5rem;\\n}\\n.pt-4 {\\n  padding-top: 1rem;\\n}\\n.text-left {\\n  text-align: left;\\n}\\n.text-center {\\n  text-align: center;\\n}\\n.align-middle {\\n  vertical-align: middle;\\n}\\n.font-mono {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace;\\n}\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\n.text-5xl {\\n  font-size: 3rem;\\n  line-height: 1;\\n}\\n.text-\\\\[17px\\\\] {\\n  font-size: 17px;\\n}\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\n.font-bold {\\n  font-weight: 700;\\n}\\n.font-extrabold {\\n  font-weight: 800;\\n}\\n.font-semibold {\\n  font-weight: 600;\\n}\\n.font-thin {\\n  font-weight: 100;\\n}\\n.leading-5 {\\n  line-height: 1.25rem;\\n}\\n.leading-\\\\[32px\\\\] {\\n  line-height: 32px;\\n}\\n.leading-\\\\[40px\\\\] {\\n  line-height: 40px;\\n}\\n.leading-\\\\[43px\\\\] {\\n  line-height: 43px;\\n}\\n.leading-\\\\[44px\\\\] {\\n  line-height: 44px;\\n}\\n.leading-normal {\\n  line-height: 1.5;\\n}\\n.text-gray-100 {\\n  --tw-text-opacity: 1;\\n  color: rgb(243 244 246 / var(--tw-text-opacity));\\n}\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\n.text-gray-800 {\\n  --tw-text-opacity: 1;\\n  color: rgb(31 41 55 / var(--tw-text-opacity));\\n}\\n.text-teal-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(45 212 191 / var(--tw-text-opacity));\\n}\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n.underline {\\n  text-decoration-line: underline;\\n}\\n.no-underline {\\n  text-decoration-line: none;\\n}\\n.shadow {\\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.backdrop-blur-2xl {\\n  --tw-backdrop-blur: blur(40px);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n.backdrop-blur-md {\\n  --tw-backdrop-blur: blur(12px);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n.transition-colors {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.duration-200 {\\n  transition-duration: 200ms;\\n}\\n\\n:root {\\n  --foreground-rgb: 0, 0, 0;\\n  --background-start-rgb: 214, 219, 220;\\n  --background-end-rgb: 255, 255, 255;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  :root {\\n    --foreground-rgb: 255, 255, 255;\\n    --background-start-rgb: 0, 0, 0;\\n    --background-end-rgb: 0, 0, 0;\\n  }\\n}\\n\\nbody {\\n  color: rgb(var(--foreground-rgb));\\n  background: linear-gradient(\\n      to bottom,\\n      transparent,\\n      rgb(var(--background-end-rgb))\\n    )\\n    rgb(var(--background-start-rgb));\\n}\\n\\n.before\\\\:absolute::before {\\n  content: var(--tw-content);\\n  position: absolute;\\n}\\n\\n.before\\\\:h-\\\\[300px\\\\]::before {\\n  content: var(--tw-content);\\n  height: 300px;\\n}\\n\\n.before\\\\:w-\\\\[480px\\\\]::before {\\n  content: var(--tw-content);\\n  width: 480px;\\n}\\n\\n.before\\\\:-translate-x-1\\\\/2::before {\\n  content: var(--tw-content);\\n  --tw-translate-x: -50%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.before\\\\:rounded-full::before {\\n  content: var(--tw-content);\\n  border-radius: 9999px;\\n}\\n\\n.before\\\\:bg-gradient-radial::before {\\n  content: var(--tw-content);\\n  background-image: radial-gradient(var(--tw-gradient-stops));\\n}\\n\\n.before\\\\:from-white::before {\\n  content: var(--tw-content);\\n  --tw-gradient-from: #fff var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n\\n.before\\\\:to-transparent::before {\\n  content: var(--tw-content);\\n  --tw-gradient-to: transparent var(--tw-gradient-to-position);\\n}\\n\\n.before\\\\:blur-2xl::before {\\n  content: var(--tw-content);\\n  --tw-blur: blur(40px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n\\n.before\\\\:content-\\\\[\\\\'\\\\'\\\\]::before {\\n  --tw-content: '';\\n  content: var(--tw-content);\\n}\\n\\n.after\\\\:absolute::after {\\n  content: var(--tw-content);\\n  position: absolute;\\n}\\n\\n.after\\\\:-z-20::after {\\n  content: var(--tw-content);\\n  z-index: -20;\\n}\\n\\n.after\\\\:h-\\\\[180px\\\\]::after {\\n  content: var(--tw-content);\\n  height: 180px;\\n}\\n\\n.after\\\\:w-\\\\[240px\\\\]::after {\\n  content: var(--tw-content);\\n  width: 240px;\\n}\\n\\n.after\\\\:translate-x-1\\\\/3::after {\\n  content: var(--tw-content);\\n  --tw-translate-x: 33.333333%;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.after\\\\:bg-gradient-conic::after {\\n  content: var(--tw-content);\\n  background-image: conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops));\\n}\\n\\n.after\\\\:from-sky-200::after {\\n  content: var(--tw-content);\\n  --tw-gradient-from: #bae6fd var(--tw-gradient-from-position);\\n  --tw-gradient-to: rgb(186 230 253 / 0) var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n}\\n\\n.after\\\\:via-blue-200::after {\\n  content: var(--tw-content);\\n  --tw-gradient-to: rgb(191 219 254 / 0)  var(--tw-gradient-to-position);\\n  --tw-gradient-stops: var(--tw-gradient-from), #bfdbfe var(--tw-gradient-via-position), var(--tw-gradient-to);\\n}\\n\\n.after\\\\:blur-2xl::after {\\n  content: var(--tw-content);\\n  --tw-blur: blur(40px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n\\n.after\\\\:content-\\\\[\\\\'\\\\'\\\\]::after {\\n  --tw-content: '';\\n  content: var(--tw-content);\\n}\\n\\n.hover\\\\:whitespace-break-spaces:hover {\\n  white-space: break-spaces;\\n}\\n\\n.hover\\\\:border-yellow-600:hover {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(202 138 4 / var(--tw-border-opacity));\\n}\\n\\n.hover\\\\:bg-gray-300:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-teal-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(20 184 166 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-yellow-100:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(254 249 195 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-yellow-500:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(234 179 8 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-teal-300:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(94 234 212 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:text-yellow-600:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(202 138 4 / var(--tw-text-opacity));\\n}\\n\\n.focus\\\\:bg-gray-100:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\\n}\\n\\n.focus\\\\:bg-white:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n\\n  .dark\\\\:border-neutral-800 {\\n    --tw-border-opacity: 1;\\n    border-color: rgb(38 38 38 / var(--tw-border-opacity));\\n  }\\n\\n  .dark\\\\:bg-zinc-800\\\\/30 {\\n    background-color: rgb(39 39 42 / 0.3);\\n  }\\n\\n  .dark\\\\:from-inherit {\\n    --tw-gradient-from: inherit var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .dark\\\\:drop-shadow-\\\\[0_0_0\\\\.3rem_\\\\#ffffff70\\\\] {\\n    --tw-drop-shadow: drop-shadow(0 0 0.3rem #ffffff70);\\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n  }\\n\\n  .dark\\\\:invert {\\n    --tw-invert: invert(100%);\\n    filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n  }\\n\\n  .before\\\\:dark\\\\:bg-gradient-to-br::before {\\n    content: var(--tw-content);\\n    background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));\\n  }\\n\\n  .before\\\\:dark\\\\:from-transparent::before {\\n    content: var(--tw-content);\\n    --tw-gradient-from: transparent var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .before\\\\:dark\\\\:to-blue-700::before {\\n    content: var(--tw-content);\\n    --tw-gradient-to: #1d4ed8 var(--tw-gradient-to-position);\\n  }\\n\\n  .before\\\\:dark\\\\:opacity-10::before {\\n    content: var(--tw-content);\\n    opacity: 0.1;\\n  }\\n\\n  .after\\\\:dark\\\\:from-sky-900::after {\\n    content: var(--tw-content);\\n    --tw-gradient-from: #0c4a6e var(--tw-gradient-from-position);\\n    --tw-gradient-to: rgb(12 74 110 / 0) var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\\n  }\\n\\n  .after\\\\:dark\\\\:via-\\\\[\\\\#0141ff\\\\]::after {\\n    content: var(--tw-content);\\n    --tw-gradient-to: rgb(1 65 255 / 0)  var(--tw-gradient-to-position);\\n    --tw-gradient-stops: var(--tw-gradient-from), #0141ff var(--tw-gradient-via-position), var(--tw-gradient-to);\\n  }\\n\\n  .after\\\\:dark\\\\:opacity-40::after {\\n    content: var(--tw-content);\\n    opacity: 0.4;\\n  }\\n}\\n\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .sm\\\\:w-auto {\\n    width: auto;\\n  }\\n\\n  .sm\\\\:flex-row {\\n    flex-direction: row;\\n  }\\n\\n  .sm\\\\:p-4 {\\n    padding: 1rem;\\n  }\\n\\n  .sm\\\\:leading-6 {\\n    line-height: 1.5rem;\\n  }\\n}\\n\\n@media (min-width: 768px) {\\n\\n  .md\\\\:right-\\\\[12px\\\\] {\\n    right: 12px;\\n  }\\n\\n  .md\\\\:top-\\\\[10px\\\\] {\\n    top: 10px;\\n  }\\n\\n  .md\\\\:my-2 {\\n    margin-top: 0.5rem;\\n    margin-bottom: 0.5rem;\\n  }\\n\\n  .md\\\\:mb-0 {\\n    margin-bottom: 0px;\\n  }\\n\\n  .md\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .md\\\\:flex {\\n    display: flex;\\n  }\\n\\n  .md\\\\:w-1\\\\/3 {\\n    width: 33.333333%;\\n  }\\n\\n  .md\\\\:w-2\\\\/3 {\\n    width: 66.666667%;\\n  }\\n\\n  .md\\\\:max-w-\\\\[340px\\\\] {\\n    max-width: 340px;\\n  }\\n\\n  .md\\\\:items-center {\\n    align-items: center;\\n  }\\n\\n  .md\\\\:rounded-xl {\\n    border-radius: 0.75rem;\\n  }\\n\\n  .md\\\\:border {\\n    border-width: 1px;\\n  }\\n\\n  .md\\\\:border-4 {\\n    border-width: 4px;\\n  }\\n\\n  .md\\\\:\\\\!border-t {\\n    border-top-width: 1px !important;\\n  }\\n\\n  .md\\\\:px-0 {\\n    padding-left: 0px;\\n    padding-right: 0px;\\n  }\\n\\n  .md\\\\:px-3 {\\n    padding-left: 0.75rem;\\n    padding-right: 0.75rem;\\n  }\\n\\n  .md\\\\:px-4 {\\n    padding-left: 1rem;\\n    padding-right: 1rem;\\n  }\\n\\n  .md\\\\:py-0 {\\n    padding-top: 0px;\\n    padding-bottom: 0px;\\n  }\\n\\n  .md\\\\:pb-0 {\\n    padding-bottom: 0px;\\n  }\\n\\n  .md\\\\:pt-3 {\\n    padding-top: 0.75rem;\\n  }\\n\\n  .md\\\\:text-left {\\n    text-align: left;\\n  }\\n}\\n\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:static {\\n    position: static;\\n  }\\n\\n  .lg\\\\:fixed {\\n    position: fixed;\\n  }\\n\\n  .lg\\\\:right-\\\\[10px\\\\] {\\n    right: 10px;\\n  }\\n\\n  .lg\\\\:my-0 {\\n    margin-top: 0px;\\n    margin-bottom: 0px;\\n  }\\n\\n  .lg\\\\:my-3 {\\n    margin-top: 0.75rem;\\n    margin-bottom: 0.75rem;\\n  }\\n\\n  .lg\\\\:mb-0 {\\n    margin-bottom: 0px;\\n  }\\n\\n  .lg\\\\:mb-3 {\\n    margin-bottom: 0.75rem;\\n  }\\n\\n  .lg\\\\:mt-0 {\\n    margin-top: 0px;\\n  }\\n\\n  .lg\\\\:mt-72 {\\n    margin-top: 18rem;\\n  }\\n\\n  .lg\\\\:mt-8 {\\n    margin-top: 2rem;\\n  }\\n\\n  .lg\\\\:block {\\n    display: block;\\n  }\\n\\n  .lg\\\\:flex {\\n    display: flex;\\n  }\\n\\n  .lg\\\\:hidden {\\n    display: none;\\n  }\\n\\n  .lg\\\\:h-auto {\\n    height: auto;\\n  }\\n\\n  .lg\\\\:max-h-\\\\[calc\\\\(100vh-120px\\\\)\\\\] {\\n    max-height: calc(100vh - 120px);\\n  }\\n\\n  .lg\\\\:w-1\\\\/4 {\\n    width: 25%;\\n  }\\n\\n  .lg\\\\:w-1\\\\/5 {\\n    width: 20%;\\n  }\\n\\n  .lg\\\\:w-3\\\\/4 {\\n    width: 75%;\\n  }\\n\\n  .lg\\\\:w-4\\\\/5 {\\n    width: 80%;\\n  }\\n\\n  .lg\\\\:w-\\\\[240px\\\\] {\\n    width: 240px;\\n  }\\n\\n  .lg\\\\:w-auto {\\n    width: auto;\\n  }\\n\\n  .lg\\\\:justify-normal {\\n    justify-content: normal;\\n  }\\n\\n  .lg\\\\:overflow-y-hidden {\\n    overflow-y: hidden;\\n  }\\n\\n  .lg\\\\:rounded-xl {\\n    border-radius: 0.75rem;\\n  }\\n\\n  .lg\\\\:border {\\n    border-width: 1px;\\n  }\\n\\n  .lg\\\\:border-transparent {\\n    border-color: transparent;\\n  }\\n\\n  .lg\\\\:bg-gray-200 {\\n    --tw-bg-opacity: 1;\\n    background-color: rgb(229 231 235 / var(--tw-bg-opacity));\\n  }\\n\\n  .lg\\\\:bg-transparent {\\n    background-color: transparent;\\n  }\\n\\n  .lg\\\\:bg-none {\\n    background-image: none;\\n  }\\n\\n  .lg\\\\:px-3 {\\n    padding-left: 0.75rem;\\n    padding-right: 0.75rem;\\n  }\\n\\n  .lg\\\\:pb-6 {\\n    padding-bottom: 1.5rem;\\n  }\\n\\n  .lg\\\\:pb-\\\\[24px\\\\] {\\n    padding-bottom: 24px;\\n  }\\n\\n  .lg\\\\:pl-5 {\\n    padding-left: 1.25rem;\\n  }\\n\\n  .lg\\\\:text-9xl {\\n    font-size: 8rem;\\n    line-height: 1;\\n  }\\n\\n  .lg\\\\:text-lg {\\n    font-size: 1.125rem;\\n    line-height: 1.75rem;\\n  }\\n\\n  .lg\\\\:text-xl {\\n    font-size: 1.25rem;\\n    line-height: 1.75rem;\\n  }\\n\\n  .lg\\\\:shadow-none {\\n    --tw-shadow: 0 0 #0000;\\n    --tw-shadow-colored: 0 0 #0000;\\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n  }\\n\\n  .before\\\\:lg\\\\:h-\\\\[360px\\\\]::before {\\n    content: var(--tw-content);\\n    height: 360px;\\n  }\\n\\n  .lg\\\\:hover\\\\:bg-transparent:hover {\\n    background-color: transparent;\\n  }\\n\\n  @media (prefers-color-scheme: dark) {\\n\\n    .lg\\\\:dark\\\\:bg-zinc-800\\\\/30 {\\n      background-color: rgb(39 39 42 / 0.3);\\n    }\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/globals.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n:root {\\n  --foreground-rgb: 0, 0, 0;\\n  --background-start-rgb: 214, 219, 220;\\n  --background-end-rgb: 255, 255, 255;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  :root {\\n    --foreground-rgb: 255, 255, 255;\\n    --background-start-rgb: 0, 0, 0;\\n    --background-end-rgb: 0, 0, 0;\\n  }\\n}\\n\\nbody {\\n  color: rgb(var(--foreground-rgb));\\n  background: linear-gradient(\\n      to bottom,\\n      transparent,\\n      rgb(var(--background-end-rgb))\\n    )\\n    rgb(var(--background-start-rgb));\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMl0hLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQzJIO0FBQzNILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFZQUFxWSxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCwwQ0FBMEMsNENBQTRDLFVBQVUsZ0tBQWdLLGVBQWUsaUNBQWlDLFVBQVUsMk5BQTJOLGVBQWUsMkJBQTJCLGtDQUFrQyxVQUFVLGlHQUFpRyw4Q0FBOEMsOENBQThDLEdBQUcsa0dBQWtHLHVCQUF1Qix5QkFBeUIsR0FBRyxpRkFBaUYsbUJBQW1CLDZCQUE2QixHQUFHLDJFQUEyRSx3QkFBd0IsR0FBRywwSkFBMEoseUhBQXlILDJCQUEyQixVQUFVLGlFQUFpRSxtQkFBbUIsR0FBRywyR0FBMkcsbUJBQW1CLG1CQUFtQix1QkFBdUIsNkJBQTZCLEdBQUcsU0FBUyxvQkFBb0IsR0FBRyxTQUFTLGdCQUFnQixHQUFHLGdiQUFnYixvQkFBb0Isa0NBQWtDLHNDQUFzQyxVQUFVLGtNQUFrTSwwQkFBMEIsMkNBQTJDLDZDQUE2Qyw0QkFBNEIsaUNBQWlDLGlDQUFpQywyQkFBMkIsc0JBQXNCLHVCQUF1QixVQUFVLDhGQUE4Rix5QkFBeUIsR0FBRyxtTEFBbUwsZ0NBQWdDLDBDQUEwQyxtQ0FBbUMsVUFBVSwrRkFBK0Ysa0JBQWtCLEdB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V0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxXQUFXLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sS0FBSyxZQUFZLFVBQVUsT0FBTyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE9BQU8sS0FBSyxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLGFBQWEsTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyx3Q0FBd0MsdUJBQXVCLHNCQUFzQixXQUFXLDhCQUE4QiwwQ0FBMEMsd0NBQXdDLEdBQUcseUNBQXlDLFdBQVcsc0NBQXNDLHNDQUFzQyxvQ0FBb0MsS0FBSyxHQUFHLFVBQVUsc0NBQXNDLDBKQUEwSixHQUFHLHFCQUFxQjtBQUN2MzJDO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0eWxlcy9nbG9iYWxzLmNzcz82MjQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcbiEgdGFpbHdpbmRjc3MgdjMuMy4zIHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcbiovLypcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcbiovXFxuXFxuKixcXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxufVxcblxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgLS10dy1jb250ZW50OiAnJztcXG59XFxuXFxuLypcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuNS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuNi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXFxuICAtby10YWItc2l6ZTogNDtcXG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiOyAvKiA0ICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogNSAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogNiAqL1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXG4qL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHIge1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXG4qL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxuKi9cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxudGFibGUge1xcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxcbiovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9J2J1dHRvbiddLFxcblt0eXBlPSdyZXNldCddLFxcblt0eXBlPSdzdWJtaXQnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxcbiovXFxuXFxuOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IGF1dG87XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGA6aW52YWxpZGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcXG4qL1xcblxcbjotbW96LXVpLWludmFsaWQge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLypcXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4qL1xcblxcblt0eXBlPSdzZWFyY2gnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qXFxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxcbiovXFxuXFxuYmxvY2txdW90ZSxcXG5kbCxcXG5kZCxcXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5ocixcXG5maWd1cmUsXFxucCxcXG5wcmUge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5sZWdlbmQge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxub2wsXFxudWwsXFxubWVudSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5SZXNldCBkZWZhdWx0IHN0eWxpbmcgZm9yIGRpYWxvZ3MuXFxuKi9cXG5kaWFsb2cge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi8qXFxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxcbiovXFxuXFxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxcbiovXFxuXFxuYnV0dG9uLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi8qXFxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cXG4qL1xcbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qXFxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbjIuIEFkZCBgdmVydGljYWwtYWxpZ246IG1pZGRsZWAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cXG4qL1xcblxcbmltZyxcXG5zdmcsXFxudmlkZW8sXFxuY2FudmFzLFxcbmF1ZGlvLFxcbmlmcmFtZSxcXG5lbWJlZCxcXG5vYmplY3Qge1xcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuKi9cXG5cXG5pbWcsXFxudmlkZW8ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKiBNYWtlIGVsZW1lbnRzIHdpdGggdGhlIEhUTUwgaGlkZGVuIGF0dHJpYnV0ZSBzdGF5IGhpZGRlbiBieSBkZWZhdWx0ICovXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuXFxuOjpiYWNrZHJvcCB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXG4uY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDY0MHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDc2OHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XFxuXFxuICAuY29udGFpbmVyIHtcXG4gICAgbWF4LXdpZHRoOiAxMDI0cHg7XFxuICB9XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDEyODBweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDE1MzZweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogMTUzNnB4O1xcbiAgfVxcbn1cXG4uZml4ZWQge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbn1cXG4uYWJzb2x1dGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ucmVsYXRpdmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uc3RpY2t5IHtcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxufVxcbi5pbnNldC0wIHtcXG4gIGluc2V0OiAwcHg7XFxufVxcbi4tdG9wLTEge1xcbiAgdG9wOiAtMC4yNXJlbTtcXG59XFxuLmxlZnQtMCB7XFxuICBsZWZ0OiAwcHg7XFxufVxcbi5yaWdodC0wIHtcXG4gIHJpZ2h0OiAwcHg7XFxufVxcbi5yaWdodC1cXFxcWzE2cHhcXFxcXSB7XFxuICByaWdodDogMTZweDtcXG59XFxuLnRvcC0wIHtcXG4gIHRvcDogMHB4O1xcbn1cXG4udG9wLTEge1xcbiAgdG9wOiAwLjI1cmVtO1xcbn1cXG4uei0yMCB7XFxuICB6LWluZGV4OiAyMDtcXG59XFxuLnotXFxcXFstMVxcXFxdIHtcXG4gIHotaW5kZXg6IC0xO1xcbn1cXG4uZmxvYXQtcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4uZmxvYXQtbGVmdCB7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuLm14LWF1dG8ge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxufVxcbi5teS0wIHtcXG4gIG1hcmdpbi10b3A6IDBweDtcXG4gIG1hcmdpbi1ib3R0b206IDBweDtcXG59XFxuLm15LTIge1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXG4uLW1sLTEge1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjI1cmVtO1xcbn1cXG4uLW10LTIge1xcbiAgbWFyZ2luLXRvcDogLTAuNXJlbTtcXG59XFxuLi1tdC0zIHtcXG4gIG1hcmdpbi10b3A6IC0wLjc1cmVtO1xcbn1cXG4uLW10LVxcXFxbNHB4XFxcXF0ge1xcbiAgbWFyZ2luLXRvcDogLTRweDtcXG59XFxuLm1iLTEge1xcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcXG59XFxuLm1iLTEwIHtcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXG59XFxuLm1iLTMge1xcbiAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXG59XFxuLm1iLTQge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuLm1iLTUge1xcbiAgbWFyZ2luLWJvdHRvbTogMS4yNXJlbTtcXG59XFxuLm1iLTYge1xcbiAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcbn1cXG4ubWItXFxcXFsyMHB4XFxcXF0ge1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuLm1sLTMge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxufVxcbi5tbC00IHtcXG4gIG1hcmdpbi1sZWZ0OiAxcmVtO1xcbn1cXG4ubWwtNDAge1xcbiAgbWFyZ2luLWxlZnQ6IDEwcmVtO1xcbn1cXG4ubXItMSB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuMjVyZW07XFxufVxcbi5tci0yIHtcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXG4ubXItMyB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNzVyZW07XFxufVxcbi5tdC0wIHtcXG4gIG1hcmdpbi10b3A6IDBweDtcXG59XFxuLm10LTEge1xcbiAgbWFyZ2luLXRvcDogMC4yNXJlbTtcXG59XFxuLm10LTIge1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbn1cXG4ubXQtMyB7XFxuICBtYXJnaW4tdG9wOiAwLjc1cmVtO1xcbn1cXG4ubXQtNCB7XFxuICBtYXJnaW4tdG9wOiAxcmVtO1xcbn1cXG4ubXQtNiB7XFxuICBtYXJnaW4tdG9wOiAxLjVyZW07XFxufVxcbi5tdC04IHtcXG4gIG1hcmdpbi10b3A6IDJyZW07XFxufVxcbi5tdC05NiB7XFxuICBtYXJnaW4tdG9wOiAyNHJlbTtcXG59XFxuLmxpbmUtY2xhbXAtMiB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1saW5lLWNsYW1wOiAyO1xcbn1cXG4uYmxvY2sge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5pbmxpbmUtYmxvY2sge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4uaW5saW5lIHtcXG4gIGRpc3BsYXk6IGlubGluZTtcXG59XFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uaC0zIHtcXG4gIGhlaWdodDogMC43NXJlbTtcXG59XFxuLmgtXFxcXFsyNnB4XFxcXF0ge1xcbiAgaGVpZ2h0OiAyNnB4O1xcbn1cXG4uaC1cXFxcWzQwcHhcXFxcXSB7XFxuICBoZWlnaHQ6IDQwcHg7XFxufVxcbi5oLWZ1bGwge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG4uaC1zY3JlZW4ge1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuLm1heC1oLTY0IHtcXG4gIG1heC1oZWlnaHQ6IDE2cmVtO1xcbn1cXG4udy1mdWxsIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4ubWF4LXctNnhsIHtcXG4gIG1heC13aWR0aDogNzJyZW07XFxufVxcbi5tYXgtdy1cXFxcWzEwMTJweFxcXFxdIHtcXG4gIG1heC13aWR0aDogMTAxMnB4O1xcbn1cXG4uY3Vyc29yLWhlbHAge1xcbiAgY3Vyc29yOiBoZWxwO1xcbn1cXG4uY3Vyc29yLXBvaW50ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uYXBwZWFyYW5jZS1ub25lIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuLmZsZXgtY29sIHtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcbi5mbGV4LXdyYXAge1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4uZmxleC1ub3dyYXAge1xcbiAgZmxleC13cmFwOiBub3dyYXA7XFxufVxcbi5wbGFjZS1pdGVtcy1jZW50ZXIge1xcbiAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcXG59XFxuLml0ZW1zLXN0YXJ0IHtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbn1cXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWVuZCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbn1cXG4uanVzdGlmeS1jZW50ZXIge1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWJldHdlZW4ge1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG4uZ2FwLTEge1xcbiAgZ2FwOiAwLjI1cmVtO1xcbn1cXG4uZ2FwLTIge1xcbiAgZ2FwOiAwLjVyZW07XFxufVxcbi5nYXAteC0zIHtcXG4gIC1tb3otY29sdW1uLWdhcDogMC43NXJlbTtcXG4gICAgICAgY29sdW1uLWdhcDogMC43NXJlbTtcXG59XFxuLmdhcC15LVxcXFxbMTBweFxcXFxdIHtcXG4gIHJvdy1nYXA6IDEwcHg7XFxufVxcbi5zcGFjZS14LTEgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuMjVyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDAuMjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxufVxcbi5zcGFjZS14LTIgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDAuNXJlbSAqIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoMC41cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXG4uc3BhY2UteC01ID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXgtcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi1yaWdodDogY2FsYygxLjI1cmVtICogdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7XFxuICBtYXJnaW4tbGVmdDogY2FsYygxLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSkpO1xcbn1cXG4uc3BhY2UteS0zID4gOm5vdChbaGlkZGVuXSkgfiA6bm90KFtoaWRkZW5dKSB7XFxuICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcXG4gIG1hcmdpbi10b3A6IGNhbGMoMC43NXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC43NXJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbn1cXG4uc2VsZi1jZW50ZXIge1xcbiAgYWxpZ24tc2VsZjogY2VudGVyO1xcbn1cXG4ub3ZlcmZsb3cteS1hdXRvIHtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxufVxcbi5vdmVyZmxvdy14LWhpZGRlbiB7XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxufVxcbi50cnVuY2F0ZSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4ud2hpdGVzcGFjZS1ub3dyYXAge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLmJyZWFrLXdvcmRzIHtcXG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxufVxcbi5yb3VuZGVkLWZ1bGwge1xcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcbn1cXG4ucm91bmRlZC1tZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjM3NXJlbTtcXG59XFxuLmJvcmRlciB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci15IHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG59XFxuLlxcXFwhYm9yZGVyLXQtMCB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAwcHggIWltcG9ydGFudDtcXG59XFxuLmJvcmRlci1iIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci1iLTIge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMnB4O1xcbn1cXG4uYm9yZGVyLWItNCB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiA0cHg7XFxufVxcbi5ib3JkZXItbC00IHtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiA0cHg7XFxufVxcbi5ib3JkZXItYmxhY2sge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmJvcmRlci1ncmF5LTMwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYm9yZGVyLWdyYXktNDAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5ib3JkZXItZ3JheS02MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDc1IDg1IDk5IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuLmJvcmRlci10cmFuc3BhcmVudCB7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG4uYm9yZGVyLXllbGxvdy02MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIwMiAxMzggNCAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5iZy1ncmF5LTIwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIzMSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1ncmF5LTMwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy10ZWFsLTQwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNDUgMjEyIDE5MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLXdoaXRlIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLXdoaXRlXFxcXC8zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyAwLjMpO1xcbn1cXG4uYmctZ3JhZGllbnQtdG8tYiB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCB2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpO1xcbn1cXG4uZnJvbS16aW5jLTIwMCB7XFxuICAtLXR3LWdyYWRpZW50LWZyb206ICNlNGU0ZTcgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbik7XFxuICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjI4IDIyOCAyMzEgLyAwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxuICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbn1cXG4uZmlsbC1jdXJyZW50IHtcXG4gIGZpbGw6IGN1cnJlbnRDb2xvcjtcXG59XFxuLm9iamVjdC1jb3ZlciB7XFxuICAtby1vYmplY3QtZml0OiBjb3ZlcjtcXG4gICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcbn1cXG4ucC0yIHtcXG4gIHBhZGRpbmc6IDAuNXJlbTtcXG59XFxuLnAtMyB7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbn1cXG4ucC00IHtcXG4gIHBhZGRpbmc6IDFyZW07XFxufVxcbi5wLTgge1xcbiAgcGFkZGluZzogMnJlbTtcXG59XFxuLnAtXFxcXFs2cHhcXFxcXSB7XFxuICBwYWRkaW5nOiA2cHg7XFxufVxcbi5weC0wIHtcXG4gIHBhZGRpbmctbGVmdDogMHB4O1xcbiAgcGFkZGluZy1yaWdodDogMHB4O1xcbn1cXG4ucHgtMiB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXG59XFxuLnB4LTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxuLnB4LTQge1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXG59XFxuLnB4LTYge1xcbiAgcGFkZGluZy1sZWZ0OiAxLjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAxLjVyZW07XFxufVxcbi5weC1cXFxcWzIwcHhcXFxcXSB7XFxuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcbn1cXG4ucHgtXFxcXFsyMnB4XFxcXF0ge1xcbiAgcGFkZGluZy1sZWZ0OiAyMnB4O1xcbiAgcGFkZGluZy1yaWdodDogMjJweDtcXG59XFxuLnB5LTEge1xcbiAgcGFkZGluZy10b3A6IDAuMjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMC4yNXJlbTtcXG59XFxuLnB5LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxufVxcbi5weS0zIHtcXG4gIHBhZGRpbmctdG9wOiAwLjc1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxufVxcbi5wYi0xIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjI1cmVtO1xcbn1cXG4ucGItNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcbn1cXG4ucGwtMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDBweDtcXG59XFxuLnBsLTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbn1cXG4ucGwtNCB7XFxuICBwYWRkaW5nLWxlZnQ6IDFyZW07XFxufVxcbi5wci0wIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDBweDtcXG59XFxuLnByLTIge1xcbiAgcGFkZGluZy1yaWdodDogMC41cmVtO1xcbn1cXG4ucHItNCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcbn1cXG4ucHItXFxcXFs4MHB4XFxcXF0ge1xcbiAgcGFkZGluZy1yaWdodDogODBweDtcXG59XFxuLnB0LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG59XFxuLnB0LTQge1xcbiAgcGFkZGluZy10b3A6IDFyZW07XFxufVxcbi50ZXh0LWxlZnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnRleHQtY2VudGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmFsaWduLW1pZGRsZSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4uZm9udC1tb25vIHtcXG4gIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsIFxcXCJDb3VyaWVyIE5ld1xcXCIsIG1vbm9zcGFjZTtcXG59XFxuLnRleHQtMnhsIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxufVxcbi50ZXh0LTN4bCB7XFxuICBmb250LXNpemU6IDEuODc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDIuMjVyZW07XFxufVxcbi50ZXh0LTV4bCB7XFxuICBmb250LXNpemU6IDNyZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG59XFxuLnRleHQtXFxcXFsxN3B4XFxcXF0ge1xcbiAgZm9udC1zaXplOiAxN3B4O1xcbn1cXG4udGV4dC1iYXNlIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjVyZW07XFxufVxcbi50ZXh0LWxnIHtcXG4gIGZvbnQtc2l6ZTogMS4xMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxuLnRleHQtc20ge1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbn1cXG4udGV4dC14bCB7XFxuICBmb250LXNpemU6IDEuMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxuLnRleHQteHMge1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDFyZW07XFxufVxcbi5mb250LWJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuLmZvbnQtZXh0cmFib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcbi5mb250LXNlbWlib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcbi5mb250LXRoaW4ge1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG59XFxuLmxlYWRpbmctNSB7XFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXG59XFxuLmxlYWRpbmctXFxcXFszMnB4XFxcXF0ge1xcbiAgbGluZS1oZWlnaHQ6IDMycHg7XFxufVxcbi5sZWFkaW5nLVxcXFxbNDBweFxcXFxdIHtcXG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbn1cXG4ubGVhZGluZy1cXFxcWzQzcHhcXFxcXSB7XFxuICBsaW5lLWhlaWdodDogNDNweDtcXG59XFxuLmxlYWRpbmctXFxcXFs0NHB4XFxcXF0ge1xcbiAgbGluZS1oZWlnaHQ6IDQ0cHg7XFxufVxcbi5sZWFkaW5nLW5vcm1hbCB7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbn1cXG4udGV4dC1ncmF5LTEwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjQzIDI0NCAyNDYgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS02MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDc1IDg1IDk5IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWdyYXktNzAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig1NSA2NSA4MSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1ncmF5LTgwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMzEgNDEgNTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtdGVhbC00MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDQ1IDIxMiAxOTEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtd2hpdGUge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi51bmRlcmxpbmUge1xcbiAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcXG59XFxuLm5vLXVuZGVybGluZSB7XFxuICB0ZXh0LWRlY29yYXRpb24tbGluZTogbm9uZTtcXG59XFxuLnNoYWRvdyB7XFxuICAtLXR3LXNoYWRvdzogMCAxcHggM3B4IDAgcmdiKDAgMCAwIC8gMC4xKSwgMCAxcHggMnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMXB4IDNweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgMXB4IDJweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXG4uYmFja2Ryb3AtYmx1ci0yeGwge1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiBibHVyKDQwcHgpO1xcbiAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKTtcXG4gICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxufVxcbi5iYWNrZHJvcC1ibHVyLW1kIHtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cigxMnB4KTtcXG4gIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxuICAgICAgICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1cikgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcykgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0KSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5KSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEpO1xcbn1cXG4udHJhbnNpdGlvbi1jb2xvcnMge1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2U7XFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xcbn1cXG4uZHVyYXRpb24tMjAwIHtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDIwMG1zO1xcbn1cXG5cXG46cm9vdCB7XFxuICAtLWZvcmVncm91bmQtcmdiOiAwLCAwLCAwO1xcbiAgLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYjogMjE0LCAyMTksIDIyMDtcXG4gIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcbn1cXG5cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuICA6cm9vdCB7XFxuICAgIC0tZm9yZWdyb3VuZC1yZ2I6IDI1NSwgMjU1LCAyNTU7XFxuICAgIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDAsIDAsIDA7XFxuICAgIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAwLCAwLCAwO1xcbiAgfVxcbn1cXG5cXG5ib2R5IHtcXG4gIGNvbG9yOiByZ2IodmFyKC0tZm9yZWdyb3VuZC1yZ2IpKTtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgICB0byBib3R0b20sXFxuICAgICAgdHJhbnNwYXJlbnQsXFxuICAgICAgcmdiKHZhcigtLWJhY2tncm91bmQtZW5kLXJnYikpXFxuICAgIClcXG4gICAgcmdiKHZhcigtLWJhY2tncm91bmQtc3RhcnQtcmdiKSk7XFxufVxcblxcbi5iZWZvcmVcXFxcOmFic29sdXRlOjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5iZWZvcmVcXFxcOmgtXFxcXFszMDBweFxcXFxdOjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBoZWlnaHQ6IDMwMHB4O1xcbn1cXG5cXG4uYmVmb3JlXFxcXDp3LVxcXFxbNDgwcHhcXFxcXTo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgd2lkdGg6IDQ4MHB4O1xcbn1cXG5cXG4uYmVmb3JlXFxcXDotdHJhbnNsYXRlLXgtMVxcXFwvMjo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgLS10dy10cmFuc2xhdGUteDogLTUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG5cXG4uYmVmb3JlXFxcXDpyb3VuZGVkLWZ1bGw6OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLmJlZm9yZVxcXFw6YmctZ3JhZGllbnQtcmFkaWFsOjpiZWZvcmUge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiByYWRpYWwtZ3JhZGllbnQodmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKTtcXG59XFxuXFxuLmJlZm9yZVxcXFw6ZnJvbS13aGl0ZTo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgLS10dy1ncmFkaWVudC1mcm9tOiAjZmZmIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcbiAgLS10dy1ncmFkaWVudC10bzogcmdiKDI1NSAyNTUgMjU1IC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtZnJvbSksIHZhcigtLXR3LWdyYWRpZW50LXRvKTtcXG59XFxuXFxuLmJlZm9yZVxcXFw6dG8tdHJhbnNwYXJlbnQ6OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctZ3JhZGllbnQtdG86IHRyYW5zcGFyZW50IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG59XFxuXFxuLmJlZm9yZVxcXFw6Ymx1ci0yeGw6OmJlZm9yZSB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctYmx1cjogYmx1cig0MHB4KTtcXG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXG59XFxuXFxuLmJlZm9yZVxcXFw6Y29udGVudC1cXFxcW1xcXFwnXFxcXCdcXFxcXTo6YmVmb3JlIHtcXG4gIC0tdHctY29udGVudDogJyc7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG59XFxuXFxuLmFmdGVyXFxcXDphYnNvbHV0ZTo6YWZ0ZXIge1xcbiAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5hZnRlclxcXFw6LXotMjA6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgei1pbmRleDogLTIwO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOmgtXFxcXFsxODBweFxcXFxdOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIGhlaWdodDogMTgwcHg7XFxufVxcblxcbi5hZnRlclxcXFw6dy1cXFxcWzI0MHB4XFxcXF06OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgd2lkdGg6IDI0MHB4O1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOnRyYW5zbGF0ZS14LTFcXFxcLzM6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgLS10dy10cmFuc2xhdGUteDogMzMuMzMzMzMzJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOmJnLWdyYWRpZW50LWNvbmljOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IGNvbmljLWdyYWRpZW50KGZyb20gMTgwZGVnIGF0IDUwJSA1MCUsIHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSk7XFxufVxcblxcbi5hZnRlclxcXFw6ZnJvbS1za3ktMjAwOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctZ3JhZGllbnQtZnJvbTogI2JhZTZmZCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigxODYgMjMwIDI1MyAvIDApIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxufVxcblxcbi5hZnRlclxcXFw6dmlhLWJsdWUtMjAwOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctZ3JhZGllbnQtdG86IHJnYigxOTEgMjE5IDI1NCAvIDApICB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxuICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgI2JmZGJmZSB2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxufVxcblxcbi5hZnRlclxcXFw6Ymx1ci0yeGw6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgLS10dy1ibHVyOiBibHVyKDQwcHgpO1xcbiAgZmlsdGVyOiB2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpO1xcbn1cXG5cXG4uYWZ0ZXJcXFxcOmNvbnRlbnQtXFxcXFtcXFxcJ1xcXFwnXFxcXF06OmFmdGVyIHtcXG4gIC0tdHctY29udGVudDogJyc7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG59XFxuXFxuLmhvdmVyXFxcXDp3aGl0ZXNwYWNlLWJyZWFrLXNwYWNlczpob3ZlciB7XFxuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci15ZWxsb3ctNjAwOmhvdmVyIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMDIgMTM4IDQgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLWdyYXktMzAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMDkgMjEzIDIxOSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy10ZWFsLTUwMDpob3ZlciB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjAgMTg0IDE2NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy15ZWxsb3ctMTAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTQgMjQ5IDE5NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy15ZWxsb3ctNTAwOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzQgMTc5IDggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctdGVhbC0zMDA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDk0IDIzNCAyMTIgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC15ZWxsb3ctNjAwOmhvdmVyIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyMDIgMTM4IDQgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ncmF5LTEwMDpmb2N1cyB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQzIDI0NCAyNDYgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5mb2N1c1xcXFw6Ymctd2hpdGU6Zm9jdXMge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOm91dGxpbmUtbm9uZTpmb2N1cyB7XFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcbn1cXG5cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuXFxuICAuZGFya1xcXFw6Ym9yZGVyLW5ldXRyYWwtODAwIHtcXG4gICAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2IoMzggMzggMzggLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbiAgfVxcblxcbiAgLmRhcmtcXFxcOmJnLXppbmMtODAwXFxcXC8zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigzOSAzOSA0MiAvIDAuMyk7XFxuICB9XFxuXFxuICAuZGFya1xcXFw6ZnJvbS1pbmhlcml0IHtcXG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiBpbmhlcml0IHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMjU1IDI1NSAyNTUgLyAwKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbik7XFxuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LWZyb20pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxuICB9XFxuXFxuICAuZGFya1xcXFw6ZHJvcC1zaGFkb3ctXFxcXFswXzBfMFxcXFwuM3JlbV9cXFxcI2ZmZmZmZjcwXFxcXF0ge1xcbiAgICAtLXR3LWRyb3Atc2hhZG93OiBkcm9wLXNoYWRvdygwIDAgMC4zcmVtICNmZmZmZmY3MCk7XFxuICAgIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXG4gIH1cXG5cXG4gIC5kYXJrXFxcXDppbnZlcnQge1xcbiAgICAtLXR3LWludmVydDogaW52ZXJ0KDEwMCUpO1xcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxuICB9XFxuXFxuICAuYmVmb3JlXFxcXDpkYXJrXFxcXDpiZy1ncmFkaWVudC10by1icjo6YmVmb3JlIHtcXG4gICAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gcmlnaHQsIHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSk7XFxuICB9XFxuXFxuICAuYmVmb3JlXFxcXDpkYXJrXFxcXDpmcm9tLXRyYW5zcGFyZW50OjpiZWZvcmUge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiB0cmFuc3BhcmVudCB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKTtcXG4gICAgLS10dy1ncmFkaWVudC10bzogcmdiKDAgMCAwIC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbiAgfVxcblxcbiAgLmJlZm9yZVxcXFw6ZGFya1xcXFw6dG8tYmx1ZS03MDA6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiAjMWQ0ZWQ4IHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTtcXG4gIH1cXG5cXG4gIC5iZWZvcmVcXFxcOmRhcmtcXFxcOm9wYWNpdHktMTA6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgICBvcGFjaXR5OiAwLjE7XFxuICB9XFxuXFxuICAuYWZ0ZXJcXFxcOmRhcmtcXFxcOmZyb20tc2t5LTkwMDo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiAjMGM0YTZlIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMTIgNzQgMTEwIC8gMCkgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pO1xcbiAgfVxcblxcbiAgLmFmdGVyXFxcXDpkYXJrXFxcXDp2aWEtXFxcXFtcXFxcIzAxNDFmZlxcXFxdOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6IHZhcigtLXR3LWNvbnRlbnQpO1xcbiAgICAtLXR3LWdyYWRpZW50LXRvOiByZ2IoMSA2NSAyNTUgLyAwKSAgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pO1xcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSwgIzAxNDFmZiB2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC10byk7XFxuICB9XFxuXFxuICAuYWZ0ZXJcXFxcOmRhcmtcXFxcOm9wYWNpdHktNDA6OmFmdGVyIHtcXG4gICAgY29udGVudDogdmFyKC0tdHctY29udGVudCk7XFxuICAgIG9wYWNpdHk6IDAuNDtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XFxuXFxuICAuc21cXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnctYXV0byB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbGV4LXJvdyB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICB9XFxuXFxuICAuc21cXFxcOnAtNCB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICB9XFxuXFxuICAuc21cXFxcOmxlYWRpbmctNiB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjVyZW07XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcblxcbiAgLm1kXFxcXDpyaWdodC1cXFxcWzEycHhcXFxcXSB7XFxuICAgIHJpZ2h0OiAxMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0b3AtXFxcXFsxMHB4XFxcXF0ge1xcbiAgICB0b3A6IDEwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LTIge1xcbiAgICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWItMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDBweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXQtMCB7XFxuICAgIG1hcmdpbi10b3A6IDBweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuXFxuICAubWRcXFxcOnctMVxcXFwvMyB7XFxuICAgIHdpZHRoOiAzMy4zMzMzMzMlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LTJcXFxcLzMge1xcbiAgICB3aWR0aDogNjYuNjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LXctXFxcXFszNDBweFxcXFxdIHtcXG4gICAgbWF4LXdpZHRoOiAzNDBweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aXRlbXMtY2VudGVyIHtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC14bCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAuNzVyZW07XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlciB7XFxuICAgIGJvcmRlci13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItNCB7XFxuICAgIGJvcmRlci13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpcXFxcIWJvcmRlci10IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDBweDtcXG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC0zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweS0wIHtcXG4gICAgcGFkZGluZy10b3A6IDBweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDBweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItMCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAwcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LTMge1xcbiAgICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dGV4dC1sZWZ0IHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCkge1xcblxcbiAgLmxnXFxcXDpzdGF0aWMge1xcbiAgICBwb3NpdGlvbjogc3RhdGljO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmaXhlZCB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cmlnaHQtXFxcXFsxMHB4XFxcXF0ge1xcbiAgICByaWdodDogMTBweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktMCB7XFxuICAgIG1hcmdpbi10b3A6IDBweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS0zIHtcXG4gICAgbWFyZ2luLXRvcDogMC43NXJlbTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWItMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDBweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWItMyB7XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNzVyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTcyIHtcXG4gICAgbWFyZ2luLXRvcDogMThyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTgge1xcbiAgICBtYXJnaW4tdG9wOiAycmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpibG9jayB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbGV4IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC1hdXRvIHtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC1cXFxcW2NhbGNcXFxcKDEwMHZoLTEyMHB4XFxcXClcXFxcXSB7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAxMjBweCk7XFxuICB9XFxuXFxuICAubGdcXFxcOnctMVxcXFwvNCB7XFxuICAgIHdpZHRoOiAyNSU7XFxuICB9XFxuXFxuICAubGdcXFxcOnctMVxcXFwvNSB7XFxuICAgIHdpZHRoOiAyMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnctM1xcXFwvNCB7XFxuICAgIHdpZHRoOiA3NSU7XFxuICB9XFxuXFxuICAubGdcXFxcOnctNFxcXFwvNSB7XFxuICAgIHdpZHRoOiA4MCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnctXFxcXFsyNDBweFxcXFxdIHtcXG4gICAgd2lkdGg6IDI0MHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LWF1dG8ge1xcbiAgICB3aWR0aDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6anVzdGlmeS1ub3JtYWwge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IG5vcm1hbDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3cteS1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQteGwge1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXIge1xcbiAgICBib3JkZXItd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXRyYW5zcGFyZW50IHtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctZ3JheS0yMDAge1xcbiAgICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMjkgMjMxIDIzNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctdHJhbnNwYXJlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ymctbm9uZSB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLTYge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi1cXFxcWzI0cHhcXFxcXSB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxLjI1cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LTl4bCB7XFxuICAgIGZvbnQtc2l6ZTogOHJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtbGcge1xcbiAgICBmb250LXNpemU6IDEuMTI1cmVtO1xcbiAgICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGV4dC14bCB7XFxuICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOnNoYWRvdy1ub25lIHtcXG4gICAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gICAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbiAgfVxcblxcbiAgLmJlZm9yZVxcXFw6bGdcXFxcOmgtXFxcXFszNjBweFxcXFxdOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gICAgaGVpZ2h0OiAzNjBweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuXFxuICAgIC5sZ1xcXFw6ZGFya1xcXFw6YmctemluYy04MDBcXFxcLzMwIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzkgMzkgNDIgLyAwLjMpO1xcbiAgICB9XFxuICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztDQUFjLENBQWQ7OztDQUFjOztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7Ozs7Ozs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjLEVBQWQsTUFBYztFQUFkLDhCQUFjLEVBQWQsTUFBYztFQUFkLGdCQUFjLEVBQWQsTUFBYztFQUFkLGNBQWM7S0FBZCxXQUFjLEVBQWQsTUFBYztFQUFkLDROQUFjLEVBQWQsTUFBYztFQUFkLDZCQUFjLEVBQWQsTUFBYztFQUFkLCtCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFNBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDtFQUFBLFNBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHlDQUFjO1VBQWQsaUNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7Ozs7O0VBQUEsa0JBQWM7RUFBZCxvQkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsY0FBYztFQUFkLHdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsbUJBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwrR0FBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsY0FBYztBQUFBOztB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O0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGVBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkIsb0JBQW1CO0VBQW5CLDRCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0tBQW5CLHFCQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7T0FBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQix1REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsc0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLHVEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQiwrREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkIsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLDREQUFtQjtFQUFuQixxRUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxlQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwwRUFBbUI7RUFBbkIsOEZBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsOEJBQW1CO0VBQW5CLCtRQUFtQjtVQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDhCQUFtQjtFQUFuQiwrUUFBbUI7VUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwrRkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7O0FBRW5CO0VBQ0UseUJBQXlCO0VBQ3pCLHFDQUFxQztFQUNyQyxtQ0FBbUM7QUFDckM7O0FBRUE7RUFDRTtJQUNFLCtCQUErQjtJQUMvQiwrQkFBK0I7SUFDL0IsNkJBQTZCO0VBQy9CO0FBQ0Y7O0FBRUE7RUFDRSxpQ0FBaUM7RUFDakM7Ozs7O29DQUtrQztBQUNwQzs7QUExQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsc0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBLHlEQTJCQTtFQTNCQSxxRUEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQSxxQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsZ0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsMEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsNEJBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsNERBMkJBO0VBM0JBLHFFQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSwwQkEyQkE7RUEzQkEsc0VBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDBCQTJCQTtFQTNCQSxxQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsZ0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBO0FBMkJBOztBQTNCQTtFQUFBLHNCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLGtCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLG9CQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7RUFBQSxrQkEyQkE7RUEzQkE7QUEyQkE7O0FBM0JBO0VBQUEsa0JBMkJBO0VBM0JBO0FBMkJBOztBQTNCQTtFQUFBLDhCQTJCQTtFQTNCQTtBQTJCQTs7QUEzQkE7O0VBQUE7SUFBQSxzQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsNERBMkJBO0lBM0JBLHFFQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxtREEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEseUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSwwQkEyQkE7SUEzQkEsZ0VBMkJBO0lBM0JBLCtEQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSwwQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsMEJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQSw0REEyQkE7SUEzQkEsbUVBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQSxtRUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsMEJBMkJBO0lBM0JBO0VBMkJBO0FBQUE7O0FBM0JBOztFQUFBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7QUFBQTs7QUEzQkE7O0VBQUE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQSxrQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsaUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLHFCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxrQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsZ0JBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBO0FBQUE7O0FBM0JBOztFQUFBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsZUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsbUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBO0VBMkJBOztFQTNCQTtJQUFBLGtCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7SUFBQSxxQkEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUE7RUEyQkE7O0VBM0JBO0lBQUEsZUEyQkE7SUEzQkE7RUEyQkE7O0VBM0JBO0lBQUEsbUJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLGtCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQSxzQkEyQkE7SUEzQkEsOEJBMkJBO0lBM0JBO0VBMkJBOztFQTNCQTtJQUFBLDBCQTJCQTtJQTNCQTtFQTJCQTs7RUEzQkE7SUFBQTtFQTJCQTs7RUEzQkE7O0lBQUE7TUFBQTtJQTJCQTtFQUFBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQHRhaWx3aW5kIGJhc2U7XFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXG5cXG46cm9vdCB7XFxuICAtLWZvcmVncm91bmQtcmdiOiAwLCAwLCAwO1xcbiAgLS1iYWNrZ3JvdW5kLXN0YXJ0LXJnYjogMjE0LCAyMTksIDIyMDtcXG4gIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAyNTUsIDI1NSwgMjU1O1xcbn1cXG5cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuICA6cm9vdCB7XFxuICAgIC0tZm9yZWdyb3VuZC1yZ2I6IDI1NSwgMjU1LCAyNTU7XFxuICAgIC0tYmFja2dyb3VuZC1zdGFydC1yZ2I6IDAsIDAsIDA7XFxuICAgIC0tYmFja2dyb3VuZC1lbmQtcmdiOiAwLCAwLCAwO1xcbiAgfVxcbn1cXG5cXG5ib2R5IHtcXG4gIGNvbG9yOiByZ2IodmFyKC0tZm9yZWdyb3VuZC1yZ2IpKTtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXG4gICAgICB0byBib3R0b20sXFxuICAgICAgdHJhbnNwYXJlbnQsXFxuICAgICAgcmdiKHZhcigtLWJhY2tncm91bmQtZW5kLXJnYikpXFxuICAgIClcXG4gICAgcmdiKHZhcigtLWJhY2tncm91bmQtc3RhcnQtcmdiKSk7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qLyAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./src/pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./src/styles/globals.css":
/*!********************************!*\
  !*** ./src/styles/globals.css ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[8].oneOf[13].use[2]!./src/styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyx1TkFBMkc7QUFDN0gsMEJBQTBCLG1CQUFPLENBQUMscWZBQXVQOztBQUV6Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0scWZBQXVQO0FBQzdQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscWZBQXVQOztBQUVqUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3R5bGVzL2dsb2JhbHMuY3NzPzE1MDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzhdLm9uZU9mWzEzXS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0ub25lT2ZbMTNdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s4XS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./src/contexts/AuthContext.js":
/*!*************************************!*\
  !*** ./src/contexts/AuthContext.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: function() { return /* binding */ AuthContext; },\n/* harmony export */   \"default\": function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/fcl */ \"../../node_modules/@onflow/fcl/dist/fcl.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n// import { checkIsInitialized, IS_INITIALIZED } from \"../flow/scripts\";\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({});\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s1();\n    // Create a state variable to keep track of the currentUser\n    const [currentUser, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        loggedIn: false,\n        addr: undefined\n    });\n    // Create a state variable to represent if a user's account\n    // has been initialized or not\n    // const [isInitialized, setIsInitialized] = useState(false);\n    // Use FCL to subscribe to changes in the user (login, logout, etc)\n    // Tell FCL to call `setUser` and update our state variables\n    // if anything changes\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>_onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.currentUser.subscribe(setUser), []);\n    // If currentUser is set, i.e. user is logged in\n    // check whether their account is initialized or not\n    // useEffect(() => {\n    //   if (currentUser.addr) {\n    //     checkInit();\n    //   }\n    // }, [currentUser]);\n    // Helper function to log the user out of the dApp\n    const logOut = async ()=>{\n        _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.unauthenticate();\n        setUser({\n            loggedIn: false,\n            addr: undefined\n        });\n    };\n    // Helper function to log the user in to the dApp\n    // p.s. this feels even easier than RainbowKit, eh?\n    const logIn = ()=>{\n        _onflow_fcl__WEBPACK_IMPORTED_MODULE_1__.logIn();\n    };\n    // Use the `checkIsInitialized` script we wrote earlier\n    // and update the state variable as necessary\n    // const checkInit = async () => {\n    //   const isInit = await checkIsInitialized(currentUser.addr);\n    //   setIsInitialized(isInit);\n    // };\n    // Build the object of everything we want to expose through \n    // the context\n    const value = {\n        currentUser,\n        logOut,\n        logIn\n    };\n    // Return the Context Provider with the value set\n    // Render all children of the component inside of it\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\contexts\\\\AuthContext.js\",\n        lineNumber: 62,\n        columnNumber: 12\n    }, this);\n}\n_s1(AuthProvider, \"Ev2DadeV8F2jO9FfDWbkAI6wwYo=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGV4dHMvQXV0aENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNvQztBQUN2RSx3RUFBd0U7QUFFakUsTUFBTUssNEJBQWNKLG9EQUFhQSxDQUFDLENBQUMsR0FBRztBQUV0QyxNQUFNSyxVQUFVOztJQUFNSixPQUFBQSxpREFBVUEsQ0FBQ0c7QUFBVyxFQUFFO0dBQXhDQztBQUVFLFNBQVNDLGFBQWEsS0FBWTtRQUFaLEVBQUVDLFFBQVEsRUFBRSxHQUFaOztJQUVqQywyREFBMkQ7SUFDM0QsTUFBTSxDQUFDQyxhQUFhQyxRQUFRLEdBQUdOLCtDQUFRQSxDQUFDO1FBQ3RDTyxVQUFVO1FBQ1ZDLE1BQU1DO0lBQ1I7SUFDQSwyREFBMkQ7SUFDM0QsOEJBQThCO0lBQzlCLDZEQUE2RDtJQUU3RCxtRUFBbUU7SUFDbkUsNERBQTREO0lBQzVELHNCQUFzQjtJQUN0QlYsZ0RBQVNBLENBQUMsSUFBTUgsb0RBQWUsQ0FBQ2MsU0FBUyxDQUFDSixVQUFVLEVBQUU7SUFFdEQsZ0RBQWdEO0lBQ2hELG9EQUFvRDtJQUNwRCxvQkFBb0I7SUFDcEIsNEJBQTRCO0lBQzVCLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04scUJBQXFCO0lBRXJCLGtEQUFrRDtJQUNsRCxNQUFNSyxTQUFTO1FBQ2JmLHVEQUFrQjtRQUNsQlUsUUFBUTtZQUFFQyxVQUFVO1lBQU9DLE1BQU1DO1FBQVU7SUFDN0M7SUFFQSxpREFBaUQ7SUFDakQsbURBQW1EO0lBQ25ELE1BQU1JLFFBQVE7UUFDWmpCLDhDQUFTO0lBQ1g7SUFFQSx1REFBdUQ7SUFDdkQsNkNBQTZDO0lBQzdDLGtDQUFrQztJQUNsQywrREFBK0Q7SUFDL0QsOEJBQThCO0lBQzlCLEtBQUs7SUFFTCw0REFBNEQ7SUFDNUQsY0FBYztJQUNkLE1BQU1rQixRQUFRO1FBQ1pUO1FBQ0FNO1FBQ0FFO0lBQ0Y7SUFFQSxpREFBaUQ7SUFDakQsb0RBQW9EO0lBQ3BELHFCQUFPLDhEQUFDWixZQUFZYyxRQUFRO1FBQUNELE9BQU9BO2tCQUFRVjs7Ozs7O0FBQzlDO0lBdERzQkQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL0F1dGhDb250ZXh0LmpzPzc4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZmNsIGZyb20gXCJAb25mbG93L2ZjbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IGNoZWNrSXNJbml0aWFsaXplZCwgSVNfSU5JVElBTElaRUQgfSBmcm9tIFwiLi4vZmxvdy9zY3JpcHRzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCkgPT4gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgc3RhdGUgdmFyaWFibGUgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudFVzZXJcclxuICAgIGNvbnN0IFtjdXJyZW50VXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZSh7XHJcbiAgICAgIGxvZ2dlZEluOiBmYWxzZSxcclxuICAgICAgYWRkcjogdW5kZWZpbmVkLFxyXG4gICAgfSk7XHJcbiAgICAvLyBDcmVhdGUgYSBzdGF0ZSB2YXJpYWJsZSB0byByZXByZXNlbnQgaWYgYSB1c2VyJ3MgYWNjb3VudFxyXG4gICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb3Igbm90XHJcbiAgICAvLyBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgXHJcbiAgICAvLyBVc2UgRkNMIHRvIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSB1c2VyIChsb2dpbiwgbG9nb3V0LCBldGMpXHJcbiAgICAvLyBUZWxsIEZDTCB0byBjYWxsIGBzZXRVc2VyYCBhbmQgdXBkYXRlIG91ciBzdGF0ZSB2YXJpYWJsZXNcclxuICAgIC8vIGlmIGFueXRoaW5nIGNoYW5nZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiBmY2wuY3VycmVudFVzZXIuc3Vic2NyaWJlKHNldFVzZXIpLCBbXSk7XHJcbiAgXHJcbiAgICAvLyBJZiBjdXJyZW50VXNlciBpcyBzZXQsIGkuZS4gdXNlciBpcyBsb2dnZWQgaW5cclxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlaXIgYWNjb3VudCBpcyBpbml0aWFsaXplZCBvciBub3RcclxuICAgIC8vIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyAgIGlmIChjdXJyZW50VXNlci5hZGRyKSB7XHJcbiAgICAvLyAgICAgY2hlY2tJbml0KCk7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH0sIFtjdXJyZW50VXNlcl0pO1xyXG4gIFxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGxvZyB0aGUgdXNlciBvdXQgb2YgdGhlIGRBcHBcclxuICAgIGNvbnN0IGxvZ091dCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgZmNsLnVuYXV0aGVudGljYXRlKCk7XHJcbiAgICAgIHNldFVzZXIoeyBsb2dnZWRJbjogZmFsc2UsIGFkZHI6IHVuZGVmaW5lZCB9KTtcclxuICAgIH07XHJcbiAgXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gbG9nIHRoZSB1c2VyIGluIHRvIHRoZSBkQXBwXHJcbiAgICAvLyBwLnMuIHRoaXMgZmVlbHMgZXZlbiBlYXNpZXIgdGhhbiBSYWluYm93S2l0LCBlaD9cclxuICAgIGNvbnN0IGxvZ0luID0gKCkgPT4ge1xyXG4gICAgICBmY2wubG9nSW4oKTtcclxuICAgIH07XHJcbiAgXHJcbiAgICAvLyBVc2UgdGhlIGBjaGVja0lzSW5pdGlhbGl6ZWRgIHNjcmlwdCB3ZSB3cm90ZSBlYXJsaWVyXHJcbiAgICAvLyBhbmQgdXBkYXRlIHRoZSBzdGF0ZSB2YXJpYWJsZSBhcyBuZWNlc3NhcnlcclxuICAgIC8vIGNvbnN0IGNoZWNrSW5pdCA9IGFzeW5jICgpID0+IHtcclxuICAgIC8vICAgY29uc3QgaXNJbml0ID0gYXdhaXQgY2hlY2tJc0luaXRpYWxpemVkKGN1cnJlbnRVc2VyLmFkZHIpO1xyXG4gICAgLy8gICBzZXRJc0luaXRpYWxpemVkKGlzSW5pdCk7XHJcbiAgICAvLyB9O1xyXG4gIFxyXG4gICAgLy8gQnVpbGQgdGhlIG9iamVjdCBvZiBldmVyeXRoaW5nIHdlIHdhbnQgdG8gZXhwb3NlIHRocm91Z2ggXHJcbiAgICAvLyB0aGUgY29udGV4dFxyXG4gICAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICAgIGN1cnJlbnRVc2VyLFxyXG4gICAgICBsb2dPdXQsXHJcbiAgICAgIGxvZ0luLFxyXG4gICAgfTtcclxuICBcclxuICAgIC8vIFJldHVybiB0aGUgQ29udGV4dCBQcm92aWRlciB3aXRoIHRoZSB2YWx1ZSBzZXRcclxuICAgIC8vIFJlbmRlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudCBpbnNpZGUgb2YgaXRcclxuICAgIHJldHVybiA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT57Y2hpbGRyZW59PC9BdXRoQ29udGV4dC5Qcm92aWRlcj47XHJcbiAgfSJdLCJuYW1lcyI6WyJmY2wiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQXV0aENvbnRleHQiLCJ1c2VBdXRoIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50VXNlciIsInNldFVzZXIiLCJsb2dnZWRJbiIsImFkZHIiLCJ1bmRlZmluZWQiLCJzdWJzY3JpYmUiLCJsb2dPdXQiLCJ1bmF1dGhlbnRpY2F0ZSIsImxvZ0luIiwidmFsdWUiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/AuthContext.js\n"));

/***/ }),

/***/ "./src/pages/_app.js":
/*!***************************!*\
  !*** ./src/pages/_app.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contexts/AuthContext */ \"./src/contexts/AuthContext.js\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/styles/globals.css */ \"./src/styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction App(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n            ...pageProps\n        }, void 0, false, {\n            fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\pages\\\\_app.js\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\web3\\\\Flow\\\\FlowVo\\\\client\\\\flowvo\\\\src\\\\pages\\\\_app.js\",\n        lineNumber: 6,\n        columnNumber: 5\n    }, this);\n}\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1EO0FBQ3RCO0FBRWQsU0FBU0MsSUFBSSxLQUF3QjtRQUF4QixFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRSxHQUF4QjtJQUMxQixxQkFDRSw4REFBQ0gsNkRBQVlBO2tCQUNYLDRFQUFDRTtZQUFXLEdBQUdDLFNBQVM7Ozs7Ozs7Ozs7O0FBRzlCO0tBTndCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvX2FwcC5qcz84ZmRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBdXRoUHJvdmlkZXIgZnJvbSBcIi4uL2NvbnRleHRzL0F1dGhDb250ZXh0XCI7XG5pbXBvcnQgJ0Avc3R5bGVzL2dsb2JhbHMuY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gIHJldHVybiAoXG4gICAgPEF1dGhQcm92aWRlcj5cbiAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cbiAgICA8L0F1dGhQcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkF1dGhQcm92aWRlciIsIkFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/_app.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/config/dist/config.module.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@onflow/config/dist/config.module.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearConfig: function() { return /* binding */ clearConfig; },\n/* harmony export */   config: function() { return /* binding */ config; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-actor */ \"../../node_modules/@onflow/util-actor/dist/actor.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/util-logger */ \"../../node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-invariant */ \"../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n\n\n\n\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\n\n// Inject config into logger to break circular dependency\n_onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.setConfig(config);\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\n(0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.spawn)(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.subscriber)(NAME, () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.spawn)(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_0__.send)(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn : _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.error\n    });\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isEmulator, `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`);\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_1__.LEVELS.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n\n//# sourceMappingURL=config.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvY29uZmlnL2Rpc3QvY29uZmlnLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUN2QztBQUNLOztBQUVuRDtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxnR0FBZ0csZUFBZTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUSw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Zy9kaXN0L2NvbmZpZy5tb2R1bGUuanM/MGVkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcGF3biwgU1VCU0NSSUJFLCBVTlNVQlNDUklCRSwgc2VuZCwgc3Vic2NyaWJlciB9IGZyb20gJ0BvbmZsb3cvdXRpbC1hY3Rvcic7XG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnQG9uZmxvdy91dGlsLWxvZ2dlcic7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdAb25mbG93L3V0aWwtaW52YXJpYW50JztcblxuY29uc3QgcGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiB2ID0+IHtcbiAgICByZXR1cm4gZnVuY3MucmVkdWNlKChyZXMsIGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiBmdW5jKHJlcyk7XG4gICAgfSwgdik7XG4gIH07XG59O1xuXG4vKioqXG4gKiBNZXJnZSBtdWx0aXBsZSBmdW5jdGlvbnMgcmV0dXJuaW5nIG9iamVjdHMgaW50byBvbmUgb2JqZWN0LlxuICogQHBhcmFtIHsuLi5mdW5jdGlvbigqKTogb2JqZWN0fSBmdW5jcyAtIEZ1bmN0aW9ucyB0byBtZXJnZVxuICogQHJldHVybiB7b2JqZWN0fSAtIE1lcmdlZCBvYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIC4uLmZ1bmModilcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gT2JqZWN0IGNoZWNrXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIG9iamVjdCBzdGF0dXNcbiAqL1xuY29uc3QgaXNPYmplY3QgPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHsuLi5vYmplY3RbXX0gc291cmNlcyAtIFNvdXJjZSBvYmplY3RzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBvYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VEZWVwID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHNvdXJjZXNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIGlmICghdGFyZ2V0W2tleV0pIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG4gICAgICAgICAgW2tleV06IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG4gICAgICAgICAgW2tleV06IHNvdXJjZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VEZWVwKHRhcmdldCwgLi4uc291cmNlcyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWVwIG1lcmdlIG11bHRpcGxlIEZsb3cgSlNPTi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE1lcmdlZCBGbG93IEpTT05cbiAqL1xuY29uc3QgbWVyZ2VGbG93SlNPTnMgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IG1lcmdlRGVlcCh7fSwgLi4udmFsdWUpIDogdmFsdWU7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZpbHRlciBvdXQgY29udHJhY3RzIHNlY3Rpb24gb2YgZmxvdy5qc29uLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IG9iaiAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0cyBzZWN0aW9uIG9mIEZsb3cgSlNPTlxuICovXG5jb25zdCBmaWx0ZXJDb250cmFjdHMgPSBvYmogPT4gb2JqLmNvbnRyYWN0cyA/IG9iai5jb250cmFjdHMgOiB7fTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2F0aGVycyBjb250cmFjdCBhZGRyZXNzZXMgYnkgbmV0d29ya1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGdhdGhlciBhZGRyZXNzZXMgZm9yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0IG5hbWVzIGJ5IGFkZHJlc3NlcyBtYXBwaW5nIGUuZyB7IFwiSGVsbG9Xb3JsZFwiOiBcIjB4MTIzXCIgfVxuICovXG5jb25zdCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzID0gbmV0d29yayA9PiBjb250cmFjdHMgPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY29udHJhY3RzKS5yZWR1Y2UoKGMsIF9yZWYpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJhY3RBbGlhcyA9IHZhbHVlPy5hbGlhc2VzPy5bbmV0d29ya107XG4gICAgaWYgKG5ldHdvcmtDb250cmFjdEFsaWFzKSB7XG4gICAgICBjW2tleV0gPSBuZXR3b3JrQ29udHJhY3RBbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sIHt9KTtcbn07XG5jb25zdCBtYXBEZXBsb3ltZW50c1RvTmV0d29ya0FkZHJlc3MgPSBuZXR3b3JrID0+IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBkZXBsb3ltZW50cyA9IHt9LFxuICAgIGFjY291bnRzID0ge31cbiAgfSA9IF9yZWYyO1xuICBjb25zdCBuZXR3b3JrRGVwbG95bWVudCA9IGRlcGxveW1lbnRzPy5bbmV0d29ya107XG4gIGlmICghbmV0d29ya0RlcGxveW1lbnQpIHJldHVybiB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG5ldHdvcmtEZXBsb3ltZW50KS5yZWR1Y2UoKGMsIF9yZWYzKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYzO1xuICAgIC8vIFJlc29sdmUgYWNjb3VudCBhZGRyZXNzXG4gICAgY29uc3QgYWNjb3VudEFkZHJlc3MgPSBhY2NvdW50c1trZXldPy5hZGRyZXNzO1xuICAgIGlmICghYWNjb3VudEFkZHJlc3MpIHJldHVybiBjO1xuXG4gICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBhc3NpZ25pbmcgdGhlIGFkZHJlc3MgdG8gdGhlIGNvbnRyYWN0IG5hbWUuXG4gICAgcmV0dXJuIHZhbHVlLnJlZHVjZSgoYywgY29udHJhY3QpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIFtjb250cmFjdF06IGFjY291bnRBZGRyZXNzXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBpbiBmbG93Lmpzb24gZmlsZXMgYW5kIHJldHVybiBjb250cmFjdCB0byBhZGRyZXNzIG1hcHBpbmcgYnkgbmV0d29ya1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGpzb25zIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBnYXRoZXIgYWRkcmVzc2VzIGZvclxuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdCBuYW1lcyBieSBhZGRyZXNzZXMgbWFwcGluZyBlLmcgeyBcIkhlbGxvV29ybGRcIjogXCIweDEyM1wiIH1cbiAqL1xuY29uc3QgZ2V0Q29udHJhY3RzID0gKGpzb25zLCBuZXR3b3JrKSA9PiB7XG4gIHJldHVybiBwaXBlKG1lcmdlRmxvd0pTT05zLCBtZXJnZVBpcGUobWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzKG5ldHdvcmspLCBwaXBlKGZpbHRlckNvbnRyYWN0cywgbWFwQ29udHJhY3RBbGlhc2VzVG9OZXR3b3JrQWRkcmVzcyhuZXR3b3JrKSkpKShqc29ucyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgc3RyaW5nIGlzIGhleGlkZWNpbWFsXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBJcyBoZXhpZGVjaW1hbCBzdGF0dXNcbiAqL1xuY29uc3QgaXNIZXhpZGVjaW1hbCA9IHN0ciA9PiB7XG4gIC8vIENoZWNrIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIC9eWzAtOUEtRmEtZl0rJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGZsb3cuanNvbiBmaWxlIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBmbG93SlNPTiAtIEZsb3cgSlNPTlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgaGFzUHJpdmF0ZUtleXMgPSBmbG93SlNPTiA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhmbG93SlNPTj8uYWNjb3VudHMpLnJlZHVjZSgoaGFzUHJpdmF0ZUtleSwgX3JlZjQpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjQ7XG4gICAgaWYgKGhhc1ByaXZhdGVLZXkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB2YWx1ZT8uaGFzT3duUHJvcGVydHkoXCJrZXlcIikgJiYgaXNIZXhpZGVjaW1hbCh2YWx1ZT8ua2V5KTtcbiAgfSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjaGVja3MgZm9yIHByaXZhdGUga2V5c1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHZhbHVlIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhhcyBwcml2YXRlIGtleXMgc3RhdHVzXG4gKi9cbmNvbnN0IGFueUhhc1ByaXZhdGVLZXlzID0gdmFsdWUgPT4ge1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSByZXR1cm4gaGFzUHJpdmF0ZUtleXModmFsdWUpO1xuICByZXR1cm4gdmFsdWUuc29tZShoYXNQcml2YXRlS2V5cyk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGb3JtYXQgbmV0d29yayB0byBhbHdheXMgYmUgJ2VtdWxhdG9yJywgJ3Rlc3RuZXQnLCBvciAnbWFpbm5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBmb3JtYXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRm9ybWF0dGVkIG5ldHdvcmsgbmFtZSAoZWl0aGVyICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnKVxuICovXG5jb25zdCBjbGVhbk5ldHdvcmsgPSBuZXR3b3JrID0+IG5ldHdvcms/LnRvTG93ZXJDYXNlKCkgPT09IFwibG9jYWxcIiA/IFwiZW11bGF0b3JcIiA6IG5ldHdvcms/LnRvTG93ZXJDYXNlKCk7XG5cbi8vIEluamVjdCBjb25maWcgaW50byBsb2dnZXIgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeVxubG9nZ2VyLnNldENvbmZpZyhjb25maWcpO1xuY29uc3QgTkFNRSA9IFwiY29uZmlnXCI7XG5jb25zdCBQVVQgPSBcIlBVVF9DT05GSUdcIjtcbmNvbnN0IEdFVCA9IFwiR0VUX0NPTkZJR1wiO1xuY29uc3QgR0VUX0FMTCA9IFwiR0VUX0FMTF9DT05GSUdcIjtcbmNvbnN0IFVQREFURSA9IFwiVVBEQVRFX0NPTkZJR1wiO1xuY29uc3QgREVMRVRFID0gXCJERUxFVEVfQ09ORklHXCI7XG5jb25zdCBDTEVBUiA9IFwiQ0xFQVJfQ09ORklHXCI7XG5jb25zdCBXSEVSRSA9IFwiV0hFUkVfQ09ORklHXCI7XG5jb25zdCBVUERBVEVEID0gXCJDT05GSUcvVVBEQVRFRFwiO1xuY29uc3QgaWRlbnRpdHkgPSB2ID0+IHY7XG5jb25zdCBIQU5ETEVSUyA9IHtcbiAgW1BVVF06IChjdHgsIF9sZXR0ZXIsIF9yZWYpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9wdXQuXCIpO1xuICAgIGN0eC5wdXQoa2V5LCB2YWx1ZSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0dFVF06IChjdHgsIGxldHRlciwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZ2V0XCIpO1xuICAgIGxldHRlci5yZXBseShjdHguZ2V0KGtleSwgZmFsbGJhY2spKTtcbiAgfSxcbiAgW0dFVF9BTExdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXR0ZXIucmVwbHkoe1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVUERBVEVdOiAoY3R4LCBsZXR0ZXIsIF9yZWYzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZuXG4gICAgfSA9IF9yZWYzO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL3VwZGF0ZVwiKTtcbiAgICBjdHgudXBkYXRlKGtleSwgZm4gfHwgaWRlbnRpdHkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtERUxFVEVdOiAoY3R4LCBsZXR0ZXIsIF9yZWY0KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmNDtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9kZWxldGVcIik7XG4gICAgY3R4LmRlbGV0ZShrZXkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtDTEVBUl06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoY3R4LmFsbCgpKTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykgY3R4LmRlbGV0ZShrZXkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtXSEVSRV06IChjdHgsIGxldHRlciwgX3JlZjUpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0dGVyblxuICAgIH0gPSBfcmVmNTtcbiAgICBpZiAocGF0dGVybiA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdwYXR0ZXJuJyBmb3IgY29uZmlnL3doZXJlXCIpO1xuICAgIGxldHRlci5yZXBseShjdHgud2hlcmUocGF0dGVybikpO1xuICB9LFxuICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVU5TVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICB9XG59O1xuc3Bhd24oSEFORExFUlMsIE5BTUUpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBZGRzIGEga2V5LXZhbHVlIHBhaXIgdG8gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFkZFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgc2VuZChOQU1FLCBQVVQsIHtcbiAgICBrZXksXG4gICAgdmFsdWVcbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyBhIGtleS12YWx1ZSBwYWlyIHdpdGggYSBmYWxsYmFjayBmcm9tIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHsqfSBbZmFsbGJhY2tdIC0gVGhlIGZhbGxiYWNrIHZhbHVlIHRvIHJldHVybiBpZiBrZXkgaXMgbm90IGZvdW5kXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBUaGUgdmFsdWUgZm91bmQgYXQga2V5IG9yIGZhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGdldChrZXksIGZhbGxiYWNrKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIEdFVCwge1xuICAgIGtleSxcbiAgICBmYWxsYmFja1xuICB9LCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGZpcnN0IG5vbiBudWxsIGNvbmZpZyB2YWx1ZSBvciB0aGUgZmFsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nW119IHdhbnRzIC0gVGhlIGtleXMgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHsqfSBmYWxsYmFjayAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5hc3luYyBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgbGV0IHdhbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIGlmICghd2FudHMubGVuZ3RoKSByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IFtoZWFkLCAuLi5yZXN0XSA9IHdhbnRzO1xuICBjb25zdCByZXQgPSBhd2FpdCBnZXQoaGVhZCk7XG4gIGlmIChyZXQgPT0gbnVsbCkgcmV0dXJuIGZpcnN0KHJlc3QsIGZhbGxiYWNrKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgY3VycmVudCBjb25maWdcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbCgpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgR0VUX0FMTCwgbnVsbCwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIHZhbHVlIHdpdGhcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShrZXkpIHtcbiAgbGV0IGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZGVudGl0eTtcbiAgc2VuZChOQU1FLCBVUERBVEUsIHtcbiAgICBrZXksXG4gICAgZm5cbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVsZXRlcyBhIGtleS12YWx1ZSBwYWlyIGZyb20gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gZGVsZXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICBzZW5kKE5BTUUsIERFTEVURSwge1xuICAgIGtleVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZygpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBjb25maWcgYmFzZWQgb24gYSBwYXR0ZXJuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIGtleXMgYWdhaW5zdFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgc3Vic2V0IG9mIHRoZSBjb25maWdcbiAqL1xuZnVuY3Rpb24gd2hlcmUocGF0dGVybikge1xuICByZXR1cm4gc2VuZChOQU1FLCBXSEVSRSwge1xuICAgIHBhdHRlcm5cbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTdWJzY3JpYmVzIHRvIGNvbmZpZyB1cGRhdGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gY29uZmlnIGlzIHVwZGF0ZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBUaGUgdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gIHJldHVybiBzdWJzY3JpYmVyKE5BTUUsICgpID0+IHNwYXduKEhBTkRMRVJTLCBOQU1FKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDbGVhcnMgdGhlIGNvbmZpZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNsZWFyQ29uZmlnKCkge1xuICByZXR1cm4gc2VuZChOQU1FLCBDTEVBUik7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgY29uZmlnIHRvIGEgcHJldmlvdXMgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRDb25maWcgLSBUaGUgcHJldmlvdXMgY29uZmlnIHN0YXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiByZXNldENvbmZpZyhvbGRDb25maWcpIHtcbiAgcmV0dXJuIGNsZWFyQ29uZmlnKCkudGhlbihjb25maWcob2xkQ29uZmlnKSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2VzIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNyZWF0ZXMgY29udHJhY3QgcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSAtIFRoZSBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZChkYXRhKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBnZXQoXCJmbG93Lm5ldHdvcmtcIik7XG4gIGNvbnN0IGNsZWFuZWROZXR3b3JrID0gY2xlYW5OZXR3b3JrKG5ldHdvcmspO1xuICBjb25zdCB7XG4gICAgZmxvd0pTT05cbiAgfSA9IGRhdGE7XG4gIGludmFyaWFudChCb29sZWFuKGZsb3dKU09OKSwgXCJjb25maWcubG9hZCAtLSAnZmxvd0pTT04nIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50KGNsZWFuZWROZXR3b3JrLCBgRmxvdyBOZXR3b3JrIFJlcXVpcmVkIC0tIEluIG9yZGVyIGZvciBGQ0wgdG8gbG9hZCB5b3VyIGNvbnRyYWN0cyBwbGVhc2UgZGVmaW5lIFwiZmxvdy5uZXR3b3JrXCIgdG8gXCJlbXVsYXRvclwiLCBcImxvY2FsXCIsIFwidGVzdG5ldFwiLCBvciBcIm1haW5uZXRcIiBpbiB5b3VyIGNvbmZpZy4gU2VlIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmZsb3cuY29tL3Rvb2xzL2ZjbC1qcy9yZWZlcmVuY2UvY29uZmlndXJlLWZjbGApO1xuICBpZiAoYW55SGFzUHJpdmF0ZUtleXMoZmxvd0pTT04pKSB7XG4gICAgY29uc3QgaXNFbXVsYXRvciA9IGNsZWFuZWROZXR3b3JrID09PSBcImVtdWxhdG9yXCI7XG4gICAgbG9nZ2VyLmxvZyh7XG4gICAgICB0aXRsZTogXCJQcml2YXRlIEtleXMgRGV0ZWN0ZWRcIixcbiAgICAgIG1lc3NhZ2U6IGBQcml2YXRlIGtleXMgc2hvdWxkIGJlIHN0b3JlZCBpbiBhIHNlcGFyYXRlIGZsb3cuanNvbiBmaWxlIGZvciBzZWN1cml0eS4gU2VlIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmZsb3cuY29tL3Rvb2xzL2Zsb3ctY2xpL3NlY3VyaXR5YCxcbiAgICAgIGxldmVsOiBpc0VtdWxhdG9yID8gbG9nZ2VyLkxFVkVMUy53YXJuIDogbG9nZ2VyLkxFVkVMUy5lcnJvclxuICAgIH0pO1xuICAgIGludmFyaWFudChpc0VtdWxhdG9yLCBgUHJpdmF0ZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBmbG93Lmpzb24gZmlsZSBmb3Igc2VjdXJpdHkuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mbG93LWNsaS9zZWN1cml0eWApO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGdldENvbnRyYWN0cyhmbG93SlNPTiwgY2xlYW5lZE5ldHdvcmspKSkge1xuICAgIGNvbnN0IGNvbnRyYWN0Q29uZmlnS2V5ID0gYDB4JHtrZXl9YDtcbiAgICBjb25zdCBleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ID0gYXdhaXQgZ2V0KGNvbnRyYWN0Q29uZmlnS2V5KTtcbiAgICBpZiAoZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAmJiBleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ICE9PSB2YWx1ZSkge1xuICAgICAgbG9nZ2VyLmxvZyh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBsb2dnZXIuTEVWRUxTLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoY29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtQ29udHJhY3RDb25maWdLZXkgPSBgc3lzdGVtLmNvbnRyYWN0cy4ke2tleX1gO1xuICAgIGNvbnN0IHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSA9IGF3YWl0IGdldChzeXN0ZW1Db250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAmJiBzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBsb2dnZXIubG9nKHtcbiAgICAgICAgdGl0bGU6IFwiQ29udHJhY3QgUGxhY2Vob2xkZXIgQ29uZmxpY3QgRGV0ZWN0ZWRcIixcbiAgICAgICAgbWVzc2FnZTogYEEgZ2VuZXJhdGVkIGNvbnRyYWN0IHBsYWNlaG9sZGVyIGZyb20gY29uZmlnLmxvYWQgY29uZmxpY3RzIHdpdGggYSBwbGFjZWhvbGRlciB5b3UndmUgc2V0IG1hbnVhbGx5IGluIGNvbmZpZyBoYXZlIHRoZSBzYW1lIG5hbWUuYCxcbiAgICAgICAgbGV2ZWw6IGxvZ2dlci5MRVZFTFMud2FyblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dChzeXN0ZW1Db250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1yZXR1cm5zXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXSAtIFRoZSB2YWx1ZXMgdG8gc2V0XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZyh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLm1hcChkID0+IHB1dChkLCB2YWx1ZXNbZF0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHB1dCxcbiAgICBnZXQsXG4gICAgYWxsLFxuICAgIGZpcnN0LFxuICAgIHVwZGF0ZSxcbiAgICBkZWxldGU6IF9kZWxldGUsXG4gICAgd2hlcmUsXG4gICAgc3Vic2NyaWJlLFxuICAgIG92ZXJsb2FkLFxuICAgIGxvYWRcbiAgfTtcbn1cbmNvbmZpZy5wdXQgPSBwdXQ7XG5jb25maWcuZ2V0ID0gZ2V0O1xuY29uZmlnLmFsbCA9IGFsbDtcbmNvbmZpZy5maXJzdCA9IGZpcnN0O1xuY29uZmlnLnVwZGF0ZSA9IHVwZGF0ZTtcbmNvbmZpZy5kZWxldGUgPSBfZGVsZXRlO1xuY29uZmlnLndoZXJlID0gd2hlcmU7XG5jb25maWcuc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuY29uZmlnLm92ZXJsb2FkID0gb3ZlcmxvYWQ7XG5jb25maWcubG9hZCA9IGxvYWQ7XG5jb25zdCBub29wID0gdiA9PiB2O1xuZnVuY3Rpb24gb3ZlcmxvYWQoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG9sZENvbmZpZyA9IGF3YWl0IGFsbCgpO1xuICAgIHRyeSB7XG4gICAgICBjb25maWcob3B0cyk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soYXdhaXQgYWxsKCkpO1xuICAgICAgYXdhaXQgcmVzZXRDb25maWcob2xkQ29uZmlnKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgcmVzZXRDb25maWcob2xkQ29uZmlnKTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgY2xlYXJDb25maWcsIGNvbmZpZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/config/dist/config.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/fcl/dist/fcl.module.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@onflow/fcl/dist/fcl.module.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppUtils: function() { return /* binding */ index$1; },\n/* harmony export */   InteractionTemplateUtils: function() { return /* binding */ index; },\n/* harmony export */   TestUtils: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.TestUtils; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   WalletUtils: function() { return /* binding */ index$2; },\n/* harmony export */   account: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.account; },\n/* harmony export */   arg: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg; },\n/* harmony export */   args: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args; },\n/* harmony export */   atBlockHeight: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockHeight; },\n/* harmony export */   atBlockId: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockId; },\n/* harmony export */   authenticate: function() { return /* binding */ authenticate; },\n/* harmony export */   authorization: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorization; },\n/* harmony export */   authorizations: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorizations; },\n/* harmony export */   authz: function() { return /* binding */ authz; },\n/* harmony export */   block: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block; },\n/* harmony export */   build: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.build; },\n/* harmony export */   cadence: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__.template; },\n/* harmony export */   cdc: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__.template; },\n/* harmony export */   config: function() { return /* reexport safe */ _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config; },\n/* harmony export */   createSignableVoucher: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.createSignableVoucher; },\n/* harmony export */   currentUser: function() { return /* binding */ currentUser; },\n/* harmony export */   decode: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode; },\n/* harmony export */   discovery: function() { return /* binding */ discovery; },\n/* harmony export */   display: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.display; },\n/* harmony export */   events: function() { return /* binding */ events; },\n/* harmony export */   getAccount: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getAccount; },\n/* harmony export */   getBlock: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getBlock; },\n/* harmony export */   getBlockHeader: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getBlockHeader; },\n/* harmony export */   getChainId: function() { return /* binding */ getChainId; },\n/* harmony export */   getCollection: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getCollection; },\n/* harmony export */   getEvents: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEvents; },\n/* harmony export */   getEventsAtBlockHeightRange: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockHeightRange; },\n/* harmony export */   getEventsAtBlockIds: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockIds; },\n/* harmony export */   getNetworkParameters: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getNetworkParameters; },\n/* harmony export */   getTransaction: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransaction; },\n/* harmony export */   getTransactionStatus: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransactionStatus; },\n/* harmony export */   invariant: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant; },\n/* harmony export */   isBad: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.isBad; },\n/* harmony export */   isOk: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.isOk; },\n/* harmony export */   limit: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit; },\n/* harmony export */   logIn: function() { return /* binding */ logIn; },\n/* harmony export */   mutate: function() { return /* binding */ mutate; },\n/* harmony export */   param: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.param; },\n/* harmony export */   params: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.params; },\n/* harmony export */   payer: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.payer; },\n/* harmony export */   ping: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.ping; },\n/* harmony export */   pipe: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.pipe; },\n/* harmony export */   pluginRegistry: function() { return /* binding */ pluginRegistry; },\n/* harmony export */   proposer: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.proposer; },\n/* harmony export */   query: function() { return /* binding */ query; },\n/* harmony export */   reauthenticate: function() { return /* binding */ reauthenticate; },\n/* harmony export */   ref: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   sansPrefix: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix; },\n/* harmony export */   script: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.script; },\n/* harmony export */   send: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   t: function() { return /* binding */ t; },\n/* harmony export */   transaction: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.transaction; },\n/* harmony export */   tx: function() { return /* binding */ transaction; },\n/* harmony export */   unauthenticate: function() { return /* binding */ unauthenticate; },\n/* harmony export */   validator: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.validator; },\n/* harmony export */   verifyUserSignatures: function() { return /* binding */ verifyUserSignatures; },\n/* harmony export */   voucherIntercept: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.voucherIntercept; },\n/* harmony export */   voucherToTxId: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.voucherToTxId; },\n/* harmony export */   why: function() { return /* reexport safe */ _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.why; },\n/* harmony export */   withPrefix: function() { return /* reexport safe */ _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix; }\n/* harmony export */ });\n/* harmony import */ var _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/sdk */ \"../../node_modules/@onflow/sdk/dist/sdk.module.js\");\n/* harmony import */ var _onflow_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/types */ \"../../node_modules/@onflow/types/dist/types.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-invariant */ \"../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cross-fetch */ \"../../node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _onflow_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/config */ \"../../node_modules/@onflow/config/dist/config.module.js\");\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @onflow/util-address */ \"../../node_modules/@onflow/util-address/dist/util-address.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @onflow/util-logger */ \"../../node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @onflow/rlp */ \"../../node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @onflow/util-actor */ \"../../node_modules/@onflow/util-actor/dist/actor.module.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\");\n/* harmony import */ var _onflow_util_template__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @onflow/util-template */ \"../../node_modules/@onflow/util-template/dist/template.module.js\");\n/* harmony import */ var _onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @onflow/util-uid */ \"../../node_modules/@onflow/util-uid/dist/util-uid.module.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"1.6.0\" ;\n\nconst is = type => d => typeof d === type;\nconst isRequired = d => d != null;\nconst isObject = is(\"object\");\nconst isString = is(\"string\");\nconst isFunc = is(\"function\");\nconst isNumber = is(\"number\");\n\nfunction normalizeArgs(ax) {\n  if (isFunc(ax)) return ax(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg, _onflow_types__WEBPACK_IMPORTED_MODULE_1__);\n  return [];\n}\n\nasync function httpDocumentResolver(_ref) {\n  let {\n    url\n  } = _ref;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  let res;\n  try {\n    res = await cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(url);\n  } catch (e) {\n    throw new Error(\"httpDocumentResolver Error: Failed to retrieve document.\");\n  }\n  let document = res.ok ? await res.json() : null;\n  return document;\n}\nconst DOCUMENT_RESOLVERS = new Map([[\"http\", httpDocumentResolver], [\"https\", httpDocumentResolver]]);\nasync function retrieve(_ref2) {\n  let {\n    url\n  } = _ref2;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof url === \"string\", \"retrieve({ url }) -- url must be a string\");\n  const documentResolversFromConfig = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)().where(/^document\\.resolver\\./);\n  Object.keys(documentResolversFromConfig).map(key => {\n    const resolverFromConfig = documentResolversFromConfig[key];\n    const resolverProtocol = key.replace(/^document\\.resolver\\./, \"\");\n    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);\n  });\n  const urlParts = /^(.*):\\/\\/([A-Za-z0-9\\-\\.]+)(:[0-9]+)?(.*)$/.exec(url);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(urlParts, \"Failed to parse URL\");\n  const protocol = urlParts[1];\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(urlParts, \"Failed to parse URL protocol\");\n  const resolver = DOCUMENT_RESOLVERS.get(protocol);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(resolver, `No resolver found for protcol=${protocol}`);\n  let document = await resolver({\n    url\n  });\n  return document;\n}\n\nfunction normalizeInteractionTemplate(template) {\n  if (template == null) return null;\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      return template;\n    default:\n      throw new Error(\"normalizeInteractionTemplate Error: Invalid InteractionTemplate\");\n  }\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n * \n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {string} - Cadence\n */\nfunction deriveCadenceByNetwork(_ref) {\n  let {\n    network,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(network != undefined, \"deriveCadenceByNetwork({ network }) -- network must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof network === \"string\", \"deriveCadenceByNetwork({ network }) -- network must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let networkDependencies = Object.keys(template?.data?.dependencies).map(dependencyPlaceholder => {\n        let dependencyNetworkContracts = Object.values(template?.data?.dependencies?.[dependencyPlaceholder]);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyNetworkContracts, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyNetworkContracts.length === 0, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        let dependencyContract = dependencyNetworkContracts[0];\n        let dependencyContractForNetwork = dependencyContract?.[network];\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(dependencyContractForNetwork, `deriveCadenceByNetwork -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);\n        return [dependencyPlaceholder, dependencyContractForNetwork.address];\n      });\n      return networkDependencies.reduce((cadence, _ref2) => {\n        let [placeholder, address] = _ref2;\n        const regex = new RegExp(\"(\\\\b\" + placeholder + \"\\\\b)\", \"g\");\n        return cadence.replace(regex, address);\n      }, template.data.cadence);\n    default:\n      throw new Error(\"deriveCadenceByNetwork Error: Unsupported template version\");\n  }\n}\n\nasync function fetchChainId() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const response = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getNetworkParameters()], opts).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n  return response.chainId;\n}\n\n// Cache of chainId promises for each access node value\n// key: access node, value: chainId promise\nlet chainIdCache = {};\nlet hasWarnedEnv = false;\n\n/**\n * @description\n * Gets the chain ID if its set, otherwise gets the chain ID from the access node\n *\n * @param {object} opts - Optional parameters\n * @returns {Promise<string>} The chain ID of the access node\n * @throws {Error} If the chain ID is not found\n *\n * @example\n * // returns \"testnet\"\n * getChainId()\n */\nasync function getChainId() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let flowNetworkCfg = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"flow.network\");\n  let envCfg = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"env\");\n  if (envCfg && !hasWarnedEnv) {\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log.deprecate({\n      pkg: \"FCL\",\n      subject: 'Using the \"env\" configuration key for specifying the flow network',\n      message: \"Configuring to specify flow network is no longer required\",\n      transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key\"\n    });\n    hasWarnedEnv = true;\n  }\n  const accessNode = opts.node || (await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"accessNode.api\"));\n  if (!accessNode) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg;\n    } else if (envCfg) {\n      return envCfg;\n    }\n    throw new Error(`Either the \"accessNode.api\" config key or opts.node must be set`);\n  }\n\n  // Try using cached chainId first if it exists and access node is the same\n  if (chainIdCache[accessNode]) {\n    try {\n      return await chainIdCache[accessNode];\n    } catch {}\n  }\n\n  // If no cached chainId, value is stale, or last attempt failed, try getting chainId from access node\n  // Check if another getChainId() call has already started a new promise, if not, start a new one\n  // There may have been concurrent calls to getChainId() while the first call was waiting for the response\n  if (!chainIdCache[accessNode]) {\n    chainIdCache[accessNode] = fetchChainId(opts).catch(error => {\n      // If there was an error, reset the promise so that the next call will try again\n      chainIdCache[accessNode] = null;\n      throw error;\n    });\n  }\n\n  // Use newly created promise\n  try {\n    return await chainIdCache[accessNode];\n  } catch (e) {\n    // Fall back to deprecated flow.network and env config keys\n    // This probably should have been done before trying to fetch the chainId from the access node\n    // However, this was the behaviour with the initial implementation of getChainId()\n    if (flowNetworkCfg) {\n      return flowNetworkCfg;\n    } else if (envCfg) {\n      return envCfg;\n    }\n    throw new Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`);\n  }\n}\n\n/**\n * @description\n * Watches the config for changes to access node and updates the chain id accordingly\n *\n * @returns {Function} A function that unsubscribes the listener\n *\n */\nfunction watchForChainIdChanges() {\n  return _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.subscribe(() => {\n    // Call getChainId to update the chainId cache if access node has changed\n    getChainId({\n      enableRequestLogging: false\n    }).catch(() => {});\n  });\n}\n\nfunction isAndroid() {\n  return typeof navigator !== \"undefined\" && /android/i.test(navigator.userAgent);\n}\nfunction isSmallIOS() {\n  return typeof navigator !== \"undefined\" && /iPhone|iPod/.test(navigator.userAgent);\n}\nfunction isLargeIOS() {\n  return typeof navigator !== \"undefined\" && /iPad/.test(navigator.userAgent);\n}\nfunction isIOS() {\n  return isSmallIOS() || isLargeIOS();\n}\nfunction isMobile() {\n  return isAndroid() || isIOS();\n}\n\nasync function deriveDependencies() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const template = opts.template;\n  const network = await getChainId(opts);\n  const derivedDependencies = {};\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      const dependencyPlaceholderKeys = Object.keys(template?.data?.dependencies);\n      for (let dependencyPlaceholderKey of dependencyPlaceholderKeys) {\n        let dependencyPlaceholder = template?.data?.dependencies[dependencyPlaceholderKey];\n        const dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependencyPlaceholderContractsKeys.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${dependencyPlaceholderKey}`);\n        const dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];\n        const dependency = dependencyPlaceholderContract[network];\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependency, `FCL configureDependencies Error: No dependency information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(dependency?.address, `FCL configureDependencies Error: No address information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        derivedDependencies[dependencyPlaceholderKey] = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(dependency?.address);\n      }\n      return derivedDependencies;\n    default:\n      throw new Error(\"FCL configureDependencies Error: Unsupported template version\");\n  }\n}\n\nasync function prepTemplateOpts(opts) {\n  if (isString(opts?.template)) {\n    opts.template = await retrieve({\n      url: opts?.template\n    });\n  }\n  let dependencies = {};\n  if (opts?.template) {\n    opts.template = normalizeInteractionTemplate(opts?.template);\n    dependencies = await deriveDependencies({\n      template: opts.template\n    });\n  }\n  const cadence = opts.cadence || deriveCadenceByNetwork({\n    template: opts.template,\n    network: await getChainId(opts)\n  });\n  opts.cadence = cadence;\n  opts.dependencies = dependencies;\n  return opts;\n}\n\nasync function pre(type, opts) {\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(opts), `${type}(opts) -- opts is required`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isObject(opts), `${type}(opts) -- opts must be an object`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);\n  // // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().get(\"accessNode.api\"), `${type}(opts) -- Required value for \"accessNode.api\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`);\n}\nasync function preMutate(opts) {\n  return pre(\"mutate\", opts);\n}\nasync function preQuery(opts) {\n  return pre(\"query\", opts);\n}\n\n/**\n * @description\n * Allows you to submit scripts to query the blockchain.\n *\n *  @param {object} opts - Query Options and configuration\n *  @param {string} opts.cadence - Cadence Script used to query Flow\n *  @param {import(\"../fcl\").ArgsFn} [opts.args] - Arguments passed to cadence script\n *  @param {object} [opts.template] - Interaction Template for a script\n *  @param {number} [opts.limit]   - Compute Limit for Query\n *  @returns {Promise}\n *\n *  @example\n *    const cadence = `\n *      cadence: `\n *        pub fun main(a: Int, b: Int, c: Address): Int {\n *          log(c)\n *          return a + b\n *        }\n *    `.trim()\n *\n *    const args = (arg, t) => [\n *      arg(5, t.Int),\n *      arg(7, t.Int),\n *      arg(\"0xb2db43ad6bc345fec9\", t.Address),\n *    ]\n *\n *    await query({ cadence, args })\n */\nasync function query() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  await preQuery(opts);\n  opts = await prepTemplateOpts(opts);\n  return _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().overload(opts.dependencies || {}, async () =>\n  // prettier-ignore\n  _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.script(opts.cadence), _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === \"number\" && _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit(opts.limit)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode));\n}\n\nconst FCL_REDIRECT_URL_PARAM_NAME = 'fcl_redirect_url';\nconst FCL_RESPONSE_PARAM_NAME = 'fclResponseJson';\nconst CORE_STRATEGIES = {\n  \"HTTP/RPC\": \"HTTP/RPC\",\n  \"HTTP/POST\": \"HTTP/POST\",\n  \"IFRAME/RPC\": \"IFRAME/RPC\",\n  \"POP/RPC\": \"POP/RPC\",\n  \"TAB/RPC\": \"TAB/RPC\",\n  \"EXT/RPC\": \"EXT/RPC\",\n  \"DEEPLINK/RPC\": \"DEEPLINK/RPC\"\n};\n\n/**\n * @description\n * Listens for messages from FCL\n * \n * @param {string} messageType - Message type\n * @param {Function} cb - Callback function\n * @returns {Function} - Function to remove event listener\n */\nconst onMessageFromFCL = function (messageType) {\n  let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  const buildData = data => {\n    if (data.deprecated) console.warn(\"DEPRECATION NOTICE\", data.deprecated.message);\n    delete data?.body?.interaction;\n    return data;\n  };\n  const internal = e => {\n    const {\n      data\n    } = e;\n    if (typeof data !== \"object\") return;\n    if (typeof data == null) return;\n    if (data.type !== messageType) return;\n    cb(buildData(data));\n  };\n  window.addEventListener(\"message\", internal);\n  return () => window.removeEventListener(\"message\", internal);\n};\n\n// This is a workaround for an ongoing issue with URL in React Native\nconst _URL = globalThis.URL;\nclass URL extends _URL {\n  constructor(url, base) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    super(url, base, ...args);\n\n    // Extra check if in React Native\n    {\n      return;\n    }\n  }\n}\n\n/**\n * @description\n * Sends message to FCL window\n *\n * @param {string} type - Message type\n * @param {object} msg - Message object\n * @returns {void}\n *\n * @example\n * sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n *    f_type: \"PollingResponse\",\n *    f_vsn: \"1.0.0\",\n *    status: \"APPROVED\",\n *    reason: null,\n *    data: data,\n *  })\n */\nconst sendMsgToFCL = function (type) {\n  let msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const data = {\n    ...msg,\n    type\n  };\n  const urlParams = new URLSearchParams(window.location.search);\n  const redirectUrl = urlParams.get(FCL_REDIRECT_URL_PARAM_NAME);\n  if (redirectUrl) {\n    const url = new URL(redirectUrl);\n    url.searchParams.append(FCL_RESPONSE_PARAM_NAME, JSON.stringify(data));\n    window.location.href = url.href;\n  } else if (window.location !== window.parent.location) {\n    window.parent.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else if (window.opener) {\n    window.opener.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else {\n    throw new Error(\"Unable to communicate with parent FCL instance\");\n  }\n};\n\n/**\n * @description\n * Listens for \"FCL:VIEW:READY:RESPONSE\" and sends \"FCL:VIEW:READY\"\n *\n * @param {Function} cb - Callback function\n * @param {object} msg - Message object\n * @returns {void}\n */\nconst ready = function (cb) {\n  onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", cb);\n  sendMsgToFCL(\"FCL:VIEW:READY\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:CLOSE\"\n *\n * @returns {void}\n */\nconst close = () => {\n  sendMsgToFCL(\"FCL:VIEW:CLOSE\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"APPROVED\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nconst approve = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"APPROVED\",\n    reason: null,\n    data: data\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"DECLINED\"\n *\n * @param {string} reason - Reason for declining\n * @returns {void}\n */\nconst decline = reason => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"DECLINED\",\n    reason: reason,\n    data: null\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"REDIRECT\"\n *\n * @param {object} data - Data object\n * @returns {void}\n */\nconst redirect = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"REDIRECT\",\n    reason: null,\n    data: data\n  });\n};\n\nconst SERVICE_PRAGMA = {\n  f_type: \"Service\",\n  f_vsn: \"1.0.0\"\n};\nconst IDENTITY_PRAGMA = {\n  f_type: \"Identity\",\n  f_vsn: \"1.0.0\"\n};\nconst USER_PRAGMA = {\n  f_type: \"USER\",\n  f_vsn: \"1.0.0\"\n};\nconst POLLING_RESPONSE_PRAGMA = {\n  f_type: \"PollingResponse\",\n  f_vsn: \"1.0.0\"\n};\nconst COMPOSITE_SIGNATURE_PRAGMA = {\n  f_type: \"CompositeSignature\",\n  f_vsn: \"1.0.0\"\n};\n\n/**\n * @description\n * Constructs a new CompositeSignature instance.\n *\n * @param {string} addr - Flow Address\n * @param {number} keyId - Key ID\n * @param {string} signature - Signature as a hex string\n */\nfunction CompositeSignature(addr, keyId, signature) {\n  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;\n  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;\n  this.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(addr);\n  this.keyId = Number(keyId);\n  this.signature = signature;\n}\n\nconst rightPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(value.padEnd(pad * 2, \"0\"), \"hex\");\nconst leftPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(value.padStart(pad * 2, \"0\"), \"hex\");\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8);\nconst nonceBuffer = nonce => _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(nonce, \"hex\");\nconst encodeAccountProof = function (_ref) {\n  let {\n    address,\n    nonce,\n    appIdentifier\n  } = _ref;\n  let includeDomainTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(address, \"Encode Message For Provable Authn Error: address must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(nonce, \"Encode Message For Provable Authn Error: nonce must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(appIdentifier, \"Encode Message For Provable Authn Error: appIdentifier must be defined\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(nonce.length >= 64, \"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes\");\n  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(\"FCL-ACCOUNT-PROOF-V0.0\").toString(\"hex\"), 32);\n  if (includeDomainTag) {\n    return _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([appIdentifier, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address)), nonceBuffer(nonce)])]).toString(\"hex\");\n  }\n  return (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([appIdentifier, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address)), nonceBuffer(nonce)]).toString(\"hex\");\n};\n\nfunction injectExtService(service) {\n  if (service.type === \"authn\" && service.endpoint != null) {\n    if (!Array.isArray(window.fcl_extensions)) {\n      window.fcl_extensions = [];\n    }\n    window.fcl_extensions.push(service);\n  } else {\n    console.warn(\"Authn service is required\");\n  }\n}\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sendMsgToFCL: sendMsgToFCL,\n  ready: ready,\n  close: close,\n  approve: approve,\n  decline: decline,\n  redirect: redirect,\n  onMessageFromFCL: onMessageFromFCL,\n  encodeMessageFromSignable: _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.encodeMessageFromSignable,\n  CompositeSignature: CompositeSignature,\n  encodeAccountProof: encodeAccountProof,\n  injectExtService: injectExtService\n});\n\nconst ACCOUNT_PROOF = \"ACCOUNT_PROOF\";\nconst USER_SIGNATURE = \"USER_SIGNATURE\";\nconst validateArgs = args => {\n  if (args.appIdentifier) {\n    const {\n      appIdentifier,\n      address,\n      nonce,\n      signatures\n    } = args;\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(appIdentifier), \"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(address) && (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address).length === 16, \"verifyAccountProof({ address }) -- address must be a valid address\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(nonce), \"nonce must be a hex string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  } else {\n    const {\n      message,\n      address,\n      compSigs\n    } = args;\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(message), \"Signed message must be a hex string\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isString(address) && (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(address).length === 16, \"verifyUserSignatures({ address }) -- address must be a valid address\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  }\n};\n\n// TODO: pass in option for contract but we're connected to testnet\n// log address + network -> in sync?\nconst getVerifySignaturesScript = async (sig, opts) => {\n  const verifyFunction = sig === \"ACCOUNT_PROOF\" ? \"verifyAccountProofSignatures\" : \"verifyUserSignatures\";\n  let network = await getChainId(opts);\n  let fclCryptoContract;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(opts.fclCryptoContract || network === \"testnet\" || network === \"mainnet\", \"${verifyFunction}({ fclCryptoContract }) -- fclCrypto contract address must be set for non-mainnet/testnet networks\");\n  if (opts.fclCryptoContract) {\n    fclCryptoContract = opts.fclCryptoContract;\n  } else {\n    fclCryptoContract = network === \"testnet\" ? \"0x74daa6f9c7ef24b1\" : \"0xb4b82a1c9d21d284\";\n  }\n  return `\n      import FCLCrypto from ${fclCryptoContract}\n\n      pub fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `;\n};\n\n/**\n * @description\n * Verify a valid account proof signature or signatures for an account on Flow.\n *\n * @param {string} appIdentifier - A message string in hexadecimal format\n * @param {object} accountProofData - An object consisting of address, nonce, and signatures\n * @param {string} accountProofData.address - A Flow account address\n * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)\n * @param {object[]} accountProofData.signatures - An array of composite signatures to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed\n * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const accountProofData = {\n *   address: \"0x123\",\n *   nonce: \"F0123\"\n *   signatures: [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *  }\n *\n *  const isValid = await fcl.AppUtils.verifyAccountProof(\n *    \"AwesomeAppId\",\n *    accountProofData,\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyAccountProof(appIdentifier, _ref) {\n  let {\n    address,\n    nonce,\n    signatures\n  } = _ref;\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  validateArgs({\n    appIdentifier,\n    address,\n    nonce,\n    signatures\n  });\n  const message = encodeAccountProof({\n    address,\n    nonce,\n    appIdentifier\n  }, false);\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of signatures) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),\n    args: (arg, t) => [arg((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(address), t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\n/**\n * @description\n * Verify a valid signature/s for an account on Flow.\n *\n * @param {string} message - A message string in hexadecimal format\n * @param {Array} compSigs - An array of Composite Signatures\n * @param {string} compSigs[].addr - The account address\n * @param {number} compSigs[].keyId - The account keyId\n * @param {string} compSigs[].signature - The signature to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed\n * @returns {boolean} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const isValid = await fcl.AppUtils.verifyUserSignatures(\n *    Buffer.from('FOO').toString(\"hex\"),\n *    [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyUserSignatures$1(message, compSigs) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const address = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(compSigs[0].addr);\n  validateArgs({\n    message,\n    address,\n    compSigs\n  });\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of compSigs) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),\n    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  verifyAccountProof: verifyAccountProof,\n  verifyUserSignatures: verifyUserSignatures$1\n});\n\n/**\n * Verify a valid signature/s for an account on Flow.\n *\n * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead\n *\n */\nconst verifyUserSignatures = _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log.deprecate({\n  pkg: \"FCL\",\n  subject: \"fcl.verifyUserSignatures()\",\n  message: \"Please use fcl.AppUtils.verifyUserSignatures()\",\n  callback: function verifyUserSignatures(message, compSigs) {\n    return verifyUserSignatures$1(message, compSigs);\n  }\n});\n\nconst serialize = async function () {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolveFunction = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config.first([\"sdk.resolve\"], opts.resolve || _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.resolve);\n  if (Array.isArray(args)) args = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.pipe)((0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.interaction)(), args);\n  return JSON.stringify((0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.createSignableVoucher)(await resolveFunction(args)), null, 2);\n};\n\nasync function configLens(regex) {\n  return Object.fromEntries(Object.entries(await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)().where(regex)).map(_ref => {\n    let [key, value] = _ref;\n    return [key.replace(regex, \"\"), value];\n  }));\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Transaction} Transaction\n */\n\n/**\n * @typedef {import(\"@onflow/typedefs\").TransactionStatus} TransactionStatus\n */\n\nconst RATE$1 = 2500;\nconst POLL = \"POLL\";\nconst fetchTxStatus = async transactionId => {\n  return (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getTransactionStatus)(transactionId)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n};\nconst isExpired = tx => tx.status === 5;\nconst isSealed = tx => tx.status >= 4;\nconst isExecuted = tx => tx.status >= 3;\nconst isFinalized = tx => tx.status >= 2;\nconst isPending = tx => tx.status >= 1;\nconst isUnknown = tx => tx.status >= 0;\nconst isDiff = (cur, next) => {\n  return JSON.stringify(cur) !== JSON.stringify(next);\n};\nconst HANDLERS$3 = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    ctx.sendSelf(POLL);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UPDATED, ctx.all());\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SNAPSHOT]: async (ctx, letter) => {\n    letter.reply(ctx.all());\n  },\n  [POLL]: async ctx => {\n    let tx;\n    try {\n      tx = await fetchTxStatus(ctx.self());\n    } catch (e) {\n      return ctx.fatalError(e);\n    }\n    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE$1);\n    if (isDiff(ctx.all(), tx)) ctx.broadcast(_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UPDATED, tx);\n    ctx.merge(tx);\n  }\n};\nconst scoped = transactionId => {\n  if (typeof transactionId === \"object\") transactionId = transactionId.transactionId;\n  if (transactionId == null) throw new Error(\"transactionId required\");\n  return transactionId;\n};\nconst spawnTransaction = transactionId => {\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$3, scoped(transactionId));\n};\n\n/**\n * @callback SubscriptionCallback\n * @param {TransactionStatus} txStatus\n * @returns {void}\n */\n\n/**\n * Provides methods for interacting with a transaction\n * \n * @param {string} transactionId - The transaction ID\n * @returns {{\n *    snapshot: function(): Promise<TransactionStatus>,\n *    subscribe: function(SubscriptionCallback): function(): void,\n *    onceFinalized: function(): Promise<TransactionStatus>,\n *    onceExecuted: function(): Promise<TransactionStatus>,\n *    onceSealed: function(): Promise<TransactionStatus>\n * }}\n */\nfunction transaction(transactionId) {\n  function snapshot() {\n    return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.snapshoter)(transactionId, spawnTransaction);\n  }\n  function subscribe(callback) {\n    return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(scoped(transactionId), spawnTransaction, callback);\n  }\n  function once(predicate) {\n    return function innerOnce() {\n      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const suppress = opts.suppress || false;\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe((txStatus, error) => {\n          if ((error || txStatus.statusCode) && !suppress) {\n            reject(error || txStatus.errorMessage);\n            unsub();\n          } else if (predicate(txStatus)) {\n            resolve(txStatus);\n            unsub();\n          }\n        });\n      });\n    };\n  }\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed)\n  };\n}\ntransaction.isUnknown = isUnknown;\ntransaction.isPending = isPending;\ntransaction.isFinalized = isFinalized;\ntransaction.isExecuted = isExecuted;\ntransaction.isSealed = isSealed;\ntransaction.isExpired = isExpired;\n\nconst RATE = 10000;\nconst UPDATED$1 = \"UPDATED\";\nconst TICK = \"TICK\";\nconst HIGH_WATER_MARK = \"hwm\";\nconst scheduleTick = async ctx => {\n  return setTimeout(() => ctx.sendSelf(TICK), await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(\"fcl.eventPollRate\", RATE));\n};\nconst HANDLERS$2 = {\n  [TICK]: async ctx => {\n    if (!ctx.hasSubs()) return;\n    let hwm = ctx.get(HIGH_WATER_MARK);\n    if (hwm == null) {\n      ctx.put(HIGH_WATER_MARK, await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)());\n      ctx.put(TICK, await scheduleTick(ctx));\n    } else {\n      let next = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)();\n      ctx.put(HIGH_WATER_MARK, next);\n      if (hwm.height < next.height) {\n        const data = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getEventsAtBlockHeightRange)(ctx.self(), hwm.height + 1, next.height)]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n        for (let d of data) ctx.broadcast(UPDATED$1, d.data);\n      }\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: async (ctx, letter) => {\n    if (!ctx.hasSubs()) {\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n    ctx.subscribe(letter.from);\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n    if (!ctx.hasSubs()) {\n      clearTimeout(ctx.get(TICK));\n      ctx.delete(TICK);\n      ctx.delete(HIGH_WATER_MARK);\n    }\n  }\n};\nconst spawnEvents = key => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$2, key);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Event} Event\n */\n\n/**\n * @typedef {object} SubscribeObject\n * @property {Function} subscribe - The subscribe function.\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Event}\n */\n\n/**\n * @description - Subscribe to events\n * @param {string} key - A valid event name\n * @returns {SubscribeObject}\n * \n * @example\n * import * as fcl from \"@onflow/fcl\"\n * fcl.events(eventName).subscribe((event) => console.log(event))\n */\nfunction events(key) {\n  return {\n    /**\n     * @description - Subscribe to events\n     * @param {Function} callback - The callback function\n     * @returns {SubscriptionCallback}\n     */\n    subscribe: callback => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(key, spawnEvents, callback)\n  };\n}\n\nconst stub = () => {\n  throw new Error(`Platform specific Core Strategies are not initialized`);\n};\nconst stubCoreStrategies = {\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: stub,\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: stub,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: stub\n};\nconst supportedPlugins = [\"ServicePlugin\"];\nconst supportedServicePlugins = [\"discovery-service\"];\nconst validateDiscoveryPlugin = servicePlugin => {\n  const {\n    services,\n    serviceStrategy\n  } = servicePlugin;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(services) && services.length, \"Array of Discovery Services is required\");\n  for (const ds of services) {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(ds.f_type) && ds.f_type === \"Service\", \"Service is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(ds.type) && ds.type === \"authn\", `Service must be type authn. Received ${ds.type}`);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);\n  }\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy), \"Service strategy is required\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), \"Service strategy method is required\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), \"Service strategy exec function is required\");\n  return {\n    discoveryServices: services,\n    serviceStrategy\n  };\n};\nconst ServiceRegistry = _ref => {\n  let {\n    coreStrategies\n  } = _ref;\n  let services = new Set();\n  let strategies = new Map(Object.entries(coreStrategies));\n  const add = servicePlugin => {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);\n    if (servicePlugin.type === \"discovery-service\") {\n      const {\n        discoveryServices,\n        serviceStrategy\n      } = validateDiscoveryPlugin(servicePlugin);\n      setServices(discoveryServices);\n      if (!strategies.has(serviceStrategy.method)) {\n        strategies.set(serviceStrategy.method, serviceStrategy.exec);\n      } else {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `Add Service Plugin`,\n          message: `Service strategy for ${serviceStrategy.method} already exists`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.warn\n        });\n      }\n    }\n  };\n  const setServices = discoveryServices => services = new Set([...discoveryServices]);\n  const getServices = () => [...services];\n  const getStrategy = method => strategies.get(method);\n  const getStrategies = () => [...strategies.keys()];\n  return Object.freeze({\n    add,\n    getServices,\n    getStrategy,\n    getStrategies\n  });\n};\nconst validatePlugins = plugins => {\n  let pluginsArray;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(plugins, \"No plugins supplied\");\n  if (!Array.isArray(plugins)) {\n    pluginsArray = [plugins];\n  } else {\n    pluginsArray = [...plugins];\n  }\n  for (const p of pluginsArray) {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(p.name), \"Plugin name is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(isRequired(p.f_type), \"Plugin f_type is required\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);\n  }\n  return pluginsArray;\n};\nconst PluginRegistry = () => {\n  const pluginsMap = new Map();\n  const getPlugins = () => pluginsMap;\n  const add = plugins => {\n    const pluginsArray = validatePlugins(plugins);\n    for (const p of pluginsArray) {\n      pluginsMap.set(p.name, p);\n      if (p.f_type === \"ServicePlugin\") {\n        serviceRegistry.add(p);\n      }\n    }\n  };\n  return Object.freeze({\n    add,\n    getPlugins\n  });\n};\nlet serviceRegistry;\nconst getIsServiceRegistryInitialized = () => typeof serviceRegistry !== 'undefined';\nconst initServiceRegistry = _ref2 => {\n  let {\n    coreStrategies\n  } = _ref2;\n  if (getIsServiceRegistryInitialized()) {\n    return serviceRegistry;\n  }\n  const _serviceRegistry = ServiceRegistry({\n    coreStrategies\n  });\n  serviceRegistry = _serviceRegistry;\n  return _serviceRegistry;\n};\nconst getServiceRegistry = () => {\n  if (!getIsServiceRegistryInitialized()) {\n    console.warn(\"Registry is not initalized, it will be initialized with stub core strategies\");\n    return initServiceRegistry({\n      coreStrategies: stubCoreStrategies\n    });\n  }\n  return serviceRegistry;\n};\nconst pluginRegistry = PluginRegistry();\n\nconst makeDiscoveryServices = async () => {\n  const extensionServices = window?.fcl_extensions || [];\n  return [...extensionServices, ...getServiceRegistry().getServices()];\n};\nasync function getDiscoveryService(service) {\n  const discoveryAuthnInclude = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.include\", []);\n  const discoveryWalletMethod = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"discovery.wallet.method\", \"discovery.wallet.method.default\"]);\n  const method = service?.method ? service.method : discoveryWalletMethod;\n  const endpoint = service?.endpoint ?? (await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"discovery.wallet\", \"challenge.handshake\"]));\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(endpoint, `\n    If no service is passed to \"authenticate,\" then \"discovery.wallet\" must be defined in fcl config.\n    See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n    `);\n  return {\n    ...service,\n    type: \"authn\",\n    endpoint,\n    method,\n    discoveryAuthnInclude\n  };\n}\n\nasync function getServices(_ref) {\n  let {\n    types\n  } = _ref;\n  const endpoint = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.endpoint\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(Boolean(endpoint), `\"discovery.authn.endpoint\" in config must be defined.`);\n  const include = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"discovery.authn.include\", []);\n  const url = new URL(endpoint);\n  return fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      type: types,\n      fclVersion: VERSION,\n      include,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies(),\n      userAgent: window?.navigator?.userAgent,\n      network: await getChainId()\n    })\n  }).then(d => d.json());\n}\n\nconst SERVICE_ACTOR_KEYS = {\n  AUTHN: \"authn\",\n  RESULTS: \"results\",\n  SNAPSHOT: \"SNAPSHOT\",\n  UPDATED: \"UPDATED\",\n  UPDATE_RESULTS: \"UPDATE_RESULTS\"\n};\nconst warn = (fact, msg) => {\n  if (fact) {\n    console.warn(`\n      %cFCL Warning\n      ============================\n      ${msg}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `, \"font-weight:bold;font-family:monospace;\");\n  }\n};\nconst fetchServicesFromDiscovery = async () => {\n  try {\n    const services = await getServices({\n      types: [SERVICE_ACTOR_KEYS.AUTHN]\n    });\n    (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {\n      results: services\n    });\n  } catch (error) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: `${error.name} Error fetching Discovery API services.`,\n      message: error.message,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n    });\n  }\n};\nconst HANDLERS$1 = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    warn(typeof window === \"undefined\", '\"fcl.discovery\" is only available in the browser.');\n    // If you call this before the window is loaded extensions will not be set yet\n    if (document.readyState === 'complete') {\n      fetchServicesFromDiscovery();\n    } else {\n      window.onload = async () => {\n        fetchServicesFromDiscovery();\n      };\n    }\n  },\n  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {\n    ctx.merge(data);\n    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),\n  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({\n    ...ctx.all()\n  })\n};\nconst spawnProviders = () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS$1, SERVICE_ACTOR_KEYS.AUTHN);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Service} Service\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Service[]}\n */\n\n/**\n * @description\n * Discovery methods for interacting with Authn.\n * \n * @typedef {object} Authn\n * @property {Function} subscribe - Subscribe to Discovery authn services\n * @property {Function} snapshot - Get the current Discovery authn services spanshot\n * @property {Function} update - Trigger an update of authn services\n */\nconst authn = {\n  /**\n   * @description - Subscribe to Discovery authn services\n   * @param {Function} cb\n   * @returns {SubscriptionCallback}\n   */\n  subscribe: cb => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.subscriber)(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb),\n  /**\n   * @description - Get the current Discovery authn services spanshot\n   * @returns {Service[]}\n   */\n  snapshot: () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.snapshoter)(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders),\n  /**\n   * @description - Trigger an update of authn services\n   * @returns {void}\n   */\n  update: () => fetchServicesFromDiscovery()\n};\n\nconst discovery = {\n  authn\n};\n\nvar sha3 = {};\n\nvar sponge = {};\n\nvar permute = {};\n\nvar chi = {};\n\nvar copy = function copy(I, i) {\n  return function (O, o) {\n    var oi = o * 2;\n    var ii = i * 2;\n    O[oi] = I[ii];\n    O[oi + 1] = I[ii + 1];\n  };\n};\nvar copy_1 = copy;\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var chi = function chi(_ref) {\n    var A = _ref.A,\n      C = _ref.C;\n    for (var y = 0; y < 25; y += 5) {\n      for (var x = 0; x < 5; x++) {\n        (0, _copy[\"default\"])(A, y + x)(C, x);\n      }\n      for (var _x = 0; _x < 5; _x++) {\n        var xy = (y + _x) * 2;\n        var x1 = (_x + 1) % 5 * 2;\n        var x2 = (_x + 2) % 5 * 2;\n        A[xy] ^= ~C[x1] & C[x2];\n        A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];\n      }\n    }\n  };\n  var _default = chi;\n  exports[\"default\"] = _default;\n})(chi);\n\nvar iota = {};\n\nvar roundConstants = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);\n  var _default = ROUND_CONSTANTS;\n  exports[\"default\"] = _default;\n})(roundConstants);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _roundConstants = _interopRequireDefault(roundConstants);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var iota = function iota(_ref) {\n    var A = _ref.A,\n      roundIndex = _ref.roundIndex;\n    var i = roundIndex * 2;\n    A[0] ^= _roundConstants[\"default\"][i];\n    A[1] ^= _roundConstants[\"default\"][i + 1];\n  };\n  var _default = iota;\n  exports[\"default\"] = _default;\n})(iota);\n\nvar rhoPi = {};\n\nvar piShuffles = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];\n  var _default = PI_SHUFFLES;\n  exports[\"default\"] = _default;\n})(piShuffles);\n\nvar rhoOffsets = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];\n  var _default = RHO_OFFSETS;\n  exports[\"default\"] = _default;\n})(rhoOffsets);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _piShuffles = _interopRequireDefault(piShuffles);\n  var _rhoOffsets = _interopRequireDefault(rhoOffsets);\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var rhoPi = function rhoPi(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      W = _ref.W;\n    (0, _copy[\"default\"])(A, 1)(W, 0);\n    var H = 0;\n    var L = 0;\n    var Wi = 0;\n    var ri = 32;\n    for (var i = 0; i < 24; i++) {\n      var j = _piShuffles[\"default\"][i];\n      var r = _rhoOffsets[\"default\"][i];\n      (0, _copy[\"default\"])(A, j)(C, 0);\n      H = W[0];\n      L = W[1];\n      ri = 32 - r;\n      Wi = r < 32 ? 0 : 1;\n      W[Wi] = H << r | L >>> ri;\n      W[(Wi + 1) % 2] = L << r | H >>> ri;\n      (0, _copy[\"default\"])(W, 0)(A, j);\n      (0, _copy[\"default\"])(C, 0)(W, 0);\n    }\n  };\n  var _default = rhoPi;\n  exports[\"default\"] = _default;\n})(rhoPi);\n\nvar theta = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var theta = function theta(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      D = _ref.D,\n      W = _ref.W;\n    var H = 0;\n    var L = 0;\n    for (var x = 0; x < 5; x++) {\n      var x20 = x * 2;\n      var x21 = (x + 5) * 2;\n      var x22 = (x + 10) * 2;\n      var x23 = (x + 15) * 2;\n      var x24 = (x + 20) * 2;\n      C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];\n      C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];\n    }\n    for (var _x = 0; _x < 5; _x++) {\n      (0, _copy[\"default\"])(C, (_x + 1) % 5)(W, 0);\n      H = W[0];\n      L = W[1];\n      W[0] = H << 1 | L >>> 31;\n      W[1] = L << 1 | H >>> 31;\n      D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];\n      D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];\n      for (var y = 0; y < 25; y += 5) {\n        A[(y + _x) * 2] ^= D[_x * 2];\n        A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];\n      }\n    }\n  };\n  var _default = theta;\n  exports[\"default\"] = _default;\n})(theta);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _chi = _interopRequireDefault(chi);\n  var _iota = _interopRequireDefault(iota);\n  var _rhoPi = _interopRequireDefault(rhoPi);\n  var _theta = _interopRequireDefault(theta);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var permute = function permute() {\n    var C = new Uint32Array(10);\n    var D = new Uint32Array(10);\n    var W = new Uint32Array(2);\n    return function (A) {\n      for (var roundIndex = 0; roundIndex < 24; roundIndex++) {\n        (0, _theta[\"default\"])({\n          A: A,\n          C: C,\n          D: D,\n          W: W\n        });\n        (0, _rhoPi[\"default\"])({\n          A: A,\n          C: C,\n          W: W\n        });\n        (0, _chi[\"default\"])({\n          A: A,\n          C: C\n        });\n        (0, _iota[\"default\"])({\n          A: A,\n          roundIndex: roundIndex\n        });\n      }\n      C.fill(0);\n      D.fill(0);\n      W.fill(0);\n    };\n  };\n  var _default = permute;\n  exports[\"default\"] = _default;\n})(permute);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _buffer = buffer__WEBPACK_IMPORTED_MODULE_9__;\n  var _permute = _interopRequireDefault(permute);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var xorWords = function xorWords(I, O) {\n    for (var i = 0; i < I.length; i += 8) {\n      var o = i / 4;\n      O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];\n      O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];\n    }\n    return O;\n  };\n  var readWords = function readWords(I, O) {\n    for (var o = 0; o < O.length; o += 8) {\n      var i = o / 4;\n      O[o] = I[i + 1];\n      O[o + 1] = I[i + 1] >>> 8;\n      O[o + 2] = I[i + 1] >>> 16;\n      O[o + 3] = I[i + 1] >>> 24;\n      O[o + 4] = I[i];\n      O[o + 5] = I[i] >>> 8;\n      O[o + 6] = I[i] >>> 16;\n      O[o + 7] = I[i] >>> 24;\n    }\n    return O;\n  };\n  var Sponge = function Sponge(_ref) {\n    var _this = this;\n    var capacity = _ref.capacity,\n      padding = _ref.padding;\n    var keccak = (0, _permute[\"default\"])();\n    var stateSize = 200;\n    var blockSize = capacity / 8;\n    var queueSize = stateSize - capacity / 4;\n    var queueOffset = 0;\n    var state = new Uint32Array(stateSize / 4);\n    var queue = _buffer.Buffer.allocUnsafe(queueSize);\n    this.absorb = function (buffer) {\n      for (var i = 0; i < buffer.length; i++) {\n        queue[queueOffset] = buffer[i];\n        queueOffset += 1;\n        if (queueOffset >= queueSize) {\n          xorWords(queue, state);\n          keccak(state);\n          queueOffset = 0;\n        }\n      }\n      return _this;\n    };\n    this.squeeze = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var output = {\n        buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),\n        padding: options.padding || padding,\n        queue: _buffer.Buffer.allocUnsafe(queue.length),\n        state: new Uint32Array(state.length)\n      };\n      queue.copy(output.queue);\n      for (var i = 0; i < state.length; i++) {\n        output.state[i] = state[i];\n      }\n      output.queue.fill(0, queueOffset);\n      output.queue[queueOffset] |= output.padding;\n      output.queue[queueSize - 1] |= 128;\n      xorWords(output.queue, output.state);\n      for (var offset = 0; offset < output.buffer.length; offset += queueSize) {\n        keccak(output.state);\n        readWords(output.state, output.buffer.slice(offset, offset + queueSize));\n      }\n      return output.buffer;\n    };\n    this.reset = function () {\n      queue.fill(0);\n      state.fill(0);\n      queueOffset = 0;\n      return _this;\n    };\n    return this;\n  };\n  var _default = Sponge;\n  exports[\"default\"] = _default;\n})(sponge);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;\n  var _buffer = buffer__WEBPACK_IMPORTED_MODULE_9__;\n  var _sponge = _interopRequireDefault(sponge);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var createHash = function createHash(_ref) {\n    var allowedSizes = _ref.allowedSizes,\n      defaultSize = _ref.defaultSize,\n      padding = _ref.padding;\n    return function Hash() {\n      var _this = this;\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;\n      if (!this || this.constructor !== Hash) {\n        return new Hash(size);\n      }\n      if (allowedSizes && !allowedSizes.includes(size)) {\n        throw new Error(\"Unsupported hash length\");\n      }\n      var sponge = new _sponge[\"default\"]({\n        capacity: size\n      });\n      this.update = function (input) {\n        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n        if (_buffer.Buffer.isBuffer(input)) {\n          sponge.absorb(input);\n          return _this;\n        }\n        if (typeof input === \"string\") {\n          return _this.update(_buffer.Buffer.from(input, encoding));\n        }\n        throw new TypeError(\"Not a string or buffer\");\n      };\n      this.digest = function () {\n        var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"binary\";\n        var options = typeof formatOrOptions === \"string\" ? {\n          format: formatOrOptions\n        } : formatOrOptions;\n        var buffer = sponge.squeeze({\n          buffer: options.buffer,\n          padding: options.padding || padding\n        });\n        if (options.format && options.format !== \"binary\") {\n          return buffer.toString(options.format);\n        }\n        return buffer;\n      };\n      this.reset = function () {\n        sponge.reset();\n        return _this;\n      };\n      return this;\n    };\n  };\n  var Keccak = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 1\n  });\n  exports.Keccak = Keccak;\n  var SHA3 = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 6\n  });\n  exports.SHA3 = SHA3;\n  var SHAKE = createHash({\n    allowedSizes: [128, 256],\n    defaultSize: 256,\n    padding: 31\n  });\n  exports.SHAKE = SHAKE;\n  var SHA3Hash = Keccak;\n  exports.SHA3Hash = SHA3Hash;\n  SHA3.SHA3Hash = SHA3Hash;\n  var _default = SHA3;\n  exports[\"default\"] = _default;\n})(sha3);\n\nasync function genHash(utf8String) {\n  const sha = new sha3.SHA3(256);\n  sha.update(_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(utf8String, \"utf8\"));\n  return sha.digest(\"hex\");\n}\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *  \n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nasync function generateTemplateId(_ref) {\n  let {\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateTemplateId({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateTemplateId({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const templateData = template.data;\n      const messages = await Promise.all(Object.keys(templateData.messages).map(async messageKey => [await genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));\n      const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async dependencyAddressPlaceholder => [await genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async dependencyContract => [await genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async dependencyContractNetwork => [await genHash(dependencyContractNetwork), [await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), await genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));\n      const _arguments = await Promise.all(Object.keys(templateData?.[\"arguments\"]).map(async argumentLabel => [await genHash(argumentLabel), [await genHash(String(templateData?.[\"arguments\"]?.[argumentLabel].index)), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].type), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].balance || \"\"), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages).map(async argumentMessageKey => [await genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));\n      const encodedHex = (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([await genHash(\"InteractionTemplate\"), await genHash(\"1.0.0\"), await genHash(templateData?.type), await genHash(templateData?.interface), messages, await genHash(templateData?.cadence), dependencies, _arguments]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateId Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Returns whether a set of auditors have audited a given Interaction Template\n *\n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @param {Array<string>} params.auditors - Array of auditors\n * @param {object} opts\n * @param {string} opts.flowInteractionAuditContract - Flow Interaction Template Audit contract address\n * @returns {Promise<object>} - Object of auditor addresses and audit status\n */\nasync function getInteractionTemplateAudits(_ref) {\n  let {\n    template,\n    auditors\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getInteractionTemplateAudits({ template }) -- template must be defined\");\n  template = normalizeInteractionTemplate(template);\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate\");\n\n  // Recompute ID to be sure it matches\n  let recomputedTemplateID = await generateTemplateId({\n    template\n  });\n  if (recomputedTemplateID !== template.id) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: \"getInteractionTemplateAudits Debug Error\",\n      message: `Could not recompute and match template ID\n                computed: ${recomputedTemplateID}\n                template: ${template.id}\n            `,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.debug\n    });\n    throw new Error(\"getInteractionTemplateAudits Error: Could not recompute and match template ID\");\n  }\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const _auditors = auditors || (await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(\"flow.auditors\"));\n      (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(_auditors, \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set\");\n      (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(Array.isArray(_auditors), \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array\");\n      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;\n      if (!FlowInteractionAuditContract) {\n        const fclNetwork = await getChainId(opts);\n        (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(fclNetwork === \"mainnet\" || fclNetwork === \"testnet\", \"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'\");\n        if (fclNetwork === \"mainnet\") {\n          FlowInteractionAuditContract = \"0xfd100e39d50a13e6\";\n        } else {\n          FlowInteractionAuditContract = \"0xf78bfc12d0a786dc\";\n        }\n      }\n      const audits = await query({\n        cadence: `\n        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}\n        pub fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,\n        args: (arg, t) => [arg(recomputedTemplateID, t.String), arg(_auditors, t.Array(t.Address))]\n      });\n      return audits;\n    default:\n      throw new Error(\"getInteractionTemplateAudits Error: Unsupported template version\");\n  }\n}\n\nfunction generateImport(_ref) {\n  let {\n    contractName,\n    address\n  } = _ref;\n  return {\n    contractName,\n    address,\n    contract: \"\"\n  };\n}\n\nfunction findImports(cadence) {\n  let imports = [];\n  let importsReg = /import ((\\w|,| )+)* from 0x\\w+/g;\n  let fileImports = cadence.match(importsReg) || [];\n  for (const fileImport of fileImports) {\n    const importLineReg = /import ((\\w+|, |)*) from (0x\\w+)/g;\n    const importLine = importLineReg.exec(fileImport);\n    const contractsReg = /((?:\\w+)+),?/g;\n    const contracts = importLine[1].match(contractsReg) || [];\n    for (const contract of contracts) {\n      imports.push(generateImport({\n        address: importLine[3],\n        contractName: contract.replace(/,/g, \"\")\n      }));\n    }\n  }\n  return imports;\n}\n\n/**\n * @description Produces a dependency pin for a contract at a given block height\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {number} params.blockHeight - The block height to produce the dependency pin for\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPin(_ref) {\n  let {\n    address,\n    contractName,\n    blockHeight\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(address != undefined, \"generateDependencyPin({ address }) -- address must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(contractName != undefined, \"generateDependencyPin({ contractName }) -- contractName must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) -- blockHeight must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof address === \"string\", \"generateDependencyPin({ address }) -- address must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof contractName === \"string\", \"generateDependencyPin({ contractName }) -- contractName must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) -- blockHeight must be a number\");\n  let horizon = [generateImport({\n    contractName,\n    address\n  })];\n  for (const horizonImport of horizon) {\n    let account = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send)([(0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.getAccount)(await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config)().get(horizonImport.address, horizonImport.address)), (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.atBlockHeight)(blockHeight)], opts).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode);\n    horizonImport.contract = account.contracts?.[horizonImport.contractName];\n    if (!horizonImport.contract) {\n      console.error(\"Did not find expected contract\", horizonImport, account);\n      throw new Error(\"Did not find expected contract\");\n    }\n    let contractImports = findImports(horizonImport.contract);\n    horizon.push(...contractImports);\n  }\n  let contractHashes = horizon.map(iport => genHash(iport.contract));\n  let contractHashesJoined = contractHashes.join(\"\");\n  return genHash(contractHashesJoined);\n}\n\n/**\n * @description Produces a dependency pin for a contract at latest sealed block\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPinAtLatestSealedBlock(_ref2) {\n  let {\n    address,\n    contractName\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)({\n    sealed: true\n  }, opts);\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return generateDependencyPin({\n    address,\n    contractName,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\nfunction normalizeInteractionTemplateInterface(templateInterface) {\n  if (templateInterface == null) return null;\n  switch (templateInterface[\"f_version\"]) {\n    case \"1.0.0\":\n      return templateInterface;\n    default:\n      throw new Error(\"normalizeInteractionTemplateInterface Error: Invalid InteractionTemplateInterface\");\n  }\n}\n\n/**\n * @description Generates Interaction Template Interface ID for a given Interaction Template Interface\n * \n * @param {object} params\n * @param {object} params.templateInterface - Interaction Template Interface\n * @returns {Promise<string>} - Interaction Template Interface ID\n */\nasync function generateTemplateInterfaceId(_ref) {\n  let {\n    templateInterface\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(templateInterface != undefined, \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof templateInterface === \"object\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof templateInterface.f_type === \"InteractionTemplateInterface\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface object must be an InteractionTemplate\");\n  templateInterface = normalizeInteractionTemplateInterface(templateInterface);\n  switch (templateInterface.f_version) {\n    case \"1.0.0\":\n      const interfaceData = templateInterface.data;\n      const encodedHex = (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode)([await genHash(\"InteractionTemplateInterface\"), await genHash(\"1.0.0\"), await genHash(interfaceData.flip), await Promise.all(Object.keys(interfaceData.arguments).map(async argumentLabel => [await genHash(argumentLabel), await genHash(String(interfaceData.arguments[argumentLabel].index)), await genHash(interfaceData.arguments[argumentLabel].type)]))]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateInterfaceId Error: Unsupported templateInterface version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at a block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {number} params.blockHeight - Block height to check pins at\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSame(_ref) {\n  let {\n    template,\n    blockHeight,\n    network\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(network != undefined, \"generateDependencyPin({ network }) network must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) blockHeight must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) blockHeight must be a number\");\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let templateDependenciesPlaceholderKeys = Object.keys(template.data.dependencies);\n      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {\n        let templateDependencyPlaceholder = template.data.dependencies[templateDependencyPlaceholderKey];\n        let templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);\n        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {\n          let templateDependencyPlaceholderContractNetworks = template.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];\n          let templateDependency = templateDependencyPlaceholderContractNetworks[network];\n          if (typeof templateDependency === \"undefined\") continue;\n          let pin = await generateDependencyPin({\n            address: templateDependency.address,\n            contractName: templateDependency.contract,\n            blockHeight\n          }, opts);\n          if (pin !== templateDependency.pin) {\n            (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n              title: \"verifyDependencyPinsSame Debug Error\",\n              message: `Could not recompute and match dependency pin.\n                                address: ${templateDependency.address} | contract: ${templateDependency.contract}\n                                computed: ${pin}\n                                template: ${templateDependency.pin}\n                            `,\n              level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.debug\n            });\n            return false;\n          }\n        }\n      }\n      return true;\n    default:\n      throw new Error(\"verifyDependencyPinsSame Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at the latest block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {\n  let {\n    template,\n    network\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.block)({\n    sealed: true\n  });\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return verifyDependencyPinsSame({\n    template,\n    network,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\n/**\n * @description Get Interaction Template argument message\n * \n * @param {object} params\n * @param {string} params.localization [localization=\"en-US\"] - Localization code\n * @param {string} params.messageKey - Message key\n * @param {object} params.template - Interaction Template\n * @returns {string} - Message\n */\nfunction getTemplateMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    messageKey,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(messageKey, \"getTemplateMessage({ messageKey }) -- messageKey must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateMessage({ messageKey }) -- messageKey must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(localization, \"getTemplateMessage({ localization }) -- localization must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof localization === \"string\", \"getTemplateMessage({ localization }) -- localization must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getTemplateMessage({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"getTemplateMessage({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"getTemplateMessage({ template }) -- template object must be an InteractionTemplate\");\n  const messages = template?.data?.messages;\n  return messages?.[messageKey]?.i18n?.[localization];\n}\n\n/**\n * @description Gets Interaction Template argument message by message key, argument label, and localization\n * \n * @param {object} opts\n * @param {string} opts.localization [localization=\"en-US\"] - Localization to get message for\n * @param {string} opts.argumentLabel - Argument label to get message for\n * @param {string} opts.messageKey - Message key to get message for\n * @param {object} opts.template - Interaction Template to get message from\n * @returns {string} - Message\n */\nfunction getTemplateArgumentMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    argumentLabel,\n    messageKey,\n    template\n  } = _ref;\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(messageKey, \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(argumentLabel, \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(localization, \"getTemplateArgumentMessage({ localization }) -- localization must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof localization === \"string\", \"getTemplateArgumentMessage({ localization }) -- localization must be a string\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(template != undefined, \"getTemplateArgumentMessage({ template }) -- template must be defined\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template === \"object\", \"getTemplateArgumentMessage({ template }) -- template must be an object\");\n  (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.invariant)(typeof template.f_type === \"InteractionTemplate\", \"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate\");\n  const args = template?.data?.arguments;\n  return args?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getInteractionTemplateAudits: getInteractionTemplateAudits,\n  generateDependencyPin: generateDependencyPin,\n  generateDependencyPinAtLatestSealedBlock: generateDependencyPinAtLatestSealedBlock,\n  generateTemplateId: generateTemplateId,\n  generateTemplateInterfaceId: generateTemplateInterfaceId,\n  verifyDependencyPinsSame: verifyDependencyPinsSame,\n  verifyDependencyPinsSameAtLatestSealedBlock: verifyDependencyPinsSameAtLatestSealedBlock,\n  deriveCadenceByNetwork: deriveCadenceByNetwork,\n  getTemplateMessage: getTemplateMessage,\n  getTemplateArgumentMessage: getTemplateArgumentMessage\n});\n\n/**\n * @type {Types}\n */\nconst t = _onflow_types__WEBPACK_IMPORTED_MODULE_1__;\n\n// Set chain id default on access node change\nwatchForChainIdChanges();\n\nasync function fetchServices(servicesURL, code) {\n  if (servicesURL == null || code == null) return [];\n  const url = new URL(servicesURL);\n  url.searchParams.append(\"code\", code);\n  const resp = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).then(d => d.json());\n  if (Array.isArray(resp)) return resp;\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services = [];\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service\n      });\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider\n    });\n  }\n  return services;\n}\n\nfunction mergeServices() {\n  let sx1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let sx2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // TODO: Make this smarter\n  return [...sx1, ...sx2];\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"identity\": {\n//     \"address\": \"0x____\"\n//   },\n//   \"provider\": {\n//     \"address\": \"0x____\",\n//     \"name\": \"Best Wallet\",\n//     \"description\": \"The Best Wallet\"\n//     \"icon\": \"https://\",\n//   }\n// }\nfunction normalizeAuthn(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.authn,\n        id: service.pid,\n        provider: {\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          name: service.name,\n          icon: service.icon\n        }\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"pre-authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of pre-authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizePreAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"frame\",\n//    \"endpoint\": \"https://rawr\",\n//    \"data\": {},   // Sent to frame when ready\n//    \"params\": {}, // include in query params on frame\n// }\nfunction normalizeFrame(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        old: service,\n        ...SERVICE_PRAGMA,\n        type: \"frame\",\n        endpoint: service.endpoint,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"back-channel-rpc\",\n//    \"endpoint\": \"https://rawr\",\n//    \"method\": \"HTTP/GET\", // HTTP/GET | HTTP/POST\n//    \"data\": {},           // included in body of rpc\n//    \"params\": {},         // included as query params on endpoint url\n// }\nfunction normalizeBackChannelRpc(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: \"back-channel-rpc\",\n        endpoint: service.endpoint,\n        method: service.method,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"open-id\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"method: \"data\",\n//   \"data\": {\n//      \"profile\": {\n//        \"name\": \"Bob\",\n//        \"family_name\": \"Builder\",\n//        \"given_name\": \"Robert\",\n//        \"middle_name\": \"the\",\n//        \"nickname\": \"Bob the Builder\",\n//        \"perferred_username\": \"bob\",\n//        \"profile\": \"https://www.bobthebuilder.com/\",\n//        \"picture\": \"https://avatars.onflow.org/avatar/bob\",\n//        \"gender\": \"...\",\n//        \"birthday\": \"2001-01-18\",\n//        \"zoneinfo\": \"America/Vancouver\",\n//        \"locale\": \"en-us\",\n//        \"updated_at\": \"1614970797388\"\n//      },\n//      \"email\": {\n//        \"email\": \"bob@bob.bob\",\n//        \"email_verified\": true\n//      },\n//      \"address\": {\n//        \"address\": \"One Apple Park Way, Cupertino, CA 95014, USA\"\n//      },\n//      \"phone\": {\n//        \"phone_number\": \"+1 (xxx) yyy-zzzz\",\n//        \"phone_number_verified\": true\n//      },\n//      \"social\": {\n//        \"twitter\": \"@_qvvg\",\n//        \"twitter_verified\": true\n//      },\n//   }\n// }\nfunction normalizeOpenId(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return null;\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"user-signature\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"IFRAME/RPC\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of user-signature request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeUserSignature(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid user-signature service\");\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    type: \"local-view\",\n//    method: \"VIEW/IFRAME\",\n//    endpoint: \"https://woot.org/authz/local\",\n//    data: {},\n//    params: {},\n// }\nfunction normalizeLocalView(resp) {\n  if (resp == null) return null;\n  if (resp.method == null) {\n    resp = {\n      ...resp,\n      type: \"local-view\",\n      method: \"VIEW/IFRAME\"\n    };\n  }\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: resp.type || \"local-view\",\n        method: resp.method,\n        endpoint: resp.endpoint,\n        data: resp.data || {},\n        params: resp.params || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",                    // Its a service!\n//   \"f_vsn\": \"1.0.0\",                       // Follows the v1.0.0 spec for the service\n//   \"type\": \"account-proof\",                // the type of service it is\n//   \"method\": \"DATA\",                       // Its data!\n//   \"uid\": \"awesome-wallet#account-proof\",  // A unique identifier for the service\n//   \"data\": {\n//     \"f_type\": \"account-proof\",\n//     \"f_vsn\": \"1.0.0\",\n//     \"nonce\": \"0A1BC2FF\",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)\n//     \"address\": \"0xUSER\",                  // The user's address (8 bytes, i.e 16 hex characters)\n//     \"signature\": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)\n// }\n\nfunction normalizeAccountProof(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(`FCL Normalizer Error: Invalid account-proof service`);\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn-refresh\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\",  // \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthnRefresh(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid authn-refresh service\");\n  }\n}\n\nconst serviceNormalizers = {\n  \"back-channel-rpc\": normalizeBackChannelRpc,\n  \"pre-authz\": normalizePreAuthz,\n  authz: normalizeAuthz,\n  authn: normalizeAuthn,\n  frame: normalizeFrame,\n  \"open-id\": normalizeOpenId,\n  \"user-signature\": normalizeUserSignature,\n  \"local-view\": normalizeLocalView,\n  \"account-proof\": normalizeAccountProof,\n  \"authn-refresh\": normalizeAuthnRefresh\n};\nfunction normalizeService(service, data) {\n  try {\n    var normalized = serviceNormalizers[service.type](service, data);\n    return normalized;\n  } catch (error) {\n    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);\n    return service;\n  }\n}\n\nfunction deriveCompositeId(authn) {\n  return _onflow_rlp__WEBPACK_IMPORTED_MODULE_7__.encode([authn.provider.address || authn.provider.name || \"UNSPECIFIED\", authn.id]).toString(\"hex\");\n}\nfunction normalizeData(data) {\n  data.addr = data.addr ? (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.addr) : null;\n  data.paddr = data.paddr ? (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.paddr) : null;\n  return data;\n}\nfunction findService(type, services) {\n  return services.find(d => d.type === type);\n}\nasync function buildUser(data) {\n  data = normalizeData(data);\n  var services = mergeServices(data.services || [], await fetchServices(data.hks, data.code)).map(service => normalizeService(service, data));\n  const authn = findService(\"authn\", services);\n  return {\n    ...USER_PRAGMA,\n    addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(data.addr),\n    cid: deriveCompositeId(authn),\n    loggedIn: true,\n    services: services,\n    expiresAt: data.expires\n  };\n}\n\nfunction serviceOfType() {\n  let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let type = arguments.length > 1 ? arguments[1] : undefined;\n  return services.find(service => service.type === type);\n}\n\nconst execStrategy = async _ref => {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const strategy = getServiceRegistry().getStrategy(service.method);\n  return strategy({\n    service,\n    body,\n    config,\n    opts\n  });\n};\nasync function execService(_ref2) {\n  let {\n    service,\n    msg = {},\n    config = {},\n    opts = {},\n    platform\n  } = _ref2;\n  msg.data = service.data;\n  const execConfig = {\n    services: await configLens(/^service\\./),\n    app: await configLens(/^app\\.detail\\./),\n    client: {\n      ...config.client,\n      platform,\n      fclVersion: VERSION,\n      fclLibrary: \"https://github.com/onflow/fcl-js\",\n      hostname: window?.location?.hostname ?? null,\n      network: await getChainId(opts)\n    }\n  };\n  try {\n    const res = await execStrategy({\n      service,\n      body: msg,\n      config: execConfig,\n      opts\n    });\n    if (res.status === \"REDIRECT\") {\n      (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(service.type === res.data.type, \"Cannot shift recursive service type in execService\");\n      return await execService({\n        service: res.data,\n        msg,\n        config: execConfig,\n        opts\n      });\n    } else {\n      return res;\n    }\n  } catch (error) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: `Error on execService ${service?.type}`,\n      message: error,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n    });\n    throw error;\n  }\n}\n\n// {\n//    \"f_type\": \"CompositeSignature\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"addr\": \"_____\",         // sans-prefix\n//    \"signature\": \"adfe1234\", // hex\n//    \"keyId\": 3,\n// }\nfunction normalizeCompositeSignature(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...COMPOSITE_SIGNATURE_PRAGMA,\n        addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(resp.addr || resp.address),\n        signature: resp.signature || resp.sig,\n        keyId: resp.keyId\n      };\n  }\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").CurrentUser} CurrentUser\n * @typedef {import(\"@onflow/typedefs\").CompositeSignature} CompositeSignature\n */\n\nconst isFn = d => typeof d === \"function\";\nconst NAME = \"CURRENT_USER\";\nconst UPDATED = \"CURRENT_USER/UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\";\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\";\nconst DATA = `{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}`;\nconst getStoredUser = async storage => {\n  const fallback = JSON.parse(DATA);\n  const stored = await storage.get(NAME);\n  if (stored != null && fallback[\"f_vsn\"] !== stored[\"f_vsn\"]) {\n    storage.removeItem(NAME);\n    return fallback;\n  }\n  return stored || fallback;\n};\nconst HANDLERS = {\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.INIT]: async ctx => {\n    if (typeof window === \"undefined\") {\n      console.warn(`\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        `, \"font-weight:bold;font-family:monospace;\");\n    }\n    ctx.merge(JSON.parse(DATA));\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) {\n      const user = await getStoredUser(storage);\n      if (notExpired(user)) ctx.merge(user);\n    }\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [SET_CURRENT_USER]: async (ctx, letter, data) => {\n    ctx.merge(data);\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DEL_CURRENT_USER]: async (ctx, letter) => {\n    ctx.merge(JSON.parse(DATA));\n    const storage = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  }\n};\nconst spawnCurrentUser = () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(HANDLERS, NAME);\nfunction notExpired(user) {\n  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();\n}\nasync function getAccountProofData() {\n  let accountProofDataResolver = await _onflow_config__WEBPACK_IMPORTED_MODULE_4__.config.get(\"fcl.accountProof.resolver\");\n  if (accountProofDataResolver == null) return;\n  if (!isFn(accountProofDataResolver)) {\n    (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n      title: \"Account Proof Data Resolver must be a function\",\n      message: `Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}\n                `,\n      level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.warn\n    });\n    return;\n  }\n  const accountProofData = await accountProofDataResolver();\n  if (accountProofData == null) return;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof accountProofData.appIdentifier === \"string\", \"appIdentifier must be a string\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(accountProofData.nonce), \"Nonce must be a hex string\");\n  return accountProofData;\n}\nconst makeConfig = async _ref => {\n  let {\n    discoveryAuthnInclude\n  } = _ref;\n  return {\n    client: {\n      discoveryAuthnInclude,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: getServiceRegistry().getStrategies()\n    }\n  };\n};\n\n/**\n * @description - Authenticate a user\n * @param {object} [opts] - Options\n * @param {object} [opts.platform] - platform that runs the function\n * @param {object} [opts.service] - Optional service to use for authentication\n * @param {boolean} [opts.redir=false] - Optional flag to allow window to stay open after authentication\n * @returns {Promise<CurrentUser>} - User object\n */\nconst getAuthenticate = _ref2 => {\n  let {\n    platform\n  } = _ref2;\n  return async function () {\n    let {\n      service,\n      redir = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {\n      window.location.href = service?.provider?.install_link;\n      return;\n    }\n    return new Promise(async (resolve, reject) => {\n      spawnCurrentUser();\n      const opts = {\n        redir\n      };\n      const user = await snapshot();\n      const discoveryService = await getDiscoveryService(service);\n      const refreshService = serviceOfType(user.services, \"authn-refresh\");\n      let accountProofData;\n      if (user.loggedIn) {\n        if (refreshService) {\n          try {\n            const response = await execService({\n              service: refreshService,\n              msg: accountProofData,\n              opts,\n              platform\n            });\n            (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SET_CURRENT_USER, await buildUser(response));\n          } catch (error) {\n            (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n              title: `${error.name} Could not refresh wallet authentication.`,\n              message: error.message,\n              level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n            });\n          } finally {\n            return resolve(await snapshot());\n          }\n        } else {\n          return resolve(user);\n        }\n      }\n      try {\n        accountProofData = await getAccountProofData();\n      } catch (error) {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `${error.name} On Authentication: Could not resolve account proof data.`,\n          message: error.message,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n        });\n        return reject(error);\n      }\n      try {\n        const response = await execService({\n          service: discoveryService,\n          msg: accountProofData,\n          config: await makeConfig(discoveryService),\n          opts,\n          platform\n        });\n        (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SET_CURRENT_USER, await buildUser(response));\n      } catch (error) {\n        (0,_onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.log)({\n          title: `${error} On Authentication`,\n          message: error,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_6__.LEVELS.error\n        });\n      } finally {\n        resolve(await snapshot());\n      }\n    });\n  };\n};\n\n/**\n * @description - Unauthenticate a user\n * @returns {void}\n */\nfunction unauthenticate$1() {\n  spawnCurrentUser();\n  (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, DEL_CURRENT_USER);\n}\nconst normalizePreAuthzResponse = authz => ({\n  f_type: \"PreAuthzResponse\",\n  f_vsn: \"1.0.0\",\n  proposer: (authz || {}).proposer,\n  payer: (authz || {}).payer || [],\n  authorization: (authz || {}).authorization || []\n});\nconst getResolvePreAuthz = _ref3 => {\n  let {\n    platform\n  } = _ref3;\n  return authz => {\n    const resp = normalizePreAuthzResponse(authz);\n    const axs = [];\n    if (resp.proposer != null) axs.push([\"PROPOSER\", resp.proposer]);\n    for (let az of resp.payer || []) axs.push([\"PAYER\", az]);\n    for (let az of resp.authorization || []) axs.push([\"AUTHORIZER\", az]);\n    var result = axs.map(_ref4 => {\n      let [role, az] = _ref4;\n      return {\n        tempId: [az.identity.address, az.identity.keyId].join(\"|\"),\n        addr: az.identity.address,\n        keyId: az.identity.keyId,\n        signingFunction(signable) {\n          return execService({\n            service: az,\n            msg: signable,\n            platform\n          });\n        },\n        role: {\n          proposer: role === \"PROPOSER\",\n          payer: role === \"PAYER\",\n          authorizer: role === \"AUTHORIZER\"\n        }\n      };\n    });\n    return result;\n  };\n};\n\n/**\n * @description\n * Produces the needed authorization details for the current user to submit transactions to Flow\n * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.\n * \n * @param {object} ops - running options\n * @param {string} ops.platform - platform that runs the function\n * @param {object} account - Account object\n * @returns {Promise<object>} - Account object with signing function\n */\nconst getAuthorization = _ref5 => {\n  let {\n    platform\n  } = _ref5;\n  return async account => {\n    spawnCurrentUser();\n    return {\n      ...account,\n      tempId: \"CURRENT_USER\",\n      async resolve(account, preSignable) {\n        const user = await getAuthenticate({\n          platform\n        })({\n          redir: true\n        });\n        const authz = serviceOfType(user.services, \"authz\");\n        const preAuthz = serviceOfType(user.services, \"pre-authz\");\n        if (preAuthz) return getResolvePreAuthz({\n          platform\n        })(await execService({\n          service: preAuthz,\n          msg: preSignable,\n          platform\n        }));\n        if (authz) {\n          let windowRef;\n          if (isMobile() && authz.method === \"WC/RPC\") {\n            windowRef = window.open(\"\", \"_blank\");\n          }\n          return {\n            ...account,\n            tempId: \"CURRENT_USER\",\n            resolve: null,\n            addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authz.identity.address),\n            keyId: authz.identity.keyId,\n            sequenceNum: null,\n            signature: null,\n            async signingFunction(signable) {\n              return normalizeCompositeSignature(await execService({\n                service: authz,\n                msg: signable,\n                opts: {\n                  includeOlderJsonRpcCall: true,\n                  windowRef\n                },\n                platform\n              }));\n            }\n          };\n        }\n        throw new Error(\"No Authz or PreAuthz Service configured for CURRENT_USER\");\n      }\n    };\n  };\n};\n\n/**\n * @description\n * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.\n * \n * @param {Function} callback - Callback function\n * @returns {Function} - Unsubscribe function\n */\nfunction subscribe(callback) {\n  spawnCurrentUser();\n  const EXIT = \"@EXIT\";\n  const self = (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.spawn)(async ctx => {\n    ctx.send(NAME, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      if (letter.tag === EXIT) {\n        ctx.send(NAME, _onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data);\n    }\n  });\n  return () => (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(self, EXIT);\n}\n\n/**\n * @description - Gets the current user\n * @returns {Promise<CurrentUser>} - User object\n */\nfunction snapshot() {\n  spawnCurrentUser();\n  return (0,_onflow_util_actor__WEBPACK_IMPORTED_MODULE_8__.send)(NAME, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\n\n/**\n * @description - Resolves the current user as an argument\n * \n * @param {object} ops - running options\n * @param {string} ops.platform - platform that runs the function\n * @returns {Promise<Function>}\n */\nconst getResolveArgument = _ref6 => {\n  let {\n    platform\n  } = _ref6;\n  return async () => {\n    const {\n      addr\n    } = await getAuthenticate({\n      platform\n    })();\n    return (0,_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.arg)((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(addr), _onflow_types__WEBPACK_IMPORTED_MODULE_1__.Address);\n  };\n};\nconst makeSignable = msg => {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(/^[0-9a-f]+$/i.test(msg), \"Message must be a hex string\");\n  return {\n    message: msg\n  };\n};\n\n/**\n * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.\n * @param {string} msg - Message to sign\n * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures\n */\nconst getSignUserMessage = _ref7 => {\n  let {\n    platform\n  } = _ref7;\n  return async msg => {\n    spawnCurrentUser();\n    const user = await getAuthenticate({\n      platform\n    })({\n      redir: true\n    });\n    const signingService = serviceOfType(user.services, \"user-signature\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(signingService, \"Current user must have authorized a signing service.\");\n    try {\n      const response = await execService({\n        service: signingService,\n        msg: makeSignable(msg),\n        platform\n      });\n      if (Array.isArray(response)) {\n        return response.map(compSigs => normalizeCompositeSignature(compSigs));\n      } else {\n        return [normalizeCompositeSignature(response)];\n      }\n    } catch (error) {\n      return error;\n    }\n  };\n};\nconst getCurrentUser = _ref8 => {\n  let {\n    platform\n  } = _ref8;\n  let currentUser = () => {\n    return {\n      authenticate: getAuthenticate({\n        platform\n      }),\n      unauthenticate: unauthenticate$1,\n      authorization: getAuthorization({\n        platform\n      }),\n      signUserMessage: getSignUserMessage({\n        platform\n      }),\n      subscribe,\n      snapshot,\n      resolveArgument: getResolveArgument({\n        platform\n      })\n    };\n  };\n  currentUser.authenticate = getAuthenticate({\n    platform\n  });\n  currentUser.unauthenticate = unauthenticate$1;\n  currentUser.authorization = getAuthorization({\n    platform\n  });\n  currentUser.signUserMessage = getSignUserMessage({\n    platform\n  });\n  currentUser.subscribe = subscribe;\n  currentUser.snapshot = snapshot;\n  currentUser.resolveArgument = getResolveArgument({\n    platform\n  });\n  return currentUser;\n};\n\nconst getMutate = _ref => {\n  let {\n    platform\n  } = _ref;\n  /**\n   * @description\n   * Allows you to submit transactions to the blockchain to potentially mutate the state.\n   *\n   * @param {object} [opts] - Mutation Options and configuration\n   * @param {string} [opts.cadence] - Cadence Transaction used to mutate Flow\n   * @param {import(\"../shared-exports\").ArgsFn} [opts.args] - Arguments passed to cadence transaction\n   * @param {object | string} [opts.template] - Interaction Template for a transaction\n   * @param {number} [opts.limit] - Compute Limit for transaction\n   * @param {Function} [opts.authz] - Authorization function for transaction\n   * @param {Function} [opts.proposer] - Proposer Authorization function for transaction\n   * @param {Function} [opts.payer] - Payer Authorization function for transaction\n   * @param {Array<Function>} [opts.authorizations] - Authorizations function for transaction\n   * @returns {Promise<string>} Transaction Id\n   *\n   * @example\n   * fcl.mutate({\n   *   cadence: `\n   *     transaction(a: Int, b: Int, c: Address) {\n   *       prepare(acct: AuthAccount) {\n   *         log(acct)\n   *         log(a)\n   *         log(b)\n   *         log(c)\n   *       }\n   *     }\n   *   `,\n   *   args: (arg, t) => [\n   *     arg(6, t.Int),\n   *     arg(7, t.Int),\n   *     arg(\"0xba1132bc08f82fe2\", t.Address),\n   *   ],\n   * })\n   *\n   *\n   * Options:\n   * type Options = {\n   *   template: InteractionTemplate | String // InteractionTemplate or url to one\n   *   cadence: String!,\n   *   args: (arg, t) => Array<Arg>,\n   *   limit: Number,\n   *   authz: AuthzFn, // will overload the trinity of signatory roles\n   *   proposer: AuthzFn, // will overload the proposer signatory role\n   *   payer: AuthzFn, // will overload the payer signatory role\n   *   authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles\n   * }\n   */\n  const mutate = async function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var txid;\n    try {\n      await preMutate(opts);\n      opts = await prepTemplateOpts(opts);\n      const currentUser = getCurrentUser({\n        platform\n      });\n      // Allow for a config to overwrite the authorization function.\n      // prettier-ignore\n      const authz = await _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().get(\"fcl.authz\", currentUser().authorization);\n      txid = _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.config().overload(opts.dependencies || {}, async () =>\n      // prettier-ignore\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.send([_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.transaction(opts.cadence), _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.limit(opts.limit),\n      // opts.proposer > opts.authz > authz\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.proposer(opts.proposer || opts.authz || authz),\n      // opts.payer > opts.authz > authz\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.payer(opts.payer || opts.authz || authz),\n      // opts.authorizations > [opts.authz > authz]\n      _onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.authorizations(opts.authorizations || [opts.authz || authz])]).then(_onflow_sdk__WEBPACK_IMPORTED_MODULE_0__.decode));\n      return txid;\n    } catch (error) {\n      throw error;\n    }\n  };\n  return mutate;\n};\n\nconst FRAME = \"FCL_IFRAME\";\nconst FRAME_STYLES = `\n  position:fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  height: 100%;\n  width: 100vw;\n  display:block;\n  background:rgba(0,0,0,0.25);\n  z-index: 2147483647;\n  box-sizing: border-box;\n  color-scheme: light;\n`;\nfunction renderFrame(src) {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(!document.getElementById(FRAME), \"Attempt at triggering multiple Frames\", {\n    src\n  });\n  const $frame = document.createElement(\"iframe\");\n  $frame.src = src;\n  $frame.id = FRAME;\n  $frame.allow = \"usb *; hid *\";\n  $frame.frameBorder = \"0\";\n  $frame.style.cssText = FRAME_STYLES;\n  document.body.append($frame);\n  const unmount = () => {\n    if (document.getElementById(FRAME)) {\n      document.getElementById(FRAME).remove();\n    }\n  };\n  return [$frame.contentWindow, unmount];\n}\n\nconst POP = \"FCL_POP\";\nlet popup = null;\nlet previousUrl$1 = null;\nfunction popupWindow(url, windowName, win, w, h) {\n  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;\n  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;\n  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);\n  if (!popup) throw new Error(\"Popup failed to open (was it blocked by a popup blocker?)\");\n  return popup;\n}\nfunction renderPop(src) {\n  if (popup == null || popup?.closed) {\n    popup = popupWindow(src, POP, window, 640, 770);\n  } else if (previousUrl$1 !== src) {\n    popup.location.replace(src);\n    popup.focus();\n  } else {\n    popup.focus();\n  }\n  previousUrl$1 = src;\n  const unmount = () => {\n    if (popup && !popup.closed) {\n      popup.close();\n    }\n    popup = null;\n  };\n  return [popup, unmount];\n}\n\nlet tab$1 = null;\nlet previousUrl = null;\nfunction renderTab(src) {\n  if (tab$1 == null || tab$1?.closed) {\n    tab$1 = window.open(src, \"_blank\");\n    if (!tab$1) throw new Error(\"Tab failed to open (was it blocked by the browser?)\");\n  } else if (previousUrl !== src) {\n    tab$1.location.replace(src);\n    tab$1.focus();\n  } else {\n    tab$1.focus();\n  }\n  previousUrl = src;\n  const unmount = () => {\n    if (tab$1 && !tab$1.closed) {\n      tab$1.close();\n    }\n    tab$1 = null;\n  };\n  return [tab$1, unmount];\n}\n\nconst isServerSide = () => typeof window === \"undefined\";\nconst getSessionStorage = () => {\n  try {\n    const SESSION_STORAGE = {\n      can: !isServerSide(),\n      get: async key => JSON.parse(sessionStorage.getItem(key)),\n      put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))\n    };\n    return SESSION_STORAGE;\n  } catch (error) {\n    return null;\n  }\n};\nconst getDefaultConfig = () => {\n  return {\n    \"discovery.wallet.method.default\": \"IFRAME/RPC\",\n    \"fcl.storage.default\": getSessionStorage()\n  };\n};\n\nfunction serviceEndpoint(service) {\n  const url = new URL(service.endpoint);\n  if (window?.location?.origin) {\n    url.searchParams.append(\"l6n\", window.location.origin);\n  }\n  if (service.params != null) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value);\n    }\n  }\n  return url;\n}\n\nfunction fetchService(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const method = opts.method || \"POST\";\n  const body = method === \"GET\" ? undefined : JSON.stringify(opts.data || service.data || {});\n  return fetch(serviceEndpoint(service), {\n    method: method,\n    headers: {\n      ...(service.headers || {}),\n      ...(opts.headers || {}),\n      \"Content-Type\": \"application/json\"\n    },\n    body: body\n  }).then(d => d.json());\n}\n\n// {\n//    \"f_type\": \"PollingResponse\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"status\": \"PENDING\", // PENDING | APPROVED | DECLINED | REDIRECT\n//    \"reason\": null,      // Reason for Declining Transaction\n//    \"data\": null,        // Return value for APPROVED\n//    \"updates\": BackChannelRpc,\n//    \"local\": Frame,\n// }\nfunction normalizePollingResponse(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...POLLING_RESPONSE_PRAGMA,\n        status: resp.status ?? \"APPROVED\",\n        reason: resp.reason ?? null,\n        data: resp.compositeSignature || resp.data || {\n          ...resp\n        } || {},\n        updates: normalizeBackChannelRpc(resp.authorizationUpdates),\n        local: normalizeFrame((resp.local || [])[0])\n      };\n  }\n}\n\nconst OPTIONS = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\"\n};\nconst serviceMethod = service => {\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(OPTIONS[service.method], \"Invalid Service Method for type back-channel-rpc\", {\n    service\n  });\n  return OPTIONS[service.method];\n};\nasync function poll(service) {\n  let checkCanContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => true;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(service, \"Missing Polling Service\", {\n    service\n  });\n  const canContinue = checkCanContinue();\n  if (!canContinue) throw new Error(\"Externally Halted\");\n  let resp;\n  try {\n    if (typeof document !== \"undefined\" && document.visibilityState === \"hidden\") {\n      await new Promise(r => setTimeout(r, 500));\n      return poll(service, checkCanContinue);\n    }\n    resp = await fetchService(service, {\n      method: serviceMethod(service)\n    }).then(normalizePollingResponse);\n  } catch (error) {\n    throw error;\n  }\n  switch (resp.status) {\n    case \"APPROVED\":\n      return resp.data;\n    case \"DECLINED\":\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n    default:\n      await new Promise(r => setTimeout(r, 500));\n      return poll(resp.updates, checkCanContinue);\n  }\n}\n\nconst getExecHttpPost = execLocal => async _ref => {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const resp = await fetchService(service, {\n    data: {\n      fclVersion: VERSION,\n      service: {\n        params: service.params,\n        data: service.data,\n        type: service.type\n      },\n      config,\n      ...body\n    }\n  }).then(normalizePollingResponse);\n  if (resp.status === \"APPROVED\") {\n    return resp.data;\n  } else if (resp.status === \"DECLINED\") {\n    throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n  } else if (resp.status === \"REDIRECT\") {\n    return resp;\n  } else if (resp.status === \"PENDING\") {\n    // these two flags are required to run polling one more time before it stops\n    var canContinue = true;\n    var shouldContinue = true;\n    const [_, unmount] = await execLocal(normalizeLocalView(resp.local), {\n      serviceEndpoint,\n      onClose: () => shouldContinue = false\n    });\n    const close = () => {\n      try {\n        unmount();\n        shouldContinue = false;\n      } catch (error) {\n        console.error(\"Frame Close Error\", error);\n      }\n    };\n    /**\n     * this function is run once per poll call.\n     * Offsetting canContinue flag to make sure that\n     * the polling is performed one extra time after canContinue flag is set to false\n     * to prevent halting on Android when a browser calls window.close\n     * before FCL receives a successful result from polling\n     *\n     * @returns {boolean} \n     */\n    const checkCanContinue = () => {\n      const offsetCanContinue = canContinue;\n      canContinue = shouldContinue;\n      return offsetCanContinue;\n    };\n    return poll(resp.updates, checkCanContinue).then(serviceResponse => {\n      close();\n      return serviceResponse;\n    }).catch(error => {\n      console.error(error);\n      close();\n      throw error;\n    });\n  } else {\n    console.error(`Auto Decline: Invalid Response`, {\n      service,\n      resp\n    });\n    throw new Error(`Auto Decline: Invalid Response`);\n  }\n};\n\nconst CLOSE_EVENT = \"FCL:VIEW:CLOSE\";\nconst READY_EVENT = \"FCL:VIEW:READY\";\nconst RESPONSE_EVENT = \"FCL:VIEW:RESPONSE\";\nconst _ = e => typeof e === \"string\" && e.toLowerCase();\nconst IGNORE = new Set([\"monetizationstart\", \"monetizationpending\", \"monetizationprogress\", \"monetizationstop\"]);\nconst deprecate = (was, want) => console.warn(\"DEPRECATION NOTICE\", `Received ${was}, please use ${want} for this and future versions of FCL`);\nconst buildMessageHandler = _ref => {\n  let {\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  } = _ref;\n  return e => {\n    try {\n      if (typeof e.data !== \"object\") return;\n      if (IGNORE.has(e.data.type)) return;\n      if (_(e.data.type) === _(CLOSE_EVENT)) close();\n      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {\n        send,\n        close\n      });\n      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {\n        send,\n        close\n      });\n      onMessage(e, {\n        send,\n        close\n      });\n\n      // Backwards Compatible\n      if (_(e.data.type) === _(\"FCL:FRAME:READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:CLOSE\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      //\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::AUTHZ_READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      if (_(e.data.type) === _(\"FCL::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n    } catch (error) {\n      console.error(\"Frame Callback Error\", error);\n      close();\n    }\n  };\n};\n\nconst noop$3 = () => {};\nfunction frame(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$3,\n    close: noop$3\n  };\n  const onClose = opts.onClose || noop$3;\n  const onMessage = opts.onMessage || noop$3;\n  const onReady = opts.onReady || noop$3;\n  const onResponse = opts.onResponse || noop$3;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$frame, unmount] = renderFrame(serviceEndpoint(service));\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Frame Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Frame Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execIframeRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;\n    frame(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            fclVersion: VERSION,\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params],\n              deprecated: {\n                message: \"jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n              }\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$2 = () => {};\nfunction pop(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$2,\n    close: noop$2\n  };\n  const onClose = opts.onClose || noop$2;\n  const onMessage = opts.onMessage || noop$2;\n  const onReady = opts.onReady || noop$2;\n  const onResponse = opts.onResponse || noop$2;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$pop, unmount] = renderPop(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($pop && $pop.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Popup Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Popup Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execPopRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    pop(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$1 = () => {};\nfunction tab(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$1,\n    close: noop$1\n  };\n  const onClose = opts.onClose || noop$1;\n  const onMessage = opts.onMessage || noop$1;\n  const onReady = opts.onReady || noop$1;\n  const onResponse = opts.onResponse || noop$1;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$tab, unmount] = renderTab(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($tab && $tab.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Tab Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Tab Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execTabRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = (0,_onflow_util_uid__WEBPACK_IMPORTED_MODULE_11__.uid)();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    tab(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop = () => {};\nfunction extension(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop,\n    close: noop\n  };\n  const onClose = opts.onClose || noop;\n  const onMessage = opts.onMessage || noop;\n  const onReady = opts.onReady || noop;\n  const onResponse = opts.onResponse || noop;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  send({\n    service\n  });\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      onClose();\n    } catch (error) {\n      console.error(\"Ext Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Ext Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execExtRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    extension(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execExtRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst NOT_IMPLEMENTED = () => {\n  throw new Error(\"Strategy util has not been implemented on this platform\");\n};\nconst VIEWS = {\n  \"VIEW/IFRAME\": renderFrame,\n  \"VIEW/POP\": renderPop,\n  \"VIEW/TAB\": renderTab,\n  \"VIEW/MOBILE_BROWSER\": NOT_IMPLEMENTED,\n  \"VIEW/DEEPLINK\": NOT_IMPLEMENTED\n};\nasync function execLocal(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    serviceEndpoint: () => {}\n  };\n  const {\n    serviceEndpoint\n  } = opts;\n  try {\n    return VIEWS[service.method](serviceEndpoint(service), opts);\n  } catch (error) {\n    console.error(\"execLocal({service, opts = {}})\", error, {\n      service,\n      opts\n    });\n    throw error;\n  }\n}\n\nconst coreStrategies = {\n  [CORE_STRATEGIES[\"HTTP/RPC\"]]: getExecHttpPost(execLocal),\n  [CORE_STRATEGIES[\"HTTP/POST\"]]: getExecHttpPost(execLocal),\n  [CORE_STRATEGIES[\"IFRAME/RPC\"]]: execIframeRPC,\n  [CORE_STRATEGIES[\"POP/RPC\"]]: execPopRPC,\n  [CORE_STRATEGIES[\"TAB/RPC\"]]: execTabRPC,\n  [CORE_STRATEGIES[\"EXT/RPC\"]]: execExtRPC\n};\n\nconst mutate = getMutate({\n  platform: \"web\"\n});\nconst currentUser = getCurrentUser({\n  platform: \"web\"\n});\nconst authenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst unauthenticate = () => currentUser().unauthenticate();\nconst reauthenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  currentUser().unauthenticate();\n  return currentUser().authenticate(opts);\n};\nconst signUp = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst logIn = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst authz = currentUser().authorization;\n(0,_onflow_config__WEBPACK_IMPORTED_MODULE_4__.config)(getDefaultConfig());\ninitServiceRegistry({\n  coreStrategies\n});\n\n\n//# sourceMappingURL=fcl.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvZmNsL2Rpc3QvZmNsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUM4TjtBQUMyTztBQUN2YztBQUNjO0FBQ1Y7QUFDRDtBQUNBO0FBQ3NCO0FBQ1M7QUFDckI7QUFDZjtBQUNVO0FBQ2tIO0FBQy9IO0FBQzZDO0FBQ3RDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsNENBQU8sRUFBRSwwQ0FBRztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFLGlFQUFTLHlDQUF5QyxLQUFLO0FBQ3pEO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQWM7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFLGlFQUFTLHlDQUF5QyxLQUFLO0FBQ3pELEVBQUUsaUVBQVMsc0NBQXNDLEtBQUs7QUFDdEQsNENBQTRDLHNEQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxpRUFBUztBQUNYO0FBQ0EsRUFBRSxpRUFBUztBQUNYO0FBQ0EsRUFBRSxpRUFBUyw0Q0FBNEMsU0FBUztBQUNoRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsc0RBQVcsaURBQWlELFNBQVM7QUFD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QUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRXdTO0FBQ3pTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9mY2wvZGlzdC9mY2wubW9kdWxlLmpzPzAxMzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2RrIGZyb20gJ0BvbmZsb3cvc2RrJztcbmltcG9ydCB7IGludmFyaWFudCBhcyBpbnZhcmlhbnQkMSwgZW5jb2RlTWVzc2FnZUZyb21TaWduYWJsZSwgY29uZmlnIGFzIGNvbmZpZyQxLCByZXNvbHZlLCBwaXBlLCBpbnRlcmFjdGlvbiwgY3JlYXRlU2lnbmFibGVWb3VjaGVyLCBzZW5kLCBnZXRUcmFuc2FjdGlvblN0YXR1cywgZGVjb2RlLCBibG9jaywgZ2V0RXZlbnRzQXRCbG9ja0hlaWdodFJhbmdlLCBnZXRBY2NvdW50LCBhdEJsb2NrSGVpZ2h0LCBhcmcgfSBmcm9tICdAb25mbG93L3Nkayc7XG5leHBvcnQgeyBUZXN0VXRpbHMsIGFjY291bnQsIGFyZywgYXJncywgYXRCbG9ja0hlaWdodCwgYXRCbG9ja0lkLCBhdXRob3JpemF0aW9uLCBhdXRob3JpemF0aW9ucywgYmxvY2ssIGJ1aWxkLCBjcmVhdGVTaWduYWJsZVZvdWNoZXIsIGRlY29kZSwgZ2V0QWNjb3VudCwgZ2V0QmxvY2ssIGdldEJsb2NrSGVhZGVyLCBnZXRDb2xsZWN0aW9uLCBnZXRFdmVudHMsIGdldEV2ZW50c0F0QmxvY2tIZWlnaHRSYW5nZSwgZ2V0RXZlbnRzQXRCbG9ja0lkcywgZ2V0TmV0d29ya1BhcmFtZXRlcnMsIGdldFRyYW5zYWN0aW9uLCBnZXRUcmFuc2FjdGlvblN0YXR1cywgaW52YXJpYW50LCBpc0JhZCwgaXNPaywgbGltaXQsIHBhcmFtLCBwYXJhbXMsIHBheWVyLCBwaW5nLCBwaXBlLCBwcm9wb3NlciwgcmVmLCBzY3JpcHQsIHNlbmQsIHRyYW5zYWN0aW9uLCB2YWxpZGF0b3IsIHZvdWNoZXJJbnRlcmNlcHQsIHZvdWNoZXJUb1R4SWQsIHdoeSB9IGZyb20gJ0BvbmZsb3cvc2RrJztcbmltcG9ydCAqIGFzIHQkMSBmcm9tICdAb25mbG93L3R5cGVzJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ0BvbmZsb3cvdXRpbC1pbnZhcmlhbnQnO1xuaW1wb3J0IGZldGNoVHJhbnNwb3J0IGZyb20gJ2Nyb3NzLWZldGNoJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BvbmZsb3cvY29uZmlnJztcbmV4cG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BvbmZsb3cvY29uZmlnJztcbmltcG9ydCB7IHdpdGhQcmVmaXgsIHNhbnNQcmVmaXggfSBmcm9tICdAb25mbG93L3V0aWwtYWRkcmVzcyc7XG5leHBvcnQgeyBkaXNwbGF5LCBzYW5zUHJlZml4LCB3aXRoUHJlZml4IH0gZnJvbSAnQG9uZmxvdy91dGlsLWFkZHJlc3MnO1xuaW1wb3J0IHsgbG9nLCBMRVZFTFMgfSBmcm9tICdAb25mbG93L3V0aWwtbG9nZ2VyJztcbmltcG9ydCAqIGFzIHJscCBmcm9tICdAb25mbG93L3JscCc7XG5pbXBvcnQgeyBCdWZmZXIsIGVuY29kZSB9IGZyb20gJ0BvbmZsb3cvcmxwJztcbmltcG9ydCB7IHNuYXBzaG90ZXIsIHN1YnNjcmliZXIsIHNwYXduLCBJTklULCBTVUJTQ1JJQkUsIFVQREFURUQgYXMgVVBEQVRFRCQyLCBVTlNVQlNDUklCRSwgU05BUFNIT1QgYXMgU05BUFNIT1QkMSwgc2VuZCBhcyBzZW5kJDEgfSBmcm9tICdAb25mbG93L3V0aWwtYWN0b3InO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAnYnVmZmVyJztcbmV4cG9ydCB7IHRlbXBsYXRlIGFzIGNhZGVuY2UsIHRlbXBsYXRlIGFzIGNkYyB9IGZyb20gJ0BvbmZsb3cvdXRpbC10ZW1wbGF0ZSc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICdAb25mbG93L3V0aWwtdWlkJztcblxuY29uc3QgVkVSU0lPTiA9IFwiMS42LjBcIiA7XG5cbmNvbnN0IGlzID0gdHlwZSA9PiBkID0+IHR5cGVvZiBkID09PSB0eXBlO1xuY29uc3QgaXNSZXF1aXJlZCA9IGQgPT4gZCAhPSBudWxsO1xuY29uc3QgaXNPYmplY3QgPSBpcyhcIm9iamVjdFwiKTtcbmNvbnN0IGlzU3RyaW5nID0gaXMoXCJzdHJpbmdcIik7XG5jb25zdCBpc0Z1bmMgPSBpcyhcImZ1bmN0aW9uXCIpO1xuY29uc3QgaXNOdW1iZXIgPSBpcyhcIm51bWJlclwiKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQXJncyhheCkge1xuICBpZiAoaXNGdW5jKGF4KSkgcmV0dXJuIGF4KHNkay5hcmcsIHQkMSk7XG4gIHJldHVybiBbXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaHR0cERvY3VtZW50UmVzb2x2ZXIoX3JlZikge1xuICBsZXQge1xuICAgIHVybFxuICB9ID0gX3JlZjtcbiAgaW52YXJpYW50KHR5cGVvZiB1cmwgIT09IFwidW5kZWZpbmVkXCIsIFwicmV0cmlldmUoeyB1cmwgfSkgLS0gdXJsIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgbGV0IHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhd2FpdCBmZXRjaFRyYW5zcG9ydCh1cmwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaHR0cERvY3VtZW50UmVzb2x2ZXIgRXJyb3I6IEZhaWxlZCB0byByZXRyaWV2ZSBkb2N1bWVudC5cIik7XG4gIH1cbiAgbGV0IGRvY3VtZW50ID0gcmVzLm9rID8gYXdhaXQgcmVzLmpzb24oKSA6IG51bGw7XG4gIHJldHVybiBkb2N1bWVudDtcbn1cbmNvbnN0IERPQ1VNRU5UX1JFU09MVkVSUyA9IG5ldyBNYXAoW1tcImh0dHBcIiwgaHR0cERvY3VtZW50UmVzb2x2ZXJdLCBbXCJodHRwc1wiLCBodHRwRG9jdW1lbnRSZXNvbHZlcl1dKTtcbmFzeW5jIGZ1bmN0aW9uIHJldHJpZXZlKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgdXJsXG4gIH0gPSBfcmVmMjtcbiAgaW52YXJpYW50KHR5cGVvZiB1cmwgIT09IFwidW5kZWZpbmVkXCIsIFwicmV0cmlldmUoeyB1cmwgfSkgLS0gdXJsIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50KHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIsIFwicmV0cmlldmUoeyB1cmwgfSkgLS0gdXJsIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGNvbnN0IGRvY3VtZW50UmVzb2x2ZXJzRnJvbUNvbmZpZyA9IGF3YWl0IGNvbmZpZygpLndoZXJlKC9eZG9jdW1lbnRcXC5yZXNvbHZlclxcLi8pO1xuICBPYmplY3Qua2V5cyhkb2N1bWVudFJlc29sdmVyc0Zyb21Db25maWcpLm1hcChrZXkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVyRnJvbUNvbmZpZyA9IGRvY3VtZW50UmVzb2x2ZXJzRnJvbUNvbmZpZ1trZXldO1xuICAgIGNvbnN0IHJlc29sdmVyUHJvdG9jb2wgPSBrZXkucmVwbGFjZSgvXmRvY3VtZW50XFwucmVzb2x2ZXJcXC4vLCBcIlwiKTtcbiAgICBET0NVTUVOVF9SRVNPTFZFUlMuc2V0KHJlc29sdmVyUHJvdG9jb2wsIHJlc29sdmVyRnJvbUNvbmZpZyk7XG4gIH0pO1xuICBjb25zdCB1cmxQYXJ0cyA9IC9eKC4qKTpcXC9cXC8oW0EtWmEtejAtOVxcLVxcLl0rKSg6WzAtOV0rKT8oLiopJC8uZXhlYyh1cmwpO1xuICBpbnZhcmlhbnQodXJsUGFydHMsIFwiRmFpbGVkIHRvIHBhcnNlIFVSTFwiKTtcbiAgY29uc3QgcHJvdG9jb2wgPSB1cmxQYXJ0c1sxXTtcbiAgaW52YXJpYW50KHVybFBhcnRzLCBcIkZhaWxlZCB0byBwYXJzZSBVUkwgcHJvdG9jb2xcIik7XG4gIGNvbnN0IHJlc29sdmVyID0gRE9DVU1FTlRfUkVTT0xWRVJTLmdldChwcm90b2NvbCk7XG4gIGludmFyaWFudChyZXNvbHZlciwgYE5vIHJlc29sdmVyIGZvdW5kIGZvciBwcm90Y29sPSR7cHJvdG9jb2x9YCk7XG4gIGxldCBkb2N1bWVudCA9IGF3YWl0IHJlc29sdmVyKHtcbiAgICB1cmxcbiAgfSk7XG4gIHJldHVybiBkb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSW50ZXJhY3Rpb25UZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICBpZiAodGVtcGxhdGUgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAodGVtcGxhdGVbXCJmX3ZlcnNpb25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9ybWFsaXplSW50ZXJhY3Rpb25UZW1wbGF0ZSBFcnJvcjogSW52YWxpZCBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZpbGxzIGltcG9ydCBhZGRyZXNzZXMgaW4gQ2FkZW5jZSBmb3IgbmV0d29ya1xuICogXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5ldHdvcmsgLSBOZXR3b3JrIHRvIGRlcml2ZSBDYWRlbmNlIGZvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIHRvIGRlcml2ZSBDYWRlbmNlIGZyb21cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQ2FkZW5jZVxuICovXG5mdW5jdGlvbiBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBuZXR3b3JrLFxuICAgIHRlbXBsYXRlXG4gIH0gPSBfcmVmO1xuICBpbnZhcmlhbnQkMShuZXR3b3JrICE9IHVuZGVmaW5lZCwgXCJkZXJpdmVDYWRlbmNlQnlOZXR3b3JrKHsgbmV0d29yayB9KSAtLSBuZXR3b3JrIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIG5ldHdvcmsgPT09IFwic3RyaW5nXCIsIFwiZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayh7IG5ldHdvcmsgfSkgLS0gbmV0d29yayBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZSAhPSB1bmRlZmluZWQsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGUgPT09IFwib2JqZWN0XCIsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGludmFyaWFudCQxKHRlbXBsYXRlLmZfdHlwZSA9PT0gXCJJbnRlcmFjdGlvblRlbXBsYXRlXCIsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBhbiBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuICB0ZW1wbGF0ZSA9IG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUodGVtcGxhdGUpO1xuICBzd2l0Y2ggKHRlbXBsYXRlLmZfdmVyc2lvbikge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgbGV0IG5ldHdvcmtEZXBlbmRlbmNpZXMgPSBPYmplY3Qua2V5cyh0ZW1wbGF0ZT8uZGF0YT8uZGVwZW5kZW5jaWVzKS5tYXAoZGVwZW5kZW5jeVBsYWNlaG9sZGVyID0+IHtcbiAgICAgICAgbGV0IGRlcGVuZGVuY3lOZXR3b3JrQ29udHJhY3RzID0gT2JqZWN0LnZhbHVlcyh0ZW1wbGF0ZT8uZGF0YT8uZGVwZW5kZW5jaWVzPy5bZGVwZW5kZW5jeVBsYWNlaG9sZGVyXSk7XG4gICAgICAgIGludmFyaWFudCQxKGRlcGVuZGVuY3lOZXR3b3JrQ29udHJhY3RzLCBgZGVyaXZlQ2FkZW5jZUJ5TmV0d29yayAtLSBDb3VsZCBub3QgZmluZCBjb250cmFjdHMgZm9yIGRlcGVuZGVuY3kgcGxhY2Vob2xkZXI6ICR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyfWApO1xuICAgICAgICBpbnZhcmlhbnQkMShkZXBlbmRlbmN5TmV0d29ya0NvbnRyYWN0cy5sZW5ndGggPT09IDAsIGBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrIC0tIENvdWxkIG5vdCBmaW5kIGNvbnRyYWN0cyBmb3IgZGVwZW5kZW5jeSBwbGFjZWhvbGRlcjogJHtkZXBlbmRlbmN5UGxhY2Vob2xkZXJ9YCk7XG4gICAgICAgIGxldCBkZXBlbmRlbmN5Q29udHJhY3QgPSBkZXBlbmRlbmN5TmV0d29ya0NvbnRyYWN0c1swXTtcbiAgICAgICAgbGV0IGRlcGVuZGVuY3lDb250cmFjdEZvck5ldHdvcmsgPSBkZXBlbmRlbmN5Q29udHJhY3Q/LltuZXR3b3JrXTtcbiAgICAgICAgaW52YXJpYW50JDEoZGVwZW5kZW5jeUNvbnRyYWN0Rm9yTmV0d29yaywgYGRlcml2ZUNhZGVuY2VCeU5ldHdvcmsgLS0gQ291bGQgbm90IGZpbmQgJHtuZXR3b3JrfSBuZXR3b3JrIGluZm9ybWF0aW9uIGZvciBkZXBlbmRlbmN5OiAke2RlcGVuZGVuY3lQbGFjZWhvbGRlcn1gKTtcbiAgICAgICAgcmV0dXJuIFtkZXBlbmRlbmN5UGxhY2Vob2xkZXIsIGRlcGVuZGVuY3lDb250cmFjdEZvck5ldHdvcmsuYWRkcmVzc107XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXR3b3JrRGVwZW5kZW5jaWVzLnJlZHVjZSgoY2FkZW5jZSwgX3JlZjIpID0+IHtcbiAgICAgICAgbGV0IFtwbGFjZWhvbGRlciwgYWRkcmVzc10gPSBfcmVmMjtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwiKFxcXFxiXCIgKyBwbGFjZWhvbGRlciArIFwiXFxcXGIpXCIsIFwiZ1wiKTtcbiAgICAgICAgcmV0dXJuIGNhZGVuY2UucmVwbGFjZShyZWdleCwgYWRkcmVzcyk7XG4gICAgICB9LCB0ZW1wbGF0ZS5kYXRhLmNhZGVuY2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXJpdmVDYWRlbmNlQnlOZXR3b3JrIEVycm9yOiBVbnN1cHBvcnRlZCB0ZW1wbGF0ZSB2ZXJzaW9uXCIpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQ2hhaW5JZCgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNkay5zZW5kKFtzZGsuZ2V0TmV0d29ya1BhcmFtZXRlcnMoKV0sIG9wdHMpLnRoZW4oc2RrLmRlY29kZSk7XG4gIHJldHVybiByZXNwb25zZS5jaGFpbklkO1xufVxuXG4vLyBDYWNoZSBvZiBjaGFpbklkIHByb21pc2VzIGZvciBlYWNoIGFjY2VzcyBub2RlIHZhbHVlXG4vLyBrZXk6IGFjY2VzcyBub2RlLCB2YWx1ZTogY2hhaW5JZCBwcm9taXNlXG5sZXQgY2hhaW5JZENhY2hlID0ge307XG5sZXQgaGFzV2FybmVkRW52ID0gZmFsc2U7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXRzIHRoZSBjaGFpbiBJRCBpZiBpdHMgc2V0LCBvdGhlcndpc2UgZ2V0cyB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYWNjZXNzIG5vZGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBjaGFpbiBJRCBvZiB0aGUgYWNjZXNzIG5vZGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY2hhaW4gSUQgaXMgbm90IGZvdW5kXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgXCJ0ZXN0bmV0XCJcbiAqIGdldENoYWluSWQoKVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDaGFpbklkKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBmbG93TmV0d29ya0NmZyA9IGF3YWl0IGNvbmZpZy5nZXQoXCJmbG93Lm5ldHdvcmtcIik7XG4gIGxldCBlbnZDZmcgPSBhd2FpdCBjb25maWcuZ2V0KFwiZW52XCIpO1xuICBpZiAoZW52Q2ZnICYmICFoYXNXYXJuZWRFbnYpIHtcbiAgICBsb2cuZGVwcmVjYXRlKHtcbiAgICAgIHBrZzogXCJGQ0xcIixcbiAgICAgIHN1YmplY3Q6ICdVc2luZyB0aGUgXCJlbnZcIiBjb25maWd1cmF0aW9uIGtleSBmb3Igc3BlY2lmeWluZyB0aGUgZmxvdyBuZXR3b3JrJyxcbiAgICAgIG1lc3NhZ2U6IFwiQ29uZmlndXJpbmcgdG8gc3BlY2lmeSBmbG93IG5ldHdvcmsgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkXCIsXG4gICAgICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmNsL1RSQU5TSVRJT05TLm1kIzAwMDEtZGVwcmVjYXRlLWVudi1jb25maWcta2V5XCJcbiAgICB9KTtcbiAgICBoYXNXYXJuZWRFbnYgPSB0cnVlO1xuICB9XG4gIGNvbnN0IGFjY2Vzc05vZGUgPSBvcHRzLm5vZGUgfHwgKGF3YWl0IGNvbmZpZy5nZXQoXCJhY2Nlc3NOb2RlLmFwaVwiKSk7XG4gIGlmICghYWNjZXNzTm9kZSkge1xuICAgIC8vIEZhbGwgYmFjayB0byBkZXByZWNhdGVkIGZsb3cubmV0d29yayBhbmQgZW52IGNvbmZpZyBrZXlzXG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGQgaGF2ZSBiZWVuIGRvbmUgYmVmb3JlIHRyeWluZyB0byBmZXRjaCB0aGUgY2hhaW5JZCBmcm9tIHRoZSBhY2Nlc3Mgbm9kZVxuICAgIC8vIEhvd2V2ZXIsIHRoaXMgd2FzIHRoZSBiZWhhdmlvdXIgd2l0aCB0aGUgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBnZXRDaGFpbklkKClcbiAgICBpZiAoZmxvd05ldHdvcmtDZmcpIHtcbiAgICAgIHJldHVybiBmbG93TmV0d29ya0NmZztcbiAgICB9IGVsc2UgaWYgKGVudkNmZykge1xuICAgICAgcmV0dXJuIGVudkNmZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFaXRoZXIgdGhlIFwiYWNjZXNzTm9kZS5hcGlcIiBjb25maWcga2V5IG9yIG9wdHMubm9kZSBtdXN0IGJlIHNldGApO1xuICB9XG5cbiAgLy8gVHJ5IHVzaW5nIGNhY2hlZCBjaGFpbklkIGZpcnN0IGlmIGl0IGV4aXN0cyBhbmQgYWNjZXNzIG5vZGUgaXMgdGhlIHNhbWVcbiAgaWYgKGNoYWluSWRDYWNoZVthY2Nlc3NOb2RlXSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2hhaW5JZENhY2hlW2FjY2Vzc05vZGVdO1xuICAgIH0gY2F0Y2gge31cbiAgfVxuXG4gIC8vIElmIG5vIGNhY2hlZCBjaGFpbklkLCB2YWx1ZSBpcyBzdGFsZSwgb3IgbGFzdCBhdHRlbXB0IGZhaWxlZCwgdHJ5IGdldHRpbmcgY2hhaW5JZCBmcm9tIGFjY2VzcyBub2RlXG4gIC8vIENoZWNrIGlmIGFub3RoZXIgZ2V0Q2hhaW5JZCgpIGNhbGwgaGFzIGFscmVhZHkgc3RhcnRlZCBhIG5ldyBwcm9taXNlLCBpZiBub3QsIHN0YXJ0IGEgbmV3IG9uZVxuICAvLyBUaGVyZSBtYXkgaGF2ZSBiZWVuIGNvbmN1cnJlbnQgY2FsbHMgdG8gZ2V0Q2hhaW5JZCgpIHdoaWxlIHRoZSBmaXJzdCBjYWxsIHdhcyB3YWl0aW5nIGZvciB0aGUgcmVzcG9uc2VcbiAgaWYgKCFjaGFpbklkQ2FjaGVbYWNjZXNzTm9kZV0pIHtcbiAgICBjaGFpbklkQ2FjaGVbYWNjZXNzTm9kZV0gPSBmZXRjaENoYWluSWQob3B0cykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCByZXNldCB0aGUgcHJvbWlzZSBzbyB0aGF0IHRoZSBuZXh0IGNhbGwgd2lsbCB0cnkgYWdhaW5cbiAgICAgIGNoYWluSWRDYWNoZVthY2Nlc3NOb2RlXSA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVzZSBuZXdseSBjcmVhdGVkIHByb21pc2VcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgY2hhaW5JZENhY2hlW2FjY2Vzc05vZGVdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGRlcHJlY2F0ZWQgZmxvdy5uZXR3b3JrIGFuZCBlbnYgY29uZmlnIGtleXNcbiAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZCBoYXZlIGJlZW4gZG9uZSBiZWZvcmUgdHJ5aW5nIHRvIGZldGNoIHRoZSBjaGFpbklkIGZyb20gdGhlIGFjY2VzcyBub2RlXG4gICAgLy8gSG93ZXZlciwgdGhpcyB3YXMgdGhlIGJlaGF2aW91ciB3aXRoIHRoZSBpbml0aWFsIGltcGxlbWVudGF0aW9uIG9mIGdldENoYWluSWQoKVxuICAgIGlmIChmbG93TmV0d29ya0NmZykge1xuICAgICAgcmV0dXJuIGZsb3dOZXR3b3JrQ2ZnO1xuICAgIH0gZWxzZSBpZiAoZW52Q2ZnKSB7XG4gICAgICByZXR1cm4gZW52Q2ZnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgY2hhaW5JZCBmcm9tIGFjY2VzcyBub2RlIC0gYXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBhY2Nlc3Mgbm9kZSBlbmRwb2ludC4gIElmIHJ1bm5pbmcgbG9jYWxseSwgaXMgeW91ciBlbXVsYXRvciB1cC10by1kYXRlPyAke2UubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogV2F0Y2hlcyB0aGUgY29uZmlnIGZvciBjaGFuZ2VzIHRvIGFjY2VzcyBub2RlIGFuZCB1cGRhdGVzIHRoZSBjaGFpbiBpZCBhY2NvcmRpbmdseVxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHVuc3Vic2NyaWJlcyB0aGUgbGlzdGVuZXJcbiAqXG4gKi9cbmZ1bmN0aW9uIHdhdGNoRm9yQ2hhaW5JZENoYW5nZXMoKSB7XG4gIHJldHVybiBjb25maWcuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAvLyBDYWxsIGdldENoYWluSWQgdG8gdXBkYXRlIHRoZSBjaGFpbklkIGNhY2hlIGlmIGFjY2VzcyBub2RlIGhhcyBjaGFuZ2VkXG4gICAgZ2V0Q2hhaW5JZCh7XG4gICAgICBlbmFibGVSZXF1ZXN0TG9nZ2luZzogZmFsc2VcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzU21hbGxJT1MoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9pUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzTGFyZ2VJT1MoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9pUGFkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gIHJldHVybiBpc1NtYWxsSU9TKCkgfHwgaXNMYXJnZUlPUygpO1xufVxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHJldHVybiBpc0FuZHJvaWQoKSB8fCBpc0lPUygpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVEZXBlbmRlbmNpZXMoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgdGVtcGxhdGUgPSBvcHRzLnRlbXBsYXRlO1xuICBjb25zdCBuZXR3b3JrID0gYXdhaXQgZ2V0Q2hhaW5JZChvcHRzKTtcbiAgY29uc3QgZGVyaXZlZERlcGVuZGVuY2llcyA9IHt9O1xuICBzd2l0Y2ggKHRlbXBsYXRlW1wiZl92ZXJzaW9uXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICBjb25zdCBkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXlzID0gT2JqZWN0LmtleXModGVtcGxhdGU/LmRhdGE/LmRlcGVuZGVuY2llcyk7XG4gICAgICBmb3IgKGxldCBkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXkgb2YgZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5cykge1xuICAgICAgICBsZXQgZGVwZW5kZW5jeVBsYWNlaG9sZGVyID0gdGVtcGxhdGU/LmRhdGE/LmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXldO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdHNLZXlzID0gT2JqZWN0LmtleXMoZGVwZW5kZW5jeVBsYWNlaG9sZGVyKTtcbiAgICAgICAgaW52YXJpYW50KGRlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0c0tleXMubGVuZ3RoID4gMCwgYEZDTCBjb25maWd1cmVEZXBlbmRlbmNpZXMgRXJyb3I6IE5vIGNvbnRyYWN0cyBmb3VuZCBpbiB0ZW1wbGF0ZSBmb3IgcGxhY2Vob2xkZXI9JHtkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXl9YCk7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0ID0gZGVwZW5kZW5jeVBsYWNlaG9sZGVyW2RlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0c0tleXNbMF1dO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3RbbmV0d29ya107XG4gICAgICAgIGludmFyaWFudChkZXBlbmRlbmN5LCBgRkNMIGNvbmZpZ3VyZURlcGVuZGVuY2llcyBFcnJvcjogTm8gZGVwZW5kZW5jeSBpbmZvcm1hdGlvbiBmb3IgcGxhY2Vob2xkZXI9JHtkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXl9IGNvbnRyYWN0PSR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3RzS2V5c1swXX0gbmV0d29yaz0ke25ldHdvcmt9YCk7XG4gICAgICAgIGludmFyaWFudChkZXBlbmRlbmN5Py5hZGRyZXNzLCBgRkNMIGNvbmZpZ3VyZURlcGVuZGVuY2llcyBFcnJvcjogTm8gYWRkcmVzcyBpbmZvcm1hdGlvbiBmb3IgcGxhY2Vob2xkZXI9JHtkZXBlbmRlbmN5UGxhY2Vob2xkZXJLZXl9IGNvbnRyYWN0PSR7ZGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3RzS2V5c1swXX0gbmV0d29yaz0ke25ldHdvcmt9YCk7XG4gICAgICAgIGRlcml2ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeVBsYWNlaG9sZGVyS2V5XSA9IHdpdGhQcmVmaXgoZGVwZW5kZW5jeT8uYWRkcmVzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVyaXZlZERlcGVuZGVuY2llcztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRkNMIGNvbmZpZ3VyZURlcGVuZGVuY2llcyBFcnJvcjogVW5zdXBwb3J0ZWQgdGVtcGxhdGUgdmVyc2lvblwiKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVwVGVtcGxhdGVPcHRzKG9wdHMpIHtcbiAgaWYgKGlzU3RyaW5nKG9wdHM/LnRlbXBsYXRlKSkge1xuICAgIG9wdHMudGVtcGxhdGUgPSBhd2FpdCByZXRyaWV2ZSh7XG4gICAgICB1cmw6IG9wdHM/LnRlbXBsYXRlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGRlcGVuZGVuY2llcyA9IHt9O1xuICBpZiAob3B0cz8udGVtcGxhdGUpIHtcbiAgICBvcHRzLnRlbXBsYXRlID0gbm9ybWFsaXplSW50ZXJhY3Rpb25UZW1wbGF0ZShvcHRzPy50ZW1wbGF0ZSk7XG4gICAgZGVwZW5kZW5jaWVzID0gYXdhaXQgZGVyaXZlRGVwZW5kZW5jaWVzKHtcbiAgICAgIHRlbXBsYXRlOiBvcHRzLnRlbXBsYXRlXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2FkZW5jZSA9IG9wdHMuY2FkZW5jZSB8fCBkZXJpdmVDYWRlbmNlQnlOZXR3b3JrKHtcbiAgICB0ZW1wbGF0ZTogb3B0cy50ZW1wbGF0ZSxcbiAgICBuZXR3b3JrOiBhd2FpdCBnZXRDaGFpbklkKG9wdHMpXG4gIH0pO1xuICBvcHRzLmNhZGVuY2UgPSBjYWRlbmNlO1xuICBvcHRzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgcmV0dXJuIG9wdHM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZSh0eXBlLCBvcHRzKSB7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQoaXNSZXF1aXJlZChvcHRzKSwgYCR7dHlwZX0ob3B0cykgLS0gb3B0cyBpcyByZXF1aXJlZGApO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50KGlzT2JqZWN0KG9wdHMpLCBgJHt0eXBlfShvcHRzKSAtLSBvcHRzIG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQoIShvcHRzLmNhZGVuY2UgJiYgb3B0cy50ZW1wbGF0ZSksIGAke3R5cGV9KHsgdGVtcGxhdGUsIGNhZGVuY2UgfSkgLS0gY2Fubm90IHBhc3MgYm90aCBjYWRlbmNlIGFuZCB0ZW1wbGF0ZWApO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50KGlzUmVxdWlyZWQob3B0cy5jYWRlbmNlIHx8IG9wdHM/LnRlbXBsYXRlKSwgYCR7dHlwZX0oeyBjYWRlbmNlIH0pIC0tIGNhZGVuY2UgaXMgcmVxdWlyZWRgKTtcbiAgLy8gLy8gcHJldHRpZXItaWdub3JlXG4gIGludmFyaWFudChpc1N0cmluZyhvcHRzLmNhZGVuY2UpIHx8IG9wdHM/LnRlbXBsYXRlLCBgJHt0eXBlfSh7IGNhZGVuY2UgfSkgLS0gY2FkZW5jZSBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQoYXdhaXQgc2RrLmNvbmZpZygpLmdldChcImFjY2Vzc05vZGUuYXBpXCIpLCBgJHt0eXBlfShvcHRzKSAtLSBSZXF1aXJlZCB2YWx1ZSBmb3IgXCJhY2Nlc3NOb2RlLmFwaVwiIG5vdCBkZWZpbmVkIGluIGNvbmZpZy4gU2VlOiAke1wiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9mY2wvc3JjL2V4ZWMvcXVlcnkubWQjY29uZmlndXJhdGlvblwifWApO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlTXV0YXRlKG9wdHMpIHtcbiAgcmV0dXJuIHByZShcIm11dGF0ZVwiLCBvcHRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZVF1ZXJ5KG9wdHMpIHtcbiAgcmV0dXJuIHByZShcInF1ZXJ5XCIsIG9wdHMpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQWxsb3dzIHlvdSB0byBzdWJtaXQgc2NyaXB0cyB0byBxdWVyeSB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBRdWVyeSBPcHRpb25zIGFuZCBjb25maWd1cmF0aW9uXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG9wdHMuY2FkZW5jZSAtIENhZGVuY2UgU2NyaXB0IHVzZWQgdG8gcXVlcnkgRmxvd1xuICogIEBwYXJhbSB7aW1wb3J0KFwiLi4vZmNsXCIpLkFyZ3NGbn0gW29wdHMuYXJnc10gLSBBcmd1bWVudHMgcGFzc2VkIHRvIGNhZGVuY2Ugc2NyaXB0XG4gKiAgQHBhcmFtIHtvYmplY3R9IFtvcHRzLnRlbXBsYXRlXSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIGZvciBhIHNjcmlwdFxuICogIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5saW1pdF0gICAtIENvbXB1dGUgTGltaXQgZm9yIFF1ZXJ5XG4gKiAgQHJldHVybnMge1Byb21pc2V9XG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBjb25zdCBjYWRlbmNlID0gYFxuICogICAgICBjYWRlbmNlOiBgXG4gKiAgICAgICAgcHViIGZ1biBtYWluKGE6IEludCwgYjogSW50LCBjOiBBZGRyZXNzKTogSW50IHtcbiAqICAgICAgICAgIGxvZyhjKVxuICogICAgICAgICAgcmV0dXJuIGEgKyBiXG4gKiAgICAgICAgfVxuICogICAgYC50cmltKClcbiAqXG4gKiAgICBjb25zdCBhcmdzID0gKGFyZywgdCkgPT4gW1xuICogICAgICBhcmcoNSwgdC5JbnQpLFxuICogICAgICBhcmcoNywgdC5JbnQpLFxuICogICAgICBhcmcoXCIweGIyZGI0M2FkNmJjMzQ1ZmVjOVwiLCB0LkFkZHJlc3MpLFxuICogICAgXVxuICpcbiAqICAgIGF3YWl0IHF1ZXJ5KHsgY2FkZW5jZSwgYXJncyB9KVxuICovXG5hc3luYyBmdW5jdGlvbiBxdWVyeSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBhd2FpdCBwcmVRdWVyeShvcHRzKTtcbiAgb3B0cyA9IGF3YWl0IHByZXBUZW1wbGF0ZU9wdHMob3B0cyk7XG4gIHJldHVybiBzZGsuY29uZmlnKCkub3ZlcmxvYWQob3B0cy5kZXBlbmRlbmNpZXMgfHwge30sIGFzeW5jICgpID0+XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzZGsuc2VuZChbc2RrLnNjcmlwdChvcHRzLmNhZGVuY2UpLCBzZGsuYXJncyhub3JtYWxpemVBcmdzKG9wdHMuYXJncyB8fCBbXSkpLCBvcHRzLmxpbWl0ICYmIHR5cGVvZiBvcHRzLmxpbWl0ID09PSBcIm51bWJlclwiICYmIHNkay5saW1pdChvcHRzLmxpbWl0KV0pLnRoZW4oc2RrLmRlY29kZSkpO1xufVxuXG5jb25zdCBGQ0xfUkVESVJFQ1RfVVJMX1BBUkFNX05BTUUgPSAnZmNsX3JlZGlyZWN0X3VybCc7XG5jb25zdCBGQ0xfUkVTUE9OU0VfUEFSQU1fTkFNRSA9ICdmY2xSZXNwb25zZUpzb24nO1xuY29uc3QgQ09SRV9TVFJBVEVHSUVTID0ge1xuICBcIkhUVFAvUlBDXCI6IFwiSFRUUC9SUENcIixcbiAgXCJIVFRQL1BPU1RcIjogXCJIVFRQL1BPU1RcIixcbiAgXCJJRlJBTUUvUlBDXCI6IFwiSUZSQU1FL1JQQ1wiLFxuICBcIlBPUC9SUENcIjogXCJQT1AvUlBDXCIsXG4gIFwiVEFCL1JQQ1wiOiBcIlRBQi9SUENcIixcbiAgXCJFWFQvUlBDXCI6IFwiRVhUL1JQQ1wiLFxuICBcIkRFRVBMSU5LL1JQQ1wiOiBcIkRFRVBMSU5LL1JQQ1wiXG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogTGlzdGVucyBmb3IgbWVzc2FnZXMgZnJvbSBGQ0xcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlIC0gTWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gRnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyXG4gKi9cbmNvbnN0IG9uTWVzc2FnZUZyb21GQ0wgPSBmdW5jdGlvbiAobWVzc2FnZVR5cGUpIHtcbiAgbGV0IGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAoKSA9PiB7fTtcbiAgY29uc3QgYnVpbGREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKGRhdGEuZGVwcmVjYXRlZCkgY29uc29sZS53YXJuKFwiREVQUkVDQVRJT04gTk9USUNFXCIsIGRhdGEuZGVwcmVjYXRlZC5tZXNzYWdlKTtcbiAgICBkZWxldGUgZGF0YT8uYm9keT8uaW50ZXJhY3Rpb247XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIGNvbnN0IGludGVybmFsID0gZSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSBlO1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBudWxsKSByZXR1cm47XG4gICAgaWYgKGRhdGEudHlwZSAhPT0gbWVzc2FnZVR5cGUpIHJldHVybjtcbiAgICBjYihidWlsZERhdGEoZGF0YSkpO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaW50ZXJuYWwpO1xuICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGludGVybmFsKTtcbn07XG5cbi8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhbiBvbmdvaW5nIGlzc3VlIHdpdGggVVJMIGluIFJlYWN0IE5hdGl2ZVxuY29uc3QgX1VSTCA9IGdsb2JhbFRoaXMuVVJMO1xuY2xhc3MgVVJMIGV4dGVuZHMgX1VSTCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgYmFzZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBzdXBlcih1cmwsIGJhc2UsIC4uLmFyZ3MpO1xuXG4gICAgLy8gRXh0cmEgY2hlY2sgaWYgaW4gUmVhY3QgTmF0aXZlXG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU2VuZHMgbWVzc2FnZSB0byBGQ0wgd2luZG93XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBNZXNzYWdlIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtc2cgLSBNZXNzYWdlIG9iamVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKlxuICogQGV4YW1wbGVcbiAqIHNlbmRNc2dUb0ZDTChcIkZDTDpWSUVXOlJFU1BPTlNFXCIsIHtcbiAqICAgIGZfdHlwZTogXCJQb2xsaW5nUmVzcG9uc2VcIixcbiAqICAgIGZfdnNuOiBcIjEuMC4wXCIsXG4gKiAgICBzdGF0dXM6IFwiQVBQUk9WRURcIixcbiAqICAgIHJlYXNvbjogbnVsbCxcbiAqICAgIGRhdGE6IGRhdGEsXG4gKiAgfSlcbiAqL1xuY29uc3Qgc2VuZE1zZ1RvRkNMID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgbGV0IG1zZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgLi4ubXNnLFxuICAgIHR5cGVcbiAgfTtcbiAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgY29uc3QgcmVkaXJlY3RVcmwgPSB1cmxQYXJhbXMuZ2V0KEZDTF9SRURJUkVDVF9VUkxfUEFSQU1fTkFNRSk7XG4gIGlmIChyZWRpcmVjdFVybCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKEZDTF9SRVNQT05TRV9QQVJBTV9OQU1FLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwuaHJlZjtcbiAgfSBlbHNlIGlmICh3aW5kb3cubG9jYXRpb24gIT09IHdpbmRvdy5wYXJlbnQubG9jYXRpb24pIHtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgIC4uLm1zZyxcbiAgICAgIHR5cGVcbiAgICB9LCBcIipcIik7XG4gIH0gZWxzZSBpZiAod2luZG93Lm9wZW5lcikge1xuICAgIHdpbmRvdy5vcGVuZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgLi4ubXNnLFxuICAgICAgdHlwZVxuICAgIH0sIFwiKlwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29tbXVuaWNhdGUgd2l0aCBwYXJlbnQgRkNMIGluc3RhbmNlXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogTGlzdGVucyBmb3IgXCJGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiIGFuZCBzZW5kcyBcIkZDTDpWSUVXOlJFQURZXCJcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gbXNnIC0gTWVzc2FnZSBvYmplY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCByZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBvbk1lc3NhZ2VGcm9tRkNMKFwiRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIiwgY2IpO1xuICBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpSRUFEWVwiKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZW5kcyBcIkZDTDpWSUVXOkNMT1NFXCJcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gIHNlbmRNc2dUb0ZDTChcIkZDTDpWSUVXOkNMT1NFXCIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlbmRzIFwiRkNMOlZJRVc6UkVTUE9OU0VcIiB3aXRoIHN0YXR1cyBcIkFQUFJPVkVEXCJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIERhdGEgb2JqZWN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgYXBwcm92ZSA9IGRhdGEgPT4ge1xuICBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpSRVNQT05TRVwiLCB7XG4gICAgZl90eXBlOiBcIlBvbGxpbmdSZXNwb25zZVwiLFxuICAgIGZfdnNuOiBcIjEuMC4wXCIsXG4gICAgc3RhdHVzOiBcIkFQUFJPVkVEXCIsXG4gICAgcmVhc29uOiBudWxsLFxuICAgIGRhdGE6IGRhdGFcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU2VuZHMgXCJGQ0w6VklFVzpSRVNQT05TRVwiIHdpdGggc3RhdHVzIFwiREVDTElORURcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBSZWFzb24gZm9yIGRlY2xpbmluZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGRlY2xpbmUgPSByZWFzb24gPT4ge1xuICBzZW5kTXNnVG9GQ0woXCJGQ0w6VklFVzpSRVNQT05TRVwiLCB7XG4gICAgZl90eXBlOiBcIlBvbGxpbmdSZXNwb25zZVwiLFxuICAgIGZfdnNuOiBcIjEuMC4wXCIsXG4gICAgc3RhdHVzOiBcIkRFQ0xJTkVEXCIsXG4gICAgcmVhc29uOiByZWFzb24sXG4gICAgZGF0YTogbnVsbFxuICB9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZW5kcyBcIkZDTDpWSUVXOlJFU1BPTlNFXCIgd2l0aCBzdGF0dXMgXCJSRURJUkVDVFwiXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBEYXRhIG9iamVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IHJlZGlyZWN0ID0gZGF0YSA9PiB7XG4gIHNlbmRNc2dUb0ZDTChcIkZDTDpWSUVXOlJFU1BPTlNFXCIsIHtcbiAgICBmX3R5cGU6IFwiUG9sbGluZ1Jlc3BvbnNlXCIsXG4gICAgZl92c246IFwiMS4wLjBcIixcbiAgICBzdGF0dXM6IFwiUkVESVJFQ1RcIixcbiAgICByZWFzb246IG51bGwsXG4gICAgZGF0YTogZGF0YVxuICB9KTtcbn07XG5cbmNvbnN0IFNFUlZJQ0VfUFJBR01BID0ge1xuICBmX3R5cGU6IFwiU2VydmljZVwiLFxuICBmX3ZzbjogXCIxLjAuMFwiXG59O1xuY29uc3QgSURFTlRJVFlfUFJBR01BID0ge1xuICBmX3R5cGU6IFwiSWRlbnRpdHlcIixcbiAgZl92c246IFwiMS4wLjBcIlxufTtcbmNvbnN0IFVTRVJfUFJBR01BID0ge1xuICBmX3R5cGU6IFwiVVNFUlwiLFxuICBmX3ZzbjogXCIxLjAuMFwiXG59O1xuY29uc3QgUE9MTElOR19SRVNQT05TRV9QUkFHTUEgPSB7XG4gIGZfdHlwZTogXCJQb2xsaW5nUmVzcG9uc2VcIixcbiAgZl92c246IFwiMS4wLjBcIlxufTtcbmNvbnN0IENPTVBPU0lURV9TSUdOQVRVUkVfUFJBR01BID0ge1xuICBmX3R5cGU6IFwiQ29tcG9zaXRlU2lnbmF0dXJlXCIsXG4gIGZfdnNuOiBcIjEuMC4wXCJcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IENvbXBvc2l0ZVNpZ25hdHVyZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkciAtIEZsb3cgQWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IGtleUlkIC0gS2V5IElEXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gU2lnbmF0dXJlIGFzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBDb21wb3NpdGVTaWduYXR1cmUoYWRkciwga2V5SWQsIHNpZ25hdHVyZSkge1xuICB0aGlzLmZfdHlwZSA9IENPTVBPU0lURV9TSUdOQVRVUkVfUFJBR01BLmZfdHlwZTtcbiAgdGhpcy5mX3ZzbiA9IENPTVBPU0lURV9TSUdOQVRVUkVfUFJBR01BLmZfdnNuO1xuICB0aGlzLmFkZHIgPSB3aXRoUHJlZml4KGFkZHIpO1xuICB0aGlzLmtleUlkID0gTnVtYmVyKGtleUlkKTtcbiAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5cbmNvbnN0IHJpZ2h0UGFkZGVkSGV4QnVmZmVyID0gKHZhbHVlLCBwYWQpID0+IEJ1ZmZlci5mcm9tKHZhbHVlLnBhZEVuZChwYWQgKiAyLCBcIjBcIiksIFwiaGV4XCIpO1xuY29uc3QgbGVmdFBhZGRlZEhleEJ1ZmZlciA9ICh2YWx1ZSwgcGFkKSA9PiBCdWZmZXIuZnJvbSh2YWx1ZS5wYWRTdGFydChwYWQgKiAyLCBcIjBcIiksIFwiaGV4XCIpO1xuY29uc3QgYWRkcmVzc0J1ZmZlciA9IGFkZHIgPT4gbGVmdFBhZGRlZEhleEJ1ZmZlcihhZGRyLCA4KTtcbmNvbnN0IG5vbmNlQnVmZmVyID0gbm9uY2UgPT4gQnVmZmVyLmZyb20obm9uY2UsIFwiaGV4XCIpO1xuY29uc3QgZW5jb2RlQWNjb3VudFByb29mID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhZGRyZXNzLFxuICAgIG5vbmNlLFxuICAgIGFwcElkZW50aWZpZXJcbiAgfSA9IF9yZWY7XG4gIGxldCBpbmNsdWRlRG9tYWluVGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICBpbnZhcmlhbnQoYWRkcmVzcywgXCJFbmNvZGUgTWVzc2FnZSBGb3IgUHJvdmFibGUgQXV0aG4gRXJyb3I6IGFkZHJlc3MgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQobm9uY2UsIFwiRW5jb2RlIE1lc3NhZ2UgRm9yIFByb3ZhYmxlIEF1dGhuIEVycm9yOiBub25jZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudChhcHBJZGVudGlmaWVyLCBcIkVuY29kZSBNZXNzYWdlIEZvciBQcm92YWJsZSBBdXRobiBFcnJvcjogYXBwSWRlbnRpZmllciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudChub25jZS5sZW5ndGggPj0gNjQsIFwiRW5jb2RlIE1lc3NhZ2UgRm9yIFByb3ZhYmxlIEF1dGhuIEVycm9yOiBub25jZSBtdXN0IGJlIG1pbmltdW0gb2YgMzIgYnl0ZXNcIik7XG4gIGNvbnN0IEFDQ09VTlRfUFJPT0ZfRE9NQUlOX1RBRyA9IHJpZ2h0UGFkZGVkSGV4QnVmZmVyKEJ1ZmZlci5mcm9tKFwiRkNMLUFDQ09VTlQtUFJPT0YtVjAuMFwiKS50b1N0cmluZyhcImhleFwiKSwgMzIpO1xuICBpZiAoaW5jbHVkZURvbWFpblRhZykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtBQ0NPVU5UX1BST09GX0RPTUFJTl9UQUcsIGVuY29kZShbYXBwSWRlbnRpZmllciwgYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KGFkZHJlc3MpKSwgbm9uY2VCdWZmZXIobm9uY2UpXSldKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlKFthcHBJZGVudGlmaWVyLCBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgoYWRkcmVzcykpLCBub25jZUJ1ZmZlcihub25jZSldKS50b1N0cmluZyhcImhleFwiKTtcbn07XG5cbmZ1bmN0aW9uIGluamVjdEV4dFNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAoc2VydmljZS50eXBlID09PSBcImF1dGhuXCIgJiYgc2VydmljZS5lbmRwb2ludCAhPSBudWxsKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHdpbmRvdy5mY2xfZXh0ZW5zaW9ucykpIHtcbiAgICAgIHdpbmRvdy5mY2xfZXh0ZW5zaW9ucyA9IFtdO1xuICAgIH1cbiAgICB3aW5kb3cuZmNsX2V4dGVuc2lvbnMucHVzaChzZXJ2aWNlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oXCJBdXRobiBzZXJ2aWNlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG59XG5cbnZhciBpbmRleCQyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNlbmRNc2dUb0ZDTDogc2VuZE1zZ1RvRkNMLFxuICByZWFkeTogcmVhZHksXG4gIGNsb3NlOiBjbG9zZSxcbiAgYXBwcm92ZTogYXBwcm92ZSxcbiAgZGVjbGluZTogZGVjbGluZSxcbiAgcmVkaXJlY3Q6IHJlZGlyZWN0LFxuICBvbk1lc3NhZ2VGcm9tRkNMOiBvbk1lc3NhZ2VGcm9tRkNMLFxuICBlbmNvZGVNZXNzYWdlRnJvbVNpZ25hYmxlOiBlbmNvZGVNZXNzYWdlRnJvbVNpZ25hYmxlLFxuICBDb21wb3NpdGVTaWduYXR1cmU6IENvbXBvc2l0ZVNpZ25hdHVyZSxcbiAgZW5jb2RlQWNjb3VudFByb29mOiBlbmNvZGVBY2NvdW50UHJvb2YsXG4gIGluamVjdEV4dFNlcnZpY2U6IGluamVjdEV4dFNlcnZpY2Vcbn0pO1xuXG5jb25zdCBBQ0NPVU5UX1BST09GID0gXCJBQ0NPVU5UX1BST09GXCI7XG5jb25zdCBVU0VSX1NJR05BVFVSRSA9IFwiVVNFUl9TSUdOQVRVUkVcIjtcbmNvbnN0IHZhbGlkYXRlQXJncyA9IGFyZ3MgPT4ge1xuICBpZiAoYXJncy5hcHBJZGVudGlmaWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwSWRlbnRpZmllcixcbiAgICAgIGFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIHNpZ25hdHVyZXNcbiAgICB9ID0gYXJncztcbiAgICBpbnZhcmlhbnQoaXNTdHJpbmcoYXBwSWRlbnRpZmllciksIFwidmVyaWZ5QWNjb3VudFByb29mKHsgYXBwSWRlbnRpZmllciB9KSAtLSBhcHBJZGVudGlmaWVyIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgaW52YXJpYW50KGlzU3RyaW5nKGFkZHJlc3MpICYmIHNhbnNQcmVmaXgoYWRkcmVzcykubGVuZ3RoID09PSAxNiwgXCJ2ZXJpZnlBY2NvdW50UHJvb2YoeyBhZGRyZXNzIH0pIC0tIGFkZHJlc3MgbXVzdCBiZSBhIHZhbGlkIGFkZHJlc3NcIik7XG4gICAgaW52YXJpYW50KC9eWzAtOWEtZl0rJC9pLnRlc3Qobm9uY2UpLCBcIm5vbmNlIG11c3QgYmUgYSBoZXggc3RyaW5nXCIpO1xuICAgIGludmFyaWFudChBcnJheS5pc0FycmF5KHNpZ25hdHVyZXMpICYmIHNpZ25hdHVyZXMuZXZlcnkoKHNpZywgaSwgYXJyKSA9PiBzaWcuZl90eXBlID09PSBcIkNvbXBvc2l0ZVNpZ25hdHVyZVwiKSwgXCJNdXN0IGluY2x1ZGUgYW4gQXJyYXkgb2YgQ29tcG9zaXRlU2lnbmF0dXJlcyB0byB2ZXJpZnlcIik7XG4gICAgaW52YXJpYW50KHNpZ25hdHVyZXMubWFwKGNzID0+IGNzLmFkZHIpLmV2ZXJ5KChhZGRyLCBpLCBhcnIpID0+IGFkZHIgPT09IGFyclswXSksIFwiVXNlciBzaWduYXR1cmVzIHRvIGJlIHZlcmlmaWVkIG11c3QgYmUgZnJvbSBhIHNpbmdsZSBhY2NvdW50IGFkZHJlc3NcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBjb21wU2lnc1xuICAgIH0gPSBhcmdzO1xuICAgIGludmFyaWFudCgvXlswLTlhLWZdKyQvaS50ZXN0KG1lc3NhZ2UpLCBcIlNpZ25lZCBtZXNzYWdlIG11c3QgYmUgYSBoZXggc3RyaW5nXCIpO1xuICAgIGludmFyaWFudChpc1N0cmluZyhhZGRyZXNzKSAmJiBzYW5zUHJlZml4KGFkZHJlc3MpLmxlbmd0aCA9PT0gMTYsIFwidmVyaWZ5VXNlclNpZ25hdHVyZXMoeyBhZGRyZXNzIH0pIC0tIGFkZHJlc3MgbXVzdCBiZSBhIHZhbGlkIGFkZHJlc3NcIik7XG4gICAgaW52YXJpYW50KEFycmF5LmlzQXJyYXkoY29tcFNpZ3MpICYmIGNvbXBTaWdzLmV2ZXJ5KChzaWcsIGksIGFycikgPT4gc2lnLmZfdHlwZSA9PT0gXCJDb21wb3NpdGVTaWduYXR1cmVcIiksIFwiTXVzdCBpbmNsdWRlIGFuIEFycmF5IG9mIENvbXBvc2l0ZVNpZ25hdHVyZXMgdG8gdmVyaWZ5XCIpO1xuICAgIGludmFyaWFudChjb21wU2lncy5tYXAoY3MgPT4gY3MuYWRkcikuZXZlcnkoKGFkZHIsIGksIGFycikgPT4gYWRkciA9PT0gYXJyWzBdKSwgXCJVc2VyIHNpZ25hdHVyZXMgdG8gYmUgdmVyaWZpZWQgbXVzdCBiZSBmcm9tIGEgc2luZ2xlIGFjY291bnQgYWRkcmVzc1wiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gVE9ETzogcGFzcyBpbiBvcHRpb24gZm9yIGNvbnRyYWN0IGJ1dCB3ZSdyZSBjb25uZWN0ZWQgdG8gdGVzdG5ldFxuLy8gbG9nIGFkZHJlc3MgKyBuZXR3b3JrIC0+IGluIHN5bmM/XG5jb25zdCBnZXRWZXJpZnlTaWduYXR1cmVzU2NyaXB0ID0gYXN5bmMgKHNpZywgb3B0cykgPT4ge1xuICBjb25zdCB2ZXJpZnlGdW5jdGlvbiA9IHNpZyA9PT0gXCJBQ0NPVU5UX1BST09GXCIgPyBcInZlcmlmeUFjY291bnRQcm9vZlNpZ25hdHVyZXNcIiA6IFwidmVyaWZ5VXNlclNpZ25hdHVyZXNcIjtcbiAgbGV0IG5ldHdvcmsgPSBhd2FpdCBnZXRDaGFpbklkKG9wdHMpO1xuICBsZXQgZmNsQ3J5cHRvQ29udHJhY3Q7XG4gIGludmFyaWFudChvcHRzLmZjbENyeXB0b0NvbnRyYWN0IHx8IG5ldHdvcmsgPT09IFwidGVzdG5ldFwiIHx8IG5ldHdvcmsgPT09IFwibWFpbm5ldFwiLCBcIiR7dmVyaWZ5RnVuY3Rpb259KHsgZmNsQ3J5cHRvQ29udHJhY3QgfSkgLS0gZmNsQ3J5cHRvIGNvbnRyYWN0IGFkZHJlc3MgbXVzdCBiZSBzZXQgZm9yIG5vbi1tYWlubmV0L3Rlc3RuZXQgbmV0d29ya3NcIik7XG4gIGlmIChvcHRzLmZjbENyeXB0b0NvbnRyYWN0KSB7XG4gICAgZmNsQ3J5cHRvQ29udHJhY3QgPSBvcHRzLmZjbENyeXB0b0NvbnRyYWN0O1xuICB9IGVsc2Uge1xuICAgIGZjbENyeXB0b0NvbnRyYWN0ID0gbmV0d29yayA9PT0gXCJ0ZXN0bmV0XCIgPyBcIjB4NzRkYWE2ZjljN2VmMjRiMVwiIDogXCIweGI0YjgyYTFjOWQyMWQyODRcIjtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgaW1wb3J0IEZDTENyeXB0byBmcm9tICR7ZmNsQ3J5cHRvQ29udHJhY3R9XG5cbiAgICAgIHB1YiBmdW4gbWFpbihcbiAgICAgICAgICBhZGRyZXNzOiBBZGRyZXNzLCBcbiAgICAgICAgICBtZXNzYWdlOiBTdHJpbmcsIFxuICAgICAgICAgIGtleUluZGljZXM6IFtJbnRdLCBcbiAgICAgICAgICBzaWduYXR1cmVzOiBbU3RyaW5nXVxuICAgICAgKTogQm9vbCB7XG4gICAgICAgIHJldHVybiBGQ0xDcnlwdG8uJHt2ZXJpZnlGdW5jdGlvbn0oYWRkcmVzczogYWRkcmVzcywgbWVzc2FnZTogbWVzc2FnZSwga2V5SW5kaWNlczoga2V5SW5kaWNlcywgc2lnbmF0dXJlczogc2lnbmF0dXJlcylcbiAgICAgIH1cbiAgICBgO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFZlcmlmeSBhIHZhbGlkIGFjY291bnQgcHJvb2Ygc2lnbmF0dXJlIG9yIHNpZ25hdHVyZXMgZm9yIGFuIGFjY291bnQgb24gRmxvdy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwSWRlbnRpZmllciAtIEEgbWVzc2FnZSBzdHJpbmcgaW4gaGV4YWRlY2ltYWwgZm9ybWF0XG4gKiBAcGFyYW0ge29iamVjdH0gYWNjb3VudFByb29mRGF0YSAtIEFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGFkZHJlc3MsIG5vbmNlLCBhbmQgc2lnbmF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRQcm9vZkRhdGEuYWRkcmVzcyAtIEEgRmxvdyBhY2NvdW50IGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50UHJvb2ZEYXRhLm5vbmNlIC0gQSByYW5kb20gc3RyaW5nIGluIGhleGFkZWNpbWFsIGZvcm1hdCAobWluaW11bSAzMiBieXRlcyBpbiB0b3RhbCwgaS5lIDY0IGhleCBjaGFyYWN0ZXJzKVxuICogQHBhcmFtIHtvYmplY3RbXX0gYWNjb3VudFByb29mRGF0YS5zaWduYXR1cmVzIC0gQW4gYXJyYXkgb2YgY29tcG9zaXRlIHNpZ25hdHVyZXMgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdHM9e31dIC0gT3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZjbENyeXB0b0NvbnRyYWN0IC0gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgRmxvdyBhY2NvdW50IGFkZHJlc3Mgd2hlcmUgdGhlIEZDTENyeXB0byBjb250cmFjdCBpcyBkZXBsb3llZFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogIGNvbnN0IGFjY291bnRQcm9vZkRhdGEgPSB7XG4gKiAgIGFkZHJlc3M6IFwiMHgxMjNcIixcbiAqICAgbm9uY2U6IFwiRjAxMjNcIlxuICogICBzaWduYXR1cmVzOiBbe2ZfdHlwZTogXCJDb21wb3NpdGVTaWduYXR1cmVcIiwgZl92c246IFwiMS4wLjBcIiwgYWRkcjogXCIweDEyM1wiLCBrZXlJZDogMCwgc2lnbmF0dXJlOiBcImFiYzEyM1wifV0sXG4gKiAgfVxuICpcbiAqICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgZmNsLkFwcFV0aWxzLnZlcmlmeUFjY291bnRQcm9vZihcbiAqICAgIFwiQXdlc29tZUFwcElkXCIsXG4gKiAgICBhY2NvdW50UHJvb2ZEYXRhLFxuICogICAge2ZjbENyeXB0b0NvbnRyYWN0fVxuICogIClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QWNjb3VudFByb29mKGFwcElkZW50aWZpZXIsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhZGRyZXNzLFxuICAgIG5vbmNlLFxuICAgIHNpZ25hdHVyZXNcbiAgfSA9IF9yZWY7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFsaWRhdGVBcmdzKHtcbiAgICBhcHBJZGVudGlmaWVyLFxuICAgIGFkZHJlc3MsXG4gICAgbm9uY2UsXG4gICAgc2lnbmF0dXJlc1xuICB9KTtcbiAgY29uc3QgbWVzc2FnZSA9IGVuY29kZUFjY291bnRQcm9vZih7XG4gICAgYWRkcmVzcyxcbiAgICBub25jZSxcbiAgICBhcHBJZGVudGlmaWVyXG4gIH0sIGZhbHNlKTtcbiAgbGV0IHNpZ25hdHVyZXNBcnIgPSBbXTtcbiAgbGV0IGtleUluZGljZXMgPSBbXTtcbiAgZm9yIChjb25zdCBlbCBvZiBzaWduYXR1cmVzKSB7XG4gICAgc2lnbmF0dXJlc0Fyci5wdXNoKGVsLnNpZ25hdHVyZSk7XG4gICAga2V5SW5kaWNlcy5wdXNoKGVsLmtleUlkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBxdWVyeSh7XG4gICAgY2FkZW5jZTogYXdhaXQgZ2V0VmVyaWZ5U2lnbmF0dXJlc1NjcmlwdChBQ0NPVU5UX1BST09GLCBvcHRzKSxcbiAgICBhcmdzOiAoYXJnLCB0KSA9PiBbYXJnKHdpdGhQcmVmaXgoYWRkcmVzcyksIHQuQWRkcmVzcyksIGFyZyhtZXNzYWdlLCB0LlN0cmluZyksIGFyZyhrZXlJbmRpY2VzLCB0LkFycmF5KHQuSW50KSksIGFyZyhzaWduYXR1cmVzQXJyLCB0LkFycmF5KHQuU3RyaW5nKSldXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVmVyaWZ5IGEgdmFsaWQgc2lnbmF0dXJlL3MgZm9yIGFuIGFjY291bnQgb24gRmxvdy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEEgbWVzc2FnZSBzdHJpbmcgaW4gaGV4YWRlY2ltYWwgZm9ybWF0XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wU2lncyAtIEFuIGFycmF5IG9mIENvbXBvc2l0ZSBTaWduYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcFNpZ3NbXS5hZGRyIC0gVGhlIGFjY291bnQgYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvbXBTaWdzW10ua2V5SWQgLSBUaGUgYWNjb3VudCBrZXlJZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBTaWdzW10uc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmNsQ3J5cHRvQ29udHJhY3QgLSBBbiBvcHRpb25hbCBvdmVycmlkZSBvZiBGbG93IGFjY291bnQgYWRkcmVzcyB3aGVyZSB0aGUgRkNMQ3J5cHRvIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGZjbC5BcHBVdGlscy52ZXJpZnlVc2VyU2lnbmF0dXJlcyhcbiAqICAgIEJ1ZmZlci5mcm9tKCdGT08nKS50b1N0cmluZyhcImhleFwiKSxcbiAqICAgIFt7Zl90eXBlOiBcIkNvbXBvc2l0ZVNpZ25hdHVyZVwiLCBmX3ZzbjogXCIxLjAuMFwiLCBhZGRyOiBcIjB4MTIzXCIsIGtleUlkOiAwLCBzaWduYXR1cmU6IFwiYWJjMTIzXCJ9XSxcbiAqICAgIHtmY2xDcnlwdG9Db250cmFjdH1cbiAqICApXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVVzZXJTaWduYXR1cmVzJDEobWVzc2FnZSwgY29tcFNpZ3MpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBjb25zdCBhZGRyZXNzID0gd2l0aFByZWZpeChjb21wU2lnc1swXS5hZGRyKTtcbiAgdmFsaWRhdGVBcmdzKHtcbiAgICBtZXNzYWdlLFxuICAgIGFkZHJlc3MsXG4gICAgY29tcFNpZ3NcbiAgfSk7XG4gIGxldCBzaWduYXR1cmVzQXJyID0gW107XG4gIGxldCBrZXlJbmRpY2VzID0gW107XG4gIGZvciAoY29uc3QgZWwgb2YgY29tcFNpZ3MpIHtcbiAgICBzaWduYXR1cmVzQXJyLnB1c2goZWwuc2lnbmF0dXJlKTtcbiAgICBrZXlJbmRpY2VzLnB1c2goZWwua2V5SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5KHtcbiAgICBjYWRlbmNlOiBhd2FpdCBnZXRWZXJpZnlTaWduYXR1cmVzU2NyaXB0KFVTRVJfU0lHTkFUVVJFLCBvcHRzKSxcbiAgICBhcmdzOiAoYXJnLCB0KSA9PiBbYXJnKGFkZHJlc3MsIHQuQWRkcmVzcyksIGFyZyhtZXNzYWdlLCB0LlN0cmluZyksIGFyZyhrZXlJbmRpY2VzLCB0LkFycmF5KHQuSW50KSksIGFyZyhzaWduYXR1cmVzQXJyLCB0LkFycmF5KHQuU3RyaW5nKSldXG4gIH0pO1xufVxuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB2ZXJpZnlBY2NvdW50UHJvb2Y6IHZlcmlmeUFjY291bnRQcm9vZixcbiAgdmVyaWZ5VXNlclNpZ25hdHVyZXM6IHZlcmlmeVVzZXJTaWduYXR1cmVzJDFcbn0pO1xuXG4vKipcbiAqIFZlcmlmeSBhIHZhbGlkIHNpZ25hdHVyZS9zIGZvciBhbiBhY2NvdW50IG9uIEZsb3cuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAnMS4wLjAtYWxwaGEuMCcsIHVzZSBBcHBVdGlscy52ZXJpZnlVc2VyU2lnbmF0dXJlcyBpbnN0ZWFkXG4gKlxuICovXG5jb25zdCB2ZXJpZnlVc2VyU2lnbmF0dXJlcyA9IGxvZy5kZXByZWNhdGUoe1xuICBwa2c6IFwiRkNMXCIsXG4gIHN1YmplY3Q6IFwiZmNsLnZlcmlmeVVzZXJTaWduYXR1cmVzKClcIixcbiAgbWVzc2FnZTogXCJQbGVhc2UgdXNlIGZjbC5BcHBVdGlscy52ZXJpZnlVc2VyU2lnbmF0dXJlcygpXCIsXG4gIGNhbGxiYWNrOiBmdW5jdGlvbiB2ZXJpZnlVc2VyU2lnbmF0dXJlcyhtZXNzYWdlLCBjb21wU2lncykge1xuICAgIHJldHVybiB2ZXJpZnlVc2VyU2lnbmF0dXJlcyQxKG1lc3NhZ2UsIGNvbXBTaWdzKTtcbiAgfVxufSk7XG5cbmNvbnN0IHNlcmlhbGl6ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHJlc29sdmVGdW5jdGlvbiA9IGF3YWl0IGNvbmZpZyQxLmZpcnN0KFtcInNkay5yZXNvbHZlXCJdLCBvcHRzLnJlc29sdmUgfHwgcmVzb2x2ZSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSBhcmdzID0gYXdhaXQgcGlwZShpbnRlcmFjdGlvbigpLCBhcmdzKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNyZWF0ZVNpZ25hYmxlVm91Y2hlcihhd2FpdCByZXNvbHZlRnVuY3Rpb24oYXJncykpLCBudWxsLCAyKTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ0xlbnMocmVnZXgpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhhd2FpdCBjb25maWcoKS53aGVyZShyZWdleCkpLm1hcChfcmVmID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICByZXR1cm4gW2tleS5yZXBsYWNlKHJlZ2V4LCBcIlwiKSwgdmFsdWVdO1xuICB9KSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuVHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiQG9uZmxvdy90eXBlZGVmc1wiKS5UcmFuc2FjdGlvblN0YXR1c30gVHJhbnNhY3Rpb25TdGF0dXNcbiAqL1xuXG5jb25zdCBSQVRFJDEgPSAyNTAwO1xuY29uc3QgUE9MTCA9IFwiUE9MTFwiO1xuY29uc3QgZmV0Y2hUeFN0YXR1cyA9IGFzeW5jIHRyYW5zYWN0aW9uSWQgPT4ge1xuICByZXR1cm4gc2VuZChbZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25JZCldKS50aGVuKGRlY29kZSk7XG59O1xuY29uc3QgaXNFeHBpcmVkID0gdHggPT4gdHguc3RhdHVzID09PSA1O1xuY29uc3QgaXNTZWFsZWQgPSB0eCA9PiB0eC5zdGF0dXMgPj0gNDtcbmNvbnN0IGlzRXhlY3V0ZWQgPSB0eCA9PiB0eC5zdGF0dXMgPj0gMztcbmNvbnN0IGlzRmluYWxpemVkID0gdHggPT4gdHguc3RhdHVzID49IDI7XG5jb25zdCBpc1BlbmRpbmcgPSB0eCA9PiB0eC5zdGF0dXMgPj0gMTtcbmNvbnN0IGlzVW5rbm93biA9IHR4ID0+IHR4LnN0YXR1cyA+PSAwO1xuY29uc3QgaXNEaWZmID0gKGN1ciwgbmV4dCkgPT4ge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3VyKSAhPT0gSlNPTi5zdHJpbmdpZnkobmV4dCk7XG59O1xuY29uc3QgSEFORExFUlMkMyA9IHtcbiAgW0lOSVRdOiBhc3luYyBjdHggPT4ge1xuICAgIGN0eC5zZW5kU2VsZihQT0xMKTtcbiAgfSxcbiAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBVUERBVEVEJDIsIGN0eC5hbGwoKSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC51bnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gIH0sXG4gIFtTTkFQU0hPVCQxXTogYXN5bmMgKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0dGVyLnJlcGx5KGN0eC5hbGwoKSk7XG4gIH0sXG4gIFtQT0xMXTogYXN5bmMgY3R4ID0+IHtcbiAgICBsZXQgdHg7XG4gICAgdHJ5IHtcbiAgICAgIHR4ID0gYXdhaXQgZmV0Y2hUeFN0YXR1cyhjdHguc2VsZigpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY3R4LmZhdGFsRXJyb3IoZSk7XG4gICAgfVxuICAgIGlmICghaXNTZWFsZWQodHgpKSBzZXRUaW1lb3V0KCgpID0+IGN0eC5zZW5kU2VsZihQT0xMKSwgUkFURSQxKTtcbiAgICBpZiAoaXNEaWZmKGN0eC5hbGwoKSwgdHgpKSBjdHguYnJvYWRjYXN0KFVQREFURUQkMiwgdHgpO1xuICAgIGN0eC5tZXJnZSh0eCk7XG4gIH1cbn07XG5jb25zdCBzY29wZWQgPSB0cmFuc2FjdGlvbklkID0+IHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkID09PSBcIm9iamVjdFwiKSB0cmFuc2FjdGlvbklkID0gdHJhbnNhY3Rpb25JZC50cmFuc2FjdGlvbklkO1xuICBpZiAodHJhbnNhY3Rpb25JZCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2FjdGlvbklkIHJlcXVpcmVkXCIpO1xuICByZXR1cm4gdHJhbnNhY3Rpb25JZDtcbn07XG5jb25zdCBzcGF3blRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25JZCA9PiB7XG4gIHJldHVybiBzcGF3bihIQU5ETEVSUyQzLCBzY29wZWQodHJhbnNhY3Rpb25JZCkpO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgU3Vic2NyaXB0aW9uQ2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TdGF0dXN9IHR4U3RhdHVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGludGVyYWN0aW5nIHdpdGggYSB0cmFuc2FjdGlvblxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNhY3Rpb25JZCAtIFRoZSB0cmFuc2FjdGlvbiBJRFxuICogQHJldHVybnMge3tcbiAqICAgIHNuYXBzaG90OiBmdW5jdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uU3RhdHVzPixcbiAqICAgIHN1YnNjcmliZTogZnVuY3Rpb24oU3Vic2NyaXB0aW9uQ2FsbGJhY2spOiBmdW5jdGlvbigpOiB2b2lkLFxuICogICAgb25jZUZpbmFsaXplZDogZnVuY3Rpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvblN0YXR1cz4sXG4gKiAgICBvbmNlRXhlY3V0ZWQ6IGZ1bmN0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb25TdGF0dXM+LFxuICogICAgb25jZVNlYWxlZDogZnVuY3Rpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvblN0YXR1cz5cbiAqIH19XG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQpIHtcbiAgZnVuY3Rpb24gc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHNuYXBzaG90ZXIodHJhbnNhY3Rpb25JZCwgc3Bhd25UcmFuc2FjdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1YnNjcmliZXIoc2NvcGVkKHRyYW5zYWN0aW9uSWQpLCBzcGF3blRyYW5zYWN0aW9uLCBjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gb25jZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5uZXJPbmNlKCkge1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgY29uc3Qgc3VwcHJlc3MgPSBvcHRzLnN1cHByZXNzIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWIgPSBzdWJzY3JpYmUoKHR4U3RhdHVzLCBlcnJvcikgPT4ge1xuICAgICAgICAgIGlmICgoZXJyb3IgfHwgdHhTdGF0dXMuc3RhdHVzQ29kZSkgJiYgIXN1cHByZXNzKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IgfHwgdHhTdGF0dXMuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmVkaWNhdGUodHhTdGF0dXMpKSB7XG4gICAgICAgICAgICByZXNvbHZlKHR4U3RhdHVzKTtcbiAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzbmFwc2hvdCxcbiAgICBzdWJzY3JpYmUsXG4gICAgb25jZUZpbmFsaXplZDogb25jZShpc0ZpbmFsaXplZCksXG4gICAgb25jZUV4ZWN1dGVkOiBvbmNlKGlzRXhlY3V0ZWQpLFxuICAgIG9uY2VTZWFsZWQ6IG9uY2UoaXNTZWFsZWQpXG4gIH07XG59XG50cmFuc2FjdGlvbi5pc1Vua25vd24gPSBpc1Vua25vd247XG50cmFuc2FjdGlvbi5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG50cmFuc2FjdGlvbi5pc0ZpbmFsaXplZCA9IGlzRmluYWxpemVkO1xudHJhbnNhY3Rpb24uaXNFeGVjdXRlZCA9IGlzRXhlY3V0ZWQ7XG50cmFuc2FjdGlvbi5pc1NlYWxlZCA9IGlzU2VhbGVkO1xudHJhbnNhY3Rpb24uaXNFeHBpcmVkID0gaXNFeHBpcmVkO1xuXG5jb25zdCBSQVRFID0gMTAwMDA7XG5jb25zdCBVUERBVEVEJDEgPSBcIlVQREFURURcIjtcbmNvbnN0IFRJQ0sgPSBcIlRJQ0tcIjtcbmNvbnN0IEhJR0hfV0FURVJfTUFSSyA9IFwiaHdtXCI7XG5jb25zdCBzY2hlZHVsZVRpY2sgPSBhc3luYyBjdHggPT4ge1xuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiBjdHguc2VuZFNlbGYoVElDSyksIGF3YWl0IGNvbmZpZyQxKCkuZ2V0KFwiZmNsLmV2ZW50UG9sbFJhdGVcIiwgUkFURSkpO1xufTtcbmNvbnN0IEhBTkRMRVJTJDIgPSB7XG4gIFtUSUNLXTogYXN5bmMgY3R4ID0+IHtcbiAgICBpZiAoIWN0eC5oYXNTdWJzKCkpIHJldHVybjtcbiAgICBsZXQgaHdtID0gY3R4LmdldChISUdIX1dBVEVSX01BUkspO1xuICAgIGlmIChod20gPT0gbnVsbCkge1xuICAgICAgY3R4LnB1dChISUdIX1dBVEVSX01BUkssIGF3YWl0IGJsb2NrKCkpO1xuICAgICAgY3R4LnB1dChUSUNLLCBhd2FpdCBzY2hlZHVsZVRpY2soY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXh0ID0gYXdhaXQgYmxvY2soKTtcbiAgICAgIGN0eC5wdXQoSElHSF9XQVRFUl9NQVJLLCBuZXh0KTtcbiAgICAgIGlmIChod20uaGVpZ2h0IDwgbmV4dC5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHNlbmQoW2dldEV2ZW50c0F0QmxvY2tIZWlnaHRSYW5nZShjdHguc2VsZigpLCBod20uaGVpZ2h0ICsgMSwgbmV4dC5oZWlnaHQpXSkudGhlbihkZWNvZGUpO1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRhdGEpIGN0eC5icm9hZGNhc3QoVVBEQVRFRCQxLCBkLmRhdGEpO1xuICAgICAgfVxuICAgICAgY3R4LnB1dChUSUNLLCBhd2FpdCBzY2hlZHVsZVRpY2soY3R4KSk7XG4gICAgfVxuICB9LFxuICBbU1VCU0NSSUJFXTogYXN5bmMgKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgaWYgKCFjdHguaGFzU3VicygpKSB7XG4gICAgICBjdHgucHV0KFRJQ0ssIGF3YWl0IHNjaGVkdWxlVGljayhjdHgpKTtcbiAgICB9XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC51bnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgaWYgKCFjdHguaGFzU3VicygpKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3R4LmdldChUSUNLKSk7XG4gICAgICBjdHguZGVsZXRlKFRJQ0spO1xuICAgICAgY3R4LmRlbGV0ZShISUdIX1dBVEVSX01BUkspO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHNwYXduRXZlbnRzID0ga2V5ID0+IHNwYXduKEhBTkRMRVJTJDIsIGtleSk7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuRXZlbnR9IEV2ZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdWJzY3JpYmVPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHN1YnNjcmliZSAtIFRoZSBzdWJzY3JpYmUgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU3Vic2NyaXB0aW9uQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtFdmVudH1cbiAqL1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIFN1YnNjcmliZSB0byBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIHZhbGlkIGV2ZW50IG5hbWVcbiAqIEByZXR1cm5zIHtTdWJzY3JpYmVPYmplY3R9XG4gKiBcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBmY2wgZnJvbSBcIkBvbmZsb3cvZmNsXCJcbiAqIGZjbC5ldmVudHMoZXZlbnROYW1lKS5zdWJzY3JpYmUoKGV2ZW50KSA9PiBjb25zb2xlLmxvZyhldmVudCkpXG4gKi9cbmZ1bmN0aW9uIGV2ZW50cyhrZXkpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gLSBTdWJzY3JpYmUgdG8gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3Vic2NyaXB0aW9uQ2FsbGJhY2t9XG4gICAgICovXG4gICAgc3Vic2NyaWJlOiBjYWxsYmFjayA9PiBzdWJzY3JpYmVyKGtleSwgc3Bhd25FdmVudHMsIGNhbGxiYWNrKVxuICB9O1xufVxuXG5jb25zdCBzdHViID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFBsYXRmb3JtIHNwZWNpZmljIENvcmUgU3RyYXRlZ2llcyBhcmUgbm90IGluaXRpYWxpemVkYCk7XG59O1xuY29uc3Qgc3R1YkNvcmVTdHJhdGVnaWVzID0ge1xuICBbQ09SRV9TVFJBVEVHSUVTW1wiRVhUL1JQQ1wiXV06IHN0dWIsXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJIVFRQL1BPU1RcIl1dOiBzdHViLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiSUZSQU1FL1JQQ1wiXV06IHN0dWIsXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJQT1AvUlBDXCJdXTogc3R1YixcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIlRBQi9SUENcIl1dOiBzdHViLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiRVhUL1JQQ1wiXV06IHN0dWJcbn07XG5jb25zdCBzdXBwb3J0ZWRQbHVnaW5zID0gW1wiU2VydmljZVBsdWdpblwiXTtcbmNvbnN0IHN1cHBvcnRlZFNlcnZpY2VQbHVnaW5zID0gW1wiZGlzY292ZXJ5LXNlcnZpY2VcIl07XG5jb25zdCB2YWxpZGF0ZURpc2NvdmVyeVBsdWdpbiA9IHNlcnZpY2VQbHVnaW4gPT4ge1xuICBjb25zdCB7XG4gICAgc2VydmljZXMsXG4gICAgc2VydmljZVN0cmF0ZWd5XG4gIH0gPSBzZXJ2aWNlUGx1Z2luO1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzZXJ2aWNlcykgJiYgc2VydmljZXMubGVuZ3RoLCBcIkFycmF5IG9mIERpc2NvdmVyeSBTZXJ2aWNlcyBpcyByZXF1aXJlZFwiKTtcbiAgZm9yIChjb25zdCBkcyBvZiBzZXJ2aWNlcykge1xuICAgIGludmFyaWFudChpc1JlcXVpcmVkKGRzLmZfdHlwZSkgJiYgZHMuZl90eXBlID09PSBcIlNlcnZpY2VcIiwgXCJTZXJ2aWNlIGlzIHJlcXVpcmVkXCIpO1xuICAgIGludmFyaWFudChpc1JlcXVpcmVkKGRzLnR5cGUpICYmIGRzLnR5cGUgPT09IFwiYXV0aG5cIiwgYFNlcnZpY2UgbXVzdCBiZSB0eXBlIGF1dGhuLiBSZWNlaXZlZCAke2RzLnR5cGV9YCk7XG4gICAgaW52YXJpYW50KGRzLm1ldGhvZCBpbiBDT1JFX1NUUkFURUdJRVMgfHwgc2VydmljZVN0cmF0ZWd5Lm1ldGhvZCA9PT0gZHMubWV0aG9kLCBgU2VydmljZSBtZXRob2QgJHtkcy5tZXRob2R9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICBpbnZhcmlhbnQoaXNSZXF1aXJlZChzZXJ2aWNlU3RyYXRlZ3kpLCBcIlNlcnZpY2Ugc3RyYXRlZ3kgaXMgcmVxdWlyZWRcIik7XG4gIGludmFyaWFudChpc1JlcXVpcmVkKHNlcnZpY2VTdHJhdGVneS5tZXRob2QpICYmIGlzU3RyaW5nKHNlcnZpY2VTdHJhdGVneS5tZXRob2QpLCBcIlNlcnZpY2Ugc3RyYXRlZ3kgbWV0aG9kIGlzIHJlcXVpcmVkXCIpO1xuICBpbnZhcmlhbnQoaXNSZXF1aXJlZChzZXJ2aWNlU3RyYXRlZ3kuZXhlYykgJiYgaXNGdW5jKHNlcnZpY2VTdHJhdGVneS5leGVjKSwgXCJTZXJ2aWNlIHN0cmF0ZWd5IGV4ZWMgZnVuY3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gIHJldHVybiB7XG4gICAgZGlzY292ZXJ5U2VydmljZXM6IHNlcnZpY2VzLFxuICAgIHNlcnZpY2VTdHJhdGVneVxuICB9O1xufTtcbmNvbnN0IFNlcnZpY2VSZWdpc3RyeSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvcmVTdHJhdGVnaWVzXG4gIH0gPSBfcmVmO1xuICBsZXQgc2VydmljZXMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdHJhdGVnaWVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhjb3JlU3RyYXRlZ2llcykpO1xuICBjb25zdCBhZGQgPSBzZXJ2aWNlUGx1Z2luID0+IHtcbiAgICBpbnZhcmlhbnQoc3VwcG9ydGVkU2VydmljZVBsdWdpbnMuaW5jbHVkZXMoc2VydmljZVBsdWdpbi50eXBlKSwgYFNlcnZpY2UgUGx1Z2luIHR5cGUgJHtzZXJ2aWNlUGx1Z2luLnR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICBpZiAoc2VydmljZVBsdWdpbi50eXBlID09PSBcImRpc2NvdmVyeS1zZXJ2aWNlXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlzY292ZXJ5U2VydmljZXMsXG4gICAgICAgIHNlcnZpY2VTdHJhdGVneVxuICAgICAgfSA9IHZhbGlkYXRlRGlzY292ZXJ5UGx1Z2luKHNlcnZpY2VQbHVnaW4pO1xuICAgICAgc2V0U2VydmljZXMoZGlzY292ZXJ5U2VydmljZXMpO1xuICAgICAgaWYgKCFzdHJhdGVnaWVzLmhhcyhzZXJ2aWNlU3RyYXRlZ3kubWV0aG9kKSkge1xuICAgICAgICBzdHJhdGVnaWVzLnNldChzZXJ2aWNlU3RyYXRlZ3kubWV0aG9kLCBzZXJ2aWNlU3RyYXRlZ3kuZXhlYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2coe1xuICAgICAgICAgIHRpdGxlOiBgQWRkIFNlcnZpY2UgUGx1Z2luYCxcbiAgICAgICAgICBtZXNzYWdlOiBgU2VydmljZSBzdHJhdGVneSBmb3IgJHtzZXJ2aWNlU3RyYXRlZ3kubWV0aG9kfSBhbHJlYWR5IGV4aXN0c2AsXG4gICAgICAgICAgbGV2ZWw6IExFVkVMUy53YXJuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2VydmljZXMgPSBkaXNjb3ZlcnlTZXJ2aWNlcyA9PiBzZXJ2aWNlcyA9IG5ldyBTZXQoWy4uLmRpc2NvdmVyeVNlcnZpY2VzXSk7XG4gIGNvbnN0IGdldFNlcnZpY2VzID0gKCkgPT4gWy4uLnNlcnZpY2VzXTtcbiAgY29uc3QgZ2V0U3RyYXRlZ3kgPSBtZXRob2QgPT4gc3RyYXRlZ2llcy5nZXQobWV0aG9kKTtcbiAgY29uc3QgZ2V0U3RyYXRlZ2llcyA9ICgpID0+IFsuLi5zdHJhdGVnaWVzLmtleXMoKV07XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBhZGQsXG4gICAgZ2V0U2VydmljZXMsXG4gICAgZ2V0U3RyYXRlZ3ksXG4gICAgZ2V0U3RyYXRlZ2llc1xuICB9KTtcbn07XG5jb25zdCB2YWxpZGF0ZVBsdWdpbnMgPSBwbHVnaW5zID0+IHtcbiAgbGV0IHBsdWdpbnNBcnJheTtcbiAgaW52YXJpYW50KHBsdWdpbnMsIFwiTm8gcGx1Z2lucyBzdXBwbGllZFwiKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgcGx1Z2luc0FycmF5ID0gW3BsdWdpbnNdO1xuICB9IGVsc2Uge1xuICAgIHBsdWdpbnNBcnJheSA9IFsuLi5wbHVnaW5zXTtcbiAgfVxuICBmb3IgKGNvbnN0IHAgb2YgcGx1Z2luc0FycmF5KSB7XG4gICAgaW52YXJpYW50KGlzUmVxdWlyZWQocC5uYW1lKSwgXCJQbHVnaW4gbmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICBpbnZhcmlhbnQoaXNSZXF1aXJlZChwLmZfdHlwZSksIFwiUGx1Z2luIGZfdHlwZSBpcyByZXF1aXJlZFwiKTtcbiAgICBpbnZhcmlhbnQoc3VwcG9ydGVkUGx1Z2lucy5pbmNsdWRlcyhwLmZfdHlwZSksIGBQbHVnaW4gdHlwZSAke3AuZl90eXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbiAgcmV0dXJuIHBsdWdpbnNBcnJheTtcbn07XG5jb25zdCBQbHVnaW5SZWdpc3RyeSA9ICgpID0+IHtcbiAgY29uc3QgcGx1Z2luc01hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0UGx1Z2lucyA9ICgpID0+IHBsdWdpbnNNYXA7XG4gIGNvbnN0IGFkZCA9IHBsdWdpbnMgPT4ge1xuICAgIGNvbnN0IHBsdWdpbnNBcnJheSA9IHZhbGlkYXRlUGx1Z2lucyhwbHVnaW5zKTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGx1Z2luc0FycmF5KSB7XG4gICAgICBwbHVnaW5zTWFwLnNldChwLm5hbWUsIHApO1xuICAgICAgaWYgKHAuZl90eXBlID09PSBcIlNlcnZpY2VQbHVnaW5cIikge1xuICAgICAgICBzZXJ2aWNlUmVnaXN0cnkuYWRkKHApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGFkZCxcbiAgICBnZXRQbHVnaW5zXG4gIH0pO1xufTtcbmxldCBzZXJ2aWNlUmVnaXN0cnk7XG5jb25zdCBnZXRJc1NlcnZpY2VSZWdpc3RyeUluaXRpYWxpemVkID0gKCkgPT4gdHlwZW9mIHNlcnZpY2VSZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpbml0U2VydmljZVJlZ2lzdHJ5ID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGNvcmVTdHJhdGVnaWVzXG4gIH0gPSBfcmVmMjtcbiAgaWYgKGdldElzU2VydmljZVJlZ2lzdHJ5SW5pdGlhbGl6ZWQoKSkge1xuICAgIHJldHVybiBzZXJ2aWNlUmVnaXN0cnk7XG4gIH1cbiAgY29uc3QgX3NlcnZpY2VSZWdpc3RyeSA9IFNlcnZpY2VSZWdpc3RyeSh7XG4gICAgY29yZVN0cmF0ZWdpZXNcbiAgfSk7XG4gIHNlcnZpY2VSZWdpc3RyeSA9IF9zZXJ2aWNlUmVnaXN0cnk7XG4gIHJldHVybiBfc2VydmljZVJlZ2lzdHJ5O1xufTtcbmNvbnN0IGdldFNlcnZpY2VSZWdpc3RyeSA9ICgpID0+IHtcbiAgaWYgKCFnZXRJc1NlcnZpY2VSZWdpc3RyeUluaXRpYWxpemVkKCkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJSZWdpc3RyeSBpcyBub3QgaW5pdGFsaXplZCwgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIHN0dWIgY29yZSBzdHJhdGVnaWVzXCIpO1xuICAgIHJldHVybiBpbml0U2VydmljZVJlZ2lzdHJ5KHtcbiAgICAgIGNvcmVTdHJhdGVnaWVzOiBzdHViQ29yZVN0cmF0ZWdpZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VydmljZVJlZ2lzdHJ5O1xufTtcbmNvbnN0IHBsdWdpblJlZ2lzdHJ5ID0gUGx1Z2luUmVnaXN0cnkoKTtcblxuY29uc3QgbWFrZURpc2NvdmVyeVNlcnZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBleHRlbnNpb25TZXJ2aWNlcyA9IHdpbmRvdz8uZmNsX2V4dGVuc2lvbnMgfHwgW107XG4gIHJldHVybiBbLi4uZXh0ZW5zaW9uU2VydmljZXMsIC4uLmdldFNlcnZpY2VSZWdpc3RyeSgpLmdldFNlcnZpY2VzKCldO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGdldERpc2NvdmVyeVNlcnZpY2Uoc2VydmljZSkge1xuICBjb25zdCBkaXNjb3ZlcnlBdXRobkluY2x1ZGUgPSBhd2FpdCBjb25maWcuZ2V0KFwiZGlzY292ZXJ5LmF1dGhuLmluY2x1ZGVcIiwgW10pO1xuICBjb25zdCBkaXNjb3ZlcnlXYWxsZXRNZXRob2QgPSBhd2FpdCBjb25maWcuZmlyc3QoW1wiZGlzY292ZXJ5LndhbGxldC5tZXRob2RcIiwgXCJkaXNjb3Zlcnkud2FsbGV0Lm1ldGhvZC5kZWZhdWx0XCJdKTtcbiAgY29uc3QgbWV0aG9kID0gc2VydmljZT8ubWV0aG9kID8gc2VydmljZS5tZXRob2QgOiBkaXNjb3ZlcnlXYWxsZXRNZXRob2Q7XG4gIGNvbnN0IGVuZHBvaW50ID0gc2VydmljZT8uZW5kcG9pbnQgPz8gKGF3YWl0IGNvbmZpZy5maXJzdChbXCJkaXNjb3Zlcnkud2FsbGV0XCIsIFwiY2hhbGxlbmdlLmhhbmRzaGFrZVwiXSkpO1xuICBpbnZhcmlhbnQoZW5kcG9pbnQsIGBcbiAgICBJZiBubyBzZXJ2aWNlIGlzIHBhc3NlZCB0byBcImF1dGhlbnRpY2F0ZSxcIiB0aGVuIFwiZGlzY292ZXJ5LndhbGxldFwiIG11c3QgYmUgZGVmaW5lZCBpbiBmY2wgY29uZmlnLlxuICAgIFNlZTogXCJodHRwczovL2RvY3Mub25mbG93Lm9yZy9mY2wvcmVmZXJlbmNlL2FwaS8jc2V0dGluZy1jb25maWd1cmF0aW9uLXZhbHVlc1wiXG4gICAgYCk7XG4gIHJldHVybiB7XG4gICAgLi4uc2VydmljZSxcbiAgICB0eXBlOiBcImF1dGhuXCIsXG4gICAgZW5kcG9pbnQsXG4gICAgbWV0aG9kLFxuICAgIGRpc2NvdmVyeUF1dGhuSW5jbHVkZVxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTZXJ2aWNlcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgdHlwZXNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVuZHBvaW50ID0gYXdhaXQgY29uZmlnLmdldChcImRpc2NvdmVyeS5hdXRobi5lbmRwb2ludFwiKTtcbiAgaW52YXJpYW50KEJvb2xlYW4oZW5kcG9pbnQpLCBgXCJkaXNjb3ZlcnkuYXV0aG4uZW5kcG9pbnRcIiBpbiBjb25maWcgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBjb25zdCBpbmNsdWRlID0gYXdhaXQgY29uZmlnLmdldChcImRpc2NvdmVyeS5hdXRobi5pbmNsdWRlXCIsIFtdKTtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChlbmRwb2ludCk7XG4gIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiB0eXBlcyxcbiAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICBpbmNsdWRlLFxuICAgICAgY2xpZW50U2VydmljZXM6IGF3YWl0IG1ha2VEaXNjb3ZlcnlTZXJ2aWNlcygpLFxuICAgICAgc3VwcG9ydGVkU3RyYXRlZ2llczogZ2V0U2VydmljZVJlZ2lzdHJ5KCkuZ2V0U3RyYXRlZ2llcygpLFxuICAgICAgdXNlckFnZW50OiB3aW5kb3c/Lm5hdmlnYXRvcj8udXNlckFnZW50LFxuICAgICAgbmV0d29yazogYXdhaXQgZ2V0Q2hhaW5JZCgpXG4gICAgfSlcbiAgfSkudGhlbihkID0+IGQuanNvbigpKTtcbn1cblxuY29uc3QgU0VSVklDRV9BQ1RPUl9LRVlTID0ge1xuICBBVVRITjogXCJhdXRoblwiLFxuICBSRVNVTFRTOiBcInJlc3VsdHNcIixcbiAgU05BUFNIT1Q6IFwiU05BUFNIT1RcIixcbiAgVVBEQVRFRDogXCJVUERBVEVEXCIsXG4gIFVQREFURV9SRVNVTFRTOiBcIlVQREFURV9SRVNVTFRTXCJcbn07XG5jb25zdCB3YXJuID0gKGZhY3QsIG1zZykgPT4ge1xuICBpZiAoZmFjdCkge1xuICAgIGNvbnNvbGUud2FybihgXG4gICAgICAlY0ZDTCBXYXJuaW5nXG4gICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAke21zZ31cbiAgICAgIEZvciBtb3JlIGluZm8sIHBsZWFzZSBzZWUgdGhlIGRvY3M6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2ZjbC9cbiAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIGAsIFwiZm9udC13ZWlnaHQ6Ym9sZDtmb250LWZhbWlseTptb25vc3BhY2U7XCIpO1xuICB9XG59O1xuY29uc3QgZmV0Y2hTZXJ2aWNlc0Zyb21EaXNjb3ZlcnkgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VydmljZXMgPSBhd2FpdCBnZXRTZXJ2aWNlcyh7XG4gICAgICB0eXBlczogW1NFUlZJQ0VfQUNUT1JfS0VZUy5BVVRITl1cbiAgICB9KTtcbiAgICBzZW5kJDEoU0VSVklDRV9BQ1RPUl9LRVlTLkFVVEhOLCBTRVJWSUNFX0FDVE9SX0tFWVMuVVBEQVRFX1JFU1VMVFMsIHtcbiAgICAgIHJlc3VsdHM6IHNlcnZpY2VzXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBgJHtlcnJvci5uYW1lfSBFcnJvciBmZXRjaGluZyBEaXNjb3ZlcnkgQVBJIHNlcnZpY2VzLmAsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgbGV2ZWw6IExFVkVMUy5lcnJvclxuICAgIH0pO1xuICB9XG59O1xuY29uc3QgSEFORExFUlMkMSA9IHtcbiAgW0lOSVRdOiBhc3luYyBjdHggPT4ge1xuICAgIHdhcm4odHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiwgJ1wiZmNsLmRpc2NvdmVyeVwiIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLicpO1xuICAgIC8vIElmIHlvdSBjYWxsIHRoaXMgYmVmb3JlIHRoZSB3aW5kb3cgaXMgbG9hZGVkIGV4dGVuc2lvbnMgd2lsbCBub3QgYmUgc2V0IHlldFxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBmZXRjaFNlcnZpY2VzRnJvbURpc2NvdmVyeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBmZXRjaFNlcnZpY2VzRnJvbURpc2NvdmVyeSgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIFtTRVJWSUNFX0FDVE9SX0tFWVMuVVBEQVRFX1JFU1VMVFNdOiAoY3R4LCBfbGV0dGVyLCBkYXRhKSA9PiB7XG4gICAgY3R4Lm1lcmdlKGRhdGEpO1xuICAgIGN0eC5icm9hZGNhc3QoU0VSVklDRV9BQ1RPUl9LRVlTLlVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFNFUlZJQ0VfQUNUT1JfS0VZUy5VUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VOU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pLFxuICBbU0VSVklDRV9BQ1RPUl9LRVlTLlNOQVBTSE9UXTogYXN5bmMgKGN0eCwgbGV0dGVyKSA9PiBsZXR0ZXIucmVwbHkoe1xuICAgIC4uLmN0eC5hbGwoKVxuICB9KVxufTtcbmNvbnN0IHNwYXduUHJvdmlkZXJzID0gKCkgPT4gc3Bhd24oSEFORExFUlMkMSwgU0VSVklDRV9BQ1RPUl9LRVlTLkFVVEhOKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiQG9uZmxvdy90eXBlZGVmc1wiKS5TZXJ2aWNlfSBTZXJ2aWNlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU3Vic2NyaXB0aW9uQ2FsbGJhY2tcbiAqIEByZXR1cm5zIHtTZXJ2aWNlW119XG4gKi9cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERpc2NvdmVyeSBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIEF1dGhuLlxuICogXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBBdXRoblxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc3Vic2NyaWJlIC0gU3Vic2NyaWJlIHRvIERpc2NvdmVyeSBhdXRobiBzZXJ2aWNlc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc25hcHNob3QgLSBHZXQgdGhlIGN1cnJlbnQgRGlzY292ZXJ5IGF1dGhuIHNlcnZpY2VzIHNwYW5zaG90XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGUgLSBUcmlnZ2VyIGFuIHVwZGF0ZSBvZiBhdXRobiBzZXJ2aWNlc1xuICovXG5jb25zdCBhdXRobiA9IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiAtIFN1YnNjcmliZSB0byBEaXNjb3ZlcnkgYXV0aG4gc2VydmljZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybnMge1N1YnNjcmlwdGlvbkNhbGxiYWNrfVxuICAgKi9cbiAgc3Vic2NyaWJlOiBjYiA9PiBzdWJzY3JpYmVyKFNFUlZJQ0VfQUNUT1JfS0VZUy5BVVRITiwgc3Bhd25Qcm92aWRlcnMsIGNiKSxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiAtIEdldCB0aGUgY3VycmVudCBEaXNjb3ZlcnkgYXV0aG4gc2VydmljZXMgc3BhbnNob3RcbiAgICogQHJldHVybnMge1NlcnZpY2VbXX1cbiAgICovXG4gIHNuYXBzaG90OiAoKSA9PiBzbmFwc2hvdGVyKFNFUlZJQ0VfQUNUT1JfS0VZUy5BVVRITiwgc3Bhd25Qcm92aWRlcnMpLFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIC0gVHJpZ2dlciBhbiB1cGRhdGUgb2YgYXV0aG4gc2VydmljZXNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1cGRhdGU6ICgpID0+IGZldGNoU2VydmljZXNGcm9tRGlzY292ZXJ5KClcbn07XG5cbmNvbnN0IGRpc2NvdmVyeSA9IHtcbiAgYXV0aG5cbn07XG5cbnZhciBzaGEzID0ge307XG5cbnZhciBzcG9uZ2UgPSB7fTtcblxudmFyIHBlcm11dGUgPSB7fTtcblxudmFyIGNoaSA9IHt9O1xuXG52YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkoSSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24gKE8sIG8pIHtcbiAgICB2YXIgb2kgPSBvICogMjtcbiAgICB2YXIgaWkgPSBpICogMjtcbiAgICBPW29pXSA9IElbaWldO1xuICAgIE9bb2kgKyAxXSA9IElbaWkgKyAxXTtcbiAgfTtcbn07XG52YXIgY29weV8xID0gY29weTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgX2NvcHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNvcHlfMSk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIHZhciBjaGkgPSBmdW5jdGlvbiBjaGkoX3JlZikge1xuICAgIHZhciBBID0gX3JlZi5BLFxuICAgICAgQyA9IF9yZWYuQztcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDI1OyB5ICs9IDUpIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICAgICgwLCBfY29weVtcImRlZmF1bHRcIl0pKEEsIHkgKyB4KShDLCB4KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF94ID0gMDsgX3ggPCA1OyBfeCsrKSB7XG4gICAgICAgIHZhciB4eSA9ICh5ICsgX3gpICogMjtcbiAgICAgICAgdmFyIHgxID0gKF94ICsgMSkgJSA1ICogMjtcbiAgICAgICAgdmFyIHgyID0gKF94ICsgMikgJSA1ICogMjtcbiAgICAgICAgQVt4eV0gXj0gfkNbeDFdICYgQ1t4Ml07XG4gICAgICAgIEFbeHkgKyAxXSBePSB+Q1t4MSArIDFdICYgQ1t4MiArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIF9kZWZhdWx0ID0gY2hpO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkoY2hpKTtcblxudmFyIGlvdGEgPSB7fTtcblxudmFyIHJvdW5kQ29uc3RhbnRzID0ge307XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIFJPVU5EX0NPTlNUQU5UUyA9IG5ldyBVaW50MzJBcnJheShbMCwgMSwgMCwgMzI4OTgsIDIxNDc0ODM2NDgsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAwLCAzMjkwNywgMCwgMjE0NzQ4MzY0OSwgMjE0NzQ4MzY0OCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDAsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLCAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAyMTQ3NDgzNjQ4LCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSwgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMCwgMzI3NzgsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAwLCAyMTQ3NDgzNjQ5LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDI0XSk7XG4gIHZhciBfZGVmYXVsdCA9IFJPVU5EX0NPTlNUQU5UUztcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKHJvdW5kQ29uc3RhbnRzKTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgX3JvdW5kQ29uc3RhbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyb3VuZENvbnN0YW50cyk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIHZhciBpb3RhID0gZnVuY3Rpb24gaW90YShfcmVmKSB7XG4gICAgdmFyIEEgPSBfcmVmLkEsXG4gICAgICByb3VuZEluZGV4ID0gX3JlZi5yb3VuZEluZGV4O1xuICAgIHZhciBpID0gcm91bmRJbmRleCAqIDI7XG4gICAgQVswXSBePSBfcm91bmRDb25zdGFudHNbXCJkZWZhdWx0XCJdW2ldO1xuICAgIEFbMV0gXj0gX3JvdW5kQ29uc3RhbnRzW1wiZGVmYXVsdFwiXVtpICsgMV07XG4gIH07XG4gIHZhciBfZGVmYXVsdCA9IGlvdGE7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShpb3RhKTtcblxudmFyIHJob1BpID0ge307XG5cbnZhciBwaVNodWZmbGVzID0ge307XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIFBJX1NIVUZGTEVTID0gWzEwLCA3LCAxMSwgMTcsIDE4LCAzLCA1LCAxNiwgOCwgMjEsIDI0LCA0LCAxNSwgMjMsIDE5LCAxMywgMTIsIDIsIDIwLCAxNCwgMjIsIDksIDYsIDFdO1xuICB2YXIgX2RlZmF1bHQgPSBQSV9TSFVGRkxFUztcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKHBpU2h1ZmZsZXMpO1xuXG52YXIgcmhvT2Zmc2V0cyA9IHt9O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4gIHZhciBSSE9fT0ZGU0VUUyA9IFsxLCAzLCA2LCAxMCwgMTUsIDIxLCAyOCwgMzYsIDQ1LCA1NSwgMiwgMTQsIDI3LCA0MSwgNTYsIDgsIDI1LCA0MywgNjIsIDE4LCAzOSwgNjEsIDIwLCA0NF07XG4gIHZhciBfZGVmYXVsdCA9IFJIT19PRkZTRVRTO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkocmhvT2Zmc2V0cyk7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbiAgdmFyIF9waVNodWZmbGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChwaVNodWZmbGVzKTtcbiAgdmFyIF9yaG9PZmZzZXRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyaG9PZmZzZXRzKTtcbiAgdmFyIF9jb3B5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb3B5XzEpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgcmhvUGkgPSBmdW5jdGlvbiByaG9QaShfcmVmKSB7XG4gICAgdmFyIEEgPSBfcmVmLkEsXG4gICAgICBDID0gX3JlZi5DLFxuICAgICAgVyA9IF9yZWYuVztcbiAgICAoMCwgX2NvcHlbXCJkZWZhdWx0XCJdKShBLCAxKShXLCAwKTtcbiAgICB2YXIgSCA9IDA7XG4gICAgdmFyIEwgPSAwO1xuICAgIHZhciBXaSA9IDA7XG4gICAgdmFyIHJpID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICB2YXIgaiA9IF9waVNodWZmbGVzW1wiZGVmYXVsdFwiXVtpXTtcbiAgICAgIHZhciByID0gX3Job09mZnNldHNbXCJkZWZhdWx0XCJdW2ldO1xuICAgICAgKDAsIF9jb3B5W1wiZGVmYXVsdFwiXSkoQSwgaikoQywgMCk7XG4gICAgICBIID0gV1swXTtcbiAgICAgIEwgPSBXWzFdO1xuICAgICAgcmkgPSAzMiAtIHI7XG4gICAgICBXaSA9IHIgPCAzMiA/IDAgOiAxO1xuICAgICAgV1tXaV0gPSBIIDw8IHIgfCBMID4+PiByaTtcbiAgICAgIFdbKFdpICsgMSkgJSAyXSA9IEwgPDwgciB8IEggPj4+IHJpO1xuICAgICAgKDAsIF9jb3B5W1wiZGVmYXVsdFwiXSkoVywgMCkoQSwgaik7XG4gICAgICAoMCwgX2NvcHlbXCJkZWZhdWx0XCJdKShDLCAwKShXLCAwKTtcbiAgICB9XG4gIH07XG4gIHZhciBfZGVmYXVsdCA9IHJob1BpO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0O1xufSkocmhvUGkpO1xuXG52YXIgdGhldGEgPSB7fTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgX2NvcHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNvcHlfMSk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIHZhciB0aGV0YSA9IGZ1bmN0aW9uIHRoZXRhKF9yZWYpIHtcbiAgICB2YXIgQSA9IF9yZWYuQSxcbiAgICAgIEMgPSBfcmVmLkMsXG4gICAgICBEID0gX3JlZi5ELFxuICAgICAgVyA9IF9yZWYuVztcbiAgICB2YXIgSCA9IDA7XG4gICAgdmFyIEwgPSAwO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICB2YXIgeDIwID0geCAqIDI7XG4gICAgICB2YXIgeDIxID0gKHggKyA1KSAqIDI7XG4gICAgICB2YXIgeDIyID0gKHggKyAxMCkgKiAyO1xuICAgICAgdmFyIHgyMyA9ICh4ICsgMTUpICogMjtcbiAgICAgIHZhciB4MjQgPSAoeCArIDIwKSAqIDI7XG4gICAgICBDW3gyMF0gPSBBW3gyMF0gXiBBW3gyMV0gXiBBW3gyMl0gXiBBW3gyM10gXiBBW3gyNF07XG4gICAgICBDW3gyMCArIDFdID0gQVt4MjAgKyAxXSBeIEFbeDIxICsgMV0gXiBBW3gyMiArIDFdIF4gQVt4MjMgKyAxXSBeIEFbeDI0ICsgMV07XG4gICAgfVxuICAgIGZvciAodmFyIF94ID0gMDsgX3ggPCA1OyBfeCsrKSB7XG4gICAgICAoMCwgX2NvcHlbXCJkZWZhdWx0XCJdKShDLCAoX3ggKyAxKSAlIDUpKFcsIDApO1xuICAgICAgSCA9IFdbMF07XG4gICAgICBMID0gV1sxXTtcbiAgICAgIFdbMF0gPSBIIDw8IDEgfCBMID4+PiAzMTtcbiAgICAgIFdbMV0gPSBMIDw8IDEgfCBIID4+PiAzMTtcbiAgICAgIERbX3ggKiAyXSA9IENbKF94ICsgNCkgJSA1ICogMl0gXiBXWzBdO1xuICAgICAgRFtfeCAqIDIgKyAxXSA9IENbKF94ICsgNCkgJSA1ICogMiArIDFdIF4gV1sxXTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgMjU7IHkgKz0gNSkge1xuICAgICAgICBBWyh5ICsgX3gpICogMl0gXj0gRFtfeCAqIDJdO1xuICAgICAgICBBWyh5ICsgX3gpICogMiArIDFdIF49IERbX3ggKiAyICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgX2RlZmF1bHQgPSB0aGV0YTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbn0pKHRoZXRhKTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgX2NoaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY2hpKTtcbiAgdmFyIF9pb3RhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpb3RhKTtcbiAgdmFyIF9yaG9QaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmhvUGkpO1xuICB2YXIgX3RoZXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCh0aGV0YSk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIHZhciBwZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSgpIHtcbiAgICB2YXIgQyA9IG5ldyBVaW50MzJBcnJheSgxMCk7XG4gICAgdmFyIEQgPSBuZXcgVWludDMyQXJyYXkoMTApO1xuICAgIHZhciBXID0gbmV3IFVpbnQzMkFycmF5KDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoQSkge1xuICAgICAgZm9yICh2YXIgcm91bmRJbmRleCA9IDA7IHJvdW5kSW5kZXggPCAyNDsgcm91bmRJbmRleCsrKSB7XG4gICAgICAgICgwLCBfdGhldGFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgQTogQSxcbiAgICAgICAgICBDOiBDLFxuICAgICAgICAgIEQ6IEQsXG4gICAgICAgICAgVzogV1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9yaG9QaVtcImRlZmF1bHRcIl0pKHtcbiAgICAgICAgICBBOiBBLFxuICAgICAgICAgIEM6IEMsXG4gICAgICAgICAgVzogV1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9jaGlbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgQTogQSxcbiAgICAgICAgICBDOiBDXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgX2lvdGFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgQTogQSxcbiAgICAgICAgICByb3VuZEluZGV4OiByb3VuZEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgQy5maWxsKDApO1xuICAgICAgRC5maWxsKDApO1xuICAgICAgVy5maWxsKDApO1xuICAgIH07XG4gIH07XG4gIHZhciBfZGVmYXVsdCA9IHBlcm11dGU7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShwZXJtdXRlKTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuICB2YXIgX2J1ZmZlciA9IHJlcXVpcmUkJDA7XG4gIHZhciBfcGVybXV0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocGVybXV0ZSk7XG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG4gIHZhciB4b3JXb3JkcyA9IGZ1bmN0aW9uIHhvcldvcmRzKEksIE8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEkubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBvID0gaSAvIDQ7XG4gICAgICBPW29dIF49IElbaSArIDddIDw8IDI0IHwgSVtpICsgNl0gPDwgMTYgfCBJW2kgKyA1XSA8PCA4IHwgSVtpICsgNF07XG4gICAgICBPW28gKyAxXSBePSBJW2kgKyAzXSA8PCAyNCB8IElbaSArIDJdIDw8IDE2IHwgSVtpICsgMV0gPDwgOCB8IElbaV07XG4gICAgfVxuICAgIHJldHVybiBPO1xuICB9O1xuICB2YXIgcmVhZFdvcmRzID0gZnVuY3Rpb24gcmVhZFdvcmRzKEksIE8pIHtcbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IE8ubGVuZ3RoOyBvICs9IDgpIHtcbiAgICAgIHZhciBpID0gbyAvIDQ7XG4gICAgICBPW29dID0gSVtpICsgMV07XG4gICAgICBPW28gKyAxXSA9IElbaSArIDFdID4+PiA4O1xuICAgICAgT1tvICsgMl0gPSBJW2kgKyAxXSA+Pj4gMTY7XG4gICAgICBPW28gKyAzXSA9IElbaSArIDFdID4+PiAyNDtcbiAgICAgIE9bbyArIDRdID0gSVtpXTtcbiAgICAgIE9bbyArIDVdID0gSVtpXSA+Pj4gODtcbiAgICAgIE9bbyArIDZdID0gSVtpXSA+Pj4gMTY7XG4gICAgICBPW28gKyA3XSA9IElbaV0gPj4+IDI0O1xuICAgIH1cbiAgICByZXR1cm4gTztcbiAgfTtcbiAgdmFyIFNwb25nZSA9IGZ1bmN0aW9uIFNwb25nZShfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2FwYWNpdHkgPSBfcmVmLmNhcGFjaXR5LFxuICAgICAgcGFkZGluZyA9IF9yZWYucGFkZGluZztcbiAgICB2YXIga2VjY2FrID0gKDAsIF9wZXJtdXRlW1wiZGVmYXVsdFwiXSkoKTtcbiAgICB2YXIgc3RhdGVTaXplID0gMjAwO1xuICAgIHZhciBibG9ja1NpemUgPSBjYXBhY2l0eSAvIDg7XG4gICAgdmFyIHF1ZXVlU2l6ZSA9IHN0YXRlU2l6ZSAtIGNhcGFjaXR5IC8gNDtcbiAgICB2YXIgcXVldWVPZmZzZXQgPSAwO1xuICAgIHZhciBzdGF0ZSA9IG5ldyBVaW50MzJBcnJheShzdGF0ZVNpemUgLyA0KTtcbiAgICB2YXIgcXVldWUgPSBfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShxdWV1ZVNpemUpO1xuICAgIHRoaXMuYWJzb3JiID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbcXVldWVPZmZzZXRdID0gYnVmZmVyW2ldO1xuICAgICAgICBxdWV1ZU9mZnNldCArPSAxO1xuICAgICAgICBpZiAocXVldWVPZmZzZXQgPj0gcXVldWVTaXplKSB7XG4gICAgICAgICAgeG9yV29yZHMocXVldWUsIHN0YXRlKTtcbiAgICAgICAgICBrZWNjYWsoc3RhdGUpO1xuICAgICAgICAgIHF1ZXVlT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG4gICAgdGhpcy5zcXVlZXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgYnVmZmVyOiBvcHRpb25zLmJ1ZmZlciB8fCBfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja1NpemUpLFxuICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmcgfHwgcGFkZGluZyxcbiAgICAgICAgcXVldWU6IF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKHF1ZXVlLmxlbmd0aCksXG4gICAgICAgIHN0YXRlOiBuZXcgVWludDMyQXJyYXkoc3RhdGUubGVuZ3RoKVxuICAgICAgfTtcbiAgICAgIHF1ZXVlLmNvcHkob3V0cHV0LnF1ZXVlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0LnN0YXRlW2ldID0gc3RhdGVbaV07XG4gICAgICB9XG4gICAgICBvdXRwdXQucXVldWUuZmlsbCgwLCBxdWV1ZU9mZnNldCk7XG4gICAgICBvdXRwdXQucXVldWVbcXVldWVPZmZzZXRdIHw9IG91dHB1dC5wYWRkaW5nO1xuICAgICAgb3V0cHV0LnF1ZXVlW3F1ZXVlU2l6ZSAtIDFdIHw9IDEyODtcbiAgICAgIHhvcldvcmRzKG91dHB1dC5xdWV1ZSwgb3V0cHV0LnN0YXRlKTtcbiAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG91dHB1dC5idWZmZXIubGVuZ3RoOyBvZmZzZXQgKz0gcXVldWVTaXplKSB7XG4gICAgICAgIGtlY2NhayhvdXRwdXQuc3RhdGUpO1xuICAgICAgICByZWFkV29yZHMob3V0cHV0LnN0YXRlLCBvdXRwdXQuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcXVldWVTaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmJ1ZmZlcjtcbiAgICB9O1xuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBxdWV1ZS5maWxsKDApO1xuICAgICAgc3RhdGUuZmlsbCgwKTtcbiAgICAgIHF1ZXVlT2Zmc2V0ID0gMDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICB2YXIgX2RlZmF1bHQgPSBTcG9uZ2U7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShzcG9uZ2UpO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLlNIQUtFID0gZXhwb3J0cy5TSEEzSGFzaCA9IGV4cG9ydHMuU0hBMyA9IGV4cG9ydHMuS2VjY2FrID0gdm9pZCAwO1xuICB2YXIgX2J1ZmZlciA9IHJlcXVpcmUkJDA7XG4gIHZhciBfc3BvbmdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChzcG9uZ2UpO1xuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuICB2YXIgY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2goX3JlZikge1xuICAgIHZhciBhbGxvd2VkU2l6ZXMgPSBfcmVmLmFsbG93ZWRTaXplcyxcbiAgICAgIGRlZmF1bHRTaXplID0gX3JlZi5kZWZhdWx0U2l6ZSxcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEhhc2goKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRlZmF1bHRTaXplO1xuICAgICAgaWYgKCF0aGlzIHx8IHRoaXMuY29uc3RydWN0b3IgIT09IEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNoKHNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGFsbG93ZWRTaXplcyAmJiAhYWxsb3dlZFNpemVzLmluY2x1ZGVzKHNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGhhc2ggbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHNwb25nZSA9IG5ldyBfc3BvbmdlW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIGNhcGFjaXR5OiBzaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJ1dGY4XCI7XG4gICAgICAgIGlmIChfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICBzcG9uZ2UuYWJzb3JiKGlucHV0KTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUoX2J1ZmZlci5CdWZmZXIuZnJvbShpbnB1dCwgZW5jb2RpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgc3RyaW5nIG9yIGJ1ZmZlclwiKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvcm1hdE9yT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJiaW5hcnlcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgIGZvcm1hdDogZm9ybWF0T3JPcHRpb25zXG4gICAgICAgIH0gOiBmb3JtYXRPck9wdGlvbnM7XG4gICAgICAgIHZhciBidWZmZXIgPSBzcG9uZ2Uuc3F1ZWV6ZSh7XG4gICAgICAgICAgYnVmZmVyOiBvcHRpb25zLmJ1ZmZlcixcbiAgICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmcgfHwgcGFkZGluZ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSBcImJpbmFyeVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyhvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzcG9uZ2UucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH07XG4gIHZhciBLZWNjYWsgPSBjcmVhdGVIYXNoKHtcbiAgICBhbGxvd2VkU2l6ZXM6IFsyMjQsIDI1NiwgMzg0LCA1MTJdLFxuICAgIGRlZmF1bHRTaXplOiA1MTIsXG4gICAgcGFkZGluZzogMVxuICB9KTtcbiAgZXhwb3J0cy5LZWNjYWsgPSBLZWNjYWs7XG4gIHZhciBTSEEzID0gY3JlYXRlSGFzaCh7XG4gICAgYWxsb3dlZFNpemVzOiBbMjI0LCAyNTYsIDM4NCwgNTEyXSxcbiAgICBkZWZhdWx0U2l6ZTogNTEyLFxuICAgIHBhZGRpbmc6IDZcbiAgfSk7XG4gIGV4cG9ydHMuU0hBMyA9IFNIQTM7XG4gIHZhciBTSEFLRSA9IGNyZWF0ZUhhc2goe1xuICAgIGFsbG93ZWRTaXplczogWzEyOCwgMjU2XSxcbiAgICBkZWZhdWx0U2l6ZTogMjU2LFxuICAgIHBhZGRpbmc6IDMxXG4gIH0pO1xuICBleHBvcnRzLlNIQUtFID0gU0hBS0U7XG4gIHZhciBTSEEzSGFzaCA9IEtlY2NhaztcbiAgZXhwb3J0cy5TSEEzSGFzaCA9IFNIQTNIYXNoO1xuICBTSEEzLlNIQTNIYXNoID0gU0hBM0hhc2g7XG4gIHZhciBfZGVmYXVsdCA9IFNIQTM7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG59KShzaGEzKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2VuSGFzaCh1dGY4U3RyaW5nKSB7XG4gIGNvbnN0IHNoYSA9IG5ldyBzaGEzLlNIQTMoMjU2KTtcbiAgc2hhLnVwZGF0ZShCdWZmZXIuZnJvbSh1dGY4U3RyaW5nLCBcInV0ZjhcIikpO1xuICByZXR1cm4gc2hhLmRpZ2VzdChcImhleFwiKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2VuZXJhdGVzIEludGVyYWN0aW9uIFRlbXBsYXRlIElEIGZvciBhIGdpdmVuIEludGVyYWN0aW9uIFRlbXBsYXRlXG4gKiAgXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRlbXBsYXRlIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gSW50ZXJhY3Rpb24gVGVtcGxhdGUgSURcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZW1wbGF0ZUlkKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlVGVtcGxhdGVJZCh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlID09PSBcIm9iamVjdFwiLCBcImdlbmVyYXRlVGVtcGxhdGVJZCh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGUuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVcIiwgXCJnZW5lcmF0ZVRlbXBsYXRlSWQoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBvYmplY3QgbXVzdCBiZSBhbiBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuICB0ZW1wbGF0ZSA9IG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUodGVtcGxhdGUpO1xuICBzd2l0Y2ggKHRlbXBsYXRlLmZfdmVyc2lvbikge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgY29uc3QgdGVtcGxhdGVEYXRhID0gdGVtcGxhdGUuZGF0YTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhLm1lc3NhZ2VzKS5tYXAoYXN5bmMgbWVzc2FnZUtleSA9PiBbYXdhaXQgZ2VuSGFzaChtZXNzYWdlS2V5KSwgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhLm1lc3NhZ2VzPy5bbWVzc2FnZUtleV0/LmkxOG4pLm1hcChhc3luYyBpMThua2V5bGFuZ3VhZ2UgPT4gW2F3YWl0IGdlbkhhc2goaTE4bmtleWxhbmd1YWdlKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGEubWVzc2FnZXM/LlttZXNzYWdlS2V5XT8uaTE4bj8uW2kxOG5rZXlsYW5ndWFnZV0pXSkpXSkpO1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXMpLm1hcChhc3luYyBkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyID0+IFthd2FpdCBnZW5IYXNoKGRlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXIpLCBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0ZW1wbGF0ZURhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXJdKS5tYXAoYXN5bmMgZGVwZW5kZW5jeUNvbnRyYWN0ID0+IFthd2FpdCBnZW5IYXNoKGRlcGVuZGVuY3lDb250cmFjdCksIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YT8uZGVwZW5kZW5jaWVzPy5bZGVwZW5kZW5jeUFkZHJlc3NQbGFjZWhvbGRlcl0/LltkZXBlbmRlbmN5Q29udHJhY3RdKS5tYXAoYXN5bmMgZGVwZW5kZW5jeUNvbnRyYWN0TmV0d29yayA9PiBbYXdhaXQgZ2VuSGFzaChkZXBlbmRlbmN5Q29udHJhY3ROZXR3b3JrKSwgW2F3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXM/LltkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyXT8uW2RlcGVuZGVuY3lDb250cmFjdF0/LltkZXBlbmRlbmN5Q29udHJhY3ROZXR3b3JrXS5hZGRyZXNzKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXJdPy5bZGVwZW5kZW5jeUNvbnRyYWN0XT8uW2RlcGVuZGVuY3lDb250cmFjdE5ldHdvcmtdLmNvbnRyYWN0KSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LmRlcGVuZGVuY2llcz8uW2RlcGVuZGVuY3lBZGRyZXNzUGxhY2Vob2xkZXJdPy5bZGVwZW5kZW5jeUNvbnRyYWN0XT8uW2RlcGVuZGVuY3lDb250cmFjdE5ldHdvcmtdLmZxX2FkZHJlc3MpLCBhd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8uZGVwZW5kZW5jaWVzPy5bZGVwZW5kZW5jeUFkZHJlc3NQbGFjZWhvbGRlcl0/LltkZXBlbmRlbmN5Q29udHJhY3RdPy5bZGVwZW5kZW5jeUNvbnRyYWN0TmV0d29ya10ucGluKSwgYXdhaXQgZ2VuSGFzaChTdHJpbmcodGVtcGxhdGVEYXRhPy5kZXBlbmRlbmNpZXM/LltkZXBlbmRlbmN5QWRkcmVzc1BsYWNlaG9sZGVyXT8uW2RlcGVuZGVuY3lDb250cmFjdF0/LltkZXBlbmRlbmN5Q29udHJhY3ROZXR3b3JrXS5waW5fYmxvY2tfaGVpZ2h0KSldXSkpXSkpXSkpO1xuICAgICAgY29uc3QgX2FyZ3VtZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRlbXBsYXRlRGF0YT8uW1wiYXJndW1lbnRzXCJdKS5tYXAoYXN5bmMgYXJndW1lbnRMYWJlbCA9PiBbYXdhaXQgZ2VuSGFzaChhcmd1bWVudExhYmVsKSwgW2F3YWl0IGdlbkhhc2goU3RyaW5nKHRlbXBsYXRlRGF0YT8uW1wiYXJndW1lbnRzXCJdPy5bYXJndW1lbnRMYWJlbF0uaW5kZXgpKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LltcImFyZ3VtZW50c1wiXT8uW2FyZ3VtZW50TGFiZWxdLnR5cGUpLCBhd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8uW1wiYXJndW1lbnRzXCJdPy5bYXJndW1lbnRMYWJlbF0uYmFsYW5jZSB8fCBcIlwiKSwgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGVtcGxhdGVEYXRhPy5bXCJhcmd1bWVudHNcIl0/Llthcmd1bWVudExhYmVsXS5tZXNzYWdlcykubWFwKGFzeW5jIGFyZ3VtZW50TWVzc2FnZUtleSA9PiBbYXdhaXQgZ2VuSGFzaChhcmd1bWVudE1lc3NhZ2VLZXkpLCBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0ZW1wbGF0ZURhdGE/LltcImFyZ3VtZW50c1wiXT8uW2FyZ3VtZW50TGFiZWxdLm1lc3NhZ2VzPy5bYXJndW1lbnRNZXNzYWdlS2V5XS5pMThuKS5tYXAoYXN5bmMgaTE4bmtleWxhbmd1YWdlID0+IFthd2FpdCBnZW5IYXNoKGkxOG5rZXlsYW5ndWFnZSksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy5bXCJhcmd1bWVudHNcIl0/Llthcmd1bWVudExhYmVsXS5tZXNzYWdlcz8uW2FyZ3VtZW50TWVzc2FnZUtleV0uaTE4bj8uW2kxOG5rZXlsYW5ndWFnZV0pXSkpXSkpXV0pKTtcbiAgICAgIGNvbnN0IGVuY29kZWRIZXggPSBlbmNvZGUoW2F3YWl0IGdlbkhhc2goXCJJbnRlcmFjdGlvblRlbXBsYXRlXCIpLCBhd2FpdCBnZW5IYXNoKFwiMS4wLjBcIiksIGF3YWl0IGdlbkhhc2godGVtcGxhdGVEYXRhPy50eXBlKSwgYXdhaXQgZ2VuSGFzaCh0ZW1wbGF0ZURhdGE/LmludGVyZmFjZSksIG1lc3NhZ2VzLCBhd2FpdCBnZW5IYXNoKHRlbXBsYXRlRGF0YT8uY2FkZW5jZSksIGRlcGVuZGVuY2llcywgX2FyZ3VtZW50c10pLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIGdlbkhhc2goZW5jb2RlZEhleCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdlbmVyYXRlVGVtcGxhdGVJZCBFcnJvcjogVW5zdXBwb3J0ZWQgdGVtcGxhdGUgdmVyc2lvblwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHdoZXRoZXIgYSBzZXQgb2YgYXVkaXRvcnMgaGF2ZSBhdWRpdGVkIGEgZ2l2ZW4gSW50ZXJhY3Rpb24gVGVtcGxhdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRlbXBsYXRlIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGVcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLmF1ZGl0b3JzIC0gQXJyYXkgb2YgYXVkaXRvcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mbG93SW50ZXJhY3Rpb25BdWRpdENvbnRyYWN0IC0gRmxvdyBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBBdWRpdCBjb250cmFjdCBhZGRyZXNzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIE9iamVjdCBvZiBhdWRpdG9yIGFkZHJlc3NlcyBhbmQgYXVkaXQgc3RhdHVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMoX3JlZikge1xuICBsZXQge1xuICAgIHRlbXBsYXRlLFxuICAgIGF1ZGl0b3JzXG4gIH0gPSBfcmVmO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGludmFyaWFudCQxKHRlbXBsYXRlICE9IHVuZGVmaW5lZCwgXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB0ZW1wbGF0ZSA9IG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGUodGVtcGxhdGUpO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZS5mX3R5cGUgPT09IFwiSW50ZXJhY3Rpb25UZW1wbGF0ZVwiLCBcImdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBtdXN0IGJlIGFuIEludGVyYWN0aW9uVGVtcGxhdGVcIik7XG5cbiAgLy8gUmVjb21wdXRlIElEIHRvIGJlIHN1cmUgaXQgbWF0Y2hlc1xuICBsZXQgcmVjb21wdXRlZFRlbXBsYXRlSUQgPSBhd2FpdCBnZW5lcmF0ZVRlbXBsYXRlSWQoe1xuICAgIHRlbXBsYXRlXG4gIH0pO1xuICBpZiAocmVjb21wdXRlZFRlbXBsYXRlSUQgIT09IHRlbXBsYXRlLmlkKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcImdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMgRGVidWcgRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgcmVjb21wdXRlIGFuZCBtYXRjaCB0ZW1wbGF0ZSBJRFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiAke3JlY29tcHV0ZWRUZW1wbGF0ZUlEfVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAke3RlbXBsYXRlLmlkfVxuICAgICAgICAgICAgYCxcbiAgICAgIGxldmVsOiBMRVZFTFMuZGVidWdcbiAgICB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzIEVycm9yOiBDb3VsZCBub3QgcmVjb21wdXRlIGFuZCBtYXRjaCB0ZW1wbGF0ZSBJRFwiKTtcbiAgfVxuICBzd2l0Y2ggKHRlbXBsYXRlLmZfdmVyc2lvbikge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgY29uc3QgX2F1ZGl0b3JzID0gYXVkaXRvcnMgfHwgKGF3YWl0IGNvbmZpZyQxKCkuZ2V0KFwiZmxvdy5hdWRpdG9yc1wiKSk7XG4gICAgICBpbnZhcmlhbnQkMShfYXVkaXRvcnMsIFwiZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyBFcnJvcjogUmVxdWlyZWQgY29uZmlndXJhdGlvbiBmb3IgJ2ZjbC5hdWRpdG9ycycgaXMgbm90IHNldFwiKTtcbiAgICAgIGludmFyaWFudCQxKEFycmF5LmlzQXJyYXkoX2F1ZGl0b3JzKSwgXCJnZXRJbnRlcmFjdGlvblRlbXBsYXRlQXVkaXRzIEVycm9yOiBSZXF1aXJlZCBjb25maWd1cmF0aW9uIGZvciAnZmNsLmF1ZGl0b3JzJyBpcyBub3QgYW4gYXJyYXlcIik7XG4gICAgICBsZXQgRmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdCA9IG9wdHMuZmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdDtcbiAgICAgIGlmICghRmxvd0ludGVyYWN0aW9uQXVkaXRDb250cmFjdCkge1xuICAgICAgICBjb25zdCBmY2xOZXR3b3JrID0gYXdhaXQgZ2V0Q2hhaW5JZChvcHRzKTtcbiAgICAgICAgaW52YXJpYW50JDEoZmNsTmV0d29yayA9PT0gXCJtYWlubmV0XCIgfHwgZmNsTmV0d29yayA9PT0gXCJ0ZXN0bmV0XCIsIFwiZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyBFcnJvcjogVW5hYmxlIHRvIGRldGVybWluZSBhZGRyZXNzIGZvciBGbG93SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0IGNvbnRyYWN0LiBTZXQgY29uZmlndXJhdGlvbiBmb3IgJ2ZjbC5uZXR3b3JrJyB0byAnbWFpbm5ldCcgb3IgJ3Rlc3RuZXQnXCIpO1xuICAgICAgICBpZiAoZmNsTmV0d29yayA9PT0gXCJtYWlubmV0XCIpIHtcbiAgICAgICAgICBGbG93SW50ZXJhY3Rpb25BdWRpdENvbnRyYWN0ID0gXCIweGZkMTAwZTM5ZDUwYTEzZTZcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGbG93SW50ZXJhY3Rpb25BdWRpdENvbnRyYWN0ID0gXCIweGY3OGJmYzEyZDBhNzg2ZGNcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXVkaXRzID0gYXdhaXQgcXVlcnkoe1xuICAgICAgICBjYWRlbmNlOiBgXG4gICAgICAgIGltcG9ydCBGbG93SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0IGZyb20gJHtGbG93SW50ZXJhY3Rpb25BdWRpdENvbnRyYWN0fVxuICAgICAgICBwdWIgZnVuIG1haW4odGVtcGxhdGVJZDogU3RyaW5nLCBhdWRpdG9yczogW0FkZHJlc3NdKToge0FkZHJlc3M6Qm9vbH0ge1xuICAgICAgICAgIHJldHVybiBGbG93SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0LmdldEhhc1RlbXBsYXRlQmVlbkF1ZGl0ZWRCeUF1ZGl0b3JzKHRlbXBsYXRlSWQ6IHRlbXBsYXRlSWQsIGF1ZGl0b3JzOiBhdWRpdG9ycylcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICBhcmdzOiAoYXJnLCB0KSA9PiBbYXJnKHJlY29tcHV0ZWRUZW1wbGF0ZUlELCB0LlN0cmluZyksIGFyZyhfYXVkaXRvcnMsIHQuQXJyYXkodC5BZGRyZXNzKSldXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhdWRpdHM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEludGVyYWN0aW9uVGVtcGxhdGVBdWRpdHMgRXJyb3I6IFVuc3VwcG9ydGVkIHRlbXBsYXRlIHZlcnNpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVJbXBvcnQoX3JlZikge1xuICBsZXQge1xuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBhZGRyZXNzXG4gIH0gPSBfcmVmO1xuICByZXR1cm4ge1xuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBhZGRyZXNzLFxuICAgIGNvbnRyYWN0OiBcIlwiXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRJbXBvcnRzKGNhZGVuY2UpIHtcbiAgbGV0IGltcG9ydHMgPSBbXTtcbiAgbGV0IGltcG9ydHNSZWcgPSAvaW1wb3J0ICgoXFx3fCx8ICkrKSogZnJvbSAweFxcdysvZztcbiAgbGV0IGZpbGVJbXBvcnRzID0gY2FkZW5jZS5tYXRjaChpbXBvcnRzUmVnKSB8fCBbXTtcbiAgZm9yIChjb25zdCBmaWxlSW1wb3J0IG9mIGZpbGVJbXBvcnRzKSB7XG4gICAgY29uc3QgaW1wb3J0TGluZVJlZyA9IC9pbXBvcnQgKChcXHcrfCwgfCkqKSBmcm9tICgweFxcdyspL2c7XG4gICAgY29uc3QgaW1wb3J0TGluZSA9IGltcG9ydExpbmVSZWcuZXhlYyhmaWxlSW1wb3J0KTtcbiAgICBjb25zdCBjb250cmFjdHNSZWcgPSAvKCg/OlxcdyspKyksPy9nO1xuICAgIGNvbnN0IGNvbnRyYWN0cyA9IGltcG9ydExpbmVbMV0ubWF0Y2goY29udHJhY3RzUmVnKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbnRyYWN0IG9mIGNvbnRyYWN0cykge1xuICAgICAgaW1wb3J0cy5wdXNoKGdlbmVyYXRlSW1wb3J0KHtcbiAgICAgICAgYWRkcmVzczogaW1wb3J0TGluZVszXSxcbiAgICAgICAgY29udHJhY3ROYW1lOiBjb250cmFjdC5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbXBvcnRzO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBQcm9kdWNlcyBhIGRlcGVuZGVuY3kgcGluIGZvciBhIGNvbnRyYWN0IGF0IGEgZ2l2ZW4gYmxvY2sgaGVpZ2h0XG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCBjb250YWluaW5nIHRoZSBjb250cmFjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb250cmFjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29udHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYmxvY2tIZWlnaHQgLSBUaGUgYmxvY2sgaGVpZ2h0IHRvIHByb2R1Y2UgdGhlIGRlcGVuZGVuY3kgcGluIGZvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGludGVyYWN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBkZXBlbmRlbmN5IHBpblxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZURlcGVuZGVuY3lQaW4oX3JlZikge1xuICBsZXQge1xuICAgIGFkZHJlc3MsXG4gICAgY29udHJhY3ROYW1lLFxuICAgIGJsb2NrSGVpZ2h0XG4gIH0gPSBfcmVmO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGludmFyaWFudCQxKGFkZHJlc3MgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGFkZHJlc3MgfSkgLS0gYWRkcmVzcyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKGNvbnRyYWN0TmFtZSAhPSB1bmRlZmluZWQsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgY29udHJhY3ROYW1lIH0pIC0tIGNvbnRyYWN0TmFtZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKGJsb2NrSGVpZ2h0ICE9IHVuZGVmaW5lZCwgXCJnZW5lcmF0ZURlcGVuZGVuY3lQaW4oeyBibG9ja0hlaWdodCB9KSAtLSBibG9ja0hlaWdodCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBhZGRyZXNzID09PSBcInN0cmluZ1wiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGFkZHJlc3MgfSkgLS0gYWRkcmVzcyBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgY29udHJhY3ROYW1lID09PSBcInN0cmluZ1wiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGNvbnRyYWN0TmFtZSB9KSAtLSBjb250cmFjdE5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIGJsb2NrSGVpZ2h0ID09PSBcIm51bWJlclwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGJsb2NrSGVpZ2h0IH0pIC0tIGJsb2NrSGVpZ2h0IG11c3QgYmUgYSBudW1iZXJcIik7XG4gIGxldCBob3Jpem9uID0gW2dlbmVyYXRlSW1wb3J0KHtcbiAgICBjb250cmFjdE5hbWUsXG4gICAgYWRkcmVzc1xuICB9KV07XG4gIGZvciAoY29uc3QgaG9yaXpvbkltcG9ydCBvZiBob3Jpem9uKSB7XG4gICAgbGV0IGFjY291bnQgPSBhd2FpdCBzZW5kKFtnZXRBY2NvdW50KGF3YWl0IGNvbmZpZyQxKCkuZ2V0KGhvcml6b25JbXBvcnQuYWRkcmVzcywgaG9yaXpvbkltcG9ydC5hZGRyZXNzKSksIGF0QmxvY2tIZWlnaHQoYmxvY2tIZWlnaHQpXSwgb3B0cykudGhlbihkZWNvZGUpO1xuICAgIGhvcml6b25JbXBvcnQuY29udHJhY3QgPSBhY2NvdW50LmNvbnRyYWN0cz8uW2hvcml6b25JbXBvcnQuY29udHJhY3ROYW1lXTtcbiAgICBpZiAoIWhvcml6b25JbXBvcnQuY29udHJhY3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJEaWQgbm90IGZpbmQgZXhwZWN0ZWQgY29udHJhY3RcIiwgaG9yaXpvbkltcG9ydCwgYWNjb3VudCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWQgbm90IGZpbmQgZXhwZWN0ZWQgY29udHJhY3RcIik7XG4gICAgfVxuICAgIGxldCBjb250cmFjdEltcG9ydHMgPSBmaW5kSW1wb3J0cyhob3Jpem9uSW1wb3J0LmNvbnRyYWN0KTtcbiAgICBob3Jpem9uLnB1c2goLi4uY29udHJhY3RJbXBvcnRzKTtcbiAgfVxuICBsZXQgY29udHJhY3RIYXNoZXMgPSBob3Jpem9uLm1hcChpcG9ydCA9PiBnZW5IYXNoKGlwb3J0LmNvbnRyYWN0KSk7XG4gIGxldCBjb250cmFjdEhhc2hlc0pvaW5lZCA9IGNvbnRyYWN0SGFzaGVzLmpvaW4oXCJcIik7XG4gIHJldHVybiBnZW5IYXNoKGNvbnRyYWN0SGFzaGVzSm9pbmVkKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUHJvZHVjZXMgYSBkZXBlbmRlbmN5IHBpbiBmb3IgYSBjb250cmFjdCBhdCBsYXRlc3Qgc2VhbGVkIGJsb2NrXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCBjb250YWluaW5nIHRoZSBjb250cmFjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb250cmFjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29udHJhY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBpbnRlcmFjdGlvblxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBUaGUgZGVwZW5kZW5jeSBwaW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEZXBlbmRlbmN5UGluQXRMYXRlc3RTZWFsZWRCbG9jayhfcmVmMikge1xuICBsZXQge1xuICAgIGFkZHJlc3MsXG4gICAgY29udHJhY3ROYW1lXG4gIH0gPSBfcmVmMjtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgbGF0ZXN0U2VhbGVkQmxvY2sgPSBhd2FpdCBibG9jayh7XG4gICAgc2VhbGVkOiB0cnVlXG4gIH0sIG9wdHMpO1xuICBsZXQgbGF0ZXN0U2VhbGVkQmxvY2tIZWlnaHQgPSBsYXRlc3RTZWFsZWRCbG9jaz8uaGVpZ2h0O1xuICByZXR1cm4gZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHtcbiAgICBhZGRyZXNzLFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBibG9ja0hlaWdodDogbGF0ZXN0U2VhbGVkQmxvY2tIZWlnaHRcbiAgfSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGVJbnRlcmZhY2UodGVtcGxhdGVJbnRlcmZhY2UpIHtcbiAgaWYgKHRlbXBsYXRlSW50ZXJmYWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHRlbXBsYXRlSW50ZXJmYWNlW1wiZl92ZXJzaW9uXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gdGVtcGxhdGVJbnRlcmZhY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vcm1hbGl6ZUludGVyYWN0aW9uVGVtcGxhdGVJbnRlcmZhY2UgRXJyb3I6IEludmFsaWQgSW50ZXJhY3Rpb25UZW1wbGF0ZUludGVyZmFjZVwiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZW5lcmF0ZXMgSW50ZXJhY3Rpb24gVGVtcGxhdGUgSW50ZXJmYWNlIElEIGZvciBhIGdpdmVuIEludGVyYWN0aW9uIFRlbXBsYXRlIEludGVyZmFjZVxuICogXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRlbXBsYXRlSW50ZXJmYWNlIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGUgSW50ZXJmYWNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIEludGVyZmFjZSBJRFxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBsYXRlSW50ZXJmYWNlSWQoX3JlZikge1xuICBsZXQge1xuICAgIHRlbXBsYXRlSW50ZXJmYWNlXG4gIH0gPSBfcmVmO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZUludGVyZmFjZSAhPSB1bmRlZmluZWQsIFwiZ2VuZXJhdGVUZW1wbGF0ZUludGVyZmFjZUlkKHsgdGVtcGxhdGVJbnRlcmZhY2UgfSkgLS0gdGVtcGxhdGVJbnRlcmZhY2UgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGVJbnRlcmZhY2UgPT09IFwib2JqZWN0XCIsIFwiZ2VuZXJhdGVUZW1wbGF0ZUludGVyZmFjZUlkKHsgdGVtcGxhdGVJbnRlcmZhY2UgfSkgLS0gdGVtcGxhdGVJbnRlcmZhY2UgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZUludGVyZmFjZS5mX3R5cGUgPT09IFwiSW50ZXJhY3Rpb25UZW1wbGF0ZUludGVyZmFjZVwiLCBcImdlbmVyYXRlVGVtcGxhdGVJbnRlcmZhY2VJZCh7IHRlbXBsYXRlSW50ZXJmYWNlIH0pIC0tIHRlbXBsYXRlSW50ZXJmYWNlIG9iamVjdCBtdXN0IGJlIGFuIEludGVyYWN0aW9uVGVtcGxhdGVcIik7XG4gIHRlbXBsYXRlSW50ZXJmYWNlID0gbm9ybWFsaXplSW50ZXJhY3Rpb25UZW1wbGF0ZUludGVyZmFjZSh0ZW1wbGF0ZUludGVyZmFjZSk7XG4gIHN3aXRjaCAodGVtcGxhdGVJbnRlcmZhY2UuZl92ZXJzaW9uKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICBjb25zdCBpbnRlcmZhY2VEYXRhID0gdGVtcGxhdGVJbnRlcmZhY2UuZGF0YTtcbiAgICAgIGNvbnN0IGVuY29kZWRIZXggPSBlbmNvZGUoW2F3YWl0IGdlbkhhc2goXCJJbnRlcmFjdGlvblRlbXBsYXRlSW50ZXJmYWNlXCIpLCBhd2FpdCBnZW5IYXNoKFwiMS4wLjBcIiksIGF3YWl0IGdlbkhhc2goaW50ZXJmYWNlRGF0YS5mbGlwKSwgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoaW50ZXJmYWNlRGF0YS5hcmd1bWVudHMpLm1hcChhc3luYyBhcmd1bWVudExhYmVsID0+IFthd2FpdCBnZW5IYXNoKGFyZ3VtZW50TGFiZWwpLCBhd2FpdCBnZW5IYXNoKFN0cmluZyhpbnRlcmZhY2VEYXRhLmFyZ3VtZW50c1thcmd1bWVudExhYmVsXS5pbmRleCkpLCBhd2FpdCBnZW5IYXNoKGludGVyZmFjZURhdGEuYXJndW1lbnRzW2FyZ3VtZW50TGFiZWxdLnR5cGUpXSkpXSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICByZXR1cm4gZ2VuSGFzaChlbmNvZGVkSGV4KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VuZXJhdGVUZW1wbGF0ZUludGVyZmFjZUlkIEVycm9yOiBVbnN1cHBvcnRlZCB0ZW1wbGF0ZUludGVyZmFjZSB2ZXJzaW9uXCIpO1xuICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiBhbiBJbnRlcmFjdGlvbiBUZW1wbGF0ZSdzIHBpbnMgbWF0Y2ggdGhvc2UgZ2VuZXJhdGVkIGF0IGEgYmxvY2sgaGVpZ2h0XG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGVtcGxhdGUgLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSB0byBjaGVjayBwaW5zIGZvclxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ibG9ja0hlaWdodCAtIEJsb2NrIGhlaWdodCB0byBjaGVjayBwaW5zIGF0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5ldHdvcmsgLSBOZXR3b3JrIHRvIGNoZWNrIHBpbnMgb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcGlucyBtYXRjaFxuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWUoX3JlZikge1xuICBsZXQge1xuICAgIHRlbXBsYXRlLFxuICAgIGJsb2NrSGVpZ2h0LFxuICAgIG5ldHdvcmtcbiAgfSA9IF9yZWY7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlID09PSBcIm9iamVjdFwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0ZW1wbGF0ZS5mX3R5cGUgPT09IFwiSW50ZXJhY3Rpb25UZW1wbGF0ZVwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUgPSBub3JtYWxpemVJbnRlcmFjdGlvblRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgaW52YXJpYW50JDEobmV0d29yayAhPSB1bmRlZmluZWQsIFwiZ2VuZXJhdGVEZXBlbmRlbmN5UGluKHsgbmV0d29yayB9KSBuZXR3b3JrIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEoYmxvY2tIZWlnaHQgIT0gdW5kZWZpbmVkLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGJsb2NrSGVpZ2h0IH0pIGJsb2NrSGVpZ2h0IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIGJsb2NrSGVpZ2h0ID09PSBcIm51bWJlclwiLCBcImdlbmVyYXRlRGVwZW5kZW5jeVBpbih7IGJsb2NrSGVpZ2h0IH0pIGJsb2NrSGVpZ2h0IG11c3QgYmUgYSBudW1iZXJcIik7XG4gIHN3aXRjaCAodGVtcGxhdGUuZl92ZXJzaW9uKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICBsZXQgdGVtcGxhdGVEZXBlbmRlbmNpZXNQbGFjZWhvbGRlcktleXMgPSBPYmplY3Qua2V5cyh0ZW1wbGF0ZS5kYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICBmb3IgKGxldCB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlcktleSBvZiB0ZW1wbGF0ZURlcGVuZGVuY2llc1BsYWNlaG9sZGVyS2V5cykge1xuICAgICAgICBsZXQgdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXIgPSB0ZW1wbGF0ZS5kYXRhLmRlcGVuZGVuY2llc1t0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlcktleV07XG4gICAgICAgIGxldCB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0TmFtZXMgPSBPYmplY3Qua2V5cyh0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlcik7XG4gICAgICAgIGZvciAobGV0IHRlbXBsYXRlRGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3ROYW1lIG9mIHRlbXBsYXRlRGVwZW5kZW5jeVBsYWNlaG9sZGVyQ29udHJhY3ROYW1lcykge1xuICAgICAgICAgIGxldCB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0TmV0d29ya3MgPSB0ZW1wbGF0ZS5kYXRhLmRlcGVuZGVuY2llc1t0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlcktleV1bdGVtcGxhdGVEZXBlbmRlbmN5UGxhY2Vob2xkZXJDb250cmFjdE5hbWVdO1xuICAgICAgICAgIGxldCB0ZW1wbGF0ZURlcGVuZGVuY3kgPSB0ZW1wbGF0ZURlcGVuZGVuY3lQbGFjZWhvbGRlckNvbnRyYWN0TmV0d29ya3NbbmV0d29ya107XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZURlcGVuZGVuY3kgPT09IFwidW5kZWZpbmVkXCIpIGNvbnRpbnVlO1xuICAgICAgICAgIGxldCBwaW4gPSBhd2FpdCBnZW5lcmF0ZURlcGVuZGVuY3lQaW4oe1xuICAgICAgICAgICAgYWRkcmVzczogdGVtcGxhdGVEZXBlbmRlbmN5LmFkZHJlc3MsXG4gICAgICAgICAgICBjb250cmFjdE5hbWU6IHRlbXBsYXRlRGVwZW5kZW5jeS5jb250cmFjdCxcbiAgICAgICAgICAgIGJsb2NrSGVpZ2h0XG4gICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgaWYgKHBpbiAhPT0gdGVtcGxhdGVEZXBlbmRlbmN5LnBpbikge1xuICAgICAgICAgICAgbG9nKHtcbiAgICAgICAgICAgICAgdGl0bGU6IFwidmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lIERlYnVnIEVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgcmVjb21wdXRlIGFuZCBtYXRjaCBkZXBlbmRlbmN5IHBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogJHt0ZW1wbGF0ZURlcGVuZGVuY3kuYWRkcmVzc30gfCBjb250cmFjdDogJHt0ZW1wbGF0ZURlcGVuZGVuY3kuY29udHJhY3R9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiAke3Bpbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICR7dGVtcGxhdGVEZXBlbmRlbmN5LnBpbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLFxuICAgICAgICAgICAgICBsZXZlbDogTEVWRUxTLmRlYnVnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWUgRXJyb3I6IFVuc3VwcG9ydGVkIHRlbXBsYXRlIHZlcnNpb25cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIGFuIEludGVyYWN0aW9uIFRlbXBsYXRlJ3MgcGlucyBtYXRjaCB0aG9zZSBnZW5lcmF0ZWQgYXQgdGhlIGxhdGVzdCBibG9jayBoZWlnaHRcbiAqIFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlIHRvIGNoZWNrIHBpbnMgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5ldHdvcmsgLSBOZXR3b3JrIHRvIGNoZWNrIHBpbnMgb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcGlucyBtYXRjaFxuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWVBdExhdGVzdFNlYWxlZEJsb2NrKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgdGVtcGxhdGUsXG4gICAgbmV0d29ya1xuICB9ID0gX3JlZjI7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IGxhdGVzdFNlYWxlZEJsb2NrID0gYXdhaXQgYmxvY2soe1xuICAgIHNlYWxlZDogdHJ1ZVxuICB9KTtcbiAgbGV0IGxhdGVzdFNlYWxlZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0U2VhbGVkQmxvY2s/LmhlaWdodDtcbiAgcmV0dXJuIHZlcmlmeURlcGVuZGVuY3lQaW5zU2FtZSh7XG4gICAgdGVtcGxhdGUsXG4gICAgbmV0d29yayxcbiAgICBibG9ja0hlaWdodDogbGF0ZXN0U2VhbGVkQmxvY2tIZWlnaHRcbiAgfSwgb3B0cyk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldCBJbnRlcmFjdGlvbiBUZW1wbGF0ZSBhcmd1bWVudCBtZXNzYWdlXG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubG9jYWxpemF0aW9uIFtsb2NhbGl6YXRpb249XCJlbi1VU1wiXSAtIExvY2FsaXphdGlvbiBjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2VLZXkgLSBNZXNzYWdlIGtleVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50ZW1wbGF0ZSAtIEludGVyYWN0aW9uIFRlbXBsYXRlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcGxhdGVNZXNzYWdlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBsb2NhbGl6YXRpb24gPSBcImVuLVVTXCIsXG4gICAgbWVzc2FnZUtleSxcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjtcbiAgaW52YXJpYW50JDEobWVzc2FnZUtleSwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyBtZXNzYWdlS2V5IH0pIC0tIG1lc3NhZ2VLZXkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgbWVzc2FnZUtleSA9PT0gXCJzdHJpbmdcIiwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyBtZXNzYWdlS2V5IH0pIC0tIG1lc3NhZ2VLZXkgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEobG9jYWxpemF0aW9uLCBcImdldFRlbXBsYXRlTWVzc2FnZSh7IGxvY2FsaXphdGlvbiB9KSAtLSBsb2NhbGl6YXRpb24gbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgbG9jYWxpemF0aW9uID09PSBcInN0cmluZ1wiLCBcImdldFRlbXBsYXRlTWVzc2FnZSh7IGxvY2FsaXphdGlvbiB9KSAtLSBsb2NhbGl6YXRpb24gbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEodGVtcGxhdGUgIT0gdW5kZWZpbmVkLCBcImdldFRlbXBsYXRlTWVzc2FnZSh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlID09PSBcIm9iamVjdFwiLCBcImdldFRlbXBsYXRlTWVzc2FnZSh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgdGVtcGxhdGUuZl90eXBlID09PSBcIkludGVyYWN0aW9uVGVtcGxhdGVcIiwgXCJnZXRUZW1wbGF0ZU1lc3NhZ2UoeyB0ZW1wbGF0ZSB9KSAtLSB0ZW1wbGF0ZSBvYmplY3QgbXVzdCBiZSBhbiBJbnRlcmFjdGlvblRlbXBsYXRlXCIpO1xuICBjb25zdCBtZXNzYWdlcyA9IHRlbXBsYXRlPy5kYXRhPy5tZXNzYWdlcztcbiAgcmV0dXJuIG1lc3NhZ2VzPy5bbWVzc2FnZUtleV0/LmkxOG4/Lltsb2NhbGl6YXRpb25dO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIEludGVyYWN0aW9uIFRlbXBsYXRlIGFyZ3VtZW50IG1lc3NhZ2UgYnkgbWVzc2FnZSBrZXksIGFyZ3VtZW50IGxhYmVsLCBhbmQgbG9jYWxpemF0aW9uXG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGl6YXRpb24gW2xvY2FsaXphdGlvbj1cImVuLVVTXCJdIC0gTG9jYWxpemF0aW9uIHRvIGdldCBtZXNzYWdlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuYXJndW1lbnRMYWJlbCAtIEFyZ3VtZW50IGxhYmVsIHRvIGdldCBtZXNzYWdlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubWVzc2FnZUtleSAtIE1lc3NhZ2Uga2V5IHRvIGdldCBtZXNzYWdlIGZvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMudGVtcGxhdGUgLSBJbnRlcmFjdGlvbiBUZW1wbGF0ZSB0byBnZXQgbWVzc2FnZSBmcm9tXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIE1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoX3JlZikge1xuICBsZXQge1xuICAgIGxvY2FsaXphdGlvbiA9IFwiZW4tVVNcIixcbiAgICBhcmd1bWVudExhYmVsLFxuICAgIG1lc3NhZ2VLZXksXG4gICAgdGVtcGxhdGVcbiAgfSA9IF9yZWY7XG4gIGludmFyaWFudCQxKG1lc3NhZ2VLZXksIFwiZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoeyBtZXNzYWdlS2V5IH0pIC0tIG1lc3NhZ2VLZXkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMSh0eXBlb2YgbWVzc2FnZUtleSA9PT0gXCJzdHJpbmdcIiwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IG1lc3NhZ2VLZXkgfSkgLS0gbWVzc2FnZUtleSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBpbnZhcmlhbnQkMShhcmd1bWVudExhYmVsLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgYXJndW1lbnRMYWJlbCB9KSAtLSBhcmd1bWVudExhYmVsIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIG1lc3NhZ2VLZXkgPT09IFwic3RyaW5nXCIsIFwiZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoeyBhcmd1bWVudExhYmVsIH0pIC0tIGFyZ3VtZW50TGFiZWwgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50JDEobG9jYWxpemF0aW9uLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgbG9jYWxpemF0aW9uIH0pIC0tIGxvY2FsaXphdGlvbiBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiBsb2NhbGl6YXRpb24gPT09IFwic3RyaW5nXCIsIFwiZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2UoeyBsb2NhbGl6YXRpb24gfSkgLS0gbG9jYWxpemF0aW9uIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIGludmFyaWFudCQxKHRlbXBsYXRlICE9IHVuZGVmaW5lZCwgXCJnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZSh7IHRlbXBsYXRlIH0pIC0tIHRlbXBsYXRlIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50JDEodHlwZW9mIHRlbXBsYXRlID09PSBcIm9iamVjdFwiLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGludmFyaWFudCQxKHR5cGVvZiB0ZW1wbGF0ZS5mX3R5cGUgPT09IFwiSW50ZXJhY3Rpb25UZW1wbGF0ZVwiLCBcImdldFRlbXBsYXRlQXJndW1lbnRNZXNzYWdlKHsgdGVtcGxhdGUgfSkgLS0gdGVtcGxhdGUgb2JqZWN0IG11c3QgYmUgYW4gSW50ZXJhY3Rpb25UZW1wbGF0ZVwiKTtcbiAgY29uc3QgYXJncyA9IHRlbXBsYXRlPy5kYXRhPy5hcmd1bWVudHM7XG4gIHJldHVybiBhcmdzPy5bYXJndW1lbnRMYWJlbF0/Lm1lc3NhZ2VzPy5bbWVzc2FnZUtleV0/LmkxOG4/Lltsb2NhbGl6YXRpb25dO1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0czogZ2V0SW50ZXJhY3Rpb25UZW1wbGF0ZUF1ZGl0cyxcbiAgZ2VuZXJhdGVEZXBlbmRlbmN5UGluOiBnZW5lcmF0ZURlcGVuZGVuY3lQaW4sXG4gIGdlbmVyYXRlRGVwZW5kZW5jeVBpbkF0TGF0ZXN0U2VhbGVkQmxvY2s6IGdlbmVyYXRlRGVwZW5kZW5jeVBpbkF0TGF0ZXN0U2VhbGVkQmxvY2ssXG4gIGdlbmVyYXRlVGVtcGxhdGVJZDogZ2VuZXJhdGVUZW1wbGF0ZUlkLFxuICBnZW5lcmF0ZVRlbXBsYXRlSW50ZXJmYWNlSWQ6IGdlbmVyYXRlVGVtcGxhdGVJbnRlcmZhY2VJZCxcbiAgdmVyaWZ5RGVwZW5kZW5jeVBpbnNTYW1lOiB2ZXJpZnlEZXBlbmRlbmN5UGluc1NhbWUsXG4gIHZlcmlmeURlcGVuZGVuY3lQaW5zU2FtZUF0TGF0ZXN0U2VhbGVkQmxvY2s6IHZlcmlmeURlcGVuZGVuY3lQaW5zU2FtZUF0TGF0ZXN0U2VhbGVkQmxvY2ssXG4gIGRlcml2ZUNhZGVuY2VCeU5ldHdvcms6IGRlcml2ZUNhZGVuY2VCeU5ldHdvcmssXG4gIGdldFRlbXBsYXRlTWVzc2FnZTogZ2V0VGVtcGxhdGVNZXNzYWdlLFxuICBnZXRUZW1wbGF0ZUFyZ3VtZW50TWVzc2FnZTogZ2V0VGVtcGxhdGVBcmd1bWVudE1lc3NhZ2Vcbn0pO1xuXG4vKipcbiAqIEB0eXBlIHtUeXBlc31cbiAqL1xuY29uc3QgdCA9IHQkMTtcblxuLy8gU2V0IGNoYWluIGlkIGRlZmF1bHQgb24gYWNjZXNzIG5vZGUgY2hhbmdlXG53YXRjaEZvckNoYWluSWRDaGFuZ2VzKCk7XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmljZXMoc2VydmljZXNVUkwsIGNvZGUpIHtcbiAgaWYgKHNlcnZpY2VzVVJMID09IG51bGwgfHwgY29kZSA9PSBudWxsKSByZXR1cm4gW107XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoc2VydmljZXNVUkwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNvZGVcIiwgY29kZSk7XG4gIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9XG4gIH0pLnRoZW4oZCA9PiBkLmpzb24oKSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHJlc3ApKSByZXR1cm4gcmVzcDtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgRmlyc3QtR2VuIFdhbGxldCBQcm92aWRlcnNcbiAgY29uc3Qgc2VydmljZXMgPSBbXTtcblxuICAvLyBDb252ZXJ0IGF1dGhvcml6YXRpb25zIGludG8gYXV0aHogc2VydmljZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzcC5hdXRob3JpemF0aW9ucykpIHtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIHJlc3AuYXV0aG9yaXphdGlvbnMpIHtcbiAgICAgIHNlcnZpY2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImF1dGh6XCIsXG4gICAgICAgIGtleUlkOiByZXNwLmtleUlkLFxuICAgICAgICAuLi5zZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDb252ZXJ0IFByb3ZpZGVyIGluZm8gaW50byBhbiBhdXRobiBzZXJ2aWNlXG4gIGlmIChyZXNwLnByb3ZpZGVyICE9IG51bGwpIHtcbiAgICBzZXJ2aWNlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiYXV0aG5cIixcbiAgICAgIGlkOiBcIndhbGxldC1wcm92aWRlciNhdXRoblwiLFxuICAgICAgLi4ucmVzcC5wcm92aWRlclxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZXJ2aWNlcztcbn1cblxuZnVuY3Rpb24gbWVyZ2VTZXJ2aWNlcygpIHtcbiAgbGV0IHN4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBzeDIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAvLyBUT0RPOiBNYWtlIHRoaXMgc21hcnRlclxuICByZXR1cm4gWy4uLnN4MSwgLi4uc3gyXTtcbn1cblxuLy8ge1xuLy8gICBcImZfdHlwZVwiOiBcIlNlcnZpY2VcIixcbi8vICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgIFwidHlwZVwiOiBcImF1dGhuXCIsXG4vLyAgIFwidWlkXCI6IFwidW5pcXVlRGVkdXBlS2V5XCIsXG4vLyAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3Jhd3JcIixcbi8vICAgXCJpZFwiOiBcInh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFwiLCAvLyB3YWxsZXRzIGludGVybmFsIGlkIGZvciB0aGUgdXNlclxuLy8gICBcImlkZW50aXR5XCI6IHtcbi8vICAgICBcImFkZHJlc3NcIjogXCIweF9fX19cIlxuLy8gICB9LFxuLy8gICBcInByb3ZpZGVyXCI6IHtcbi8vICAgICBcImFkZHJlc3NcIjogXCIweF9fX19cIixcbi8vICAgICBcIm5hbWVcIjogXCJCZXN0IFdhbGxldFwiLFxuLy8gICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgQmVzdCBXYWxsZXRcIlxuLy8gICAgIFwiaWNvblwiOiBcImh0dHBzOi8vXCIsXG4vLyAgIH1cbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUF1dGhuKHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoc2VydmljZVtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gc2VydmljZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uU0VSVklDRV9QUkFHTUEsXG4gICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZSxcbiAgICAgICAgdWlkOiBzZXJ2aWNlLmlkLFxuICAgICAgICBlbmRwb2ludDogc2VydmljZS5hdXRobixcbiAgICAgICAgaWQ6IHNlcnZpY2UucGlkLFxuICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgIGFkZHJlc3M6IHdpdGhQcmVmaXgoc2VydmljZS5hZGRyKSxcbiAgICAgICAgICBuYW1lOiBzZXJ2aWNlLm5hbWUsXG4gICAgICAgICAgaWNvbjogc2VydmljZS5pY29uXG4gICAgICAgIH1cbiAgICAgIH07XG4gIH1cbn1cblxuLy8ge1xuLy8gICBcImZfdHlwZVwiOiBcInNlcnZpY2VcIixcbi8vICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgIFwidHlwZVwiOiBcImF1dGh6XCIsXG4vLyAgIFwidWlkXCI6IFwidW5pcXVlRGVkdXBlS2V5XCIsXG4vLyAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3Jhd3JcIixcbi8vICAgXCJtZXRob2RcIjogXCJIVFRQL1BPU1RcIiwgLy8gSFRUUC9QT1NUIHwgSUZSQU1FL1JQQyB8IEhUVFAvUlBDXG4vLyAgIFwiaWRlbnRpdHlcIjoge1xuLy8gICAgICBcImFkZHJlc3NcIjogXCIweF9fX19fX1wiLFxuLy8gICAgICBcImtleUlkXCI6IDAsXG4vLyAgIH0sXG4vLyAgIFwiZGF0YVwiOiB7fSwgLy8gaW5jbHVkZWQgaW4gYm9keSBvZiBhdXRoeiByZXF1ZXN0XG4vLyAgIFwicGFyYW1zXCI6IHt9LCAvLyBpbmNsdWRlZCBhcyBxdWVyeSBwYXJhbXMgb24gZW5kcG9pbnQgdXJsXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVBdXRoeihzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLlNFUlZJQ0VfUFJBR01BLFxuICAgICAgICB0eXBlOiBzZXJ2aWNlLnR5cGUsXG4gICAgICAgIHVpZDogc2VydmljZS5pZCxcbiAgICAgICAgZW5kcG9pbnQ6IHNlcnZpY2UuZW5kcG9pbnQsXG4gICAgICAgIG1ldGhvZDogc2VydmljZS5tZXRob2QsXG4gICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgLi4uSURFTlRJVFlfUFJBR01BLFxuICAgICAgICAgIGFkZHJlc3M6IHdpdGhQcmVmaXgoc2VydmljZS5hZGRyKSxcbiAgICAgICAgICBrZXlJZDogc2VydmljZS5rZXlJZFxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGFcbiAgICAgIH07XG4gIH1cbn1cblxuLy8ge1xuLy8gICBcImZfdHlwZVwiOiBcInNlcnZpY2VcIixcbi8vICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgIFwidHlwZVwiOiBcInByZS1hdXRoelwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgIFwibWV0aG9kXCI6IFwiSFRUUC9QT1NUXCIsIC8vIEhUVFAvUE9TVCB8IElGUkFNRS9SUEMgfCBIVFRQL1JQQ1xuLy8gICBcImlkZW50aXR5XCI6IHtcbi8vICAgICAgXCJhZGRyZXNzXCI6IFwiMHhfX19fX19cIixcbi8vICAgICAgXCJrZXlJZFwiOiAwLFxuLy8gICB9LFxuLy8gICBcImRhdGFcIjoge30sIC8vIGluY2x1ZGVkIGluIGJvZHkgb2YgcHJlLWF1dGh6IHJlcXVlc3Rcbi8vICAgXCJwYXJhbXNcIjoge30sIC8vIGluY2x1ZGVkIGFzIHF1ZXJ5IHBhcmFtcyBvbiBlbmRwb2ludCB1cmxcbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByZUF1dGh6KHNlcnZpY2UpIHtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoc2VydmljZVtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gc2VydmljZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uU0VSVklDRV9QUkFHTUEsXG4gICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZSxcbiAgICAgICAgdWlkOiBzZXJ2aWNlLmlkLFxuICAgICAgICBlbmRwb2ludDogc2VydmljZS5lbmRwb2ludCxcbiAgICAgICAgbWV0aG9kOiBzZXJ2aWNlLm1ldGhvZCxcbiAgICAgICAgaWRlbnRpdHk6IHtcbiAgICAgICAgICAuLi5JREVOVElUWV9QUkFHTUEsXG4gICAgICAgICAgYWRkcmVzczogd2l0aFByZWZpeChzZXJ2aWNlLmFkZHIpLFxuICAgICAgICAgIGtleUlkOiBzZXJ2aWNlLmtleUlkXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YVxuICAgICAgfTtcbiAgfVxufVxuXG4vLyB7XG4vLyAgICBcImZfdHlwZVwiOiBcIlNlcnZpY2VcIixcbi8vICAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICAgXCJ0eXBlXCI6IFwiZnJhbWVcIixcbi8vICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3Jhd3JcIixcbi8vICAgIFwiZGF0YVwiOiB7fSwgICAvLyBTZW50IHRvIGZyYW1lIHdoZW4gcmVhZHlcbi8vICAgIFwicGFyYW1zXCI6IHt9LCAvLyBpbmNsdWRlIGluIHF1ZXJ5IHBhcmFtcyBvbiBmcmFtZVxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplRnJhbWUoc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbGQ6IHNlcnZpY2UsXG4gICAgICAgIC4uLlNFUlZJQ0VfUFJBR01BLFxuICAgICAgICB0eXBlOiBcImZyYW1lXCIsXG4gICAgICAgIGVuZHBvaW50OiBzZXJ2aWNlLmVuZHBvaW50LFxuICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zIHx8IHt9LFxuICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEgfHwge31cbiAgICAgIH07XG4gIH1cbn1cblxuLy8ge1xuLy8gICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgIFwidHlwZVwiOiBcImJhY2stY2hhbm5lbC1ycGNcIixcbi8vICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3Jhd3JcIixcbi8vICAgIFwibWV0aG9kXCI6IFwiSFRUUC9HRVRcIiwgLy8gSFRUUC9HRVQgfCBIVFRQL1BPU1Rcbi8vICAgIFwiZGF0YVwiOiB7fSwgICAgICAgICAgIC8vIGluY2x1ZGVkIGluIGJvZHkgb2YgcnBjXG4vLyAgICBcInBhcmFtc1wiOiB7fSwgICAgICAgICAvLyBpbmNsdWRlZCBhcyBxdWVyeSBwYXJhbXMgb24gZW5kcG9pbnQgdXJsXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVCYWNrQ2hhbm5lbFJwYyhzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLlNFUlZJQ0VfUFJBR01BLFxuICAgICAgICB0eXBlOiBcImJhY2stY2hhbm5lbC1ycGNcIixcbiAgICAgICAgZW5kcG9pbnQ6IHNlcnZpY2UuZW5kcG9pbnQsXG4gICAgICAgIG1ldGhvZDogc2VydmljZS5tZXRob2QsXG4gICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMgfHwge30sXG4gICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSB8fCB7fVxuICAgICAgfTtcbiAgfVxufVxuXG4vLyB7XG4vLyAgIFwiZl90eXBlXCI6IFwiU2VydmljZVwiLFxuLy8gICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgXCJ0eXBlXCI6IFwib3Blbi1pZFwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcIm1ldGhvZDogXCJkYXRhXCIsXG4vLyAgIFwiZGF0YVwiOiB7XG4vLyAgICAgIFwicHJvZmlsZVwiOiB7XG4vLyAgICAgICAgXCJuYW1lXCI6IFwiQm9iXCIsXG4vLyAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJ1aWxkZXJcIixcbi8vICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSb2JlcnRcIixcbi8vICAgICAgICBcIm1pZGRsZV9uYW1lXCI6IFwidGhlXCIsXG4vLyAgICAgICAgXCJuaWNrbmFtZVwiOiBcIkJvYiB0aGUgQnVpbGRlclwiLFxuLy8gICAgICAgIFwicGVyZmVycmVkX3VzZXJuYW1lXCI6IFwiYm9iXCIsXG4vLyAgICAgICAgXCJwcm9maWxlXCI6IFwiaHR0cHM6Ly93d3cuYm9idGhlYnVpbGRlci5jb20vXCIsXG4vLyAgICAgICAgXCJwaWN0dXJlXCI6IFwiaHR0cHM6Ly9hdmF0YXJzLm9uZmxvdy5vcmcvYXZhdGFyL2JvYlwiLFxuLy8gICAgICAgIFwiZ2VuZGVyXCI6IFwiLi4uXCIsXG4vLyAgICAgICAgXCJiaXJ0aGRheVwiOiBcIjIwMDEtMDEtMThcIixcbi8vICAgICAgICBcInpvbmVpbmZvXCI6IFwiQW1lcmljYS9WYW5jb3V2ZXJcIixcbi8vICAgICAgICBcImxvY2FsZVwiOiBcImVuLXVzXCIsXG4vLyAgICAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMTYxNDk3MDc5NzM4OFwiXG4vLyAgICAgIH0sXG4vLyAgICAgIFwiZW1haWxcIjoge1xuLy8gICAgICAgIFwiZW1haWxcIjogXCJib2JAYm9iLmJvYlwiLFxuLy8gICAgICAgIFwiZW1haWxfdmVyaWZpZWRcIjogdHJ1ZVxuLy8gICAgICB9LFxuLy8gICAgICBcImFkZHJlc3NcIjoge1xuLy8gICAgICAgIFwiYWRkcmVzc1wiOiBcIk9uZSBBcHBsZSBQYXJrIFdheSwgQ3VwZXJ0aW5vLCBDQSA5NTAxNCwgVVNBXCJcbi8vICAgICAgfSxcbi8vICAgICAgXCJwaG9uZVwiOiB7XG4vLyAgICAgICAgXCJwaG9uZV9udW1iZXJcIjogXCIrMSAoeHh4KSB5eXktenp6elwiLFxuLy8gICAgICAgIFwicGhvbmVfbnVtYmVyX3ZlcmlmaWVkXCI6IHRydWVcbi8vICAgICAgfSxcbi8vICAgICAgXCJzb2NpYWxcIjoge1xuLy8gICAgICAgIFwidHdpdHRlclwiOiBcIkBfcXZ2Z1wiLFxuLy8gICAgICAgIFwidHdpdHRlcl92ZXJpZmllZFwiOiB0cnVlXG4vLyAgICAgIH0sXG4vLyAgIH1cbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wZW5JZChzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICBcInR5cGVcIjogXCJ1c2VyLXNpZ25hdHVyZVwiLFxuLy8gICBcInVpZFwiOiBcInVuaXF1ZURlZHVwZUtleVwiLFxuLy8gICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9yYXdyXCIsXG4vLyAgIFwibWV0aG9kXCI6IFwiSUZSQU1FL1JQQ1wiLCAvLyBIVFRQL1BPU1QgfCBJRlJBTUUvUlBDIHwgSFRUUC9SUENcbi8vICAgXCJpZFwiOiBcInh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFwiLCAvLyB3YWxsZXRzIGludGVybmFsIGlkIGZvciB0aGUgdXNlclxuLy8gICBcImRhdGFcIjoge30sIC8vIGluY2x1ZGVkIGluIGJvZHkgb2YgdXNlci1zaWduYXR1cmUgcmVxdWVzdFxuLy8gICBcInBhcmFtc1wiOiB7fSwgLy8gaW5jbHVkZWQgYXMgcXVlcnkgcGFyYW1zIG9uIGVuZHBvaW50IHVybFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplVXNlclNpZ25hdHVyZShzZXJ2aWNlKSB7XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiBudWxsO1xuICBzd2l0Y2ggKHNlcnZpY2VbXCJmX3ZzblwiXSkge1xuICAgIGNhc2UgXCIxLjAuMFwiOlxuICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXNlci1zaWduYXR1cmUgc2VydmljZVwiKTtcbiAgfVxufVxuXG4vLyB7XG4vLyAgICBcImZfdHlwZVwiOiBcIlNlcnZpY2VcIixcbi8vICAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICAgdHlwZTogXCJsb2NhbC12aWV3XCIsXG4vLyAgICBtZXRob2Q6IFwiVklFVy9JRlJBTUVcIixcbi8vICAgIGVuZHBvaW50OiBcImh0dHBzOi8vd29vdC5vcmcvYXV0aHovbG9jYWxcIixcbi8vICAgIGRhdGE6IHt9LFxuLy8gICAgcGFyYW1zOiB7fSxcbi8vIH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsVmlldyhyZXNwKSB7XG4gIGlmIChyZXNwID09IG51bGwpIHJldHVybiBudWxsO1xuICBpZiAocmVzcC5tZXRob2QgPT0gbnVsbCkge1xuICAgIHJlc3AgPSB7XG4gICAgICAuLi5yZXNwLFxuICAgICAgdHlwZTogXCJsb2NhbC12aWV3XCIsXG4gICAgICBtZXRob2Q6IFwiVklFVy9JRlJBTUVcIlxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyZXNwW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiByZXNwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5TRVJWSUNFX1BSQUdNQSxcbiAgICAgICAgdHlwZTogcmVzcC50eXBlIHx8IFwibG9jYWwtdmlld1wiLFxuICAgICAgICBtZXRob2Q6IHJlc3AubWV0aG9kLFxuICAgICAgICBlbmRwb2ludDogcmVzcC5lbmRwb2ludCxcbiAgICAgICAgZGF0YTogcmVzcC5kYXRhIHx8IHt9LFxuICAgICAgICBwYXJhbXM6IHJlc3AucGFyYW1zIHx8IHt9XG4gICAgICB9O1xuICB9XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsICAgICAgICAgICAgICAgICAgICAvLyBJdHMgYSBzZXJ2aWNlIVxuLy8gICBcImZfdnNuXCI6IFwiMS4wLjBcIiwgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGxvd3MgdGhlIHYxLjAuMCBzcGVjIGZvciB0aGUgc2VydmljZVxuLy8gICBcInR5cGVcIjogXCJhY2NvdW50LXByb29mXCIsICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIHNlcnZpY2UgaXQgaXNcbi8vICAgXCJtZXRob2RcIjogXCJEQVRBXCIsICAgICAgICAgICAgICAgICAgICAgICAvLyBJdHMgZGF0YSFcbi8vICAgXCJ1aWRcIjogXCJhd2Vzb21lLXdhbGxldCNhY2NvdW50LXByb29mXCIsICAvLyBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2VydmljZVxuLy8gICBcImRhdGFcIjoge1xuLy8gICAgIFwiZl90eXBlXCI6IFwiYWNjb3VudC1wcm9vZlwiLFxuLy8gICAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICAgIFwibm9uY2VcIjogXCIwQTFCQzJGRlwiLCAgICAgICAgICAgICAgICAgIC8vIE5vbmNlIHNpZ25lZCBieSB0aGUgY3VycmVudCBhY2NvdW50LXByb29mIChtaW5pbXVtIDMyIGJ5dGVzIGluIHRvdGFsLCBpLmUgNjQgaGV4IGNoYXJhY3RlcnMpXG4vLyAgICAgXCJhZGRyZXNzXCI6IFwiMHhVU0VSXCIsICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIncyBhZGRyZXNzICg4IGJ5dGVzLCBpLmUgMTYgaGV4IGNoYXJhY3RlcnMpXG4vLyAgICAgXCJzaWduYXR1cmVcIjogQ29tcG9zaXRlU2lnbmF0dXJlLCAgICAgIC8vIGFkZHJlc3MgKHNhbnMtcHJlZml4KSwga2V5SWQsIHNpZ25hdHVyZSAoaGV4KVxuLy8gfVxuXG5mdW5jdGlvbiBub3JtYWxpemVBY2NvdW50UHJvb2Yoc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZDTCBOb3JtYWxpemVyIEVycm9yOiBJbnZhbGlkIGFjY291bnQtcHJvb2Ygc2VydmljZWApO1xuICB9XG59XG5cbi8vIHtcbi8vICAgXCJmX3R5cGVcIjogXCJTZXJ2aWNlXCIsXG4vLyAgIFwiZl92c25cIjogXCIxLjAuMFwiLFxuLy8gICBcInR5cGVcIjogXCJhdXRobi1yZWZyZXNoXCIsXG4vLyAgIFwidWlkXCI6IFwidW5pcXVlRGVkdXBlS2V5XCIsXG4vLyAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3Jhd3JcIixcbi8vICAgXCJtZXRob2RcIjogXCJIVFRQL1BPU1RcIiwgIC8vIFwiSFRUUC9QT1NUXCIsIC8vIEhUVFAvUE9TVCB8IElGUkFNRS9SUEMgfCBIVFRQL1JQQ1xuLy8gICBcImlkXCI6IFwieHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4XCIsIC8vIHdhbGxldHMgaW50ZXJuYWwgaWQgZm9yIHRoZSB1c2VyXG4vLyAgIFwiZGF0YVwiOiB7fSwgLy8gaW5jbHVkZWQgaW4gYm9keSBvZiByZXF1ZXN0XG4vLyAgIFwicGFyYW1zXCI6IHt9LCAvLyBpbmNsdWRlZCBhcyBxdWVyeSBwYXJhbXMgb24gZW5kcG9pbnQgdXJsXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVBdXRoblJlZnJlc2goc2VydmljZSkge1xuICBpZiAoc2VydmljZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChzZXJ2aWNlW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF1dGhuLXJlZnJlc2ggc2VydmljZVwiKTtcbiAgfVxufVxuXG5jb25zdCBzZXJ2aWNlTm9ybWFsaXplcnMgPSB7XG4gIFwiYmFjay1jaGFubmVsLXJwY1wiOiBub3JtYWxpemVCYWNrQ2hhbm5lbFJwYyxcbiAgXCJwcmUtYXV0aHpcIjogbm9ybWFsaXplUHJlQXV0aHosXG4gIGF1dGh6OiBub3JtYWxpemVBdXRoeixcbiAgYXV0aG46IG5vcm1hbGl6ZUF1dGhuLFxuICBmcmFtZTogbm9ybWFsaXplRnJhbWUsXG4gIFwib3Blbi1pZFwiOiBub3JtYWxpemVPcGVuSWQsXG4gIFwidXNlci1zaWduYXR1cmVcIjogbm9ybWFsaXplVXNlclNpZ25hdHVyZSxcbiAgXCJsb2NhbC12aWV3XCI6IG5vcm1hbGl6ZUxvY2FsVmlldyxcbiAgXCJhY2NvdW50LXByb29mXCI6IG5vcm1hbGl6ZUFjY291bnRQcm9vZixcbiAgXCJhdXRobi1yZWZyZXNoXCI6IG5vcm1hbGl6ZUF1dGhuUmVmcmVzaFxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlcnZpY2Uoc2VydmljZSwgZGF0YSkge1xuICB0cnkge1xuICAgIHZhciBub3JtYWxpemVkID0gc2VydmljZU5vcm1hbGl6ZXJzW3NlcnZpY2UudHlwZV0oc2VydmljZSwgZGF0YSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5yZWNvZ25pemVkIEZDTCBTZXJ2aWNlIFR5cGUgWyR7c2VydmljZS50eXBlfV1gLCBzZXJ2aWNlLCBlcnJvcik7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVyaXZlQ29tcG9zaXRlSWQoYXV0aG4pIHtcbiAgcmV0dXJuIHJscC5lbmNvZGUoW2F1dGhuLnByb3ZpZGVyLmFkZHJlc3MgfHwgYXV0aG4ucHJvdmlkZXIubmFtZSB8fCBcIlVOU1BFQ0lGSUVEXCIsIGF1dGhuLmlkXSkudG9TdHJpbmcoXCJoZXhcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEYXRhKGRhdGEpIHtcbiAgZGF0YS5hZGRyID0gZGF0YS5hZGRyID8gd2l0aFByZWZpeChkYXRhLmFkZHIpIDogbnVsbDtcbiAgZGF0YS5wYWRkciA9IGRhdGEucGFkZHIgPyB3aXRoUHJlZml4KGRhdGEucGFkZHIpIDogbnVsbDtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBmaW5kU2VydmljZSh0eXBlLCBzZXJ2aWNlcykge1xuICByZXR1cm4gc2VydmljZXMuZmluZChkID0+IGQudHlwZSA9PT0gdHlwZSk7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFVzZXIoZGF0YSkge1xuICBkYXRhID0gbm9ybWFsaXplRGF0YShkYXRhKTtcbiAgdmFyIHNlcnZpY2VzID0gbWVyZ2VTZXJ2aWNlcyhkYXRhLnNlcnZpY2VzIHx8IFtdLCBhd2FpdCBmZXRjaFNlcnZpY2VzKGRhdGEuaGtzLCBkYXRhLmNvZGUpKS5tYXAoc2VydmljZSA9PiBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UsIGRhdGEpKTtcbiAgY29uc3QgYXV0aG4gPSBmaW5kU2VydmljZShcImF1dGhuXCIsIHNlcnZpY2VzKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5VU0VSX1BSQUdNQSxcbiAgICBhZGRyOiB3aXRoUHJlZml4KGRhdGEuYWRkciksXG4gICAgY2lkOiBkZXJpdmVDb21wb3NpdGVJZChhdXRobiksXG4gICAgbG9nZ2VkSW46IHRydWUsXG4gICAgc2VydmljZXM6IHNlcnZpY2VzLFxuICAgIGV4cGlyZXNBdDogZGF0YS5leHBpcmVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlcnZpY2VPZlR5cGUoKSB7XG4gIGxldCBzZXJ2aWNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZXJ2aWNlcy5maW5kKHNlcnZpY2UgPT4gc2VydmljZS50eXBlID09PSB0eXBlKTtcbn1cblxuY29uc3QgZXhlY1N0cmF0ZWd5ID0gYXN5bmMgX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgc2VydmljZSxcbiAgICBib2R5LFxuICAgIGNvbmZpZyxcbiAgICBvcHRzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzdHJhdGVneSA9IGdldFNlcnZpY2VSZWdpc3RyeSgpLmdldFN0cmF0ZWd5KHNlcnZpY2UubWV0aG9kKTtcbiAgcmV0dXJuIHN0cmF0ZWd5KHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gZXhlY1NlcnZpY2UoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIG1zZyA9IHt9LFxuICAgIGNvbmZpZyA9IHt9LFxuICAgIG9wdHMgPSB7fSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjI7XG4gIG1zZy5kYXRhID0gc2VydmljZS5kYXRhO1xuICBjb25zdCBleGVjQ29uZmlnID0ge1xuICAgIHNlcnZpY2VzOiBhd2FpdCBjb25maWdMZW5zKC9ec2VydmljZVxcLi8pLFxuICAgIGFwcDogYXdhaXQgY29uZmlnTGVucygvXmFwcFxcLmRldGFpbFxcLi8pLFxuICAgIGNsaWVudDoge1xuICAgICAgLi4uY29uZmlnLmNsaWVudCxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgIGZjbExpYnJhcnk6IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mY2wtanNcIixcbiAgICAgIGhvc3RuYW1lOiB3aW5kb3c/LmxvY2F0aW9uPy5ob3N0bmFtZSA/PyBudWxsLFxuICAgICAgbmV0d29yazogYXdhaXQgZ2V0Q2hhaW5JZChvcHRzKVxuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjU3RyYXRlZ3koe1xuICAgICAgc2VydmljZSxcbiAgICAgIGJvZHk6IG1zZyxcbiAgICAgIGNvbmZpZzogZXhlY0NvbmZpZyxcbiAgICAgIG9wdHNcbiAgICB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gXCJSRURJUkVDVFwiKSB7XG4gICAgICBpbnZhcmlhbnQoc2VydmljZS50eXBlID09PSByZXMuZGF0YS50eXBlLCBcIkNhbm5vdCBzaGlmdCByZWN1cnNpdmUgc2VydmljZSB0eXBlIGluIGV4ZWNTZXJ2aWNlXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNTZXJ2aWNlKHtcbiAgICAgICAgc2VydmljZTogcmVzLmRhdGEsXG4gICAgICAgIG1zZyxcbiAgICAgICAgY29uZmlnOiBleGVjQ29uZmlnLFxuICAgICAgICBvcHRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBgRXJyb3Igb24gZXhlY1NlcnZpY2UgJHtzZXJ2aWNlPy50eXBlfWAsXG4gICAgICBtZXNzYWdlOiBlcnJvcixcbiAgICAgIGxldmVsOiBMRVZFTFMuZXJyb3JcbiAgICB9KTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyB7XG4vLyAgICBcImZfdHlwZVwiOiBcIkNvbXBvc2l0ZVNpZ25hdHVyZVwiLFxuLy8gICAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4vLyAgICBcImFkZHJcIjogXCJfX19fX1wiLCAgICAgICAgIC8vIHNhbnMtcHJlZml4XG4vLyAgICBcInNpZ25hdHVyZVwiOiBcImFkZmUxMjM0XCIsIC8vIGhleFxuLy8gICAgXCJrZXlJZFwiOiAzLFxuLy8gfVxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9zaXRlU2lnbmF0dXJlKHJlc3ApIHtcbiAgaWYgKHJlc3AgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAocmVzcFtcImZfdnNuXCJdKSB7XG4gICAgY2FzZSBcIjEuMC4wXCI6XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uQ09NUE9TSVRFX1NJR05BVFVSRV9QUkFHTUEsXG4gICAgICAgIGFkZHI6IHNhbnNQcmVmaXgocmVzcC5hZGRyIHx8IHJlc3AuYWRkcmVzcyksXG4gICAgICAgIHNpZ25hdHVyZTogcmVzcC5zaWduYXR1cmUgfHwgcmVzcC5zaWcsXG4gICAgICAgIGtleUlkOiByZXNwLmtleUlkXG4gICAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuQ3VycmVudFVzZXJ9IEN1cnJlbnRVc2VyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiQG9uZmxvdy90eXBlZGVmc1wiKS5Db21wb3NpdGVTaWduYXR1cmV9IENvbXBvc2l0ZVNpZ25hdHVyZVxuICovXG5cbmNvbnN0IGlzRm4gPSBkID0+IHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBOQU1FID0gXCJDVVJSRU5UX1VTRVJcIjtcbmNvbnN0IFVQREFURUQgPSBcIkNVUlJFTlRfVVNFUi9VUERBVEVEXCI7XG5jb25zdCBTTkFQU0hPVCA9IFwiU05BUFNIT1RcIjtcbmNvbnN0IFNFVF9DVVJSRU5UX1VTRVIgPSBcIlNFVF9DVVJSRU5UX1VTRVJcIjtcbmNvbnN0IERFTF9DVVJSRU5UX1VTRVIgPSBcIkRFTF9DVVJSRU5UX1VTRVJcIjtcbmNvbnN0IERBVEEgPSBge1xuICBcImZfdHlwZVwiOiBcIlVzZXJcIixcbiAgXCJmX3ZzblwiOiBcIjEuMC4wXCIsXG4gIFwiYWRkclwiOm51bGwsXG4gIFwiY2lkXCI6bnVsbCxcbiAgXCJsb2dnZWRJblwiOm51bGwsXG4gIFwiZXhwaXJlc0F0XCI6bnVsbCxcbiAgXCJzZXJ2aWNlc1wiOltdXG59YDtcbmNvbnN0IGdldFN0b3JlZFVzZXIgPSBhc3luYyBzdG9yYWdlID0+IHtcbiAgY29uc3QgZmFsbGJhY2sgPSBKU09OLnBhcnNlKERBVEEpO1xuICBjb25zdCBzdG9yZWQgPSBhd2FpdCBzdG9yYWdlLmdldChOQU1FKTtcbiAgaWYgKHN0b3JlZCAhPSBudWxsICYmIGZhbGxiYWNrW1wiZl92c25cIl0gIT09IHN0b3JlZFtcImZfdnNuXCJdKSB7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKE5BTUUpO1xuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICByZXR1cm4gc3RvcmVkIHx8IGZhbGxiYWNrO1xufTtcbmNvbnN0IEhBTkRMRVJTID0ge1xuICBbSU5JVF06IGFzeW5jIGN0eCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgXG4gICAgICAgICVjRkNMIFdhcm5pbmdcbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBcImN1cnJlbnRVc2VyXCIgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICAgIEZvciBtb3JlIGluZm8sIHBsZWFzZSBzZWUgdGhlIGRvY3M6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2ZjbC9cbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBgLCBcImZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO1wiKTtcbiAgICB9XG4gICAgY3R4Lm1lcmdlKEpTT04ucGFyc2UoREFUQSkpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBhd2FpdCBjb25maWcuZmlyc3QoW1wiZmNsLnN0b3JhZ2VcIiwgXCJmY2wuc3RvcmFnZS5kZWZhdWx0XCJdKTtcbiAgICBpZiAoc3RvcmFnZS5jYW4pIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXRTdG9yZWRVc2VyKHN0b3JhZ2UpO1xuICAgICAgaWYgKG5vdEV4cGlyZWQodXNlcikpIGN0eC5tZXJnZSh1c2VyKTtcbiAgICB9XG4gIH0sXG4gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVTlNVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC51bnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gIH0sXG4gIFtTTkFQU0hPVF06IGFzeW5jIChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldHRlci5yZXBseSh7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1NFVF9DVVJSRU5UX1VTRVJdOiBhc3luYyAoY3R4LCBsZXR0ZXIsIGRhdGEpID0+IHtcbiAgICBjdHgubWVyZ2UoZGF0YSk7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJmY2wuc3RvcmFnZVwiLCBcImZjbC5zdG9yYWdlLmRlZmF1bHRcIl0pO1xuICAgIGlmIChzdG9yYWdlLmNhbikgc3RvcmFnZS5wdXQoTkFNRSwgY3R4LmFsbCgpKTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbREVMX0NVUlJFTlRfVVNFUl06IGFzeW5jIChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5tZXJnZShKU09OLnBhcnNlKERBVEEpKTtcbiAgICBjb25zdCBzdG9yYWdlID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcImZjbC5zdG9yYWdlXCIsIFwiZmNsLnN0b3JhZ2UuZGVmYXVsdFwiXSk7XG4gICAgaWYgKHN0b3JhZ2UuY2FuKSBzdG9yYWdlLnB1dChOQU1FLCBjdHguYWxsKCkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCBzcGF3bkN1cnJlbnRVc2VyID0gKCkgPT4gc3Bhd24oSEFORExFUlMsIE5BTUUpO1xuZnVuY3Rpb24gbm90RXhwaXJlZCh1c2VyKSB7XG4gIHJldHVybiB1c2VyLmV4cGlyZXNBdCA9PSBudWxsIHx8IHVzZXIuZXhwaXJlc0F0ID09PSAwIHx8IHVzZXIuZXhwaXJlc0F0ID4gRGF0ZS5ub3coKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRQcm9vZkRhdGEoKSB7XG4gIGxldCBhY2NvdW50UHJvb2ZEYXRhUmVzb2x2ZXIgPSBhd2FpdCBjb25maWcuZ2V0KFwiZmNsLmFjY291bnRQcm9vZi5yZXNvbHZlclwiKTtcbiAgaWYgKGFjY291bnRQcm9vZkRhdGFSZXNvbHZlciA9PSBudWxsKSByZXR1cm47XG4gIGlmICghaXNGbihhY2NvdW50UHJvb2ZEYXRhUmVzb2x2ZXIpKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcIkFjY291bnQgUHJvb2YgRGF0YSBSZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgICAgIG1lc3NhZ2U6IGBDaGVjayBmY2wuYWNjb3VudFByb29mLnJlc29sdmVyIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICAgICAgRXhwZWN0ZWQ6IGZjbC5hY2NvdW50UHJvb2YucmVzb2x2ZXI6IGFzeW5jICgpID0+IHsgLi4uIH1cbiAgICAgICAgICAgICAgICBSZWNlaXZlZDogZmNsLmFjY291bnRQcm9vZi5yZXNvbHZlcjogJHt0eXBlb2YgYWNjb3VudFByb29mRGF0YVJlc29sdmVyfVxuICAgICAgICAgICAgICAgIGAsXG4gICAgICBsZXZlbDogTEVWRUxTLndhcm5cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYWNjb3VudFByb29mRGF0YSA9IGF3YWl0IGFjY291bnRQcm9vZkRhdGFSZXNvbHZlcigpO1xuICBpZiAoYWNjb3VudFByb29mRGF0YSA9PSBudWxsKSByZXR1cm47XG4gIGludmFyaWFudCh0eXBlb2YgYWNjb3VudFByb29mRGF0YS5hcHBJZGVudGlmaWVyID09PSBcInN0cmluZ1wiLCBcImFwcElkZW50aWZpZXIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaW52YXJpYW50KC9eWzAtOWEtZl0rJC9pLnRlc3QoYWNjb3VudFByb29mRGF0YS5ub25jZSksIFwiTm9uY2UgbXVzdCBiZSBhIGhleCBzdHJpbmdcIik7XG4gIHJldHVybiBhY2NvdW50UHJvb2ZEYXRhO1xufVxuY29uc3QgbWFrZUNvbmZpZyA9IGFzeW5jIF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGRpc2NvdmVyeUF1dGhuSW5jbHVkZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnQ6IHtcbiAgICAgIGRpc2NvdmVyeUF1dGhuSW5jbHVkZSxcbiAgICAgIGNsaWVudFNlcnZpY2VzOiBhd2FpdCBtYWtlRGlzY292ZXJ5U2VydmljZXMoKSxcbiAgICAgIHN1cHBvcnRlZFN0cmF0ZWdpZXM6IGdldFNlcnZpY2VSZWdpc3RyeSgpLmdldFN0cmF0ZWdpZXMoKVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQXV0aGVudGljYXRlIGEgdXNlclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIE9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0cy5wbGF0Zm9ybV0gLSBwbGF0Zm9ybSB0aGF0IHJ1bnMgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdHMuc2VydmljZV0gLSBPcHRpb25hbCBzZXJ2aWNlIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVkaXI9ZmFsc2VdIC0gT3B0aW9uYWwgZmxhZyB0byBhbGxvdyB3aW5kb3cgdG8gc3RheSBvcGVuIGFmdGVyIGF1dGhlbnRpY2F0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDdXJyZW50VXNlcj59IC0gVXNlciBvYmplY3RcbiAqL1xuY29uc3QgZ2V0QXV0aGVudGljYXRlID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIHBsYXRmb3JtXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBsZXQge1xuICAgICAgc2VydmljZSxcbiAgICAgIHJlZGlyID0gZmFsc2VcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoc2VydmljZSAmJiAhc2VydmljZT8ucHJvdmlkZXI/LmlzX2luc3RhbGxlZCAmJiBzZXJ2aWNlPy5wcm92aWRlcj8ucmVxdWlyZXNfaW5zdGFsbCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBzZXJ2aWNlPy5wcm92aWRlcj8uaW5zdGFsbF9saW5rO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3Bhd25DdXJyZW50VXNlcigpO1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgcmVkaXJcbiAgICAgIH07XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgc25hcHNob3QoKTtcbiAgICAgIGNvbnN0IGRpc2NvdmVyeVNlcnZpY2UgPSBhd2FpdCBnZXREaXNjb3ZlcnlTZXJ2aWNlKHNlcnZpY2UpO1xuICAgICAgY29uc3QgcmVmcmVzaFNlcnZpY2UgPSBzZXJ2aWNlT2ZUeXBlKHVzZXIuc2VydmljZXMsIFwiYXV0aG4tcmVmcmVzaFwiKTtcbiAgICAgIGxldCBhY2NvdW50UHJvb2ZEYXRhO1xuICAgICAgaWYgKHVzZXIubG9nZ2VkSW4pIHtcbiAgICAgICAgaWYgKHJlZnJlc2hTZXJ2aWNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXhlY1NlcnZpY2Uoe1xuICAgICAgICAgICAgICBzZXJ2aWNlOiByZWZyZXNoU2VydmljZSxcbiAgICAgICAgICAgICAgbXNnOiBhY2NvdW50UHJvb2ZEYXRhLFxuICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICBwbGF0Zm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW5kJDEoTkFNRSwgU0VUX0NVUlJFTlRfVVNFUiwgYXdhaXQgYnVpbGRVc2VyKHJlc3BvbnNlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZyh7XG4gICAgICAgICAgICAgIHRpdGxlOiBgJHtlcnJvci5uYW1lfSBDb3VsZCBub3QgcmVmcmVzaCB3YWxsZXQgYXV0aGVudGljYXRpb24uYCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgbGV2ZWw6IExFVkVMUy5lcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGF3YWl0IHNuYXBzaG90KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjb3VudFByb29mRGF0YSA9IGF3YWl0IGdldEFjY291bnRQcm9vZkRhdGEoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZyh7XG4gICAgICAgICAgdGl0bGU6IGAke2Vycm9yLm5hbWV9IE9uIEF1dGhlbnRpY2F0aW9uOiBDb3VsZCBub3QgcmVzb2x2ZSBhY2NvdW50IHByb29mIGRhdGEuYCxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIGxldmVsOiBMRVZFTFMuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBleGVjU2VydmljZSh7XG4gICAgICAgICAgc2VydmljZTogZGlzY292ZXJ5U2VydmljZSxcbiAgICAgICAgICBtc2c6IGFjY291bnRQcm9vZkRhdGEsXG4gICAgICAgICAgY29uZmlnOiBhd2FpdCBtYWtlQ29uZmlnKGRpc2NvdmVyeVNlcnZpY2UpLFxuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgcGxhdGZvcm1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbmQkMShOQU1FLCBTRVRfQ1VSUkVOVF9VU0VSLCBhd2FpdCBidWlsZFVzZXIocmVzcG9uc2UpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZyh7XG4gICAgICAgICAgdGl0bGU6IGAke2Vycm9yfSBPbiBBdXRoZW50aWNhdGlvbmAsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgICAgICAgbGV2ZWw6IExFVkVMUy5lcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc29sdmUoYXdhaXQgc25hcHNob3QoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIFVuYXV0aGVudGljYXRlIGEgdXNlclxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVuYXV0aGVudGljYXRlJDEoKSB7XG4gIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgc2VuZCQxKE5BTUUsIERFTF9DVVJSRU5UX1VTRVIpO1xufVxuY29uc3Qgbm9ybWFsaXplUHJlQXV0aHpSZXNwb25zZSA9IGF1dGh6ID0+ICh7XG4gIGZfdHlwZTogXCJQcmVBdXRoelJlc3BvbnNlXCIsXG4gIGZfdnNuOiBcIjEuMC4wXCIsXG4gIHByb3Bvc2VyOiAoYXV0aHogfHwge30pLnByb3Bvc2VyLFxuICBwYXllcjogKGF1dGh6IHx8IHt9KS5wYXllciB8fCBbXSxcbiAgYXV0aG9yaXphdGlvbjogKGF1dGh6IHx8IHt9KS5hdXRob3JpemF0aW9uIHx8IFtdXG59KTtcbmNvbnN0IGdldFJlc29sdmVQcmVBdXRoeiA9IF9yZWYzID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjM7XG4gIHJldHVybiBhdXRoeiA9PiB7XG4gICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVByZUF1dGh6UmVzcG9uc2UoYXV0aHopO1xuICAgIGNvbnN0IGF4cyA9IFtdO1xuICAgIGlmIChyZXNwLnByb3Bvc2VyICE9IG51bGwpIGF4cy5wdXNoKFtcIlBST1BPU0VSXCIsIHJlc3AucHJvcG9zZXJdKTtcbiAgICBmb3IgKGxldCBheiBvZiByZXNwLnBheWVyIHx8IFtdKSBheHMucHVzaChbXCJQQVlFUlwiLCBhel0pO1xuICAgIGZvciAobGV0IGF6IG9mIHJlc3AuYXV0aG9yaXphdGlvbiB8fCBbXSkgYXhzLnB1c2goW1wiQVVUSE9SSVpFUlwiLCBhel0pO1xuICAgIHZhciByZXN1bHQgPSBheHMubWFwKF9yZWY0ID0+IHtcbiAgICAgIGxldCBbcm9sZSwgYXpdID0gX3JlZjQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZW1wSWQ6IFthei5pZGVudGl0eS5hZGRyZXNzLCBhei5pZGVudGl0eS5rZXlJZF0uam9pbihcInxcIiksXG4gICAgICAgIGFkZHI6IGF6LmlkZW50aXR5LmFkZHJlc3MsXG4gICAgICAgIGtleUlkOiBhei5pZGVudGl0eS5rZXlJZCxcbiAgICAgICAgc2lnbmluZ0Z1bmN0aW9uKHNpZ25hYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGV4ZWNTZXJ2aWNlKHtcbiAgICAgICAgICAgIHNlcnZpY2U6IGF6LFxuICAgICAgICAgICAgbXNnOiBzaWduYWJsZSxcbiAgICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICBwcm9wb3Nlcjogcm9sZSA9PT0gXCJQUk9QT1NFUlwiLFxuICAgICAgICAgIHBheWVyOiByb2xlID09PSBcIlBBWUVSXCIsXG4gICAgICAgICAgYXV0aG9yaXplcjogcm9sZSA9PT0gXCJBVVRIT1JJWkVSXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb2R1Y2VzIHRoZSBuZWVkZWQgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGZvciB0aGUgY3VycmVudCB1c2VyIHRvIHN1Ym1pdCB0cmFuc2FjdGlvbnMgdG8gRmxvd1xuICogSXQgZGVmaW5lcyBhIHNpZ25pbmcgZnVuY3Rpb24gdGhhdCBjb25uZWN0cyB0byBhIHVzZXIncyB3YWxsZXQgcHJvdmlkZXIgdG8gcHJvZHVjZSBzaWduYXR1cmVzIHRvIHN1Ym1pdCB0cmFuc2FjdGlvbnMuXG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHMgLSBydW5uaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHMucGxhdGZvcm0gLSBwbGF0Zm9ybSB0aGF0IHJ1bnMgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gYWNjb3VudCAtIEFjY291bnQgb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIEFjY291bnQgb2JqZWN0IHdpdGggc2lnbmluZyBmdW5jdGlvblxuICovXG5jb25zdCBnZXRBdXRob3JpemF0aW9uID0gX3JlZjUgPT4ge1xuICBsZXQge1xuICAgIHBsYXRmb3JtXG4gIH0gPSBfcmVmNTtcbiAgcmV0dXJuIGFzeW5jIGFjY291bnQgPT4ge1xuICAgIHNwYXduQ3VycmVudFVzZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjb3VudCxcbiAgICAgIHRlbXBJZDogXCJDVVJSRU5UX1VTRVJcIixcbiAgICAgIGFzeW5jIHJlc29sdmUoYWNjb3VudCwgcHJlU2lnbmFibGUpIHtcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZSh7XG4gICAgICAgICAgcGxhdGZvcm1cbiAgICAgICAgfSkoe1xuICAgICAgICAgIHJlZGlyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhdXRoeiA9IHNlcnZpY2VPZlR5cGUodXNlci5zZXJ2aWNlcywgXCJhdXRoelwiKTtcbiAgICAgICAgY29uc3QgcHJlQXV0aHogPSBzZXJ2aWNlT2ZUeXBlKHVzZXIuc2VydmljZXMsIFwicHJlLWF1dGh6XCIpO1xuICAgICAgICBpZiAocHJlQXV0aHopIHJldHVybiBnZXRSZXNvbHZlUHJlQXV0aHooe1xuICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgIH0pKGF3YWl0IGV4ZWNTZXJ2aWNlKHtcbiAgICAgICAgICBzZXJ2aWNlOiBwcmVBdXRoeixcbiAgICAgICAgICBtc2c6IHByZVNpZ25hYmxlLFxuICAgICAgICAgIHBsYXRmb3JtXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGF1dGh6KSB7XG4gICAgICAgICAgbGV0IHdpbmRvd1JlZjtcbiAgICAgICAgICBpZiAoaXNNb2JpbGUoKSAmJiBhdXRoei5tZXRob2QgPT09IFwiV0MvUlBDXCIpIHtcbiAgICAgICAgICAgIHdpbmRvd1JlZiA9IHdpbmRvdy5vcGVuKFwiXCIsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWNjb3VudCxcbiAgICAgICAgICAgIHRlbXBJZDogXCJDVVJSRU5UX1VTRVJcIixcbiAgICAgICAgICAgIHJlc29sdmU6IG51bGwsXG4gICAgICAgICAgICBhZGRyOiBzYW5zUHJlZml4KGF1dGh6LmlkZW50aXR5LmFkZHJlc3MpLFxuICAgICAgICAgICAga2V5SWQ6IGF1dGh6LmlkZW50aXR5LmtleUlkLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW06IG51bGwsXG4gICAgICAgICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICAgICAgICBhc3luYyBzaWduaW5nRnVuY3Rpb24oc2lnbmFibGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUNvbXBvc2l0ZVNpZ25hdHVyZShhd2FpdCBleGVjU2VydmljZSh7XG4gICAgICAgICAgICAgICAgc2VydmljZTogYXV0aHosXG4gICAgICAgICAgICAgICAgbXNnOiBzaWduYWJsZSxcbiAgICAgICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgICBpbmNsdWRlT2xkZXJKc29uUnBjQ2FsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd1JlZlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gQXV0aHogb3IgUHJlQXV0aHogU2VydmljZSBjb25maWd1cmVkIGZvciBDVVJSRU5UX1VTRVJcIik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgY2FsbGJhY2sgcGFzc2VkIHRvIHN1YnNjcmliZSB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGF1dGhlbnRpY2F0ZXMgYW5kIHVuLWF1dGhlbnRpY2F0ZXMsIG1ha2luZyBpdCBlYXN5IHRvIHVwZGF0ZSB0aGUgVUkgYWNjb3JkaW5nbHkuXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBVbnN1YnNjcmliZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgc3Bhd25DdXJyZW50VXNlcigpO1xuICBjb25zdCBFWElUID0gXCJARVhJVFwiO1xuICBjb25zdCBzZWxmID0gc3Bhd24oYXN5bmMgY3R4ID0+IHtcbiAgICBjdHguc2VuZChOQU1FLCBTVUJTQ1JJQkUpO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBjb25zdCBsZXR0ZXIgPSBhd2FpdCBjdHgucmVjZWl2ZSgpO1xuICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgY3R4LnNlbmQoTkFNRSwgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhsZXR0ZXIuZGF0YSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHNlbmQkMShzZWxmLCBFWElUKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBHZXRzIHRoZSBjdXJyZW50IHVzZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPEN1cnJlbnRVc2VyPn0gLSBVc2VyIG9iamVjdFxuICovXG5mdW5jdGlvbiBzbmFwc2hvdCgpIHtcbiAgc3Bhd25DdXJyZW50VXNlcigpO1xuICByZXR1cm4gc2VuZCQxKE5BTUUsIFNOQVBTSE9ULCBudWxsLCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBSZXNvbHZlcyB0aGUgY3VycmVudCB1c2VyIGFzIGFuIGFyZ3VtZW50XG4gKiBcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHMgLSBydW5uaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHMucGxhdGZvcm0gLSBwbGF0Zm9ybSB0aGF0IHJ1bnMgdGhlIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbj59XG4gKi9cbmNvbnN0IGdldFJlc29sdmVBcmd1bWVudCA9IF9yZWY2ID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjY7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYWRkclxuICAgIH0gPSBhd2FpdCBnZXRBdXRoZW50aWNhdGUoe1xuICAgICAgcGxhdGZvcm1cbiAgICB9KSgpO1xuICAgIHJldHVybiBhcmcod2l0aFByZWZpeChhZGRyKSwgdCQxLkFkZHJlc3MpO1xuICB9O1xufTtcbmNvbnN0IG1ha2VTaWduYWJsZSA9IG1zZyA9PiB7XG4gIGludmFyaWFudCgvXlswLTlhLWZdKyQvaS50ZXN0KG1zZyksIFwiTWVzc2FnZSBtdXN0IGJlIGEgaGV4IHN0cmluZ1wiKTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBtc2dcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBtZXRob2QgdG8gdXNlIGFsbG93aW5nIHRoZSB1c2VyIHRvIHBlcnNvbmFsbHkgc2lnbiBkYXRhIHZpYSBGQ0wgQ29tcGF0aWJsZSBXYWxsZXRzL1NlcnZpY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIE1lc3NhZ2UgdG8gc2lnblxuICogQHJldHVybnMge1Byb21pc2U8Q29tcG9zaXRlU2lnbmF0dXJlW10+fSAtIEFycmF5IG9mIENvbXBvc2l0ZVNpZ25hdHVyZXNcbiAqL1xuY29uc3QgZ2V0U2lnblVzZXJNZXNzYWdlID0gX3JlZjcgPT4ge1xuICBsZXQge1xuICAgIHBsYXRmb3JtXG4gIH0gPSBfcmVmNztcbiAgcmV0dXJuIGFzeW5jIG1zZyA9PiB7XG4gICAgc3Bhd25DdXJyZW50VXNlcigpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGUoe1xuICAgICAgcGxhdGZvcm1cbiAgICB9KSh7XG4gICAgICByZWRpcjogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25pbmdTZXJ2aWNlID0gc2VydmljZU9mVHlwZSh1c2VyLnNlcnZpY2VzLCBcInVzZXItc2lnbmF0dXJlXCIpO1xuICAgIGludmFyaWFudChzaWduaW5nU2VydmljZSwgXCJDdXJyZW50IHVzZXIgbXVzdCBoYXZlIGF1dGhvcml6ZWQgYSBzaWduaW5nIHNlcnZpY2UuXCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGV4ZWNTZXJ2aWNlKHtcbiAgICAgICAgc2VydmljZTogc2lnbmluZ1NlcnZpY2UsXG4gICAgICAgIG1zZzogbWFrZVNpZ25hYmxlKG1zZyksXG4gICAgICAgIHBsYXRmb3JtXG4gICAgICB9KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UubWFwKGNvbXBTaWdzID0+IG5vcm1hbGl6ZUNvbXBvc2l0ZVNpZ25hdHVyZShjb21wU2lncykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtub3JtYWxpemVDb21wb3NpdGVTaWduYXR1cmUocmVzcG9uc2UpXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBnZXRDdXJyZW50VXNlciA9IF9yZWY4ID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjg7XG4gIGxldCBjdXJyZW50VXNlciA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aGVudGljYXRlOiBnZXRBdXRoZW50aWNhdGUoe1xuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSksXG4gICAgICB1bmF1dGhlbnRpY2F0ZTogdW5hdXRoZW50aWNhdGUkMSxcbiAgICAgIGF1dGhvcml6YXRpb246IGdldEF1dGhvcml6YXRpb24oe1xuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSksXG4gICAgICBzaWduVXNlck1lc3NhZ2U6IGdldFNpZ25Vc2VyTWVzc2FnZSh7XG4gICAgICAgIHBsYXRmb3JtXG4gICAgICB9KSxcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgcmVzb2x2ZUFyZ3VtZW50OiBnZXRSZXNvbHZlQXJndW1lbnQoe1xuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuICBjdXJyZW50VXNlci5hdXRoZW50aWNhdGUgPSBnZXRBdXRoZW50aWNhdGUoe1xuICAgIHBsYXRmb3JtXG4gIH0pO1xuICBjdXJyZW50VXNlci51bmF1dGhlbnRpY2F0ZSA9IHVuYXV0aGVudGljYXRlJDE7XG4gIGN1cnJlbnRVc2VyLmF1dGhvcml6YXRpb24gPSBnZXRBdXRob3JpemF0aW9uKHtcbiAgICBwbGF0Zm9ybVxuICB9KTtcbiAgY3VycmVudFVzZXIuc2lnblVzZXJNZXNzYWdlID0gZ2V0U2lnblVzZXJNZXNzYWdlKHtcbiAgICBwbGF0Zm9ybVxuICB9KTtcbiAgY3VycmVudFVzZXIuc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICBjdXJyZW50VXNlci5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICBjdXJyZW50VXNlci5yZXNvbHZlQXJndW1lbnQgPSBnZXRSZXNvbHZlQXJndW1lbnQoe1xuICAgIHBsYXRmb3JtXG4gIH0pO1xuICByZXR1cm4gY3VycmVudFVzZXI7XG59O1xuXG5jb25zdCBnZXRNdXRhdGUgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBwbGF0Zm9ybVxuICB9ID0gX3JlZjtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbGxvd3MgeW91IHRvIHN1Ym1pdCB0cmFuc2FjdGlvbnMgdG8gdGhlIGJsb2NrY2hhaW4gdG8gcG90ZW50aWFsbHkgbXV0YXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIE11dGF0aW9uIE9wdGlvbnMgYW5kIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNhZGVuY2VdIC0gQ2FkZW5jZSBUcmFuc2FjdGlvbiB1c2VkIHRvIG11dGF0ZSBGbG93XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2hhcmVkLWV4cG9ydHNcIikuQXJnc0ZufSBbb3B0cy5hcmdzXSAtIEFyZ3VtZW50cyBwYXNzZWQgdG8gY2FkZW5jZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZ30gW29wdHMudGVtcGxhdGVdIC0gSW50ZXJhY3Rpb24gVGVtcGxhdGUgZm9yIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxpbWl0XSAtIENvbXB1dGUgTGltaXQgZm9yIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmF1dGh6XSAtIEF1dGhvcml6YXRpb24gZnVuY3Rpb24gZm9yIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnByb3Bvc2VyXSAtIFByb3Bvc2VyIEF1dGhvcml6YXRpb24gZnVuY3Rpb24gZm9yIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnBheWVyXSAtIFBheWVyIEF1dGhvcml6YXRpb24gZnVuY3Rpb24gZm9yIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8RnVuY3Rpb24+fSBbb3B0cy5hdXRob3JpemF0aW9uc10gLSBBdXRob3JpemF0aW9ucyBmdW5jdGlvbiBmb3IgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVHJhbnNhY3Rpb24gSWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZmNsLm11dGF0ZSh7XG4gICAqICAgY2FkZW5jZTogYFxuICAgKiAgICAgdHJhbnNhY3Rpb24oYTogSW50LCBiOiBJbnQsIGM6IEFkZHJlc3MpIHtcbiAgICogICAgICAgcHJlcGFyZShhY2N0OiBBdXRoQWNjb3VudCkge1xuICAgKiAgICAgICAgIGxvZyhhY2N0KVxuICAgKiAgICAgICAgIGxvZyhhKVxuICAgKiAgICAgICAgIGxvZyhiKVxuICAgKiAgICAgICAgIGxvZyhjKVxuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgYCxcbiAgICogICBhcmdzOiAoYXJnLCB0KSA9PiBbXG4gICAqICAgICBhcmcoNiwgdC5JbnQpLFxuICAgKiAgICAgYXJnKDcsIHQuSW50KSxcbiAgICogICAgIGFyZyhcIjB4YmExMTMyYmMwOGY4MmZlMlwiLCB0LkFkZHJlc3MpLFxuICAgKiAgIF0sXG4gICAqIH0pXG4gICAqXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIHR5cGUgT3B0aW9ucyA9IHtcbiAgICogICB0ZW1wbGF0ZTogSW50ZXJhY3Rpb25UZW1wbGF0ZSB8IFN0cmluZyAvLyBJbnRlcmFjdGlvblRlbXBsYXRlIG9yIHVybCB0byBvbmVcbiAgICogICBjYWRlbmNlOiBTdHJpbmchLFxuICAgKiAgIGFyZ3M6IChhcmcsIHQpID0+IEFycmF5PEFyZz4sXG4gICAqICAgbGltaXQ6IE51bWJlcixcbiAgICogICBhdXRoejogQXV0aHpGbiwgLy8gd2lsbCBvdmVybG9hZCB0aGUgdHJpbml0eSBvZiBzaWduYXRvcnkgcm9sZXNcbiAgICogICBwcm9wb3NlcjogQXV0aHpGbiwgLy8gd2lsbCBvdmVybG9hZCB0aGUgcHJvcG9zZXIgc2lnbmF0b3J5IHJvbGVcbiAgICogICBwYXllcjogQXV0aHpGbiwgLy8gd2lsbCBvdmVybG9hZCB0aGUgcGF5ZXIgc2lnbmF0b3J5IHJvbGVcbiAgICogICBhdXRob3JpemF0aW9uczogW0F1dGh6Rm5dLCAvLyBhbiBhcnJheSBvZiBhdXRob3JpemF0aW9uIGZ1bmN0aW9ucyB1c2VkIGFzIGF1dGhvcml6YXRpb25zIHNpZ25hdG9yeSByb2xlc1xuICAgKiB9XG4gICAqL1xuICBjb25zdCBtdXRhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciB0eGlkO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcmVNdXRhdGUob3B0cyk7XG4gICAgICBvcHRzID0gYXdhaXQgcHJlcFRlbXBsYXRlT3B0cyhvcHRzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gZ2V0Q3VycmVudFVzZXIoe1xuICAgICAgICBwbGF0Zm9ybVxuICAgICAgfSk7XG4gICAgICAvLyBBbGxvdyBmb3IgYSBjb25maWcgdG8gb3ZlcndyaXRlIHRoZSBhdXRob3JpemF0aW9uIGZ1bmN0aW9uLlxuICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICBjb25zdCBhdXRoeiA9IGF3YWl0IHNkay5jb25maWcoKS5nZXQoXCJmY2wuYXV0aHpcIiwgY3VycmVudFVzZXIoKS5hdXRob3JpemF0aW9uKTtcbiAgICAgIHR4aWQgPSBzZGsuY29uZmlnKCkub3ZlcmxvYWQob3B0cy5kZXBlbmRlbmNpZXMgfHwge30sIGFzeW5jICgpID0+XG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIHNkay5zZW5kKFtzZGsudHJhbnNhY3Rpb24ob3B0cy5jYWRlbmNlKSwgc2RrLmFyZ3Mobm9ybWFsaXplQXJncyhvcHRzLmFyZ3MgfHwgW10pKSwgb3B0cy5saW1pdCAmJiBpc051bWJlcihvcHRzLmxpbWl0KSAmJiBzZGsubGltaXQob3B0cy5saW1pdCksXG4gICAgICAvLyBvcHRzLnByb3Bvc2VyID4gb3B0cy5hdXRoeiA+IGF1dGh6XG4gICAgICBzZGsucHJvcG9zZXIob3B0cy5wcm9wb3NlciB8fCBvcHRzLmF1dGh6IHx8IGF1dGh6KSxcbiAgICAgIC8vIG9wdHMucGF5ZXIgPiBvcHRzLmF1dGh6ID4gYXV0aHpcbiAgICAgIHNkay5wYXllcihvcHRzLnBheWVyIHx8IG9wdHMuYXV0aHogfHwgYXV0aHopLFxuICAgICAgLy8gb3B0cy5hdXRob3JpemF0aW9ucyA+IFtvcHRzLmF1dGh6ID4gYXV0aHpdXG4gICAgICBzZGsuYXV0aG9yaXphdGlvbnMob3B0cy5hdXRob3JpemF0aW9ucyB8fCBbb3B0cy5hdXRoeiB8fCBhdXRoel0pXSkudGhlbihzZGsuZGVjb2RlKSk7XG4gICAgICByZXR1cm4gdHhpZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXV0YXRlO1xufTtcblxuY29uc3QgRlJBTUUgPSBcIkZDTF9JRlJBTUVcIjtcbmNvbnN0IEZSQU1FX1NUWUxFUyA9IGBcbiAgcG9zaXRpb246Zml4ZWQ7XG4gIHRvcDogMHB4O1xuICByaWdodDogMHB4O1xuICBib3R0b206IDBweDtcbiAgbGVmdDogMHB4O1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiAxMDB2dztcbiAgZGlzcGxheTpibG9jaztcbiAgYmFja2dyb3VuZDpyZ2JhKDAsMCwwLDAuMjUpO1xuICB6LWluZGV4OiAyMTQ3NDgzNjQ3O1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBjb2xvci1zY2hlbWU6IGxpZ2h0O1xuYDtcbmZ1bmN0aW9uIHJlbmRlckZyYW1lKHNyYykge1xuICBpbnZhcmlhbnQoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEZSQU1FKSwgXCJBdHRlbXB0IGF0IHRyaWdnZXJpbmcgbXVsdGlwbGUgRnJhbWVzXCIsIHtcbiAgICBzcmNcbiAgfSk7XG4gIGNvbnN0ICRmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICRmcmFtZS5zcmMgPSBzcmM7XG4gICRmcmFtZS5pZCA9IEZSQU1FO1xuICAkZnJhbWUuYWxsb3cgPSBcInVzYiAqOyBoaWQgKlwiO1xuICAkZnJhbWUuZnJhbWVCb3JkZXIgPSBcIjBcIjtcbiAgJGZyYW1lLnN0eWxlLmNzc1RleHQgPSBGUkFNRV9TVFlMRVM7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKCRmcmFtZSk7XG4gIGNvbnN0IHVubW91bnQgPSAoKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEZSQU1FKSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoRlJBTUUpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFskZnJhbWUuY29udGVudFdpbmRvdywgdW5tb3VudF07XG59XG5cbmNvbnN0IFBPUCA9IFwiRkNMX1BPUFwiO1xubGV0IHBvcHVwID0gbnVsbDtcbmxldCBwcmV2aW91c1VybCQxID0gbnVsbDtcbmZ1bmN0aW9uIHBvcHVwV2luZG93KHVybCwgd2luZG93TmFtZSwgd2luLCB3LCBoKSB7XG4gIGNvbnN0IHkgPSB3aW4udG9wLm91dGVySGVpZ2h0IC8gMiArIHdpbi50b3Auc2NyZWVuWSAtIGggLyAyO1xuICBjb25zdCB4ID0gd2luLnRvcC5vdXRlcldpZHRoIC8gMiArIHdpbi50b3Auc2NyZWVuWCAtIHcgLyAyO1xuICBjb25zdCBwb3B1cCA9IHdpbi5vcGVuKHVybCwgd2luZG93TmFtZSwgYHRvb2xiYXI9bm8sIGxvY2F0aW9uPW5vLCBkaXJlY3Rvcmllcz1ubywgc3RhdHVzPW5vLCBtZW51YmFyPW5vLCBzY3JvbGxiYXJzPW5vLCByZXNpemFibGU9bm8sIGNvcHloaXN0b3J5PW5vLCB3aWR0aD0ke3d9LCBoZWlnaHQ9JHtofSwgdG9wPSR7eX0sIGxlZnQ9JHt4fWApO1xuICBpZiAoIXBvcHVwKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3B1cCBmYWlsZWQgdG8gb3BlbiAod2FzIGl0IGJsb2NrZWQgYnkgYSBwb3B1cCBibG9ja2VyPylcIik7XG4gIHJldHVybiBwb3B1cDtcbn1cbmZ1bmN0aW9uIHJlbmRlclBvcChzcmMpIHtcbiAgaWYgKHBvcHVwID09IG51bGwgfHwgcG9wdXA/LmNsb3NlZCkge1xuICAgIHBvcHVwID0gcG9wdXBXaW5kb3coc3JjLCBQT1AsIHdpbmRvdywgNjQwLCA3NzApO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzVXJsJDEgIT09IHNyYykge1xuICAgIHBvcHVwLmxvY2F0aW9uLnJlcGxhY2Uoc3JjKTtcbiAgICBwb3B1cC5mb2N1cygpO1xuICB9IGVsc2Uge1xuICAgIHBvcHVwLmZvY3VzKCk7XG4gIH1cbiAgcHJldmlvdXNVcmwkMSA9IHNyYztcbiAgY29uc3QgdW5tb3VudCA9ICgpID0+IHtcbiAgICBpZiAocG9wdXAgJiYgIXBvcHVwLmNsb3NlZCkge1xuICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICB9XG4gICAgcG9wdXAgPSBudWxsO1xuICB9O1xuICByZXR1cm4gW3BvcHVwLCB1bm1vdW50XTtcbn1cblxubGV0IHRhYiQxID0gbnVsbDtcbmxldCBwcmV2aW91c1VybCA9IG51bGw7XG5mdW5jdGlvbiByZW5kZXJUYWIoc3JjKSB7XG4gIGlmICh0YWIkMSA9PSBudWxsIHx8IHRhYiQxPy5jbG9zZWQpIHtcbiAgICB0YWIkMSA9IHdpbmRvdy5vcGVuKHNyYywgXCJfYmxhbmtcIik7XG4gICAgaWYgKCF0YWIkMSkgdGhyb3cgbmV3IEVycm9yKFwiVGFiIGZhaWxlZCB0byBvcGVuICh3YXMgaXQgYmxvY2tlZCBieSB0aGUgYnJvd3Nlcj8pXCIpO1xuICB9IGVsc2UgaWYgKHByZXZpb3VzVXJsICE9PSBzcmMpIHtcbiAgICB0YWIkMS5sb2NhdGlvbi5yZXBsYWNlKHNyYyk7XG4gICAgdGFiJDEuZm9jdXMoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWIkMS5mb2N1cygpO1xuICB9XG4gIHByZXZpb3VzVXJsID0gc3JjO1xuICBjb25zdCB1bm1vdW50ID0gKCkgPT4ge1xuICAgIGlmICh0YWIkMSAmJiAhdGFiJDEuY2xvc2VkKSB7XG4gICAgICB0YWIkMS5jbG9zZSgpO1xuICAgIH1cbiAgICB0YWIkMSA9IG51bGw7XG4gIH07XG4gIHJldHVybiBbdGFiJDEsIHVubW91bnRdO1xufVxuXG5jb25zdCBpc1NlcnZlclNpZGUgPSAoKSA9PiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgZ2V0U2Vzc2lvblN0b3JhZ2UgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgU0VTU0lPTl9TVE9SQUdFID0ge1xuICAgICAgY2FuOiAhaXNTZXJ2ZXJTaWRlKCksXG4gICAgICBnZXQ6IGFzeW5jIGtleSA9PiBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KSksXG4gICAgICBwdXQ6IGFzeW5jIChrZXksIHZhbHVlKSA9PiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgIH07XG4gICAgcmV0dXJuIFNFU1NJT05fU1RPUkFHRTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmNvbnN0IGdldERlZmF1bHRDb25maWcgPSAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgXCJkaXNjb3Zlcnkud2FsbGV0Lm1ldGhvZC5kZWZhdWx0XCI6IFwiSUZSQU1FL1JQQ1wiLFxuICAgIFwiZmNsLnN0b3JhZ2UuZGVmYXVsdFwiOiBnZXRTZXNzaW9uU3RvcmFnZSgpXG4gIH07XG59O1xuXG5mdW5jdGlvbiBzZXJ2aWNlRW5kcG9pbnQoc2VydmljZSkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHNlcnZpY2UuZW5kcG9pbnQpO1xuICBpZiAod2luZG93Py5sb2NhdGlvbj8ub3JpZ2luKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJsNm5cIiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gIH1cbiAgaWYgKHNlcnZpY2UucGFyYW1zICE9IG51bGwpIHtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2VydmljZS5wYXJhbXMgfHwge30pKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24gZmV0Y2hTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCBtZXRob2QgPSBvcHRzLm1ldGhvZCB8fCBcIlBPU1RcIjtcbiAgY29uc3QgYm9keSA9IG1ldGhvZCA9PT0gXCJHRVRcIiA/IHVuZGVmaW5lZCA6IEpTT04uc3RyaW5naWZ5KG9wdHMuZGF0YSB8fCBzZXJ2aWNlLmRhdGEgfHwge30pO1xuICByZXR1cm4gZmV0Y2goc2VydmljZUVuZHBvaW50KHNlcnZpY2UpLCB7XG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uKHNlcnZpY2UuaGVhZGVycyB8fCB7fSksXG4gICAgICAuLi4ob3B0cy5oZWFkZXJzIHx8IHt9KSxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBib2R5XG4gIH0pLnRoZW4oZCA9PiBkLmpzb24oKSk7XG59XG5cbi8vIHtcbi8vICAgIFwiZl90eXBlXCI6IFwiUG9sbGluZ1Jlc3BvbnNlXCIsXG4vLyAgICBcImZfdnNuXCI6IFwiMS4wLjBcIixcbi8vICAgIFwic3RhdHVzXCI6IFwiUEVORElOR1wiLCAvLyBQRU5ESU5HIHwgQVBQUk9WRUQgfCBERUNMSU5FRCB8IFJFRElSRUNUXG4vLyAgICBcInJlYXNvblwiOiBudWxsLCAgICAgIC8vIFJlYXNvbiBmb3IgRGVjbGluaW5nIFRyYW5zYWN0aW9uXG4vLyAgICBcImRhdGFcIjogbnVsbCwgICAgICAgIC8vIFJldHVybiB2YWx1ZSBmb3IgQVBQUk9WRURcbi8vICAgIFwidXBkYXRlc1wiOiBCYWNrQ2hhbm5lbFJwYyxcbi8vICAgIFwibG9jYWxcIjogRnJhbWUsXG4vLyB9XG5mdW5jdGlvbiBub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UocmVzcCkge1xuICBpZiAocmVzcCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoIChyZXNwW1wiZl92c25cIl0pIHtcbiAgICBjYXNlIFwiMS4wLjBcIjpcbiAgICAgIHJldHVybiByZXNwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5QT0xMSU5HX1JFU1BPTlNFX1BSQUdNQSxcbiAgICAgICAgc3RhdHVzOiByZXNwLnN0YXR1cyA/PyBcIkFQUFJPVkVEXCIsXG4gICAgICAgIHJlYXNvbjogcmVzcC5yZWFzb24gPz8gbnVsbCxcbiAgICAgICAgZGF0YTogcmVzcC5jb21wb3NpdGVTaWduYXR1cmUgfHwgcmVzcC5kYXRhIHx8IHtcbiAgICAgICAgICAuLi5yZXNwXG4gICAgICAgIH0gfHwge30sXG4gICAgICAgIHVwZGF0ZXM6IG5vcm1hbGl6ZUJhY2tDaGFubmVsUnBjKHJlc3AuYXV0aG9yaXphdGlvblVwZGF0ZXMpLFxuICAgICAgICBsb2NhbDogbm9ybWFsaXplRnJhbWUoKHJlc3AubG9jYWwgfHwgW10pWzBdKVxuICAgICAgfTtcbiAgfVxufVxuXG5jb25zdCBPUFRJT05TID0ge1xuICBcIkhUVFAvR0VUXCI6IFwiR0VUXCIsXG4gIFwiSFRUUC9QT1NUXCI6IFwiUE9TVFwiXG59O1xuY29uc3Qgc2VydmljZU1ldGhvZCA9IHNlcnZpY2UgPT4ge1xuICBpbnZhcmlhbnQoT1BUSU9OU1tzZXJ2aWNlLm1ldGhvZF0sIFwiSW52YWxpZCBTZXJ2aWNlIE1ldGhvZCBmb3IgdHlwZSBiYWNrLWNoYW5uZWwtcnBjXCIsIHtcbiAgICBzZXJ2aWNlXG4gIH0pO1xuICByZXR1cm4gT1BUSU9OU1tzZXJ2aWNlLm1ldGhvZF07XG59O1xuYXN5bmMgZnVuY3Rpb24gcG9sbChzZXJ2aWNlKSB7XG4gIGxldCBjaGVja0NhbkNvbnRpbnVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAoKSA9PiB0cnVlO1xuICBpbnZhcmlhbnQoc2VydmljZSwgXCJNaXNzaW5nIFBvbGxpbmcgU2VydmljZVwiLCB7XG4gICAgc2VydmljZVxuICB9KTtcbiAgY29uc3QgY2FuQ29udGludWUgPSBjaGVja0NhbkNvbnRpbnVlKCk7XG4gIGlmICghY2FuQ29udGludWUpIHRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsbHkgSGFsdGVkXCIpO1xuICBsZXQgcmVzcDtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDUwMCkpO1xuICAgICAgcmV0dXJuIHBvbGwoc2VydmljZSwgY2hlY2tDYW5Db250aW51ZSk7XG4gICAgfVxuICAgIHJlc3AgPSBhd2FpdCBmZXRjaFNlcnZpY2Uoc2VydmljZSwge1xuICAgICAgbWV0aG9kOiBzZXJ2aWNlTWV0aG9kKHNlcnZpY2UpXG4gICAgfSkudGhlbihub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICBjYXNlIFwiQVBQUk9WRURcIjpcbiAgICAgIHJldHVybiByZXNwLmRhdGE7XG4gICAgY2FzZSBcIkRFQ0xJTkVEXCI6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkLlwifWApO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgNTAwKSk7XG4gICAgICByZXR1cm4gcG9sbChyZXNwLnVwZGF0ZXMsIGNoZWNrQ2FuQ29udGludWUpO1xuICB9XG59XG5cbmNvbnN0IGdldEV4ZWNIdHRwUG9zdCA9IGV4ZWNMb2NhbCA9PiBhc3luYyBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaFNlcnZpY2Uoc2VydmljZSwge1xuICAgIGRhdGE6IHtcbiAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICBzZXJ2aWNlOiB7XG4gICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSxcbiAgICAgICAgdHlwZTogc2VydmljZS50eXBlXG4gICAgICB9LFxuICAgICAgY29uZmlnLFxuICAgICAgLi4uYm9keVxuICAgIH1cbiAgfSkudGhlbihub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UpO1xuICBpZiAocmVzcC5zdGF0dXMgPT09IFwiQVBQUk9WRURcIikge1xuICAgIHJldHVybiByZXNwLmRhdGE7XG4gIH0gZWxzZSBpZiAocmVzcC5zdGF0dXMgPT09IFwiREVDTElORURcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGVjbGluZWQ6ICR7cmVzcC5yZWFzb24gfHwgXCJObyByZWFzb24gc3VwcGxpZWQuXCJ9YCk7XG4gIH0gZWxzZSBpZiAocmVzcC5zdGF0dXMgPT09IFwiUkVESVJFQ1RcIikge1xuICAgIHJldHVybiByZXNwO1xuICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzID09PSBcIlBFTkRJTkdcIikge1xuICAgIC8vIHRoZXNlIHR3byBmbGFncyBhcmUgcmVxdWlyZWQgdG8gcnVuIHBvbGxpbmcgb25lIG1vcmUgdGltZSBiZWZvcmUgaXQgc3RvcHNcbiAgICB2YXIgY2FuQ29udGludWUgPSB0cnVlO1xuICAgIHZhciBzaG91bGRDb250aW51ZSA9IHRydWU7XG4gICAgY29uc3QgW18sIHVubW91bnRdID0gYXdhaXQgZXhlY0xvY2FsKG5vcm1hbGl6ZUxvY2FsVmlldyhyZXNwLmxvY2FsKSwge1xuICAgICAgc2VydmljZUVuZHBvaW50LFxuICAgICAgb25DbG9zZTogKCkgPT4gc2hvdWxkQ29udGludWUgPSBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICBzaG91bGRDb250aW51ZSA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZyYW1lIENsb3NlIEVycm9yXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgcnVuIG9uY2UgcGVyIHBvbGwgY2FsbC5cbiAgICAgKiBPZmZzZXR0aW5nIGNhbkNvbnRpbnVlIGZsYWcgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgKiB0aGUgcG9sbGluZyBpcyBwZXJmb3JtZWQgb25lIGV4dHJhIHRpbWUgYWZ0ZXIgY2FuQ29udGludWUgZmxhZyBpcyBzZXQgdG8gZmFsc2VcbiAgICAgKiB0byBwcmV2ZW50IGhhbHRpbmcgb24gQW5kcm9pZCB3aGVuIGEgYnJvd3NlciBjYWxscyB3aW5kb3cuY2xvc2VcbiAgICAgKiBiZWZvcmUgRkNMIHJlY2VpdmVzIGEgc3VjY2Vzc2Z1bCByZXN1bHQgZnJvbSBwb2xsaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gXG4gICAgICovXG4gICAgY29uc3QgY2hlY2tDYW5Db250aW51ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldENhbkNvbnRpbnVlID0gY2FuQ29udGludWU7XG4gICAgICBjYW5Db250aW51ZSA9IHNob3VsZENvbnRpbnVlO1xuICAgICAgcmV0dXJuIG9mZnNldENhbkNvbnRpbnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHBvbGwocmVzcC51cGRhdGVzLCBjaGVja0NhbkNvbnRpbnVlKS50aGVuKHNlcnZpY2VSZXNwb25zZSA9PiB7XG4gICAgICBjbG9zZSgpO1xuICAgICAgcmV0dXJuIHNlcnZpY2VSZXNwb25zZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGBBdXRvIERlY2xpbmU6IEludmFsaWQgUmVzcG9uc2VgLCB7XG4gICAgICBzZXJ2aWNlLFxuICAgICAgcmVzcFxuICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihgQXV0byBEZWNsaW5lOiBJbnZhbGlkIFJlc3BvbnNlYCk7XG4gIH1cbn07XG5cbmNvbnN0IENMT1NFX0VWRU5UID0gXCJGQ0w6VklFVzpDTE9TRVwiO1xuY29uc3QgUkVBRFlfRVZFTlQgPSBcIkZDTDpWSUVXOlJFQURZXCI7XG5jb25zdCBSRVNQT05TRV9FVkVOVCA9IFwiRkNMOlZJRVc6UkVTUE9OU0VcIjtcbmNvbnN0IF8gPSBlID0+IHR5cGVvZiBlID09PSBcInN0cmluZ1wiICYmIGUudG9Mb3dlckNhc2UoKTtcbmNvbnN0IElHTk9SRSA9IG5ldyBTZXQoW1wibW9uZXRpemF0aW9uc3RhcnRcIiwgXCJtb25ldGl6YXRpb25wZW5kaW5nXCIsIFwibW9uZXRpemF0aW9ucHJvZ3Jlc3NcIiwgXCJtb25ldGl6YXRpb25zdG9wXCJdKTtcbmNvbnN0IGRlcHJlY2F0ZSA9ICh3YXMsIHdhbnQpID0+IGNvbnNvbGUud2FybihcIkRFUFJFQ0FUSU9OIE5PVElDRVwiLCBgUmVjZWl2ZWQgJHt3YXN9LCBwbGVhc2UgdXNlICR7d2FudH0gZm9yIHRoaXMgYW5kIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGQ0xgKTtcbmNvbnN0IGJ1aWxkTWVzc2FnZUhhbmRsZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjbG9zZSxcbiAgICBzZW5kLFxuICAgIG9uUmVhZHksXG4gICAgb25SZXNwb25zZSxcbiAgICBvbk1lc3NhZ2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBlID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgIGlmIChJR05PUkUuaGFzKGUuZGF0YS50eXBlKSkgcmV0dXJuO1xuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKENMT1NFX0VWRU5UKSkgY2xvc2UoKTtcbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhSRUFEWV9FVkVOVCkpIG9uUmVhZHkoZSwge1xuICAgICAgICBzZW5kLFxuICAgICAgICBjbG9zZVxuICAgICAgfSk7XG4gICAgICBpZiAoXyhlLmRhdGEudHlwZSkgPT09IF8oUkVTUE9OU0VfRVZFTlQpKSBvblJlc3BvbnNlKGUsIHtcbiAgICAgICAgc2VuZCxcbiAgICAgICAgY2xvc2VcbiAgICAgIH0pO1xuICAgICAgb25NZXNzYWdlKGUsIHtcbiAgICAgICAgc2VuZCxcbiAgICAgICAgY2xvc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBCYWNrd2FyZHMgQ29tcGF0aWJsZVxuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFwiRkNMOkZSQU1FOlJFQURZXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgUkVBRFlfRVZFTlQpO1xuICAgICAgICBvblJlYWR5KGUsIHtcbiAgICAgICAgICBzZW5kLFxuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFwiRkNMOkZSQU1FOlJFU1BPTlNFXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgUkVTUE9OU0VfRVZFTlQpO1xuICAgICAgICBvblJlc3BvbnNlKGUsIHtcbiAgICAgICAgICBzZW5kLFxuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFwiRkNMOkZSQU1FOkNMT1NFXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgQ0xPU0VfRVZFTlQpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgLy9cbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDo6Q0hBTExFTkdFOjpSRVNQT05TRVwiKSkge1xuICAgICAgICBkZXByZWNhdGUoZS5kYXRhLnR5cGUsIFJFU1BPTlNFX0VWRU5UKTtcbiAgICAgICAgb25SZXNwb25zZShlLCB7XG4gICAgICAgICAgc2VuZCxcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfKGUuZGF0YS50eXBlKSA9PT0gXyhcIkZDTDo6QVVUSFpfUkVBRFlcIikpIHtcbiAgICAgICAgZGVwcmVjYXRlKGUuZGF0YS50eXBlLCBSRUFEWV9FVkVOVCk7XG4gICAgICAgIG9uUmVhZHkoZSwge1xuICAgICAgICAgIHNlbmQsXG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoXyhlLmRhdGEudHlwZSkgPT09IF8oXCJGQ0w6OkNIQUxMRU5HRTo6Q0FOQ0VMXCIpKSB7XG4gICAgICAgIGRlcHJlY2F0ZShlLmRhdGEudHlwZSwgQ0xPU0VfRVZFTlQpO1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKF8oZS5kYXRhLnR5cGUpID09PSBfKFwiRkNMOjpDQU5DRUxcIikpIHtcbiAgICAgICAgZGVwcmVjYXRlKGUuZGF0YS50eXBlLCBDTE9TRV9FVkVOVCk7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGcmFtZSBDYWxsYmFjayBFcnJvclwiLCBlcnJvcik7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IG5vb3AkMyA9ICgpID0+IHt9O1xuZnVuY3Rpb24gZnJhbWUoc2VydmljZSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChzZXJ2aWNlID09IG51bGwpIHJldHVybiB7XG4gICAgc2VuZDogbm9vcCQzLFxuICAgIGNsb3NlOiBub29wJDNcbiAgfTtcbiAgY29uc3Qgb25DbG9zZSA9IG9wdHMub25DbG9zZSB8fCBub29wJDM7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG9wdHMub25NZXNzYWdlIHx8IG5vb3AkMztcbiAgY29uc3Qgb25SZWFkeSA9IG9wdHMub25SZWFkeSB8fCBub29wJDM7XG4gIGNvbnN0IG9uUmVzcG9uc2UgPSBvcHRzLm9uUmVzcG9uc2UgfHwgbm9vcCQzO1xuICBjb25zdCBoYW5kbGVyID0gYnVpbGRNZXNzYWdlSGFuZGxlcih7XG4gICAgY2xvc2UsXG4gICAgc2VuZCxcbiAgICBvblJlYWR5LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25NZXNzYWdlXG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gIGNvbnN0IFskZnJhbWUsIHVubW91bnRdID0gcmVuZGVyRnJhbWUoc2VydmljZUVuZHBvaW50KHNlcnZpY2UpKTtcbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGNsb3NlXG4gIH07XG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICB1bm1vdW50KCk7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGcmFtZSBDbG9zZSBFcnJvclwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgdHJ5IHtcbiAgICAgICRmcmFtZS5wb3N0TWVzc2FnZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1zZyB8fCB7fSkpLCBcIipcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGcmFtZSBTZW5kIEVycm9yXCIsIG1zZywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjSWZyYW1lUlBDKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaWQgPSB1aWQoKTtcbiAgICBjb25zdCBpbmNsdWRlT2xkZXJKc29uUnBjQ2FsbCA9IG9wdHMuaW5jbHVkZU9sZGVySnNvblJwY0NhbGw7XG4gICAgZnJhbWUoc2VydmljZSwge1xuICAgICAgYXN5bmMgb25SZWFkeShfLCBfcmVmMikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHNlbmRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiLFxuICAgICAgICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBzZXJ2aWNlOiB7XG4gICAgICAgICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSxcbiAgICAgICAgICAgICAgdHlwZTogc2VydmljZS50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAgICAgdHlwZTogXCJGQ0w6RlJBTUU6UkVBRFk6UkVTUE9OU0VcIixcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBzZXJ2aWNlOiB7XG4gICAgICAgICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSxcbiAgICAgICAgICAgICAgdHlwZTogc2VydmljZS50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVwcmVjYXRlZDoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZDTDpGUkFNRTpSRUFEWTpSRVNQT05TRSBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCB3aXRoIHR5cGU6IEZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU9sZGVySnNvblJwY0NhbGwpIHtcbiAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIG1ldGhvZDogXCJmY2w6c2lnblwiLFxuICAgICAgICAgICAgICBwYXJhbXM6IFtib2R5LCBzZXJ2aWNlLnBhcmFtc10sXG4gICAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImpzb25ycGMgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgd2l0aCB0eXBlOiBGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVzcG9uc2UoZSwgX3JlZjMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwID0gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKGUuZGF0YSk7XG4gICAgICAgICAgc3dpdGNoIChyZXNwLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5kYXRhKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNJZnJhbWVSUEMgb25SZXNwb25zZSBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1lc3NhZ2UoZSwgX3JlZjQpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoZS5kYXRhLmpzb25ycGMgIT09IFwiMi4wXCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkICE9PSBpZCkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UoZS5kYXRhLnJlc3VsdCk7XG4gICAgICAgICAgc3dpdGNoIChyZXNwLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5kYXRhKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNJZnJhbWVSUEMgb25NZXNzYWdlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHJlamVjdChgRGVjbGluZWQ6IEV4dGVybmFsbHkgSGFsdGVkYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBub29wJDIgPSAoKSA9PiB7fTtcbmZ1bmN0aW9uIHBvcChzZXJ2aWNlKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIHtcbiAgICBzZW5kOiBub29wJDIsXG4gICAgY2xvc2U6IG5vb3AkMlxuICB9O1xuICBjb25zdCBvbkNsb3NlID0gb3B0cy5vbkNsb3NlIHx8IG5vb3AkMjtcbiAgY29uc3Qgb25NZXNzYWdlID0gb3B0cy5vbk1lc3NhZ2UgfHwgbm9vcCQyO1xuICBjb25zdCBvblJlYWR5ID0gb3B0cy5vblJlYWR5IHx8IG5vb3AkMjtcbiAgY29uc3Qgb25SZXNwb25zZSA9IG9wdHMub25SZXNwb25zZSB8fCBub29wJDI7XG4gIGNvbnN0IGhhbmRsZXIgPSBidWlsZE1lc3NhZ2VIYW5kbGVyKHtcbiAgICBjbG9zZSxcbiAgICBzZW5kLFxuICAgIG9uUmVhZHksXG4gICAgb25SZXNwb25zZSxcbiAgICBvbk1lc3NhZ2VcbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgY29uc3QgWyRwb3AsIHVubW91bnRdID0gcmVuZGVyUG9wKHNlcnZpY2VFbmRwb2ludChzZXJ2aWNlKSk7XG4gIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIGlmICgkcG9wICYmICRwb3AuY2xvc2VkKSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfSwgNTAwKTtcbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGNsb3NlXG4gIH07XG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHVubW91bnQoKTtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlBvcHVwIENsb3NlIEVycm9yXCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICB0cnkge1xuICAgICAgJHBvcC5wb3N0TWVzc2FnZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1zZyB8fCB7fSkpLCBcIipcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3B1cCBTZW5kIEVycm9yXCIsIG1zZywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjUG9wUlBDKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaWQgPSB1aWQoKTtcbiAgICBjb25zdCB7XG4gICAgICByZWRpcixcbiAgICAgIGluY2x1ZGVPbGRlckpzb25ScGNDYWxsXG4gICAgfSA9IG9wdHM7XG4gICAgcG9wKHNlcnZpY2UsIHtcbiAgICAgIGFzeW5jIG9uUmVhZHkoXywgX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzZW5kXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICAgICAgICB0eXBlOiBcIkZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgICAgICAgIHR5cGU6IFwiRkNMOkZSQU1FOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJGQ0w6RlJBTUU6UkVBRFk6UkVTUE9OU0UgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgd2l0aCB0eXBlOiBGQ0w6VklFVzpSRUFEWTpSRVNQT05TRVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGluY2x1ZGVPbGRlckpzb25ScGNDYWxsKSB7XG4gICAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBtZXRob2Q6IFwiZmNsOnNpZ25cIixcbiAgICAgICAgICAgICAgcGFyYW1zOiBbYm9keSwgc2VydmljZS5wYXJhbXNdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblJlc3BvbnNlKGUsIF9yZWYzKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVBvbGxpbmdSZXNwb25zZShlLmRhdGEpO1xuICAgICAgICAgIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJBUFBST1ZFRFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AuZGF0YSk7XG4gICAgICAgICAgICAgICFyZWRpciAmJiBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJERUNMSU5FRFwiOlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkXCJ9YCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFRElSRUNUXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogTm8gcmVhc29uIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXhlY1BvcFJQQyBvblJlc3BvbnNlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTWVzc2FnZShlLCBfcmVmNCkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLmRhdGEuanNvbnJwYyAhPT0gXCIyLjBcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChlLmRhdGEuaWQgIT09IGlkKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcCA9IG5vcm1hbGl6ZVBvbGxpbmdSZXNwb25zZShlLmRhdGEucmVzdWx0KTtcbiAgICAgICAgICBzd2l0Y2ggKHJlc3Auc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiQVBQUk9WRURcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLmRhdGEpO1xuICAgICAgICAgICAgICAhcmVkaXIgJiYgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVDTElORURcIjpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogJHtyZXNwLnJlYXNvbiB8fCBcIk5vIHJlYXNvbiBzdXBwbGllZFwifWApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRURJUkVDVFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6IE5vIHJlYXNvbiBzdXBwbGllZGApO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImV4ZWNQb3BSUEMgb25NZXNzYWdlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHJlamVjdChgRGVjbGluZWQ6IEV4dGVybmFsbHkgSGFsdGVkYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBub29wJDEgPSAoKSA9PiB7fTtcbmZ1bmN0aW9uIHRhYihzZXJ2aWNlKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIHtcbiAgICBzZW5kOiBub29wJDEsXG4gICAgY2xvc2U6IG5vb3AkMVxuICB9O1xuICBjb25zdCBvbkNsb3NlID0gb3B0cy5vbkNsb3NlIHx8IG5vb3AkMTtcbiAgY29uc3Qgb25NZXNzYWdlID0gb3B0cy5vbk1lc3NhZ2UgfHwgbm9vcCQxO1xuICBjb25zdCBvblJlYWR5ID0gb3B0cy5vblJlYWR5IHx8IG5vb3AkMTtcbiAgY29uc3Qgb25SZXNwb25zZSA9IG9wdHMub25SZXNwb25zZSB8fCBub29wJDE7XG4gIGNvbnN0IGhhbmRsZXIgPSBidWlsZE1lc3NhZ2VIYW5kbGVyKHtcbiAgICBjbG9zZSxcbiAgICBzZW5kLFxuICAgIG9uUmVhZHksXG4gICAgb25SZXNwb25zZSxcbiAgICBvbk1lc3NhZ2VcbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgY29uc3QgWyR0YWIsIHVubW91bnRdID0gcmVuZGVyVGFiKHNlcnZpY2VFbmRwb2ludChzZXJ2aWNlKSk7XG4gIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIGlmICgkdGFiICYmICR0YWIuY2xvc2VkKSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfSwgNTAwKTtcbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGNsb3NlXG4gIH07XG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHVubW91bnQoKTtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRhYiBDbG9zZSBFcnJvclwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgdHJ5IHtcbiAgICAgICR0YWIucG9zdE1lc3NhZ2UoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtc2cgfHwge30pKSwgXCIqXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGFiIFNlbmQgRXJyb3JcIiwgbXNnLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4ZWNUYWJSUEMoX3JlZikge1xuICBsZXQge1xuICAgIHNlcnZpY2UsXG4gICAgYm9keSxcbiAgICBjb25maWcsXG4gICAgb3B0c1xuICB9ID0gX3JlZjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpZCA9IHVpZCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyLFxuICAgICAgaW5jbHVkZU9sZGVySnNvblJwY0NhbGxcbiAgICB9ID0gb3B0cztcbiAgICB0YWIoc2VydmljZSwge1xuICAgICAgYXN5bmMgb25SZWFkeShfLCBfcmVmMikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHNlbmRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgZmNsVmVyc2lvbjogVkVSU0lPTixcbiAgICAgICAgICAgIHR5cGU6IFwiRkNMOlZJRVc6UkVBRFk6UkVTUE9OU0VcIixcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBzZXJ2aWNlOiB7XG4gICAgICAgICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSxcbiAgICAgICAgICAgICAgdHlwZTogc2VydmljZS50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VuZCh7XG4gICAgICAgICAgICBmY2xWZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAgICAgdHlwZTogXCJGQ0w6RlJBTUU6UkVBRFk6UkVTUE9OU0VcIixcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBzZXJ2aWNlOiB7XG4gICAgICAgICAgICAgIHBhcmFtczogc2VydmljZS5wYXJhbXMsXG4gICAgICAgICAgICAgIGRhdGE6IHNlcnZpY2UuZGF0YSxcbiAgICAgICAgICAgICAgdHlwZTogc2VydmljZS50eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVwcmVjYXRlZDoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZDTDpGUkFNRTpSRUFEWTpSRVNQT05TRSBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCB3aXRoIHR5cGU6IEZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU9sZGVySnNvblJwY0NhbGwpIHtcbiAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIG1ldGhvZDogXCJmY2w6c2lnblwiLFxuICAgICAgICAgICAgICBwYXJhbXM6IFtib2R5LCBzZXJ2aWNlLnBhcmFtc11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUmVzcG9uc2UoZSwgX3JlZjMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjbG9zZVxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlLmRhdGEgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwID0gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKGUuZGF0YSk7XG4gICAgICAgICAgc3dpdGNoIChyZXNwLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIkFQUFJPVkVEXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5kYXRhKTtcbiAgICAgICAgICAgICAgIXJlZGlyICYmIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRFQ0xJTkVEXCI6XG4gICAgICAgICAgICAgIHJlamVjdChgRGVjbGluZWQ6ICR7cmVzcC5yZWFzb24gfHwgXCJObyByZWFzb24gc3VwcGxpZWRcIn1gKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVESVJFQ1RcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiBObyByZWFzb24gc3VwcGxpZWRgKTtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJleGVjUG9wUlBDIG9uUmVzcG9uc2UgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25NZXNzYWdlKGUsIF9yZWY0KSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZS5kYXRhICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUuZGF0YS5qc29ucnBjICE9PSBcIjIuMFwiKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCAhPT0gaWQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCByZXNwID0gbm9ybWFsaXplUG9sbGluZ1Jlc3BvbnNlKGUuZGF0YS5yZXN1bHQpO1xuICAgICAgICAgIHN3aXRjaCAocmVzcC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJBUFBST1ZFRFwiOlxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AuZGF0YSk7XG4gICAgICAgICAgICAgICFyZWRpciAmJiBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJERUNMSU5FRFwiOlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkXCJ9YCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFRElSRUNUXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogTm8gcmVhc29uIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXhlY1BvcFJQQyBvbk1lc3NhZ2UgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbG9zZSgpIHtcbiAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogRXh0ZXJuYWxseSBIYWx0ZWRgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmZ1bmN0aW9uIGV4dGVuc2lvbihzZXJ2aWNlKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHNlcnZpY2UgPT0gbnVsbCkgcmV0dXJuIHtcbiAgICBzZW5kOiBub29wLFxuICAgIGNsb3NlOiBub29wXG4gIH07XG4gIGNvbnN0IG9uQ2xvc2UgPSBvcHRzLm9uQ2xvc2UgfHwgbm9vcDtcbiAgY29uc3Qgb25NZXNzYWdlID0gb3B0cy5vbk1lc3NhZ2UgfHwgbm9vcDtcbiAgY29uc3Qgb25SZWFkeSA9IG9wdHMub25SZWFkeSB8fCBub29wO1xuICBjb25zdCBvblJlc3BvbnNlID0gb3B0cy5vblJlc3BvbnNlIHx8IG5vb3A7XG4gIGNvbnN0IGhhbmRsZXIgPSBidWlsZE1lc3NhZ2VIYW5kbGVyKHtcbiAgICBjbG9zZSxcbiAgICBzZW5kLFxuICAgIG9uUmVhZHksXG4gICAgb25SZXNwb25zZSxcbiAgICBvbk1lc3NhZ2VcbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgc2VuZCh7XG4gICAgc2VydmljZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGNsb3NlXG4gIH07XG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeHQgQ2xvc2UgRXJyb3JcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cgJiYgd2luZG93LnBvc3RNZXNzYWdlKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobXNnIHx8IHt9KSksIFwiKlwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkV4dCBTZW5kIEVycm9yXCIsIG1zZywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjRXh0UlBDKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzZXJ2aWNlLFxuICAgIGJvZHksXG4gICAgY29uZmlnLFxuICAgIG9wdHNcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZXh0ZW5zaW9uKHNlcnZpY2UsIHtcbiAgICAgIGFzeW5jIG9uUmVhZHkoXywgX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBzZW5kXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZW5kKHtcbiAgICAgICAgICAgIGZjbFZlcnNpb246IFZFUlNJT04sXG4gICAgICAgICAgICB0eXBlOiBcIkZDTDpWSUVXOlJFQURZOlJFU1BPTlNFXCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgc2VydmljZToge1xuICAgICAgICAgICAgICBwYXJhbXM6IHNlcnZpY2UucGFyYW1zLFxuICAgICAgICAgICAgICBkYXRhOiBzZXJ2aWNlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGU6IHNlcnZpY2UudHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25SZXNwb25zZShlLCBfcmVmMykge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGUuZGF0YSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBub3JtYWxpemVQb2xsaW5nUmVzcG9uc2UoZS5kYXRhKTtcbiAgICAgICAgICBzd2l0Y2ggKHJlc3Auc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiQVBQUk9WRURcIjpcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLmRhdGEpO1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJERUNMSU5FRFwiOlxuICAgICAgICAgICAgICByZWplY3QoYERlY2xpbmVkOiAke3Jlc3AucmVhc29uIHx8IFwiTm8gcmVhc29uIHN1cHBsaWVkXCJ9YCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFRElSRUNUXCI6XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVqZWN0KGBEZWNsaW5lZDogTm8gcmVhc29uIHN1cHBsaWVkYCk7XG4gICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZXhlY0V4dFJQQyBvblJlc3BvbnNlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHJlamVjdChgRGVjbGluZWQ6IEV4dGVybmFsbHkgSGFsdGVkYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBOT1RfSU1QTEVNRU5URUQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5IHV0aWwgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIG9uIHRoaXMgcGxhdGZvcm1cIik7XG59O1xuY29uc3QgVklFV1MgPSB7XG4gIFwiVklFVy9JRlJBTUVcIjogcmVuZGVyRnJhbWUsXG4gIFwiVklFVy9QT1BcIjogcmVuZGVyUG9wLFxuICBcIlZJRVcvVEFCXCI6IHJlbmRlclRhYixcbiAgXCJWSUVXL01PQklMRV9CUk9XU0VSXCI6IE5PVF9JTVBMRU1FTlRFRCxcbiAgXCJWSUVXL0RFRVBMSU5LXCI6IE5PVF9JTVBMRU1FTlRFRFxufTtcbmFzeW5jIGZ1bmN0aW9uIGV4ZWNMb2NhbChzZXJ2aWNlKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc2VydmljZUVuZHBvaW50OiAoKSA9PiB7fVxuICB9O1xuICBjb25zdCB7XG4gICAgc2VydmljZUVuZHBvaW50XG4gIH0gPSBvcHRzO1xuICB0cnkge1xuICAgIHJldHVybiBWSUVXU1tzZXJ2aWNlLm1ldGhvZF0oc2VydmljZUVuZHBvaW50KHNlcnZpY2UpLCBvcHRzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXhlY0xvY2FsKHtzZXJ2aWNlLCBvcHRzID0ge319KVwiLCBlcnJvciwge1xuICAgICAgc2VydmljZSxcbiAgICAgIG9wdHNcbiAgICB9KTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5jb25zdCBjb3JlU3RyYXRlZ2llcyA9IHtcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIkhUVFAvUlBDXCJdXTogZ2V0RXhlY0h0dHBQb3N0KGV4ZWNMb2NhbCksXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJIVFRQL1BPU1RcIl1dOiBnZXRFeGVjSHR0cFBvc3QoZXhlY0xvY2FsKSxcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIklGUkFNRS9SUENcIl1dOiBleGVjSWZyYW1lUlBDLFxuICBbQ09SRV9TVFJBVEVHSUVTW1wiUE9QL1JQQ1wiXV06IGV4ZWNQb3BSUEMsXG4gIFtDT1JFX1NUUkFURUdJRVNbXCJUQUIvUlBDXCJdXTogZXhlY1RhYlJQQyxcbiAgW0NPUkVfU1RSQVRFR0lFU1tcIkVYVC9SUENcIl1dOiBleGVjRXh0UlBDXG59O1xuXG5jb25zdCBtdXRhdGUgPSBnZXRNdXRhdGUoe1xuICBwbGF0Zm9ybTogXCJ3ZWJcIlxufSk7XG5jb25zdCBjdXJyZW50VXNlciA9IGdldEN1cnJlbnRVc2VyKHtcbiAgcGxhdGZvcm06IFwid2ViXCJcbn0pO1xuY29uc3QgYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBjdXJyZW50VXNlcigpLmF1dGhlbnRpY2F0ZShvcHRzKTtcbn07XG5jb25zdCB1bmF1dGhlbnRpY2F0ZSA9ICgpID0+IGN1cnJlbnRVc2VyKCkudW5hdXRoZW50aWNhdGUoKTtcbmNvbnN0IHJlYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGN1cnJlbnRVc2VyKCkudW5hdXRoZW50aWNhdGUoKTtcbiAgcmV0dXJuIGN1cnJlbnRVc2VyKCkuYXV0aGVudGljYXRlKG9wdHMpO1xufTtcbmNvbnN0IHNpZ25VcCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gY3VycmVudFVzZXIoKS5hdXRoZW50aWNhdGUob3B0cyk7XG59O1xuY29uc3QgbG9nSW4gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGN1cnJlbnRVc2VyKCkuYXV0aGVudGljYXRlKG9wdHMpO1xufTtcbmNvbnN0IGF1dGh6ID0gY3VycmVudFVzZXIoKS5hdXRob3JpemF0aW9uO1xuY29uZmlnKGdldERlZmF1bHRDb25maWcoKSk7XG5pbml0U2VydmljZVJlZ2lzdHJ5KHtcbiAgY29yZVN0cmF0ZWdpZXNcbn0pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIEFwcFV0aWxzLCBpbmRleCBhcyBJbnRlcmFjdGlvblRlbXBsYXRlVXRpbHMsIFZFUlNJT04sIGluZGV4JDIgYXMgV2FsbGV0VXRpbHMsIGF1dGhlbnRpY2F0ZSwgYXV0aHosIGN1cnJlbnRVc2VyLCBkaXNjb3ZlcnksIGV2ZW50cywgZ2V0Q2hhaW5JZCwgbG9nSW4sIG11dGF0ZSwgcGx1Z2luUmVnaXN0cnksIHF1ZXJ5LCByZWF1dGhlbnRpY2F0ZSwgc2VyaWFsaXplLCBzaWduVXAsIHQsIHRyYW5zYWN0aW9uIGFzIHR4LCB1bmF1dGhlbnRpY2F0ZSwgdmVyaWZ5VXNlclNpZ25hdHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZjbC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/fcl/dist/fcl.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/rlp/dist/rlp.module.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@onflow/rlp/dist/rlp.module.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buffer: function() { return /* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   getLength: function() { return /* binding */ getLength; },\n/* harmony export */   toBuffer: function() { return /* binding */ toBuffer; }\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\");\n\n\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n **/\n\n/**\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n **/\nfunction encode(input) {\n  if (Array.isArray(input)) {\n    var output = [];\n    for (var i = 0; i < input.length; i++) {\n      output.push(encode(input[i]));\n    }\n    var buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat(output);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(buf.length, 192), buf]);\n  } else {\n    var inputBuf = toBuffer(input);\n    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\n  }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v, base) {\n  if (v.slice(0, 2) === \"00\") {\n    throw new Error(\"invalid RLP: extra zeros\");\n  }\n  return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n  if (len < 56) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([len + offset]);\n  } else {\n    var hexLength = intToHex(len);\n    var lLength = hexLength.length / 2;\n    var firstByte = intToHex(offset + 55 + lLength);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(firstByte + hexLength, \"hex\");\n  }\n}\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n **/\n\n/**\n * @param input - will be converted to buffer\n * @param stream Is the input a stream (false by default)\n * @returns returns buffer of encoded data\n **/\nfunction decode(input, stream) {\n  if (stream === void 0) {\n    stream = false;\n  }\n  if (!input || input.length === 0) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n  }\n  var inputBuffer = toBuffer(input);\n  var decoded = _decode(inputBuffer);\n  if (stream) {\n    return decoded;\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error(\"invalid remainder\");\n  }\n  return decoded.data;\n}\n\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nfunction getLength(input) {\n  if (!input || input.length === 0) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n  }\n  var inputBuffer = toBuffer(input);\n  var firstByte = inputBuffer[0];\n  if (firstByte <= 0x7f) {\n    return inputBuffer.length;\n  } else if (firstByte <= 0xb7) {\n    return firstByte - 0x7f;\n  } else if (firstByte <= 0xbf) {\n    return firstByte - 0xb6;\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    return firstByte - 0xbf;\n  } else {\n    // a list  over 55 bytes long\n    var llength = firstByte - 0xf6;\n    var length = safeParseInt(inputBuffer.slice(1, llength).toString(\"hex\"), 16);\n    return llength + length;\n  }\n}\n\n/** Decode an input with RLP */\nfunction _decode(input) {\n  var length, llength, data, innerRemainder, d;\n  var decoded = [];\n  var firstByte = input[0];\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.slice(1)\n    };\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f;\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    } else {\n      data = input.slice(1, length);\n    }\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error(\"invalid rlp encoding: byte must be less 0x80\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length)\n    };\n  } else if (firstByte <= 0xbf) {\n    llength = firstByte - 0xb6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    data = input.slice(llength, length + llength);\n    if (data.length < length) {\n      throw new Error(\"invalid RLP\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length + llength)\n    };\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    length = firstByte - 0xbf;\n    innerRemainder = input.slice(1, length);\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(length)\n    };\n  } else {\n    // a list  over 55 bytes long\n    llength = firstByte - 0xf6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    var totalLength = llength + length;\n    if (totalLength > input.length) {\n      throw new Error(\"invalid rlp: total length is larger than the data\");\n    }\n    innerRemainder = input.slice(llength, totalLength);\n    if (innerRemainder.length === 0) {\n      throw new Error(\"invalid rlp, List has a invalid length\");\n    }\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(totalLength)\n    };\n  }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n  return str.slice(0, 2) === \"0x\";\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n  if (typeof str !== \"string\") {\n    return str;\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer) {\n  if (integer < 0) {\n    throw new Error(\"Invalid integer as argument, must be unsigned!\");\n  }\n  var hex = integer.toString(16);\n  return hex.length % 2 ? \"0\" + hex : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n  return a.length % 2 ? \"0\" + a : a;\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer) {\n  var hex = intToHex(integer);\n  return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n}\n\n/** Transform anything into a Buffer */\nfunction toBuffer(v) {\n  if (!buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(v)) {\n    if (typeof v === \"string\") {\n      if (isHexPrefixed(v)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(padToEven(stripHexPrefix(v)), \"hex\");\n      } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);\n      }\n    } else if (typeof v === \"number\") {\n      if (!v) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n      } else {\n        return intToBuffer(v);\n      }\n    } else if (v === null || v === undefined) {\n      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);\n    } else if (v instanceof Uint8Array) {\n      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);\n    } else {\n      throw new Error(\"invalid type\");\n    }\n  }\n  return v;\n}\n\n\n//# sourceMappingURL=rlp.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvcmxwL2Rpc3QvcmxwLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0M7QUFDQTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsY0FBYywwQ0FBTTtBQUNwQixXQUFXLDBDQUFNO0FBQ2pCLElBQUk7QUFDSjtBQUNBLG1FQUFtRSwwQ0FBTTtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUFNO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBTTtBQUNiO0FBQ0E7QUFDQSxlQUFlLDBDQUFNO0FBQ3JCLFFBQVE7QUFDUixlQUFlLDBDQUFNO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZSwwQ0FBTTtBQUNyQixRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLDBDQUFNO0FBQ25CLE1BQU07QUFDTixhQUFhLDBDQUFNO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQztBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvcmxwL2Rpc3QvcmxwLm1vZHVsZS5qcz84N2Y3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5leHBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG4vKipcbiAqIEJ1aWx0IG9uIHRvcCBvZiBybHAgbGlicmFyeSwgcmVtb3ZpbmcgdGhlIEJOIGRlcGVuZGVuY3kgZm9yIHRoZSBmbG93LlxuICogUGFja2FnZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscFxuICogUkxQIExpY2Vuc2UgOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHAvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIGV0aGVyZXVtanMvcmxwIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZVxuICogTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjBcbiAqIFBlcm1pc3Npb25zIG9mIHRoaXMgd2VhayBjb3B5bGVmdCBsaWNlbnNlIGFyZSBjb25kaXRpb25lZCBvbiBtYWtpbmcgYXZhaWxhYmxlIHNvdXJjZSBjb2RlIG9mIGxpY2Vuc2VkIGZpbGVzIGFuZCBtb2RpZmljYXRpb25zIG9mIHRob3NlIGZpbGVzIHVuZGVyIHRoZSBzYW1lIGxpY2Vuc2UgKG9yIGluIGNlcnRhaW4gY2FzZXMsIG9uZSBvZiB0aGUgR05VIGxpY2Vuc2VzKS4gQ29weXJpZ2h0IGFuZCBsaWNlbnNlIG5vdGljZXMgbXVzdCBiZSBwcmVzZXJ2ZWQuIENvbnRyaWJ1dG9ycyBwcm92aWRlIGFuIGV4cHJlc3MgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cy4gSG93ZXZlciwgYSBsYXJnZXIgd29yayB1c2luZyB0aGUgbGljZW5zZWQgd29yayBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZGlmZmVyZW50IHRlcm1zIGFuZCB3aXRob3V0IHNvdXJjZSBjb2RlIGZvciBmaWxlcyBhZGRlZCBpbiB0aGUgbGFyZ2VyIHdvcmsuXG4gKiovXG5cbi8qKlxuICogQHBhcmFtIGlucHV0IC0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYnVmZmVyXG4gKiBAcmV0dXJucyByZXR1cm5zIGJ1ZmZlciBvZiBlbmNvZGVkIGRhdGFcbiAqKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goZW5jb2RlKGlucHV0W2ldKSk7XG4gICAgfVxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KG91dHB1dCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWZdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRCdWYgPSB0b0J1ZmZlcihpbnB1dCk7XG4gICAgcmV0dXJuIGlucHV0QnVmLmxlbmd0aCA9PT0gMSAmJiBpbnB1dEJ1ZlswXSA8IDEyOCA/IGlucHV0QnVmIDogQnVmZmVyLmNvbmNhdChbZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWZdKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGludGVnZXJzLiBDaGVjayBpZiB0aGVyZSBpcyBubyBsZWFkaW5nIHplcm9zXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcbiAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIHBhcnNlIHRoZSBpbnRlZ2VyIGludG9cbiAqL1xuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHYsIGJhc2UpIHtcbiAgaWYgKHYuc2xpY2UoMCwgMikgPT09IFwiMDBcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgUkxQOiBleHRyYSB6ZXJvc1wiKTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodiwgYmFzZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgaWYgKGxlbiA8IDU2KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGV4TGVuZ3RoID0gaW50VG9IZXgobGVuKTtcbiAgICB2YXIgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgIHZhciBmaXJzdEJ5dGUgPSBpbnRUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShmaXJzdEJ5dGUgKyBoZXhMZW5ndGgsIFwiaGV4XCIpO1xuICB9XG59XG5cbi8qKlxuICogQnVpbHQgb24gdG9wIG9mIHJscCBsaWJyYXJ5LCByZW1vdmluZyB0aGUgQk4gZGVwZW5kZW5jeSBmb3IgdGhlIGZsb3cuXG4gKiBQYWNrYWdlIDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwXG4gKiBSTFAgTGljZW5zZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogZXRoZXJldW1qcy9ybHAgaXMgbGljZW5zZWQgdW5kZXIgdGhlXG4gKiBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMFxuICogUGVybWlzc2lvbnMgb2YgdGhpcyB3ZWFrIGNvcHlsZWZ0IGxpY2Vuc2UgYXJlIGNvbmRpdGlvbmVkIG9uIG1ha2luZyBhdmFpbGFibGUgc291cmNlIGNvZGUgb2YgbGljZW5zZWQgZmlsZXMgYW5kIG1vZGlmaWNhdGlvbnMgb2YgdGhvc2UgZmlsZXMgdW5kZXIgdGhlIHNhbWUgbGljZW5zZSAob3IgaW4gY2VydGFpbiBjYXNlcywgb25lIG9mIHRoZSBHTlUgbGljZW5zZXMpLiBDb3B5cmlnaHQgYW5kIGxpY2Vuc2Ugbm90aWNlcyBtdXN0IGJlIHByZXNlcnZlZC4gQ29udHJpYnV0b3JzIHByb3ZpZGUgYW4gZXhwcmVzcyBncmFudCBvZiBwYXRlbnQgcmlnaHRzLiBIb3dldmVyLCBhIGxhcmdlciB3b3JrIHVzaW5nIHRoZSBsaWNlbnNlZCB3b3JrIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBkaWZmZXJlbnQgdGVybXMgYW5kIHdpdGhvdXQgc291cmNlIGNvZGUgZm9yIGZpbGVzIGFkZGVkIGluIHRoZSBsYXJnZXIgd29yay5cbiAqKi9cblxuLyoqXG4gKiBAcGFyYW0gaW5wdXQgLSB3aWxsIGJlIGNvbnZlcnRlZCB0byBidWZmZXJcbiAqIEBwYXJhbSBzdHJlYW0gSXMgdGhlIGlucHV0IGEgc3RyZWFtIChmYWxzZSBieSBkZWZhdWx0KVxuICogQHJldHVybnMgcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQsIHN0cmVhbSkge1xuICBpZiAoc3RyZWFtID09PSB2b2lkIDApIHtcbiAgICBzdHJlYW0gPSBmYWxzZTtcbiAgfVxuICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gIH1cbiAgdmFyIGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xuICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoaW5wdXRCdWZmZXIpO1xuICBpZiAoc3RyZWFtKSB7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVtYWluZGVyXCIpO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIFJMUCBpbnB1dFxuICogQHBhcmFtIGlucHV0XG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBvciBhbiBlbXB0eSBCdWZmZXIgaWYgbm8gaW5wdXRcbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoKGlucHV0KSB7XG4gIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgfVxuICB2YXIgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XG4gIHZhciBmaXJzdEJ5dGUgPSBpbnB1dEJ1ZmZlclswXTtcbiAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgcmV0dXJuIGlucHV0QnVmZmVyLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweDdmO1xuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YjY7XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YmY7XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBsaXN0ICBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICB2YXIgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgdmFyIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dEJ1ZmZlci5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZyhcImhleFwiKSwgMTYpO1xuICAgIHJldHVybiBsbGVuZ3RoICsgbGVuZ3RoO1xuICB9XG59XG5cbi8qKiBEZWNvZGUgYW4gaW5wdXQgd2l0aCBSTFAgKi9cbmZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgdmFyIGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGQ7XG4gIHZhciBkZWNvZGVkID0gW107XG4gIHZhciBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGlucHV0LnNsaWNlKDAsIDEpLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICAvLyBzdHJpbmcgaXMgMC01NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdmFsdWUgMHg4MCBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXG4gICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmxwIGVuY29kaW5nOiBieXRlIG11c3QgYmUgbGVzcyAweDgwXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXQuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoXCJoZXhcIiksIDE2KTtcbiAgICBkYXRhID0gaW5wdXQuc2xpY2UobGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFJMUFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCArIGxsZW5ndGgpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgIC8vIGEgbGlzdCBiZXR3ZWVuICAwLTU1IGJ5dGVzIGxvbmdcbiAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGJmO1xuICAgIGlubmVyUmVtYWluZGVyID0gaW5wdXQuc2xpY2UoMSwgbGVuZ3RoKTtcbiAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dC5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZyhcImhleFwiKSwgMTYpO1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XG4gICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhXCIpO1xuICAgIH1cbiAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIHRvdGFsTGVuZ3RoKTtcbiAgICBpZiAoaW5uZXJSZW1haW5kZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCwgTGlzdCBoYXMgYSBpbnZhbGlkIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpXG4gICAgfTtcbiAgfVxufVxuLyoqIENoZWNrIGlmIGEgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IDB4ICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIDIpID09PSBcIjB4XCI7XG59XG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBpdHMgaGV4YWRlY2ltYWwgdmFsdWUgKi9cbmZ1bmN0aW9uIGludFRvSGV4KGludGVnZXIpIHtcbiAgaWYgKGludGVnZXIgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIVwiKTtcbiAgfVxuICB2YXIgaGV4ID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXgubGVuZ3RoICUgMiA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICByZXR1cm4gYS5sZW5ndGggJSAyID8gXCIwXCIgKyBhIDogYTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgQnVmZmVyICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpbnRlZ2VyKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpbnRlZ2VyKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG59XG5cbi8qKiBUcmFuc2Zvcm0gYW55dGhpbmcgaW50byBhIEJ1ZmZlciAqL1xuZnVuY3Rpb24gdG9CdWZmZXIodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSksIFwiaGV4XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICghdikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludFRvQnVmZmVyKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XG4gICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufVxuXG5leHBvcnQgeyBkZWNvZGUsIGVuY29kZSwgZ2V0TGVuZ3RoLCB0b0J1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/rlp/dist/rlp.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/sdk/dist/sdk.module.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@onflow/sdk/dist/sdk.module.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TestUtils: function() { return /* binding */ index; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   account: function() { return /* binding */ account; },\n/* harmony export */   arg: function() { return /* binding */ arg; },\n/* harmony export */   args: function() { return /* binding */ args; },\n/* harmony export */   atBlockHeight: function() { return /* binding */ atBlockHeight; },\n/* harmony export */   atBlockId: function() { return /* binding */ atBlockId; },\n/* harmony export */   authorization: function() { return /* binding */ authorization; },\n/* harmony export */   authorizations: function() { return /* binding */ authorizations; },\n/* harmony export */   block: function() { return /* binding */ block; },\n/* harmony export */   build: function() { return /* binding */ build; },\n/* harmony export */   cadence: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template; },\n/* harmony export */   cdc: function() { return /* reexport safe */ _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template; },\n/* harmony export */   config: function() { return /* reexport safe */ _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config; },\n/* harmony export */   createSignableVoucher: function() { return /* binding */ createSignableVoucher; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   destroy: function() { return /* binding */ destroy; },\n/* harmony export */   encodeMessageFromSignable: function() { return /* binding */ encodeMessageFromSignable; },\n/* harmony export */   encodeTransactionEnvelope: function() { return /* binding */ encodeTransactionEnvelope; },\n/* harmony export */   encodeTransactionPayload: function() { return /* binding */ encodeTransactionPayload; },\n/* harmony export */   encodeTxIdFromVoucher: function() { return /* binding */ encodeTxIdFromVoucher; },\n/* harmony export */   get: function() { return /* binding */ get; },\n/* harmony export */   getAccount: function() { return /* binding */ getAccount; },\n/* harmony export */   getBlock: function() { return /* binding */ getBlock; },\n/* harmony export */   getBlockHeader: function() { return /* binding */ getBlockHeader; },\n/* harmony export */   getCollection: function() { return /* binding */ getCollection; },\n/* harmony export */   getEvents: function() { return /* binding */ getEvents; },\n/* harmony export */   getEventsAtBlockHeightRange: function() { return /* binding */ getEventsAtBlockHeightRange; },\n/* harmony export */   getEventsAtBlockIds: function() { return /* binding */ getEventsAtBlockIds; },\n/* harmony export */   getNetworkParameters: function() { return /* binding */ getNetworkParameters; },\n/* harmony export */   getTransaction: function() { return /* binding */ getTransaction; },\n/* harmony export */   getTransactionStatus: function() { return /* binding */ getTransactionStatus; },\n/* harmony export */   interaction: function() { return /* binding */ interaction; },\n/* harmony export */   invariant: function() { return /* binding */ invariant; },\n/* harmony export */   isBad: function() { return /* binding */ isBad; },\n/* harmony export */   isGetAccount: function() { return /* binding */ isGetAccount; },\n/* harmony export */   isGetBlock: function() { return /* binding */ isGetBlock; },\n/* harmony export */   isGetBlockHeader: function() { return /* binding */ isGetBlockHeader; },\n/* harmony export */   isGetCollection: function() { return /* binding */ isGetCollection; },\n/* harmony export */   isGetEvents: function() { return /* binding */ isGetEvents; },\n/* harmony export */   isGetNetworkParameters: function() { return /* binding */ isGetNetworkParameters; },\n/* harmony export */   isGetTransaction: function() { return /* binding */ isGetTransaction; },\n/* harmony export */   isGetTransactionStatus: function() { return /* binding */ isGetTransactionStatus; },\n/* harmony export */   isOk: function() { return /* binding */ isOk; },\n/* harmony export */   isPing: function() { return /* binding */ isPing; },\n/* harmony export */   isScript: function() { return /* binding */ isScript; },\n/* harmony export */   isTransaction: function() { return /* binding */ isTransaction; },\n/* harmony export */   isUnknown: function() { return /* binding */ isUnknown; },\n/* harmony export */   limit: function() { return /* binding */ limit; },\n/* harmony export */   param: function() { return /* binding */ param; },\n/* harmony export */   params: function() { return /* binding */ params; },\n/* harmony export */   payer: function() { return /* binding */ payer; },\n/* harmony export */   ping: function() { return /* binding */ ping; },\n/* harmony export */   pipe: function() { return /* binding */ pipe; },\n/* harmony export */   proposer: function() { return /* binding */ proposer; },\n/* harmony export */   put: function() { return /* binding */ put; },\n/* harmony export */   ref: function() { return /* binding */ ref; },\n/* harmony export */   resolve: function() { return /* binding */ resolve; },\n/* harmony export */   resolveAccounts: function() { return /* binding */ resolveAccounts; },\n/* harmony export */   resolveArguments: function() { return /* binding */ resolveArguments; },\n/* harmony export */   resolveCadence: function() { return /* binding */ resolveCadence; },\n/* harmony export */   resolveFinalNormalization: function() { return /* binding */ resolveFinalNormalization; },\n/* harmony export */   resolveProposerSequenceNumber: function() { return /* binding */ resolveProposerSequenceNumber; },\n/* harmony export */   resolveRefBlockId: function() { return /* binding */ resolveRefBlockId; },\n/* harmony export */   resolveSignatures: function() { return /* binding */ resolveSignatures; },\n/* harmony export */   resolveValidators: function() { return /* binding */ resolveValidators; },\n/* harmony export */   resolveVoucherIntercept: function() { return /* binding */ resolveVoucherIntercept; },\n/* harmony export */   response: function() { return /* binding */ response; },\n/* harmony export */   script: function() { return /* binding */ script; },\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   transaction: function() { return /* binding */ transaction; },\n/* harmony export */   update: function() { return /* binding */ update; },\n/* harmony export */   validator: function() { return /* binding */ validator; },\n/* harmony export */   voucherIntercept: function() { return /* binding */ voucherIntercept; },\n/* harmony export */   voucherToTxId: function() { return /* binding */ voucherToTxId; },\n/* harmony export */   why: function() { return /* binding */ why; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-logger */ \"../../node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/util-invariant */ \"../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var _onflow_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/config */ \"../../node_modules/@onflow/config/dist/config.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @onflow/rlp */ \"../../node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/transport-http */ \"../../node_modules/@onflow/transport-http/dist/sdk-send-http.module.js\");\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @onflow/util-address */ \"../../node_modules/@onflow/util-address/dist/util-address.module.js\");\n/* harmony import */ var sha3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! sha3 */ \"../../node_modules/sha3/index.js\");\n/* harmony import */ var _onflow_util_template__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @onflow/util-template */ \"../../node_modules/@onflow/util-template/dist/template.module.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst UNKNOWN /*                       */ = \"UNKNOWN\";\nconst SCRIPT /*                        */ = \"SCRIPT\";\nconst TRANSACTION /*                   */ = \"TRANSACTION\";\nconst GET_TRANSACTION_STATUS /*        */ = \"GET_TRANSACTION_STATUS\";\nconst GET_ACCOUNT /*                   */ = \"GET_ACCOUNT\";\nconst GET_EVENTS /*                    */ = \"GET_EVENTS\";\nconst PING /*                          */ = \"PING\";\nconst GET_TRANSACTION /*               */ = \"GET_TRANSACTION\";\nconst GET_BLOCK /*                     */ = \"GET_BLOCK\";\nconst GET_BLOCK_HEADER /*              */ = \"GET_BLOCK_HEADER\";\nconst GET_COLLECTION /*                */ = \"GET_COLLECTION\";\nconst GET_NETWORK_PARAMETERS /*        */ = \"GET_NETWORK_PARAMETERS\";\nconst BAD /* */ = \"BAD\";\nconst OK /*  */ = \"OK\";\nconst ACCOUNT /*  */ = \"ACCOUNT\";\nconst PARAM /*    */ = \"PARAM\";\nconst ARGUMENT /* */ = \"ARGUMENT\";\nconst AUTHORIZER /* */ = \"authorizer\";\nconst PAYER /*      */ = \"payer\";\nconst PROPOSER /*   */ = \"proposer\";\nconst ACCT = `{\n  \"kind\":\"${ACCOUNT}\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}`;\nconst ARG = `{\n  \"kind\":\"${ARGUMENT}\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}`;\nconst IX = `{\n  \"tag\":\"${UNKNOWN}\",\n  \"assigns\":{},\n  \"status\":\"${OK}\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}`;\nconst KEYS = new Set(Object.keys(JSON.parse(IX)));\nconst interaction = () => JSON.parse(IX);\nconst CHARS = \"abcdefghijklmnopqrstuvwxyz0123456789\".split(\"\");\nconst randChar = () => CHARS[~~(Math.random() * CHARS.length)];\nconst uuid = () => Array.from({\n  length: 10\n}, randChar).join(\"\");\nconst isNumber$1 = d => typeof d === \"number\";\nconst isArray$1 = d => Array.isArray(d);\nconst isObj = d => d !== null && typeof d === \"object\";\nconst isNull = d => d == null;\nconst isFn$3 = d => typeof d === \"function\";\nconst isInteraction = ix => {\n  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;\n  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;\n  return true;\n};\nconst Ok = ix => {\n  ix.status = OK;\n  return ix;\n};\nconst Bad = (ix, reason) => {\n  ix.status = BAD;\n  ix.reason = reason;\n  return ix;\n};\nconst makeIx = wat => ix => {\n  ix.tag = wat;\n  return Ok(ix);\n};\nconst prepAccountKeyId = acct => {\n  if (acct.keyId == null) return acct;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!isNaN(parseInt(acct.keyId)), \"account.keyId must be an integer\");\n  return {\n    ...acct,\n    keyId: parseInt(acct.keyId)\n  };\n};\nconst prepAccount = function (acct) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return ix => {\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(typeof acct === \"function\" || typeof acct === \"object\", \"prepAccount must be passed an authorization function or an account object\");\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(opts.role != null, \"Account must have a role\");\n    const ACCOUNT = JSON.parse(ACCT);\n    const role = opts.role;\n    const tempId = uuid();\n    if (acct.authorization && isFn$3(acct.authorization)) acct = {\n      resolve: acct.authorization\n    };\n    if (!acct.authorization && isFn$3(acct)) acct = {\n      resolve: acct\n    };\n    const resolve = acct.resolve;\n    if (resolve) acct.resolve = function (acct) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      return [resolve, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct);\n    };\n    acct = prepAccountKeyId(acct);\n    ix.accounts[tempId] = {\n      ...ACCOUNT,\n      tempId,\n      ...acct,\n      role: {\n        ...ACCOUNT.role,\n        ...(typeof acct.role === \"object\" ? acct.role : {}),\n        [role]: true\n      }\n    };\n    if (role === AUTHORIZER) {\n      ix.authorizations.push(tempId);\n    } else if (role === PAYER) {\n      ix.payer.push(tempId);\n    } else {\n      ix[role] = tempId;\n    }\n    return ix;\n  };\n};\nconst makeArgument = arg => ix => {\n  let tempId = uuid();\n  ix.message.arguments.push(tempId);\n  ix.arguments[tempId] = JSON.parse(ARG);\n  ix.arguments[tempId].tempId = tempId;\n  ix.arguments[tempId].value = arg.value;\n  ix.arguments[tempId].asArgument = arg.asArgument;\n  ix.arguments[tempId].xform = arg.xform;\n  ix.arguments[tempId].resolve = arg.resolve;\n  ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;\n  return Ok(ix);\n};\nconst makeUnknown /*                 */ = makeIx(UNKNOWN);\nconst makeScript /*                  */ = makeIx(SCRIPT);\nconst makeTransaction /*             */ = makeIx(TRANSACTION);\nconst makeGetTransactionStatus /*    */ = makeIx(GET_TRANSACTION_STATUS);\nconst makeGetTransaction /*          */ = makeIx(GET_TRANSACTION);\nconst makeGetAccount /*              */ = makeIx(GET_ACCOUNT);\nconst makeGetEvents /*               */ = makeIx(GET_EVENTS);\nconst makePing /*                    */ = makeIx(PING);\nconst makeGetBlock /*                */ = makeIx(GET_BLOCK);\nconst makeGetBlockHeader /*          */ = makeIx(GET_BLOCK_HEADER);\nconst makeGetCollection /*           */ = makeIx(GET_COLLECTION);\nconst makeGetNetworkParameters /*    */ = makeIx(GET_NETWORK_PARAMETERS);\nconst is = wat => ix => ix.tag === wat;\nconst isUnknown /*                 */ = is(UNKNOWN);\nconst isScript /*                  */ = is(SCRIPT);\nconst isTransaction /*             */ = is(TRANSACTION);\nconst isGetTransactionStatus /*    */ = is(GET_TRANSACTION_STATUS);\nconst isGetTransaction /*          */ = is(GET_TRANSACTION);\nconst isGetAccount /*              */ = is(GET_ACCOUNT);\nconst isGetEvents /*               */ = is(GET_EVENTS);\nconst isPing /*                    */ = is(PING);\nconst isGetBlock /*                */ = is(GET_BLOCK);\nconst isGetBlockHeader /*          */ = is(GET_BLOCK_HEADER);\nconst isGetCollection /*           */ = is(GET_COLLECTION);\nconst isGetNetworkParameters /*    */ = is(GET_NETWORK_PARAMETERS);\nconst isOk /*  */ = ix => ix.status === OK;\nconst isBad /* */ = ix => ix.status === BAD;\nconst why /*   */ = ix => ix.reason;\nconst isAccount /*  */ = account => account.kind === ACCOUNT;\nconst isParam /*    */ = param => param.kind === PARAM;\nconst isArgument /* */ = argument => argument.kind === ARGUMENT;\nconst hardMode = ix => {\n  for (let key of Object.keys(ix)) {\n    if (!KEYS.has(key)) throw new Error(`\"${key}\" is an invalid root level Interaction property.`);\n  }\n  return ix;\n};\nconst recPipe = async function (ix) {\n  let fns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  try {\n    ix = hardMode(await ix);\n    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);\n    if (!fns.length) return ix;\n    const [hd, ...rest] = fns;\n    const cur = await hd;\n    if (isFn$3(cur)) return recPipe(cur(ix), rest);\n    if (isNull(cur) || !cur) return recPipe(ix, rest);\n    if (isInteraction(cur)) return recPipe(cur, rest);\n    throw new Error(\"Invalid Interaction Composition\");\n  } catch (e) {\n    throw e;\n  }\n};\nconst pipe = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  const [arg1, arg2] = args;\n  if (isArray$1(arg1) && arg2 == null) return d => pipe(d, arg1);\n  return recPipe(arg1, arg2);\n};\nconst identity$1 = v => v;\nconst get = (ix, key, fallback) => {\n  return ix.assigns[key] == null ? fallback : ix.assigns[key];\n};\nconst put = (key, value) => ix => {\n  ix.assigns[key] = value;\n  return Ok(ix);\n};\nconst update = function (key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  return ix => {\n    ix.assigns[key] = fn(ix.assigns[key], ix);\n    return Ok(ix);\n  };\n};\nconst destroy = key => ix => {\n  delete ix.assigns[key];\n  return Ok(ix);\n};\n\nvar ixModule = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  UNKNOWN: UNKNOWN,\n  SCRIPT: SCRIPT,\n  TRANSACTION: TRANSACTION,\n  GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,\n  GET_ACCOUNT: GET_ACCOUNT,\n  GET_EVENTS: GET_EVENTS,\n  PING: PING,\n  GET_TRANSACTION: GET_TRANSACTION,\n  GET_BLOCK: GET_BLOCK,\n  GET_BLOCK_HEADER: GET_BLOCK_HEADER,\n  GET_COLLECTION: GET_COLLECTION,\n  GET_NETWORK_PARAMETERS: GET_NETWORK_PARAMETERS,\n  BAD: BAD,\n  OK: OK,\n  ACCOUNT: ACCOUNT,\n  PARAM: PARAM,\n  ARGUMENT: ARGUMENT,\n  AUTHORIZER: AUTHORIZER,\n  PAYER: PAYER,\n  PROPOSER: PROPOSER,\n  interaction: interaction,\n  uuid: uuid,\n  isNumber: isNumber$1,\n  isArray: isArray$1,\n  isObj: isObj,\n  isNull: isNull,\n  isFn: isFn$3,\n  isInteraction: isInteraction,\n  Ok: Ok,\n  Bad: Bad,\n  prepAccount: prepAccount,\n  makeArgument: makeArgument,\n  makeUnknown: makeUnknown,\n  makeScript: makeScript,\n  makeTransaction: makeTransaction,\n  makeGetTransactionStatus: makeGetTransactionStatus,\n  makeGetTransaction: makeGetTransaction,\n  makeGetAccount: makeGetAccount,\n  makeGetEvents: makeGetEvents,\n  makePing: makePing,\n  makeGetBlock: makeGetBlock,\n  makeGetBlockHeader: makeGetBlockHeader,\n  makeGetCollection: makeGetCollection,\n  makeGetNetworkParameters: makeGetNetworkParameters,\n  isUnknown: isUnknown,\n  isScript: isScript,\n  isTransaction: isTransaction,\n  isGetTransactionStatus: isGetTransactionStatus,\n  isGetTransaction: isGetTransaction,\n  isGetAccount: isGetAccount,\n  isGetEvents: isGetEvents,\n  isPing: isPing,\n  isGetBlock: isGetBlock,\n  isGetBlockHeader: isGetBlockHeader,\n  isGetCollection: isGetCollection,\n  isGetNetworkParameters: isGetNetworkParameters,\n  isOk: isOk,\n  isBad: isBad,\n  why: why,\n  isAccount: isAccount,\n  isParam: isParam,\n  isArgument: isArgument,\n  pipe: pipe,\n  get: get,\n  put: put,\n  update: update,\n  destroy: destroy\n});\n\nfunction build() {\n  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(interaction(), fns);\n}\n\nconst DEFAULT_RESPONSE = `{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null,\n    \"networkParameters\":null\n}`;\nconst response = () => JSON.parse(DEFAULT_RESPONSE);\n\n/**\n * @description - A builder function that returns the interaction to get the latest block\n * @param {boolean} [isSealed] - Whether or not the block should be sealed\n * @returns {Function} - An interaction object\n */\nfunction getBlock() {\n  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetBlock, ix => {\n    ix.block.isSealed = isSealed;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns the interaction to get an account by address\n * @param {string} addr - The address of the account to getq\n * @returns {Function} - An interaction object\n */\nfunction getAccount(addr) {\n  return pipe([makeGetAccount, ix => {\n    ix.account.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(addr);\n    return Ok(ix);\n  }]);\n}\n\nconst latestBlockDeprecationNotice = () => {\n  _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n    pkg: \"@onflow/decode\",\n    subject: \"Operating upon data of the latestBlock field of the response object\",\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\"\n  });\n};\nconst decodeImplicit = async i => i;\nconst decodeVoid = async () => null;\nconst decodeType = async type => {\n  return type.staticType;\n};\nconst decodePath = async path => {\n  return {\n    domain: path.domain,\n    identifier: path.identifier\n  };\n};\nconst decodeCapability = async cap => {\n  return {\n    path: cap.path,\n    address: cap.address,\n    borrowType: cap.borrowType\n  };\n};\nconst decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;\nconst decodeReference = async v => ({\n  address: v.address,\n  type: v.type\n});\nconst decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));\nconst decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {\n  acc = await acc;\n  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);\n  return acc;\n}, Promise.resolve({}));\nconst decodeComposite = async (composite, decoders, stack) => {\n  const decoded = await composite.fields.reduce(async (acc, v) => {\n    acc = await acc;\n    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);\n    return acc;\n  }, Promise.resolve({}));\n  const decoder = composite.id && decoderLookup(decoders, composite.id);\n  return decoder ? await decoder(decoded) : decoded;\n};\nconst defaultDecoders = {\n  UInt: decodeImplicit,\n  Int: decodeImplicit,\n  UInt8: decodeImplicit,\n  Int8: decodeImplicit,\n  UInt16: decodeImplicit,\n  Int16: decodeImplicit,\n  UInt32: decodeImplicit,\n  Int32: decodeImplicit,\n  UInt64: decodeImplicit,\n  Int64: decodeImplicit,\n  UInt128: decodeImplicit,\n  Int128: decodeImplicit,\n  UInt256: decodeImplicit,\n  Int256: decodeImplicit,\n  Word8: decodeImplicit,\n  Word16: decodeImplicit,\n  Word32: decodeImplicit,\n  Word64: decodeImplicit,\n  UFix64: decodeImplicit,\n  Fix64: decodeImplicit,\n  String: decodeImplicit,\n  Character: decodeImplicit,\n  Bool: decodeImplicit,\n  Address: decodeImplicit,\n  Void: decodeVoid,\n  Optional: decodeOptional,\n  Reference: decodeReference,\n  Array: decodeArray,\n  Dictionary: decodeDictionary,\n  Event: decodeComposite,\n  Resource: decodeComposite,\n  Struct: decodeComposite,\n  Enum: decodeComposite,\n  Type: decodeType,\n  Path: decodePath,\n  Capability: decodeCapability\n};\nconst decoderLookup = (decoders, lookup) => {\n  const found = Object.keys(decoders).find(decoder => {\n    if (/^\\/.*\\/$/.test(decoder)) {\n      const reg = new RegExp(decoder.substring(1, decoder.length - 1));\n      return reg.test(lookup);\n    }\n    return decoder === lookup;\n  });\n  return lookup && found && decoders[found];\n};\nconst recurseDecode = async (decodeInstructions, decoders, stack) => {\n  let decoder = decoderLookup(decoders, decodeInstructions.type);\n  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(\".\")}`);\n  return await decoder(decodeInstructions.value, decoders, stack);\n};\n\n/**\n * @description - Decodes a response from Flow into JSON\n * @param {*} decodeInstructions - The response object from Flow\n * @param {object} customDecoders - An object of custom decoders\n * @param {Array<*>} stack - The stack of the current decoding\n * @returns {Promise<*>} - The decoded response\n */\nconst decode$1 = async function (decodeInstructions) {\n  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  // Filter out all default decoders which are overridden by a custom decoder regex\n  const filteredDecoders = Object.keys(defaultDecoders).filter(decoder => !Object.keys(customDecoders).find(customDecoder => new RegExp(customDecoder).test(decoder))).reduce((decoders, decoderKey) => {\n    decoders[decoderKey] = defaultDecoders[decoderKey];\n    return decoders;\n  }, customDecoders);\n  const decoders = {\n    ...filteredDecoders,\n    ...customDecoders\n  };\n  return recurseDecode(decodeInstructions, decoders, stack);\n};\nconst decodeResponse = async function (response) {\n  let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (response.encodedData) {\n    return decode$1(response.encodedData, customDecoders);\n  } else if (response.transactionStatus) {\n    return {\n      ...response.transactionStatus,\n      events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {\n        return {\n          type: e.type,\n          transactionId: e.transactionId,\n          transactionIndex: e.transactionIndex,\n          eventIndex: e.eventIndex,\n          data: await decode$1(e.payload, customDecoders)\n        };\n      }))\n    };\n  } else if (response.transaction) {\n    return response.transaction;\n  } else if (response.events) {\n    return await Promise.all(response.events.map(async function decodeEvents(e) {\n      return {\n        blockId: e.blockId,\n        blockHeight: e.blockHeight,\n        blockTimestamp: e.blockTimestamp,\n        type: e.type,\n        transactionId: e.transactionId,\n        transactionIndex: e.transactionIndex,\n        eventIndex: e.eventIndex,\n        data: await decode$1(e.payload, customDecoders)\n      };\n    }));\n  } else if (response.account) {\n    return response.account;\n  } else if (response.block) {\n    return response.block;\n  } else if (response.blockHeader) {\n    return response.blockHeader;\n  } else if (response.latestBlock) {\n    latestBlockDeprecationNotice();\n    return response.latestBlock;\n  } else if (response.transactionId) {\n    return response.transactionId;\n  } else if (response.collection) {\n    return response.collection;\n  } else if (response.networkParameters) {\n    const chainIdMap = {\n      \"flow-testnet\": \"testnet\",\n      \"flow-mainnet\": \"mainnet\",\n      \"flow-emulator\": \"local\"\n    };\n    return {\n      chainId: chainIdMap[response.networkParameters.chainId]\n    };\n  }\n  return null;\n};\n\nconst isFn$2 = v => typeof v === \"function\";\nconst isString$1 = v => typeof v === \"string\";\nconst oldIdentifierPatternFn = () => /\\b(0x\\w+)\\b/g;\nfunction isOldIdentifierSyntax(cadence) {\n  return oldIdentifierPatternFn().test(cadence);\n}\nconst newIdentifierPatternFn = () => /import\\s+\"(\\w+)\"/g;\nfunction isNewIdentifierSyntax(cadence) {\n  return newIdentifierPatternFn().test(cadence);\n}\nfunction getContractIdentifierSyntaxMatches(cadence) {\n  return cadence.matchAll(newIdentifierPatternFn());\n}\nasync function resolveCadence(ix) {\n  if (!isTransaction(ix) && !isScript(ix)) return ix;\n  var cadence = get(ix, \"ix.cadence\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(isFn$2(cadence) || isString$1(cadence), \"Cadence needs to be a function or a string.\");\n  if (isFn$2(cadence)) cadence = await cadence({});\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(isString$1(cadence), \"Cadence needs to be a string at this point.\");\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), \"Both account identifier and contract identifier syntax not simultaneously supported.\");\n  if (isOldIdentifierSyntax(cadence)) {\n    cadence = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().where(/^0x/).then(d => Object.entries(d).reduce((cadence, _ref) => {\n      let [key, value] = _ref;\n      const regex = new RegExp(\"(\\\\b\" + key + \"\\\\b)\", \"g\");\n      return cadence.replace(regex, value);\n    }, cadence));\n  }\n  if (isNewIdentifierSyntax(cadence)) {\n    for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {\n      const address = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(`system.contracts.${contractName}`);\n      if (address) {\n        cadence = cadence.replace(fullMatch, `import ${contractName} from ${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(address)}`);\n      } else {\n        _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log({\n          title: \"Contract Placeholder not found\",\n          message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.warn\n        });\n      }\n    }\n  }\n\n  // We need to move this over in any case.\n  ix.message.cadence = cadence;\n  return ix;\n}\n\nconst isFn$1 = v => typeof v === \"function\";\nfunction cast(arg) {\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);\n  if (isFn$1(arg.xform)) return arg.xform(arg.value);\n  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value);\n\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(false, `Invalid Argument`, arg);\n}\nasync function handleArgResolution(arg) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);\n  if (isFn$1(arg.resolveArgument)) {\n    const resolvedArg = await arg.resolveArgument();\n    return handleArgResolution(resolvedArg, depth - 1);\n  } else {\n    return arg;\n  }\n}\nasync function resolveArguments(ix) {\n  if (isTransaction(ix) || isScript(ix)) {\n    for (let [id, arg] of Object.entries(ix.arguments)) {\n      const res = await handleArgResolution(arg);\n      ix.arguments[id].asArgument = cast(res);\n    }\n  }\n  return ix;\n}\n\nconst encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));\nconst encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));\nconst encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));\nconst rightPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(value.padEnd(pad * 2, 0), \"hex\");\nconst leftPaddedHexBuffer = (value, pad) => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(value.padStart(pad * 2, 0), \"hex\");\nconst TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(\"FLOW-V0.0-transaction\").toString(\"hex\"), 32).toString(\"hex\");\nconst prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8);\nconst blockBuffer = block => leftPaddedHexBuffer(block, 32);\nconst argumentToString = arg => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(JSON.stringify(arg), \"utf8\");\nconst scriptBuffer = script => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(script, \"utf8\");\nconst signatureBuffer = signature => _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(signature, \"hex\");\nconst rlpEncode = v => {\n  return (0,_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.encode)(v).toString(\"hex\");\n};\nconst sha3_256 = msg => {\n  const sha = new sha3__WEBPACK_IMPORTED_MODULE_6__.SHA3(256);\n  sha.update(_onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer.from(msg, \"hex\"));\n  return sha.digest().toString(\"hex\");\n};\nconst preparePayload = tx => {\n  validatePayload(tx);\n  return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(tx.payer)), tx.authorizers.map(authorizer => addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authorizer)))];\n};\nconst prepareEnvelope = tx => {\n  validateEnvelope(tx);\n  return [preparePayload(tx), preparePayloadSignatures(tx)];\n};\nconst preparePayloadSignatures = tx => {\n  const signers = collectSigners(tx);\n  return tx.payloadSigs.map(sig => {\n    return {\n      signerIndex: signers.get(sig.address),\n      keyId: sig.keyId,\n      sig: sig.sig\n    };\n  }).sort((a, b) => {\n    if (a.signerIndex > b.signerIndex) return 1;\n    if (a.signerIndex < b.signerIndex) return -1;\n    if (a.keyId > b.keyId) return 1;\n    if (a.keyId < b.keyId) return -1;\n  }).map(sig => {\n    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];\n  });\n};\nconst collectSigners = tx => {\n  const signers = new Map();\n  let i = 0;\n  const addSigner = addr => {\n    if (!signers.has(addr)) {\n      signers.set(addr, i);\n      i++;\n    }\n  };\n  addSigner(tx.proposalKey.address);\n  addSigner(tx.payer);\n  tx.authorizers.forEach(addSigner);\n  return signers;\n};\nconst prepareVoucher = voucher => {\n  validateVoucher(voucher);\n  const signers = collectSigners(voucher);\n  const prepareSigs = sigs => {\n    return sigs.map(_ref => {\n      let {\n        address,\n        keyId,\n        sig\n      } = _ref;\n      return {\n        signerIndex: signers.get(address),\n        keyId,\n        sig\n      };\n    }).sort((a, b) => {\n      if (a.signerIndex > b.signerIndex) return 1;\n      if (a.signerIndex < b.signerIndex) return -1;\n      if (a.keyId > b.keyId) return 1;\n      if (a.keyId < b.keyId) return -1;\n    }).map(sig => {\n      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];\n    });\n  };\n  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];\n};\nconst validatePayload = tx => {\n  payloadFields.forEach(field => checkField(tx, field));\n  proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, \"proposalKey\"));\n};\nconst validateEnvelope = tx => {\n  payloadSigsFields.forEach(field => checkField(tx, field));\n  tx.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field => checkField(sig, field, \"payloadSigs\", index));\n  });\n};\nconst validateVoucher = voucher => {\n  payloadFields.forEach(field => checkField(voucher, field));\n  proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, \"proposalKey\"));\n  payloadSigsFields.forEach(field => checkField(voucher, field));\n  voucher.payloadSigs.forEach((sig, index) => {\n    payloadSigFields.forEach(field => checkField(sig, field, \"payloadSigs\", index));\n  });\n  envelopeSigsFields.forEach(field => checkField(voucher, field));\n  voucher.envelopeSigs.forEach((sig, index) => {\n    envelopeSigFields.forEach(field => checkField(sig, field, \"envelopeSigs\", index));\n  });\n};\nconst isNumber = v => typeof v === \"number\";\nconst isString = v => typeof v === \"string\";\nconst isObject = v => v !== null && typeof v === \"object\";\nconst isArray = v => isObject(v) && v instanceof Array;\nconst payloadFields = [{\n  name: \"cadence\",\n  check: isString\n}, {\n  name: \"arguments\",\n  check: isArray\n}, {\n  name: \"refBlock\",\n  check: isString,\n  defaultVal: \"0\"\n}, {\n  name: \"computeLimit\",\n  check: isNumber\n}, {\n  name: \"proposalKey\",\n  check: isObject\n}, {\n  name: \"payer\",\n  check: isString\n}, {\n  name: \"authorizers\",\n  check: isArray\n}];\nconst proposalKeyFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sequenceNum\",\n  check: isNumber\n}];\nconst payloadSigsFields = [{\n  name: \"payloadSigs\",\n  check: isArray\n}];\nconst payloadSigFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sig\",\n  check: isString\n}];\nconst envelopeSigsFields = [{\n  name: \"envelopeSigs\",\n  check: isArray\n}];\nconst envelopeSigFields = [{\n  name: \"address\",\n  check: isString\n}, {\n  name: \"keyId\",\n  check: isNumber\n}, {\n  name: \"sig\",\n  check: isString\n}];\nconst checkField = (obj, field, base, index) => {\n  const {\n    name,\n    check,\n    defaultVal\n  } = field;\n  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;\n  if (obj[name] == null) throw missingFieldError(name, base, index);\n  if (!check(obj[name])) throw invalidFieldError(name, base, index);\n};\nconst printFieldName = (field, base, index) => {\n  if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;\n  return field;\n};\nconst missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);\nconst invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);\n\nfunction findInsideSigners(ix) {\n  // Inside Signers Are: (authorizers + proposer) - payer\n  let inside = new Set(ix.authorizations);\n  inside.add(ix.proposer);\n  if (Array.isArray(ix.payer)) {\n    ix.payer.forEach(p => inside.delete(p));\n  } else {\n    inside.delete(ix.payer);\n  }\n  return Array.from(inside);\n}\nfunction findOutsideSigners(ix) {\n  // Outside Signers Are: (payer)\n  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);\n  return Array.from(outside);\n}\nconst createSignableVoucher = ix => {\n  const buildAuthorizers = () => {\n    const authorizations = ix.authorizations.map(cid => (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[cid].addr)).reduce((prev, current) => {\n      return prev.find(item => item === current) ? prev : [...prev, current];\n    }, []);\n    return authorizations[0] ? authorizations : [];\n  };\n  const buildInsideSigners = () => findInsideSigners(ix).map(id => ({\n    address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[id].addr),\n    keyId: ix.accounts[id].keyId,\n    sig: ix.accounts[id].signature\n  }));\n  const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({\n    address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[id].addr),\n    keyId: ix.accounts[id].keyId,\n    sig: ix.accounts[id].signature\n  }));\n  return {\n    cadence: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    computeLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),\n    proposalKey: {\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum\n    },\n    payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),\n    authorizers: buildAuthorizers(),\n    payloadSigs: buildInsideSigners(),\n    envelopeSigs: buildOutsideSigners()\n  };\n};\nconst voucherToTxId = voucher => {\n  return encodeTxIdFromVoucher(voucher);\n};\n\nconst idof$1 = acct => `${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(acct.addr)}-${acct.keyId}`;\nconst isFn = v => typeof v === \"function\";\nfunction buildPreSignable(acct, ix) {\n  try {\n    return {\n      f_type: \"PreSignable\",\n      f_vsn: \"1.0.1\",\n      roles: acct.role,\n      cadence: ix.message.cadence,\n      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),\n      data: {},\n      interaction: ix,\n      voucher: createSignableVoucher(ix)\n    };\n  } catch (error) {\n    console.error(\"buildPreSignable\", error);\n    throw error;\n  }\n}\nasync function collectAccounts(ix, accounts, last) {\n  let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(depth, \"Account Resolve Recursion Limit Exceeded\", {\n    ix,\n    accounts\n  });\n  let authorizations = [];\n  for (let ax of accounts) {\n    let resolve = ax.resolve;\n    ax.resolve = null;\n    var old = last || ax;\n    if (isFn(resolve)) ax = await resolve(ax, buildPreSignable(ax, ix));\n    if (Array.isArray(ax)) {\n      await collectAccounts(ix, ax, old, depth - 1);\n    } else {\n      if (ax.addr) {\n        ax.addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ax.addr);\n      }\n      if (ax.addr != null && ax.keyId != null) {\n        ax.tempId = idof$1(ax);\n      }\n      ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;\n      ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;\n      ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;\n      ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;\n      if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {\n        ix.proposer = ax.tempId;\n      }\n      if (ix.accounts[ax.tempId].role.payer) {\n        if (Array.isArray(ix.payer)) {\n          ix.payer = Array.from(new Set([...ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));\n        } else {\n          ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));\n        }\n        if (ix.payer.length > 1) {\n          // remove payer dups based on addr and keyId\n          const dupList = [];\n          const payerAccts = [];\n          ix.payer = ix.payer.reduce((g, tempId) => {\n            const {\n              addr\n            } = ix.accounts[tempId];\n            const key = idof$1(ix.accounts[tempId]);\n            payerAccts.push(addr);\n            if (dupList.includes(key)) return g;\n            dupList.push(key);\n            return [...g, tempId];\n          }, []);\n          const multiAccts = Array.from(new Set(payerAccts));\n          if (multiAccts.length > 1) {\n            throw new Error(\"Payer can not be different accounts\");\n          }\n        }\n      }\n      if (ix.accounts[ax.tempId].role.authorizer) {\n        if (last) {\n          // do group replacement\n          authorizations = Array.from(new Set([...authorizations, ax.tempId]));\n        } else {\n          // do 1-1 replacement\n          ix.authorizations = ix.authorizations.map(d => d === old.tempId ? ax.tempId : d);\n        }\n      }\n    }\n    if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];\n  }\n  if (last) {\n    // complete (flatmap) group replacement\n    ix.authorizations = ix.authorizations.map(d => d === last.tempId ? authorizations : d).reduce((prev, curr) => Array.isArray(curr) ? [...prev, ...curr] : [...prev, curr], []);\n  }\n}\nasync function resolveAccounts(ix) {\n  if (isTransaction(ix)) {\n    if (!Array.isArray(ix.payer)) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n        pkg: \"FCL\",\n        subject: '\"ix.payer\" must be an array. Support for ix.payer as a singular',\n        message: \"See changelog for more info.\"\n      });\n    }\n    try {\n      await collectAccounts(ix, Object.values(ix.accounts));\n      await collectAccounts(ix, Object.values(ix.accounts));\n    } catch (error) {\n      console.error(\"=== SAD PANDA ===\\n\\n\", error, \"\\n\\n=== SAD PANDA ===\");\n      throw error;\n    }\n  }\n  return ix;\n}\n\nasync function resolveSignatures(ix) {\n  if (isTransaction(ix)) {\n    try {\n      let insideSigners = findInsideSigners(ix);\n      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));\n      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));\n      let outsideSigners = findOutsideSigners(ix);\n      const outsidePayload = encodeTransactionEnvelope({\n        ...prepForEncoding(ix),\n        payloadSigs: insideSigners.map(id => ({\n          address: ix.accounts[id].addr,\n          keyId: ix.accounts[id].keyId,\n          sig: ix.accounts[id].signature\n        }))\n      });\n      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));\n    } catch (error) {\n      console.error(\"Signatures\", error, {\n        ix\n      });\n      throw error;\n    }\n  }\n  return ix;\n}\nfunction fetchSignature(ix, payload) {\n  return async function innerFetchSignature(id) {\n    const acct = ix.accounts[id];\n    if (acct.signature != null) return;\n    const {\n      signature\n    } = await acct.signingFunction(buildSignable(acct, payload, ix));\n    ix.accounts[id].signature = signature;\n  };\n}\nfunction buildSignable(acct, message, ix) {\n  try {\n    return {\n      f_type: \"Signable\",\n      f_vsn: \"1.0.1\",\n      message,\n      addr: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(acct.addr),\n      keyId: acct.keyId,\n      roles: acct.role,\n      cadence: ix.message.cadence,\n      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),\n      data: {},\n      interaction: ix,\n      voucher: createSignableVoucher(ix)\n    };\n  } catch (error) {\n    console.error(\"buildSignable\", error);\n    throw error;\n  }\n}\nfunction prepForEncoding(ix) {\n  const payerAddress = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);\n  return {\n    cadence: ix.message.cadence,\n    refBlock: ix.message.refBlock || null,\n    computeLimit: ix.message.computeLimit,\n    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),\n    proposalKey: {\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[ix.proposer].addr),\n      keyId: ix.accounts[ix.proposer].keyId,\n      sequenceNum: ix.accounts[ix.proposer].sequenceNum\n    },\n    payer: payerAddress,\n    authorizers: ix.authorizations.map(cid => (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[cid].addr)).reduce((prev, current) => {\n      return prev.find(item => item === current) ? prev : [...prev, current];\n    }, [])\n  };\n}\n\nasync function resolveValidators(ix) {\n  const validators = get(ix, \"ix.validators\", []);\n  return pipe(ix, validators.map(cb => ix => cb(ix, {\n    Ok,\n    Bad\n  })));\n}\n\nasync function resolveFinalNormalization(ix) {\n  for (let key of Object.keys(ix.accounts)) {\n    ix.accounts[key].addr = (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ix.accounts[key].addr);\n  }\n  return ix;\n}\n\nasync function resolveVoucherIntercept(ix) {\n  const fn = get(ix, \"ix.voucher-intercept\");\n  if (isFn$3(fn)) {\n    await fn(createSignableVoucher(ix));\n  }\n  return ix;\n}\n\nconst DEFAULT_COMPUTE_LIMIT = 100;\nasync function resolveComputeLimit(ix) {\n  if (isTransaction(ix)) {\n    ix.message.computeLimit = ix.message.computeLimit || (await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.get(\"fcl.limit\"));\n    if (!ix.message.computeLimit) {\n      _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit\"\n      });\n      ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;\n    }\n  }\n  return ix;\n}\n\nconst noop = v => v;\nconst debug = function (key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return async ix => {\n    const accts = ix => [\"\\nAccounts:\", {\n      proposer: ix.proposer,\n      authorizations: ix.authorizations,\n      payer: ix.payer\n    }, \"\\n\\nDetails:\", ix.accounts].filter(Boolean);\n    const log = function () {\n      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {\n        msg[_key] = arguments[_key];\n      }\n      console.log(`debug[${key}] ---\\n`, ...msg, \"\\n\\n\\n---\");\n    };\n    if (await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.get(`debug.${key}`)) await fn(ix, log, accts);\n    return ix;\n  };\n};\nconst resolve = pipe([resolveCadence, debug(\"cadence\", (ix, log) => log(ix.message.cadence)), resolveComputeLimit, debug(\"compute limit\", (ix, log) => log(ix.message.computeLimit)), resolveArguments, debug(\"arguments\", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug(\"accounts\", (ix, log, accts) => log(...accts(ix))), /* special */execFetchRef, /* special */execFetchSequenceNumber, resolveSignatures, debug(\"signatures\", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug(\"resolved\", (ix, log) => log(ix))]);\nasync function execFetchRef(ix) {\n  if (isTransaction(ix) && ix.message.refBlock == null) {\n    const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n    const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n    ix.message.refBlock = (await sendFn(build([getBlock()]), {\n      config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n      response,\n      Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n      ix: ixModule\n    }, {\n      node\n    }).then(decodeResponse)).id;\n  }\n  return ix;\n}\nasync function execFetchSequenceNumber(ix) {\n  if (isTransaction(ix)) {\n    var acct = Object.values(ix.accounts).find(a => a.role.proposer);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(acct, `Transactions require a proposer`);\n    if (acct.sequenceNum == null) {\n      const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n      const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n      (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n      ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {\n        config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n        response,\n        Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n        ix: ixModule\n      }, {\n        node\n      }).then(decodeResponse).then(acct => acct.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);\n    }\n  }\n  return ix;\n}\n\nfunction invariant() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length > 1) {\n    const [predicate, message] = args;\n    return invariant((ix, _ref) => {\n      let {\n        Ok,\n        Bad\n      } = _ref;\n      return predicate ? Ok(ix) : Bad(ix, message);\n    });\n  }\n  const [fn] = args;\n  return ix => fn(ix, {\n    Ok,\n    Bad\n  });\n}\n\n/**\n * @description - Sends arbitrary scripts, transactions, and requests to Flow\n * @param {Array.<Function>} args - An array of functions that take interaction and return interaction\n * @param {object} opts - Optional parameters\n * @returns {Promise<*>} - A promise that resolves to a response\n */\nconst send = async function () {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], opts.send || _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n  invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n  const resolveFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.resolve\"], opts.resolve || resolve);\n  opts.node = opts.node || (await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\"));\n  if (Array.isArray(args)) args = pipe(interaction(), args);\n  return sendFn(await resolveFn(args), {\n    config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n    response,\n    ix: ixModule,\n    Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer\n  }, opts);\n};\n\nasync function decode(response) {\n  const decodersFromConfig = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().where(/^decoder\\./);\n  const decoders = Object.entries(decodersFromConfig).map(_ref => {\n    let [pattern, xform] = _ref;\n    pattern = `/${pattern.replace(/^decoder\\./, \"\")}$/`;\n    return [pattern, xform];\n  });\n  return decodeResponse(response, Object.fromEntries(decoders));\n}\n\nconst findPayloadSigners = voucher => {\n  // Payload Signers Are: (authorizers + proposer) - payer\n  let payload = new Set(voucher.authorizers);\n  payload.add(voucher.proposalKey.address);\n  payload.delete(voucher.payer);\n  return Array.from(payload).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix);\n};\nconst findEnvelopeSigners = voucher => {\n  // Envelope Signers Are: (payer)\n  let envelope = new Set([voucher.payer]);\n  return Array.from(envelope).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix);\n};\nclass UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {\n  constructor(signerAddress) {\n    const msg = `\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. \n        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.\n      `.trim();\n    super(msg);\n    this.name = \"Unable To Determine Message Encoding For Signer Addresss\";\n  }\n}\nconst encodeMessageFromSignable = (signable, signerAddress) => {\n  let payloadSigners = findPayloadSigners(signable.voucher);\n  let envelopeSigners = findEnvelopeSigners(signable.voucher);\n  const isPayloadSigner = payloadSigners.includes((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(signerAddress));\n  const isEnvelopeSigner = envelopeSigners.includes((0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(signerAddress));\n  if (!isPayloadSigner && !isEnvelopeSigner) {\n    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);\n  }\n  const message = {\n    cadence: signable.voucher.cadence,\n    refBlock: signable.voucher.refBlock,\n    computeLimit: signable.voucher.computeLimit,\n    arguments: signable.voucher.arguments,\n    proposalKey: {\n      ...signable.voucher.proposalKey,\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(signable.voucher.proposalKey.address)\n    },\n    payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(signable.voucher.payer),\n    authorizers: signable.voucher.authorizers.map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix),\n    payloadSigs: signable.voucher.payloadSigs.map(ps => ({\n      ...ps,\n      address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.sansPrefix)(ps.address)\n    }))\n  };\n  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);\n};\n\nfunction validator(cb) {\n  return update(\"ix.validators\", validators => Array.isArray(validators) ? validators.push(cb) : [cb]);\n}\n\n/**\n * @description - A builder function that returns a partial interaction to a block at a specific height\n * @param {number} height - The height of the block to get\n * @returns {Function} - A partial interaction object\n */\nfunction atBlockHeight(height) {\n  return pipe([ix => {\n    ix.block.height = height;\n    return ix;\n  }, validator(ix => {\n    if (typeof ix.block.isSealed === \"boolean\") throw new Error(\"Unable to specify both block height and isSealed.\");\n    if (ix.block.id) throw new Error(\"Unable to specify both block height and block id.\");\n    return ix;\n  })]);\n}\n\nfunction atBlockId(id) {\n  return pipe([ix => {\n    ix.block.id = id;\n    return Ok(ix);\n  }, validator((ix, _ref) => {\n    let {\n      Ok,\n      Bad\n    } = _ref;\n    if (isGetAccount(ix)) return Bad(ix, \"Unable to specify a block id with a Get Account interaction.\");\n    if (typeof ix.block.isSealed === \"boolean\") return Bad(ix, \"Unable to specify both block id and isSealed.\");\n    if (ix.block.height) return Bad(ix, \"Unable to specify both block id and block height.\");\n    return Ok(ix);\n  })]);\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Account} Account\n */\n\n/**\n * @description  Returns the details of an account from their public address\n * @param {string} address - Address of the account\n * @param {object} [queryOptions] - Query parameters\n * @param {number} [queryOptions.height] - Block height to query\n * @param {string} [queryOptions.id] - Block ID to query\n * @param {object} [opts] - Optional parameters\n * @returns {Promise<Account>} - A promise that resolves to an account response\n */\nfunction account(address) {\n  let {\n    height,\n    id\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 ? arguments[2] : undefined;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(id && height), `Method: account -- Cannot pass \"id\" and \"height\" simultaneously`);\n\n  // Get account by ID\n  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse);\n\n  // Get account by height\n  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);\n  return send([getAccount(address)], opts).then(decodeResponse);\n}\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Block} Block\n */\n\n/**\n * @description Returns the latest block (optionally sealed or not), by id, or by height\n * @param {object} [queryOptions] - Query parameters\n * @param {boolean} [queryOptions.sealed=false] - Whether to query for a sealed block\n * @param {number} [queryOptions.height] - Block height to query\n * @param {string} [queryOptions.id] - Block ID to query\n * @param {object} [opts] - Optional parameters\n * @returns {Promise<Block>} - A promise that resolves to a block response\n */\nfunction block() {\n  let {\n    sealed = false,\n    id,\n    height\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(sealed && id || sealed && height), `Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(!(id && height), `Method: block -- Cannot pass \"id\" and \"height\" simultaneously`);\n\n  // Get block by ID\n  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse);\n\n  // Get block by height\n  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);\n\n  // Get latest block\n  return send([getBlock(sealed)], opts).then(decodeResponse);\n}\n\nfunction authorizations() {\n  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(ax.map(authz => {\n    return prepAccount(authz, {\n      role: AUTHORIZER\n    });\n  }));\n}\nfunction authorization(addr, signingFunction, keyId, sequenceNum) {\n  return {\n    addr,\n    signingFunction,\n    keyId,\n    sequenceNum\n  };\n}\n\nfunction getEvents(eventType, start, end) {\n  if (typeof start !== \"undefined\" || typeof end !== \"undefined\") {\n    _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n      pkg: \"FCL/SDK\",\n      subject: \"Passing a start and end into getEvents\",\n      transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\"\n    });\n  }\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventType;\n    ix.events.start = start;\n    ix.events.end = end;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all instances of a particular event (by name) within a height range\n * NOTE:\n * - The block range provided must be from the current spork.\n * - The block range provided must be 250 blocks or lower per request.\n * @param {string} eventName - The name of the event to get\n * @param {number} fromBlockHeight - The height of the block to start looking for events (inclusive)\n * @param {number} toBlockHeight - The height of the block to stop looking for events (inclusive)\n * @returns {Function} - An interaction object\n */\nfunction getEventsAtBlockHeightRange(eventName, fromBlockHeight, toBlockHeight) {\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventName;\n    ix.events.start = fromBlockHeight;\n    ix.events.end = toBlockHeight;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids\n * NOTE:\n * - The block range provided must be from the current spork.\n * @param {string} eventName - The name of the event to get\n * @param {number[]} blockIds - The ids of the blocks to look for events\n * @returns {Function} - An interaction object\n */\nfunction getEventsAtBlockIds(eventName) {\n  let blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return pipe([makeGetEvents, ix => {\n    ix.events.eventType = eventName;\n    ix.events.blockIds = blockIds;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns the interaction to get a block header\n * @param {boolean} [isSealed] - Whether or not the block should be sealed\n * @returns {Function} - An interaction object\n */\nfunction getBlockHeader() {\n  let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetBlockHeader, ix => {\n    ix.block.isSealed = isSealed;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns all a collection containing a list of transaction ids by its collection id\n * NOTE:\n * - The block range provided must be from the current spork. All events emitted during past sporks is current unavailable.\n * @param {string} [id] - The id of the collection to get\n * @returns {Function} - An interaction object\n */\nfunction getCollection() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return pipe([makeGetCollection, ix => {\n    ix.collection.id = id;\n    return ix;\n  }]);\n}\n\n/**\n * @description - A builder function that returns the status of transaction\n * NOTE: The transactionID provided must be from the current spork.\n * @param {string} transactionId - The id of the transaction to get status\n * @returns {Function} - An interaction object\n */\nfunction getTransactionStatus(transactionId) {\n  return pipe([makeGetTransactionStatus, ix => {\n    ix.transaction.id = transactionId;\n    return Ok(ix);\n  }]);\n}\n\n/**\n * @description - A builder function that returns a transaction\n * NOTE: The transactionID provided must be from the current spork.\n * @param {string} transactionId - The id of the transaction to get\n * @returns {Function} - An interaction object\n */\nfunction getTransaction(transactionId) {\n  return pipe([makeGetTransaction, ix => {\n    ix.transaction.id = transactionId;\n    return Ok(ix);\n  }]);\n}\n\nfunction getNetworkParameters() {\n  return pipe([makeGetNetworkParameters, ix => {\n    return Ok(ix);\n  }]);\n}\n\nfunction limit(computeLimit) {\n  return ix => {\n    ix.message.computeLimit = computeLimit;\n    return ix;\n  };\n}\n\n/**\n * @description - A utility builder to be used with other builders to pass in arguments with a value and supported type\n * @param {Array.<*>} ax - An array of arguments\n * @returns {Function} - An interaction object\n */\nfunction args() {\n  let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return pipe(ax.map(makeArgument));\n}\n\n/**\n * @description - A utility builder to be used with fcl.args[...] to create FCL supported arguments for interactions\n * @param {any} value - The value of the argument\n * @param {Function} xform - A function to transform the value\n * @returns {object} - An argument object\n */\nfunction arg(value, xform) {\n  return {\n    value,\n    xform\n  };\n}\n\nasync function proposer(authz) {\n  return prepAccount(authz, {\n    role: PROPOSER\n  });\n}\n\nasync function payer(authz) {\n  return prepAccount(authz, {\n    role: PAYER\n  });\n}\n\nfunction ping() {\n  return makePing;\n}\n\nfunction ref(refBlock) {\n  return pipe([ix => {\n    ix.message.refBlock = refBlock;\n    return Ok(ix);\n  }]);\n}\n\nfunction script() {\n  return pipe([makeScript, put(\"ix.cadence\", (0,_onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template)(...arguments))]);\n}\n\nconst DEFAULT_SCRIPT_ACCOUNTS = [];\nconst DEFUALT_REF = null;\n\n/**\n * @description - A template builder to use a Cadence transaction for an interaction\n * @param {...*} args - The arguments to pass\n * @returns {Function} - An interaction object\n */\nfunction transaction() {\n  return pipe([makeTransaction, put(\"ix.cadence\", (0,_onflow_util_template__WEBPACK_IMPORTED_MODULE_7__.template)(...arguments)), ix => {\n    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;\n    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;\n    return Ok(ix);\n  }]);\n}\n\nfunction voucherIntercept(fn) {\n  return put(\"ix.voucher-intercept\", fn);\n}\n\nconst resolveProposerSequenceNumber = _ref => {\n  let {\n    node\n  } = _ref;\n  return async ix => {\n    if (!isTransaction(ix)) return Ok(ix);\n    if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);\n    const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n    (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n    const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {\n      config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n      response: response,\n      Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n      ix: ixModule\n    }, {\n      node\n    });\n    const decoded = await decodeResponse(response$1);\n    ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;\n    return Ok(ix);\n  };\n};\n\nasync function getRefId(opts) {\n  const node = await (0,_onflow_config__WEBPACK_IMPORTED_MODULE_2__.config)().get(\"accessNode.api\");\n  const sendFn = await _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config.first([\"sdk.transport\", \"sdk.send\"], _onflow_transport_http__WEBPACK_IMPORTED_MODULE_4__.send);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(sendFn, `Required value for sdk.transport is not defined in config. See: ${\"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21\"}`);\n  var ix;\n  ix = await pipe(interaction(), [getBlock()]);\n  ix = await sendFn(ix, {\n    config: _onflow_config__WEBPACK_IMPORTED_MODULE_2__.config,\n    response,\n    Buffer: _onflow_rlp__WEBPACK_IMPORTED_MODULE_3__.Buffer,\n    ix: ixModule\n  }, {\n    node\n  });\n  ix = await decodeResponse(ix);\n  return ix.id;\n}\nfunction resolveRefBlockId(opts) {\n  return async ix => {\n    if (!isTransaction(ix)) return Ok(ix);\n    if (ix.message.refBlock) return Ok(ix);\n    ix.message.refBlock = await getRefId();\n    return Ok(ix);\n  };\n}\n\nfunction mockAccountResponse(ix) {\n  let numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(ix.account, \"mockAccountResponse(ix) -- ix.account is missing\", ix);\n  // prettier-ignore\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_1__.invariant)(ix.account.addr, \"mockAccountResponse(ix) -- ix.account.addr is missing\", ix);\n  const address = ix.account.addr;\n  return {\n    account: {\n      addr: address,\n      keys: Array.from({\n        length: numberOfKeys\n      }, (_, i) => ({\n        index: i,\n        sequenceNumber: 42\n      }))\n    }\n  };\n}\nfunction mockGetBlockResponse(ix) {\n  return {\n    tag: \"GET_BLOCK\",\n    block: {\n      id: \"32\"\n    }\n  };\n}\nconst identity = v => v;\nfunction mockSend() {\n  let fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n  return async function execSend(ix) {\n    ix = await ix;\n    switch (true) {\n      case isGetAccount(ix):\n        return mockAccountResponse(ix);\n      case isGetBlock(ix):\n        return mockGetBlockResponse();\n      default:\n        return fallback(ix);\n    }\n  };\n}\n\nconst idof = acct => `${(0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_5__.withPrefix)(acct.addr)}-${acct.keyId}`;\nfunction sig(opts) {\n  return [\"SIGNATURE\", opts.addr, opts.keyId].join(\".\");\n}\nfunction authzFn() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const acct = {\n      ...account,\n      ...opts,\n      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction\n    };\n    return acct;\n    function fallbackSigningFunction(signable) {\n      return {\n        addr: acct.addr,\n        keyId: acct.keyId,\n        signature: sig(acct)\n      };\n    }\n  };\n}\nfunction authzResolve() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const {\n      tempId,\n      ...rest\n    } = opts;\n    return {\n      ...account,\n      tempId: tempId || \"WITH_RESOLVE\",\n      resolve: authzFn(rest)\n    };\n  };\n}\nconst ROLE = {\n  proposer: false,\n  authorizer: false,\n  payer: false\n};\nfunction authzResolveMany() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (account) {\n    const tempId = opts.tempId || \"AUTHZ_RESOLVE_MANY\";\n    return {\n      ...account,\n      tempId,\n      resolve: () => [opts.proposer && authzFn(opts.proposer)({\n        role: {\n          ...ROLE,\n          proposer: true\n        }\n      }), ...opts.authorizations.map(authzFn).map(d => d({\n        role: {\n          ...ROLE,\n          authorizer: true\n        }\n      })), opts.payer && authzFn(opts.payer)({\n        role: {\n          ...ROLE,\n          payer: true\n        }\n      })].filter(Boolean)\n    };\n  };\n}\n\nconst run = function () {\n  let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return build([ref(\"123\"), ...fns]).then(resolve);\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mockSend: mockSend,\n  authzFn: authzFn,\n  authzResolve: authzResolve,\n  authzResolveMany: authzResolveMany,\n  sig: sig,\n  idof: idof,\n  run: run\n});\n\nconst VERSION = \"1.2.2\" ;\n\n// Deprecated\nconst params = params => _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n  pkg: \"FCL/SDK\",\n  message: `The params builder has been removed from the Flow JS-SDK/FCL.`,\n  transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n  level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.error\n});\nconst param = params => _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.log.deprecate({\n  pkg: \"FCL/SDK\",\n  message: `The param builder has been removed from the Flow JS-SDK/FCL.`,\n  transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n  level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_0__.LEVELS.error\n});\n\n\n//# sourceMappingURL=sdk.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvc2RrL2Rpc3Qvc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDSjtBQUN3QjtBQUMxQjtBQUNBO0FBQ0s7QUFDVztBQUNNO0FBQ2xDO0FBQ3FCO0FBQzRCOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGNBQWM7QUFDZCxjQUFjLEdBQUc7QUFDakI7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixDQUFDOztBQUVtZ0M7QUFDcGdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy9zZGsvZGlzdC9zZGsubW9kdWxlLmpzP2QyNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ0BvbmZsb3cvdXRpbC1sb2dnZXInO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnQG9uZmxvdy91dGlsLWxvZ2dlcic7XG5pbXBvcnQgeyBpbnZhcmlhbnQgYXMgaW52YXJpYW50JDEgfSBmcm9tICdAb25mbG93L3V0aWwtaW52YXJpYW50JztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BvbmZsb3cvY29uZmlnJztcbmV4cG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BvbmZsb3cvY29uZmlnJztcbmltcG9ydCB7IEJ1ZmZlciwgZW5jb2RlIH0gZnJvbSAnQG9uZmxvdy9ybHAnO1xuaW1wb3J0IHsgc2VuZCBhcyBzZW5kJDEgfSBmcm9tICdAb25mbG93L3RyYW5zcG9ydC1odHRwJztcbmltcG9ydCB7IHNhbnNQcmVmaXgsIHdpdGhQcmVmaXggfSBmcm9tICdAb25mbG93L3V0aWwtYWRkcmVzcyc7XG5pbXBvcnQgeyBTSEEzIH0gZnJvbSAnc2hhMyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZSB9IGZyb20gJ0BvbmZsb3cvdXRpbC10ZW1wbGF0ZSc7XG5leHBvcnQgeyB0ZW1wbGF0ZSBhcyBjYWRlbmNlLCB0ZW1wbGF0ZSBhcyBjZGMgfSBmcm9tICdAb25mbG93L3V0aWwtdGVtcGxhdGUnO1xuXG5jb25zdCBVTktOT1dOIC8qICAgICAgICAgICAgICAgICAgICAgICAqLyA9IFwiVU5LTk9XTlwiO1xuY29uc3QgU0NSSVBUIC8qICAgICAgICAgICAgICAgICAgICAgICAgKi8gPSBcIlNDUklQVFwiO1xuY29uc3QgVFJBTlNBQ1RJT04gLyogICAgICAgICAgICAgICAgICAgKi8gPSBcIlRSQU5TQUNUSU9OXCI7XG5jb25zdCBHRVRfVFJBTlNBQ1RJT05fU1RBVFVTIC8qICAgICAgICAqLyA9IFwiR0VUX1RSQU5TQUNUSU9OX1NUQVRVU1wiO1xuY29uc3QgR0VUX0FDQ09VTlQgLyogICAgICAgICAgICAgICAgICAgKi8gPSBcIkdFVF9BQ0NPVU5UXCI7XG5jb25zdCBHRVRfRVZFTlRTIC8qICAgICAgICAgICAgICAgICAgICAqLyA9IFwiR0VUX0VWRU5UU1wiO1xuY29uc3QgUElORyAvKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi8gPSBcIlBJTkdcIjtcbmNvbnN0IEdFVF9UUkFOU0FDVElPTiAvKiAgICAgICAgICAgICAgICovID0gXCJHRVRfVFJBTlNBQ1RJT05cIjtcbmNvbnN0IEdFVF9CTE9DSyAvKiAgICAgICAgICAgICAgICAgICAgICovID0gXCJHRVRfQkxPQ0tcIjtcbmNvbnN0IEdFVF9CTE9DS19IRUFERVIgLyogICAgICAgICAgICAgICovID0gXCJHRVRfQkxPQ0tfSEVBREVSXCI7XG5jb25zdCBHRVRfQ09MTEVDVElPTiAvKiAgICAgICAgICAgICAgICAqLyA9IFwiR0VUX0NPTExFQ1RJT05cIjtcbmNvbnN0IEdFVF9ORVRXT1JLX1BBUkFNRVRFUlMgLyogICAgICAgICovID0gXCJHRVRfTkVUV09SS19QQVJBTUVURVJTXCI7XG5jb25zdCBCQUQgLyogKi8gPSBcIkJBRFwiO1xuY29uc3QgT0sgLyogICovID0gXCJPS1wiO1xuY29uc3QgQUNDT1VOVCAvKiAgKi8gPSBcIkFDQ09VTlRcIjtcbmNvbnN0IFBBUkFNIC8qICAgICovID0gXCJQQVJBTVwiO1xuY29uc3QgQVJHVU1FTlQgLyogKi8gPSBcIkFSR1VNRU5UXCI7XG5jb25zdCBBVVRIT1JJWkVSIC8qICovID0gXCJhdXRob3JpemVyXCI7XG5jb25zdCBQQVlFUiAvKiAgICAgICovID0gXCJwYXllclwiO1xuY29uc3QgUFJPUE9TRVIgLyogICAqLyA9IFwicHJvcG9zZXJcIjtcbmNvbnN0IEFDQ1QgPSBge1xuICBcImtpbmRcIjpcIiR7QUNDT1VOVH1cIixcbiAgXCJ0ZW1wSWRcIjpudWxsLFxuICBcImFkZHJcIjpudWxsLFxuICBcImtleUlkXCI6bnVsbCxcbiAgXCJzZXF1ZW5jZU51bVwiOm51bGwsXG4gIFwic2lnbmF0dXJlXCI6bnVsbCxcbiAgXCJzaWduaW5nRnVuY3Rpb25cIjpudWxsLFxuICBcInJlc29sdmVcIjpudWxsLFxuICBcInJvbGVcIjoge1xuICAgIFwicHJvcG9zZXJcIjpmYWxzZSxcbiAgICBcImF1dGhvcml6ZXJcIjpmYWxzZSxcbiAgICBcInBheWVyXCI6ZmFsc2UsXG4gICAgXCJwYXJhbVwiOmZhbHNlXG4gIH1cbn1gO1xuY29uc3QgQVJHID0gYHtcbiAgXCJraW5kXCI6XCIke0FSR1VNRU5UfVwiLFxuICBcInRlbXBJZFwiOm51bGwsXG4gIFwidmFsdWVcIjpudWxsLFxuICBcImFzQXJndW1lbnRcIjpudWxsLFxuICBcInhmb3JtXCI6bnVsbCxcbiAgXCJyZXNvbHZlXCI6IG51bGwsXG4gIFwicmVzb2x2ZUFyZ3VtZW50XCI6IG51bGxcbn1gO1xuY29uc3QgSVggPSBge1xuICBcInRhZ1wiOlwiJHtVTktOT1dOfVwiLFxuICBcImFzc2lnbnNcIjp7fSxcbiAgXCJzdGF0dXNcIjpcIiR7T0t9XCIsXG4gIFwicmVhc29uXCI6bnVsbCxcbiAgXCJhY2NvdW50c1wiOnt9LFxuICBcInBhcmFtc1wiOnt9LFxuICBcImFyZ3VtZW50c1wiOnt9LFxuICBcIm1lc3NhZ2VcIjoge1xuICAgIFwiY2FkZW5jZVwiOm51bGwsXG4gICAgXCJyZWZCbG9ja1wiOm51bGwsXG4gICAgXCJjb21wdXRlTGltaXRcIjpudWxsLFxuICAgIFwicHJvcG9zZXJcIjpudWxsLFxuICAgIFwicGF5ZXJcIjpudWxsLFxuICAgIFwiYXV0aG9yaXphdGlvbnNcIjpbXSxcbiAgICBcInBhcmFtc1wiOltdLFxuICAgIFwiYXJndW1lbnRzXCI6W11cbiAgfSxcbiAgXCJwcm9wb3NlclwiOm51bGwsXG4gIFwiYXV0aG9yaXphdGlvbnNcIjpbXSxcbiAgXCJwYXllclwiOltdLFxuICBcImV2ZW50c1wiOiB7XG4gICAgXCJldmVudFR5cGVcIjpudWxsLFxuICAgIFwic3RhcnRcIjpudWxsLFxuICAgIFwiZW5kXCI6bnVsbCxcbiAgICBcImJsb2NrSWRzXCI6W11cbiAgfSxcbiAgXCJ0cmFuc2FjdGlvblwiOiB7XG4gICAgXCJpZFwiOm51bGxcbiAgfSxcbiAgXCJibG9ja1wiOiB7XG4gICAgXCJpZFwiOm51bGwsXG4gICAgXCJoZWlnaHRcIjpudWxsLFxuICAgIFwiaXNTZWFsZWRcIjpudWxsXG4gIH0sXG4gIFwiYWNjb3VudFwiOiB7XG4gICAgXCJhZGRyXCI6bnVsbFxuICB9LFxuICBcImNvbGxlY3Rpb25cIjoge1xuICAgIFwiaWRcIjpudWxsXG4gIH1cbn1gO1xuY29uc3QgS0VZUyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoSlNPTi5wYXJzZShJWCkpKTtcbmNvbnN0IGludGVyYWN0aW9uID0gKCkgPT4gSlNPTi5wYXJzZShJWCk7XG5jb25zdCBDSEFSUyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCIuc3BsaXQoXCJcIik7XG5jb25zdCByYW5kQ2hhciA9ICgpID0+IENIQVJTW35+KE1hdGgucmFuZG9tKCkgKiBDSEFSUy5sZW5ndGgpXTtcbmNvbnN0IHV1aWQgPSAoKSA9PiBBcnJheS5mcm9tKHtcbiAgbGVuZ3RoOiAxMFxufSwgcmFuZENoYXIpLmpvaW4oXCJcIik7XG5jb25zdCBpc051bWJlciQxID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJudW1iZXJcIjtcbmNvbnN0IGlzQXJyYXkkMSA9IGQgPT4gQXJyYXkuaXNBcnJheShkKTtcbmNvbnN0IGlzT2JqID0gZCA9PiBkICE9PSBudWxsICYmIHR5cGVvZiBkID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNOdWxsID0gZCA9PiBkID09IG51bGw7XG5jb25zdCBpc0ZuJDMgPSBkID0+IHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc0ludGVyYWN0aW9uID0gaXggPT4ge1xuICBpZiAoIWlzT2JqKGl4KSB8fCBpc051bGwoaXgpIHx8IGlzTnVtYmVyJDEoaXgpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGtleSBvZiBLRVlTKSBpZiAoIWl4Lmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgT2sgPSBpeCA9PiB7XG4gIGl4LnN0YXR1cyA9IE9LO1xuICByZXR1cm4gaXg7XG59O1xuY29uc3QgQmFkID0gKGl4LCByZWFzb24pID0+IHtcbiAgaXguc3RhdHVzID0gQkFEO1xuICBpeC5yZWFzb24gPSByZWFzb247XG4gIHJldHVybiBpeDtcbn07XG5jb25zdCBtYWtlSXggPSB3YXQgPT4gaXggPT4ge1xuICBpeC50YWcgPSB3YXQ7XG4gIHJldHVybiBPayhpeCk7XG59O1xuY29uc3QgcHJlcEFjY291bnRLZXlJZCA9IGFjY3QgPT4ge1xuICBpZiAoYWNjdC5rZXlJZCA9PSBudWxsKSByZXR1cm4gYWNjdDtcbiAgaW52YXJpYW50JDEoIWlzTmFOKHBhcnNlSW50KGFjY3Qua2V5SWQpKSwgXCJhY2NvdW50LmtleUlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hY2N0LFxuICAgIGtleUlkOiBwYXJzZUludChhY2N0LmtleUlkKVxuICB9O1xufTtcbmNvbnN0IHByZXBBY2NvdW50ID0gZnVuY3Rpb24gKGFjY3QpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gaXggPT4ge1xuICAgIGludmFyaWFudCQxKHR5cGVvZiBhY2N0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGFjY3QgPT09IFwib2JqZWN0XCIsIFwicHJlcEFjY291bnQgbXVzdCBiZSBwYXNzZWQgYW4gYXV0aG9yaXphdGlvbiBmdW5jdGlvbiBvciBhbiBhY2NvdW50IG9iamVjdFwiKTtcbiAgICBpbnZhcmlhbnQkMShvcHRzLnJvbGUgIT0gbnVsbCwgXCJBY2NvdW50IG11c3QgaGF2ZSBhIHJvbGVcIik7XG4gICAgY29uc3QgQUNDT1VOVCA9IEpTT04ucGFyc2UoQUNDVCk7XG4gICAgY29uc3Qgcm9sZSA9IG9wdHMucm9sZTtcbiAgICBjb25zdCB0ZW1wSWQgPSB1dWlkKCk7XG4gICAgaWYgKGFjY3QuYXV0aG9yaXphdGlvbiAmJiBpc0ZuJDMoYWNjdC5hdXRob3JpemF0aW9uKSkgYWNjdCA9IHtcbiAgICAgIHJlc29sdmU6IGFjY3QuYXV0aG9yaXphdGlvblxuICAgIH07XG4gICAgaWYgKCFhY2N0LmF1dGhvcml6YXRpb24gJiYgaXNGbiQzKGFjY3QpKSBhY2N0ID0ge1xuICAgICAgcmVzb2x2ZTogYWNjdFxuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZSA9IGFjY3QucmVzb2x2ZTtcbiAgICBpZiAocmVzb2x2ZSkgYWNjdC5yZXNvbHZlID0gZnVuY3Rpb24gKGFjY3QpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3Jlc29sdmUsIHByZXBBY2NvdW50S2V5SWRdLnJlZHVjZShhc3luYyAoZCwgZm4pID0+IGZuKGF3YWl0IGQsIC4uLnJlc3QpLCBhY2N0KTtcbiAgICB9O1xuICAgIGFjY3QgPSBwcmVwQWNjb3VudEtleUlkKGFjY3QpO1xuICAgIGl4LmFjY291bnRzW3RlbXBJZF0gPSB7XG4gICAgICAuLi5BQ0NPVU5ULFxuICAgICAgdGVtcElkLFxuICAgICAgLi4uYWNjdCxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgLi4uQUNDT1VOVC5yb2xlLFxuICAgICAgICAuLi4odHlwZW9mIGFjY3Qucm9sZSA9PT0gXCJvYmplY3RcIiA/IGFjY3Qucm9sZSA6IHt9KSxcbiAgICAgICAgW3JvbGVdOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocm9sZSA9PT0gQVVUSE9SSVpFUikge1xuICAgICAgaXguYXV0aG9yaXphdGlvbnMucHVzaCh0ZW1wSWQpO1xuICAgIH0gZWxzZSBpZiAocm9sZSA9PT0gUEFZRVIpIHtcbiAgICAgIGl4LnBheWVyLnB1c2godGVtcElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXhbcm9sZV0gPSB0ZW1wSWQ7XG4gICAgfVxuICAgIHJldHVybiBpeDtcbiAgfTtcbn07XG5jb25zdCBtYWtlQXJndW1lbnQgPSBhcmcgPT4gaXggPT4ge1xuICBsZXQgdGVtcElkID0gdXVpZCgpO1xuICBpeC5tZXNzYWdlLmFyZ3VtZW50cy5wdXNoKHRlbXBJZCk7XG4gIGl4LmFyZ3VtZW50c1t0ZW1wSWRdID0gSlNPTi5wYXJzZShBUkcpO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS50ZW1wSWQgPSB0ZW1wSWQ7XG4gIGl4LmFyZ3VtZW50c1t0ZW1wSWRdLnZhbHVlID0gYXJnLnZhbHVlO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS5hc0FyZ3VtZW50ID0gYXJnLmFzQXJndW1lbnQ7XG4gIGl4LmFyZ3VtZW50c1t0ZW1wSWRdLnhmb3JtID0gYXJnLnhmb3JtO1xuICBpeC5hcmd1bWVudHNbdGVtcElkXS5yZXNvbHZlID0gYXJnLnJlc29sdmU7XG4gIGl4LmFyZ3VtZW50c1t0ZW1wSWRdLnJlc29sdmVBcmd1bWVudCA9IGlzRm4kMyhhcmcucmVzb2x2ZUFyZ3VtZW50KSA/IGFyZy5yZXNvbHZlQXJndW1lbnQuYmluZChhcmcpIDogYXJnLnJlc29sdmVBcmd1bWVudDtcbiAgcmV0dXJuIE9rKGl4KTtcbn07XG5jb25zdCBtYWtlVW5rbm93biAvKiAgICAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoVU5LTk9XTik7XG5jb25zdCBtYWtlU2NyaXB0IC8qICAgICAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoU0NSSVBUKTtcbmNvbnN0IG1ha2VUcmFuc2FjdGlvbiAvKiAgICAgICAgICAgICAqLyA9IG1ha2VJeChUUkFOU0FDVElPTik7XG5jb25zdCBtYWtlR2V0VHJhbnNhY3Rpb25TdGF0dXMgLyogICAgKi8gPSBtYWtlSXgoR0VUX1RSQU5TQUNUSU9OX1NUQVRVUyk7XG5jb25zdCBtYWtlR2V0VHJhbnNhY3Rpb24gLyogICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX1RSQU5TQUNUSU9OKTtcbmNvbnN0IG1ha2VHZXRBY2NvdW50IC8qICAgICAgICAgICAgICAqLyA9IG1ha2VJeChHRVRfQUNDT1VOVCk7XG5jb25zdCBtYWtlR2V0RXZlbnRzIC8qICAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX0VWRU5UUyk7XG5jb25zdCBtYWtlUGluZyAvKiAgICAgICAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoUElORyk7XG5jb25zdCBtYWtlR2V0QmxvY2sgLyogICAgICAgICAgICAgICAgKi8gPSBtYWtlSXgoR0VUX0JMT0NLKTtcbmNvbnN0IG1ha2VHZXRCbG9ja0hlYWRlciAvKiAgICAgICAgICAqLyA9IG1ha2VJeChHRVRfQkxPQ0tfSEVBREVSKTtcbmNvbnN0IG1ha2VHZXRDb2xsZWN0aW9uIC8qICAgICAgICAgICAqLyA9IG1ha2VJeChHRVRfQ09MTEVDVElPTik7XG5jb25zdCBtYWtlR2V0TmV0d29ya1BhcmFtZXRlcnMgLyogICAgKi8gPSBtYWtlSXgoR0VUX05FVFdPUktfUEFSQU1FVEVSUyk7XG5jb25zdCBpcyA9IHdhdCA9PiBpeCA9PiBpeC50YWcgPT09IHdhdDtcbmNvbnN0IGlzVW5rbm93biAvKiAgICAgICAgICAgICAgICAgKi8gPSBpcyhVTktOT1dOKTtcbmNvbnN0IGlzU2NyaXB0IC8qICAgICAgICAgICAgICAgICAgKi8gPSBpcyhTQ1JJUFQpO1xuY29uc3QgaXNUcmFuc2FjdGlvbiAvKiAgICAgICAgICAgICAqLyA9IGlzKFRSQU5TQUNUSU9OKTtcbmNvbnN0IGlzR2V0VHJhbnNhY3Rpb25TdGF0dXMgLyogICAgKi8gPSBpcyhHRVRfVFJBTlNBQ1RJT05fU1RBVFVTKTtcbmNvbnN0IGlzR2V0VHJhbnNhY3Rpb24gLyogICAgICAgICAgKi8gPSBpcyhHRVRfVFJBTlNBQ1RJT04pO1xuY29uc3QgaXNHZXRBY2NvdW50IC8qICAgICAgICAgICAgICAqLyA9IGlzKEdFVF9BQ0NPVU5UKTtcbmNvbnN0IGlzR2V0RXZlbnRzIC8qICAgICAgICAgICAgICAgKi8gPSBpcyhHRVRfRVZFTlRTKTtcbmNvbnN0IGlzUGluZyAvKiAgICAgICAgICAgICAgICAgICAgKi8gPSBpcyhQSU5HKTtcbmNvbnN0IGlzR2V0QmxvY2sgLyogICAgICAgICAgICAgICAgKi8gPSBpcyhHRVRfQkxPQ0spO1xuY29uc3QgaXNHZXRCbG9ja0hlYWRlciAvKiAgICAgICAgICAqLyA9IGlzKEdFVF9CTE9DS19IRUFERVIpO1xuY29uc3QgaXNHZXRDb2xsZWN0aW9uIC8qICAgICAgICAgICAqLyA9IGlzKEdFVF9DT0xMRUNUSU9OKTtcbmNvbnN0IGlzR2V0TmV0d29ya1BhcmFtZXRlcnMgLyogICAgKi8gPSBpcyhHRVRfTkVUV09SS19QQVJBTUVURVJTKTtcbmNvbnN0IGlzT2sgLyogICovID0gaXggPT4gaXguc3RhdHVzID09PSBPSztcbmNvbnN0IGlzQmFkIC8qICovID0gaXggPT4gaXguc3RhdHVzID09PSBCQUQ7XG5jb25zdCB3aHkgLyogICAqLyA9IGl4ID0+IGl4LnJlYXNvbjtcbmNvbnN0IGlzQWNjb3VudCAvKiAgKi8gPSBhY2NvdW50ID0+IGFjY291bnQua2luZCA9PT0gQUNDT1VOVDtcbmNvbnN0IGlzUGFyYW0gLyogICAgKi8gPSBwYXJhbSA9PiBwYXJhbS5raW5kID09PSBQQVJBTTtcbmNvbnN0IGlzQXJndW1lbnQgLyogKi8gPSBhcmd1bWVudCA9PiBhcmd1bWVudC5raW5kID09PSBBUkdVTUVOVDtcbmNvbnN0IGhhcmRNb2RlID0gaXggPT4ge1xuICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoaXgpKSB7XG4gICAgaWYgKCFLRVlTLmhhcyhrZXkpKSB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl9XCIgaXMgYW4gaW52YWxpZCByb290IGxldmVsIEludGVyYWN0aW9uIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBpeDtcbn07XG5jb25zdCByZWNQaXBlID0gYXN5bmMgZnVuY3Rpb24gKGl4KSB7XG4gIGxldCBmbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB0cnkge1xuICAgIGl4ID0gaGFyZE1vZGUoYXdhaXQgaXgpO1xuICAgIGlmIChpc0JhZChpeCkpIHRocm93IG5ldyBFcnJvcihgSW50ZXJhY3Rpb24gRXJyb3I6ICR7aXgucmVhc29ufWApO1xuICAgIGlmICghZm5zLmxlbmd0aCkgcmV0dXJuIGl4O1xuICAgIGNvbnN0IFtoZCwgLi4ucmVzdF0gPSBmbnM7XG4gICAgY29uc3QgY3VyID0gYXdhaXQgaGQ7XG4gICAgaWYgKGlzRm4kMyhjdXIpKSByZXR1cm4gcmVjUGlwZShjdXIoaXgpLCByZXN0KTtcbiAgICBpZiAoaXNOdWxsKGN1cikgfHwgIWN1cikgcmV0dXJuIHJlY1BpcGUoaXgsIHJlc3QpO1xuICAgIGlmIChpc0ludGVyYWN0aW9uKGN1cikpIHJldHVybiByZWNQaXBlKGN1ciwgcmVzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJbnRlcmFjdGlvbiBDb21wb3NpdGlvblwiKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5jb25zdCBwaXBlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgY29uc3QgW2FyZzEsIGFyZzJdID0gYXJncztcbiAgaWYgKGlzQXJyYXkkMShhcmcxKSAmJiBhcmcyID09IG51bGwpIHJldHVybiBkID0+IHBpcGUoZCwgYXJnMSk7XG4gIHJldHVybiByZWNQaXBlKGFyZzEsIGFyZzIpO1xufTtcbmNvbnN0IGlkZW50aXR5JDEgPSB2ID0+IHY7XG5jb25zdCBnZXQgPSAoaXgsIGtleSwgZmFsbGJhY2spID0+IHtcbiAgcmV0dXJuIGl4LmFzc2lnbnNba2V5XSA9PSBudWxsID8gZmFsbGJhY2sgOiBpeC5hc3NpZ25zW2tleV07XG59O1xuY29uc3QgcHV0ID0gKGtleSwgdmFsdWUpID0+IGl4ID0+IHtcbiAgaXguYXNzaWduc1trZXldID0gdmFsdWU7XG4gIHJldHVybiBPayhpeCk7XG59O1xuY29uc3QgdXBkYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICBsZXQgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGlkZW50aXR5JDE7XG4gIHJldHVybiBpeCA9PiB7XG4gICAgaXguYXNzaWduc1trZXldID0gZm4oaXguYXNzaWduc1trZXldLCBpeCk7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfTtcbn07XG5jb25zdCBkZXN0cm95ID0ga2V5ID0+IGl4ID0+IHtcbiAgZGVsZXRlIGl4LmFzc2lnbnNba2V5XTtcbiAgcmV0dXJuIE9rKGl4KTtcbn07XG5cbnZhciBpeE1vZHVsZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBVTktOT1dOOiBVTktOT1dOLFxuICBTQ1JJUFQ6IFNDUklQVCxcbiAgVFJBTlNBQ1RJT046IFRSQU5TQUNUSU9OLFxuICBHRVRfVFJBTlNBQ1RJT05fU1RBVFVTOiBHRVRfVFJBTlNBQ1RJT05fU1RBVFVTLFxuICBHRVRfQUNDT1VOVDogR0VUX0FDQ09VTlQsXG4gIEdFVF9FVkVOVFM6IEdFVF9FVkVOVFMsXG4gIFBJTkc6IFBJTkcsXG4gIEdFVF9UUkFOU0FDVElPTjogR0VUX1RSQU5TQUNUSU9OLFxuICBHRVRfQkxPQ0s6IEdFVF9CTE9DSyxcbiAgR0VUX0JMT0NLX0hFQURFUjogR0VUX0JMT0NLX0hFQURFUixcbiAgR0VUX0NPTExFQ1RJT046IEdFVF9DT0xMRUNUSU9OLFxuICBHRVRfTkVUV09SS19QQVJBTUVURVJTOiBHRVRfTkVUV09SS19QQVJBTUVURVJTLFxuICBCQUQ6IEJBRCxcbiAgT0s6IE9LLFxuICBBQ0NPVU5UOiBBQ0NPVU5ULFxuICBQQVJBTTogUEFSQU0sXG4gIEFSR1VNRU5UOiBBUkdVTUVOVCxcbiAgQVVUSE9SSVpFUjogQVVUSE9SSVpFUixcbiAgUEFZRVI6IFBBWUVSLFxuICBQUk9QT1NFUjogUFJPUE9TRVIsXG4gIGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbixcbiAgdXVpZDogdXVpZCxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyJDEsXG4gIGlzQXJyYXk6IGlzQXJyYXkkMSxcbiAgaXNPYmo6IGlzT2JqLFxuICBpc051bGw6IGlzTnVsbCxcbiAgaXNGbjogaXNGbiQzLFxuICBpc0ludGVyYWN0aW9uOiBpc0ludGVyYWN0aW9uLFxuICBPazogT2ssXG4gIEJhZDogQmFkLFxuICBwcmVwQWNjb3VudDogcHJlcEFjY291bnQsXG4gIG1ha2VBcmd1bWVudDogbWFrZUFyZ3VtZW50LFxuICBtYWtlVW5rbm93bjogbWFrZVVua25vd24sXG4gIG1ha2VTY3JpcHQ6IG1ha2VTY3JpcHQsXG4gIG1ha2VUcmFuc2FjdGlvbjogbWFrZVRyYW5zYWN0aW9uLFxuICBtYWtlR2V0VHJhbnNhY3Rpb25TdGF0dXM6IG1ha2VHZXRUcmFuc2FjdGlvblN0YXR1cyxcbiAgbWFrZUdldFRyYW5zYWN0aW9uOiBtYWtlR2V0VHJhbnNhY3Rpb24sXG4gIG1ha2VHZXRBY2NvdW50OiBtYWtlR2V0QWNjb3VudCxcbiAgbWFrZUdldEV2ZW50czogbWFrZUdldEV2ZW50cyxcbiAgbWFrZVBpbmc6IG1ha2VQaW5nLFxuICBtYWtlR2V0QmxvY2s6IG1ha2VHZXRCbG9jayxcbiAgbWFrZUdldEJsb2NrSGVhZGVyOiBtYWtlR2V0QmxvY2tIZWFkZXIsXG4gIG1ha2VHZXRDb2xsZWN0aW9uOiBtYWtlR2V0Q29sbGVjdGlvbixcbiAgbWFrZUdldE5ldHdvcmtQYXJhbWV0ZXJzOiBtYWtlR2V0TmV0d29ya1BhcmFtZXRlcnMsXG4gIGlzVW5rbm93bjogaXNVbmtub3duLFxuICBpc1NjcmlwdDogaXNTY3JpcHQsXG4gIGlzVHJhbnNhY3Rpb246IGlzVHJhbnNhY3Rpb24sXG4gIGlzR2V0VHJhbnNhY3Rpb25TdGF0dXM6IGlzR2V0VHJhbnNhY3Rpb25TdGF0dXMsXG4gIGlzR2V0VHJhbnNhY3Rpb246IGlzR2V0VHJhbnNhY3Rpb24sXG4gIGlzR2V0QWNjb3VudDogaXNHZXRBY2NvdW50LFxuICBpc0dldEV2ZW50czogaXNHZXRFdmVudHMsXG4gIGlzUGluZzogaXNQaW5nLFxuICBpc0dldEJsb2NrOiBpc0dldEJsb2NrLFxuICBpc0dldEJsb2NrSGVhZGVyOiBpc0dldEJsb2NrSGVhZGVyLFxuICBpc0dldENvbGxlY3Rpb246IGlzR2V0Q29sbGVjdGlvbixcbiAgaXNHZXROZXR3b3JrUGFyYW1ldGVyczogaXNHZXROZXR3b3JrUGFyYW1ldGVycyxcbiAgaXNPazogaXNPayxcbiAgaXNCYWQ6IGlzQmFkLFxuICB3aHk6IHdoeSxcbiAgaXNBY2NvdW50OiBpc0FjY291bnQsXG4gIGlzUGFyYW06IGlzUGFyYW0sXG4gIGlzQXJndW1lbnQ6IGlzQXJndW1lbnQsXG4gIHBpcGU6IHBpcGUsXG4gIGdldDogZ2V0LFxuICBwdXQ6IHB1dCxcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIGRlc3Ryb3k6IGRlc3Ryb3lcbn0pO1xuXG5mdW5jdGlvbiBidWlsZCgpIHtcbiAgbGV0IGZucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHJldHVybiBwaXBlKGludGVyYWN0aW9uKCksIGZucyk7XG59XG5cbmNvbnN0IERFRkFVTFRfUkVTUE9OU0UgPSBge1xuICAgIFwidGFnXCI6bnVsbCxcbiAgICBcInRyYW5zYWN0aW9uXCI6bnVsbCxcbiAgICBcInRyYW5zYWN0aW9uU3RhdHVzXCI6bnVsbCxcbiAgICBcInRyYW5zYWN0aW9uSWRcIjpudWxsLFxuICAgIFwiZW5jb2RlZERhdGFcIjpudWxsLFxuICAgIFwiZXZlbnRzXCI6bnVsbCxcbiAgICBcImFjY291bnRcIjpudWxsLFxuICAgIFwiYmxvY2tcIjpudWxsLFxuICAgIFwiYmxvY2tIZWFkZXJcIjpudWxsLFxuICAgIFwibGF0ZXN0QmxvY2tcIjpudWxsLFxuICAgIFwiY29sbGVjdGlvblwiOm51bGwsXG4gICAgXCJuZXR3b3JrUGFyYW1ldGVyc1wiOm51bGxcbn1gO1xuY29uc3QgcmVzcG9uc2UgPSAoKSA9PiBKU09OLnBhcnNlKERFRkFVTFRfUkVTUE9OU0UpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGludGVyYWN0aW9uIHRvIGdldCB0aGUgbGF0ZXN0IGJsb2NrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NlYWxlZF0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgYmxvY2sgc2hvdWxkIGJlIHNlYWxlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRCbG9jaygpIHtcbiAgbGV0IGlzU2VhbGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICByZXR1cm4gcGlwZShbbWFrZUdldEJsb2NrLCBpeCA9PiB7XG4gICAgaXguYmxvY2suaXNTZWFsZWQgPSBpc1NlYWxlZDtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaW50ZXJhY3Rpb24gdG8gZ2V0IGFuIGFjY291bnQgYnkgYWRkcmVzc1xuICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBnZXRxXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEFjY291bnQoYWRkcikge1xuICByZXR1cm4gcGlwZShbbWFrZUdldEFjY291bnQsIGl4ID0+IHtcbiAgICBpeC5hY2NvdW50LmFkZHIgPSBzYW5zUHJlZml4KGFkZHIpO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH1dKTtcbn1cblxuY29uc3QgbGF0ZXN0QmxvY2tEZXByZWNhdGlvbk5vdGljZSA9ICgpID0+IHtcbiAgbG9nLmRlcHJlY2F0ZSh7XG4gICAgcGtnOiBcIkBvbmZsb3cvZGVjb2RlXCIsXG4gICAgc3ViamVjdDogXCJPcGVyYXRpbmcgdXBvbiBkYXRhIG9mIHRoZSBsYXRlc3RCbG9jayBmaWVsZCBvZiB0aGUgcmVzcG9uc2Ugb2JqZWN0XCIsXG4gICAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2RlY29kZS9XQVJOSU5HUy5tZCMwMDAxLURlcHJlY2F0aW5nLWxhdGVzdEJsb2NrLWZpZWxkXCJcbiAgfSk7XG59O1xuY29uc3QgZGVjb2RlSW1wbGljaXQgPSBhc3luYyBpID0+IGk7XG5jb25zdCBkZWNvZGVWb2lkID0gYXN5bmMgKCkgPT4gbnVsbDtcbmNvbnN0IGRlY29kZVR5cGUgPSBhc3luYyB0eXBlID0+IHtcbiAgcmV0dXJuIHR5cGUuc3RhdGljVHlwZTtcbn07XG5jb25zdCBkZWNvZGVQYXRoID0gYXN5bmMgcGF0aCA9PiB7XG4gIHJldHVybiB7XG4gICAgZG9tYWluOiBwYXRoLmRvbWFpbixcbiAgICBpZGVudGlmaWVyOiBwYXRoLmlkZW50aWZpZXJcbiAgfTtcbn07XG5jb25zdCBkZWNvZGVDYXBhYmlsaXR5ID0gYXN5bmMgY2FwID0+IHtcbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBjYXAucGF0aCxcbiAgICBhZGRyZXNzOiBjYXAuYWRkcmVzcyxcbiAgICBib3Jyb3dUeXBlOiBjYXAuYm9ycm93VHlwZVxuICB9O1xufTtcbmNvbnN0IGRlY29kZU9wdGlvbmFsID0gYXN5bmMgKG9wdGlvbmFsLCBkZWNvZGVycywgc3RhY2spID0+IG9wdGlvbmFsID8gYXdhaXQgcmVjdXJzZURlY29kZShvcHRpb25hbCwgZGVjb2RlcnMsIHN0YWNrKSA6IG51bGw7XG5jb25zdCBkZWNvZGVSZWZlcmVuY2UgPSBhc3luYyB2ID0+ICh7XG4gIGFkZHJlc3M6IHYuYWRkcmVzcyxcbiAgdHlwZTogdi50eXBlXG59KTtcbmNvbnN0IGRlY29kZUFycmF5ID0gYXN5bmMgKGFycmF5LCBkZWNvZGVycywgc3RhY2spID0+IGF3YWl0IFByb21pc2UuYWxsKGFycmF5Lm1hcCh2ID0+IG5ldyBQcm9taXNlKGFzeW5jIHJlcyA9PiByZXMoYXdhaXQgcmVjdXJzZURlY29kZSh2LCBkZWNvZGVycywgWy4uLnN0YWNrLCB2LnR5cGVdKSkpKSk7XG5jb25zdCBkZWNvZGVEaWN0aW9uYXJ5ID0gYXN5bmMgKGRpY3Rpb25hcnksIGRlY29kZXJzLCBzdGFjaykgPT4gYXdhaXQgZGljdGlvbmFyeS5yZWR1Y2UoYXN5bmMgKGFjYywgdikgPT4ge1xuICBhY2MgPSBhd2FpdCBhY2M7XG4gIGFjY1thd2FpdCByZWN1cnNlRGVjb2RlKHYua2V5LCBkZWNvZGVycywgWy4uLnN0YWNrLCB2LmtleV0pXSA9IGF3YWl0IHJlY3Vyc2VEZWNvZGUodi52YWx1ZSwgZGVjb2RlcnMsIFsuLi5zdGFjaywgdi5rZXldKTtcbiAgcmV0dXJuIGFjYztcbn0sIFByb21pc2UucmVzb2x2ZSh7fSkpO1xuY29uc3QgZGVjb2RlQ29tcG9zaXRlID0gYXN5bmMgKGNvbXBvc2l0ZSwgZGVjb2RlcnMsIHN0YWNrKSA9PiB7XG4gIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBjb21wb3NpdGUuZmllbGRzLnJlZHVjZShhc3luYyAoYWNjLCB2KSA9PiB7XG4gICAgYWNjID0gYXdhaXQgYWNjO1xuICAgIGFjY1t2Lm5hbWVdID0gYXdhaXQgcmVjdXJzZURlY29kZSh2LnZhbHVlLCBkZWNvZGVycywgWy4uLnN0YWNrLCB2Lm5hbWVdKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBQcm9taXNlLnJlc29sdmUoe30pKTtcbiAgY29uc3QgZGVjb2RlciA9IGNvbXBvc2l0ZS5pZCAmJiBkZWNvZGVyTG9va3VwKGRlY29kZXJzLCBjb21wb3NpdGUuaWQpO1xuICByZXR1cm4gZGVjb2RlciA/IGF3YWl0IGRlY29kZXIoZGVjb2RlZCkgOiBkZWNvZGVkO1xufTtcbmNvbnN0IGRlZmF1bHREZWNvZGVycyA9IHtcbiAgVUludDogZGVjb2RlSW1wbGljaXQsXG4gIEludDogZGVjb2RlSW1wbGljaXQsXG4gIFVJbnQ4OiBkZWNvZGVJbXBsaWNpdCxcbiAgSW50ODogZGVjb2RlSW1wbGljaXQsXG4gIFVJbnQxNjogZGVjb2RlSW1wbGljaXQsXG4gIEludDE2OiBkZWNvZGVJbXBsaWNpdCxcbiAgVUludDMyOiBkZWNvZGVJbXBsaWNpdCxcbiAgSW50MzI6IGRlY29kZUltcGxpY2l0LFxuICBVSW50NjQ6IGRlY29kZUltcGxpY2l0LFxuICBJbnQ2NDogZGVjb2RlSW1wbGljaXQsXG4gIFVJbnQxMjg6IGRlY29kZUltcGxpY2l0LFxuICBJbnQxMjg6IGRlY29kZUltcGxpY2l0LFxuICBVSW50MjU2OiBkZWNvZGVJbXBsaWNpdCxcbiAgSW50MjU2OiBkZWNvZGVJbXBsaWNpdCxcbiAgV29yZDg6IGRlY29kZUltcGxpY2l0LFxuICBXb3JkMTY6IGRlY29kZUltcGxpY2l0LFxuICBXb3JkMzI6IGRlY29kZUltcGxpY2l0LFxuICBXb3JkNjQ6IGRlY29kZUltcGxpY2l0LFxuICBVRml4NjQ6IGRlY29kZUltcGxpY2l0LFxuICBGaXg2NDogZGVjb2RlSW1wbGljaXQsXG4gIFN0cmluZzogZGVjb2RlSW1wbGljaXQsXG4gIENoYXJhY3RlcjogZGVjb2RlSW1wbGljaXQsXG4gIEJvb2w6IGRlY29kZUltcGxpY2l0LFxuICBBZGRyZXNzOiBkZWNvZGVJbXBsaWNpdCxcbiAgVm9pZDogZGVjb2RlVm9pZCxcbiAgT3B0aW9uYWw6IGRlY29kZU9wdGlvbmFsLFxuICBSZWZlcmVuY2U6IGRlY29kZVJlZmVyZW5jZSxcbiAgQXJyYXk6IGRlY29kZUFycmF5LFxuICBEaWN0aW9uYXJ5OiBkZWNvZGVEaWN0aW9uYXJ5LFxuICBFdmVudDogZGVjb2RlQ29tcG9zaXRlLFxuICBSZXNvdXJjZTogZGVjb2RlQ29tcG9zaXRlLFxuICBTdHJ1Y3Q6IGRlY29kZUNvbXBvc2l0ZSxcbiAgRW51bTogZGVjb2RlQ29tcG9zaXRlLFxuICBUeXBlOiBkZWNvZGVUeXBlLFxuICBQYXRoOiBkZWNvZGVQYXRoLFxuICBDYXBhYmlsaXR5OiBkZWNvZGVDYXBhYmlsaXR5XG59O1xuY29uc3QgZGVjb2Rlckxvb2t1cCA9IChkZWNvZGVycywgbG9va3VwKSA9PiB7XG4gIGNvbnN0IGZvdW5kID0gT2JqZWN0LmtleXMoZGVjb2RlcnMpLmZpbmQoZGVjb2RlciA9PiB7XG4gICAgaWYgKC9eXFwvLipcXC8kLy50ZXN0KGRlY29kZXIpKSB7XG4gICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKGRlY29kZXIuc3Vic3RyaW5nKDEsIGRlY29kZXIubGVuZ3RoIC0gMSkpO1xuICAgICAgcmV0dXJuIHJlZy50ZXN0KGxvb2t1cCk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyID09PSBsb29rdXA7XG4gIH0pO1xuICByZXR1cm4gbG9va3VwICYmIGZvdW5kICYmIGRlY29kZXJzW2ZvdW5kXTtcbn07XG5jb25zdCByZWN1cnNlRGVjb2RlID0gYXN5bmMgKGRlY29kZUluc3RydWN0aW9ucywgZGVjb2RlcnMsIHN0YWNrKSA9PiB7XG4gIGxldCBkZWNvZGVyID0gZGVjb2Rlckxvb2t1cChkZWNvZGVycywgZGVjb2RlSW5zdHJ1Y3Rpb25zLnR5cGUpO1xuICBpZiAoIWRlY29kZXIpIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIERlY29kZXIgRXJyb3I6ICR7ZGVjb2RlSW5zdHJ1Y3Rpb25zLnR5cGV9QCR7c3RhY2suam9pbihcIi5cIil9YCk7XG4gIHJldHVybiBhd2FpdCBkZWNvZGVyKGRlY29kZUluc3RydWN0aW9ucy52YWx1ZSwgZGVjb2RlcnMsIHN0YWNrKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRGVjb2RlcyBhIHJlc3BvbnNlIGZyb20gRmxvdyBpbnRvIEpTT05cbiAqIEBwYXJhbSB7Kn0gZGVjb2RlSW5zdHJ1Y3Rpb25zIC0gVGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIEZsb3dcbiAqIEBwYXJhbSB7b2JqZWN0fSBjdXN0b21EZWNvZGVycyAtIEFuIG9iamVjdCBvZiBjdXN0b20gZGVjb2RlcnNcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0YWNrIC0gVGhlIHN0YWNrIG9mIHRoZSBjdXJyZW50IGRlY29kaW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBUaGUgZGVjb2RlZCByZXNwb25zZVxuICovXG5jb25zdCBkZWNvZGUkMSA9IGFzeW5jIGZ1bmN0aW9uIChkZWNvZGVJbnN0cnVjdGlvbnMpIHtcbiAgbGV0IGN1c3RvbURlY29kZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IHN0YWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgLy8gRmlsdGVyIG91dCBhbGwgZGVmYXVsdCBkZWNvZGVycyB3aGljaCBhcmUgb3ZlcnJpZGRlbiBieSBhIGN1c3RvbSBkZWNvZGVyIHJlZ2V4XG4gIGNvbnN0IGZpbHRlcmVkRGVjb2RlcnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0RGVjb2RlcnMpLmZpbHRlcihkZWNvZGVyID0+ICFPYmplY3Qua2V5cyhjdXN0b21EZWNvZGVycykuZmluZChjdXN0b21EZWNvZGVyID0+IG5ldyBSZWdFeHAoY3VzdG9tRGVjb2RlcikudGVzdChkZWNvZGVyKSkpLnJlZHVjZSgoZGVjb2RlcnMsIGRlY29kZXJLZXkpID0+IHtcbiAgICBkZWNvZGVyc1tkZWNvZGVyS2V5XSA9IGRlZmF1bHREZWNvZGVyc1tkZWNvZGVyS2V5XTtcbiAgICByZXR1cm4gZGVjb2RlcnM7XG4gIH0sIGN1c3RvbURlY29kZXJzKTtcbiAgY29uc3QgZGVjb2RlcnMgPSB7XG4gICAgLi4uZmlsdGVyZWREZWNvZGVycyxcbiAgICAuLi5jdXN0b21EZWNvZGVyc1xuICB9O1xuICByZXR1cm4gcmVjdXJzZURlY29kZShkZWNvZGVJbnN0cnVjdGlvbnMsIGRlY29kZXJzLCBzdGFjayk7XG59O1xuY29uc3QgZGVjb2RlUmVzcG9uc2UgPSBhc3luYyBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgbGV0IGN1c3RvbURlY29kZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHJlc3BvbnNlLmVuY29kZWREYXRhKSB7XG4gICAgcmV0dXJuIGRlY29kZSQxKHJlc3BvbnNlLmVuY29kZWREYXRhLCBjdXN0b21EZWNvZGVycyk7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UudHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UudHJhbnNhY3Rpb25TdGF0dXMsXG4gICAgICBldmVudHM6IGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLnRyYW5zYWN0aW9uU3RhdHVzLmV2ZW50cy5tYXAoYXN5bmMgZnVuY3Rpb24gZGVjb2RlRXZlbnRzKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgICAgdHJhbnNhY3Rpb25JZDogZS50cmFuc2FjdGlvbklkLFxuICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGUudHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgICBldmVudEluZGV4OiBlLmV2ZW50SW5kZXgsXG4gICAgICAgICAgZGF0YTogYXdhaXQgZGVjb2RlJDEoZS5wYXlsb2FkLCBjdXN0b21EZWNvZGVycylcbiAgICAgICAgfTtcbiAgICAgIH0pKVxuICAgIH07XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UudHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzcG9uc2UudHJhbnNhY3Rpb247XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuZXZlbnRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLmV2ZW50cy5tYXAoYXN5bmMgZnVuY3Rpb24gZGVjb2RlRXZlbnRzKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJsb2NrSWQ6IGUuYmxvY2tJZCxcbiAgICAgICAgYmxvY2tIZWlnaHQ6IGUuYmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NrVGltZXN0YW1wOiBlLmJsb2NrVGltZXN0YW1wLFxuICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgIHRyYW5zYWN0aW9uSWQ6IGUudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogZS50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICBldmVudEluZGV4OiBlLmV2ZW50SW5kZXgsXG4gICAgICAgIGRhdGE6IGF3YWl0IGRlY29kZSQxKGUucGF5bG9hZCwgY3VzdG9tRGVjb2RlcnMpXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChyZXNwb25zZS5hY2NvdW50KSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFjY291bnQ7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuYmxvY2spIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuYmxvY2s7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UuYmxvY2tIZWFkZXIpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuYmxvY2tIZWFkZXI7XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UubGF0ZXN0QmxvY2spIHtcbiAgICBsYXRlc3RCbG9ja0RlcHJlY2F0aW9uTm90aWNlKCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmxhdGVzdEJsb2NrO1xuICB9IGVsc2UgaWYgKHJlc3BvbnNlLnRyYW5zYWN0aW9uSWQpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UudHJhbnNhY3Rpb25JZDtcbiAgfSBlbHNlIGlmIChyZXNwb25zZS5jb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNvbGxlY3Rpb247XG4gIH0gZWxzZSBpZiAocmVzcG9uc2UubmV0d29ya1BhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjaGFpbklkTWFwID0ge1xuICAgICAgXCJmbG93LXRlc3RuZXRcIjogXCJ0ZXN0bmV0XCIsXG4gICAgICBcImZsb3ctbWFpbm5ldFwiOiBcIm1haW5uZXRcIixcbiAgICAgIFwiZmxvdy1lbXVsYXRvclwiOiBcImxvY2FsXCJcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjaGFpbklkOiBjaGFpbklkTWFwW3Jlc3BvbnNlLm5ldHdvcmtQYXJhbWV0ZXJzLmNoYWluSWRdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGlzRm4kMiA9IHYgPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nJDEgPSB2ID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xuY29uc3Qgb2xkSWRlbnRpZmllclBhdHRlcm5GbiA9ICgpID0+IC9cXGIoMHhcXHcrKVxcYi9nO1xuZnVuY3Rpb24gaXNPbGRJZGVudGlmaWVyU3ludGF4KGNhZGVuY2UpIHtcbiAgcmV0dXJuIG9sZElkZW50aWZpZXJQYXR0ZXJuRm4oKS50ZXN0KGNhZGVuY2UpO1xufVxuY29uc3QgbmV3SWRlbnRpZmllclBhdHRlcm5GbiA9ICgpID0+IC9pbXBvcnRcXHMrXCIoXFx3KylcIi9nO1xuZnVuY3Rpb24gaXNOZXdJZGVudGlmaWVyU3ludGF4KGNhZGVuY2UpIHtcbiAgcmV0dXJuIG5ld0lkZW50aWZpZXJQYXR0ZXJuRm4oKS50ZXN0KGNhZGVuY2UpO1xufVxuZnVuY3Rpb24gZ2V0Q29udHJhY3RJZGVudGlmaWVyU3ludGF4TWF0Y2hlcyhjYWRlbmNlKSB7XG4gIHJldHVybiBjYWRlbmNlLm1hdGNoQWxsKG5ld0lkZW50aWZpZXJQYXR0ZXJuRm4oKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ2FkZW5jZShpeCkge1xuICBpZiAoIWlzVHJhbnNhY3Rpb24oaXgpICYmICFpc1NjcmlwdChpeCkpIHJldHVybiBpeDtcbiAgdmFyIGNhZGVuY2UgPSBnZXQoaXgsIFwiaXguY2FkZW5jZVwiKTtcbiAgaW52YXJpYW50JDEoaXNGbiQyKGNhZGVuY2UpIHx8IGlzU3RyaW5nJDEoY2FkZW5jZSksIFwiQ2FkZW5jZSBuZWVkcyB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLlwiKTtcbiAgaWYgKGlzRm4kMihjYWRlbmNlKSkgY2FkZW5jZSA9IGF3YWl0IGNhZGVuY2Uoe30pO1xuICBpbnZhcmlhbnQkMShpc1N0cmluZyQxKGNhZGVuY2UpLCBcIkNhZGVuY2UgbmVlZHMgdG8gYmUgYSBzdHJpbmcgYXQgdGhpcyBwb2ludC5cIik7XG4gIGludmFyaWFudCQxKCFpc09sZElkZW50aWZpZXJTeW50YXgoY2FkZW5jZSkgfHwgIWlzTmV3SWRlbnRpZmllclN5bnRheChjYWRlbmNlKSwgXCJCb3RoIGFjY291bnQgaWRlbnRpZmllciBhbmQgY29udHJhY3QgaWRlbnRpZmllciBzeW50YXggbm90IHNpbXVsdGFuZW91c2x5IHN1cHBvcnRlZC5cIik7XG4gIGlmIChpc09sZElkZW50aWZpZXJTeW50YXgoY2FkZW5jZSkpIHtcbiAgICBjYWRlbmNlID0gYXdhaXQgY29uZmlnKCkud2hlcmUoL14weC8pLnRoZW4oZCA9PiBPYmplY3QuZW50cmllcyhkKS5yZWR1Y2UoKGNhZGVuY2UsIF9yZWYpID0+IHtcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwiKFxcXFxiXCIgKyBrZXkgKyBcIlxcXFxiKVwiLCBcImdcIik7XG4gICAgICByZXR1cm4gY2FkZW5jZS5yZXBsYWNlKHJlZ2V4LCB2YWx1ZSk7XG4gICAgfSwgY2FkZW5jZSkpO1xuICB9XG4gIGlmIChpc05ld0lkZW50aWZpZXJTeW50YXgoY2FkZW5jZSkpIHtcbiAgICBmb3IgKGNvbnN0IFtmdWxsTWF0Y2gsIGNvbnRyYWN0TmFtZV0gb2YgZ2V0Q29udHJhY3RJZGVudGlmaWVyU3ludGF4TWF0Y2hlcyhjYWRlbmNlKSkge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvbmZpZygpLmdldChgc3lzdGVtLmNvbnRyYWN0cy4ke2NvbnRyYWN0TmFtZX1gKTtcbiAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIGNhZGVuY2UgPSBjYWRlbmNlLnJlcGxhY2UoZnVsbE1hdGNoLCBgaW1wb3J0ICR7Y29udHJhY3ROYW1lfSBmcm9tICR7d2l0aFByZWZpeChhZGRyZXNzKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coe1xuICAgICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIG5vdCBmb3VuZFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgZmluZCBhIHZhbHVlIGZvciBjb250cmFjdCBwbGFjZWhvbGRlciAke2NvbnRyYWN0TmFtZX0uIFBsZWFzZSBhZGQgdG8geW91ciBmbG93Lmpzb24gb3IgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIGNvbmZpZyAnY29udHJhY3RzLionIG5hbWVzcGFjZS5gLFxuICAgICAgICAgIGxldmVsOiBsb2dnZXIuTEVWRUxTLndhcm5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgbmVlZCB0byBtb3ZlIHRoaXMgb3ZlciBpbiBhbnkgY2FzZS5cbiAgaXgubWVzc2FnZS5jYWRlbmNlID0gY2FkZW5jZTtcbiAgcmV0dXJuIGl4O1xufVxuXG5jb25zdCBpc0ZuJDEgPSB2ID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBjYXN0KGFyZykge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50JDEodHlwZW9mIGFyZy54Zm9ybSAhPSBudWxsLCBgTm8gdHlwZSBzcGVjaWZpZWQgZm9yIGFyZ3VtZW50OiAke2FyZy52YWx1ZX1gKTtcbiAgaWYgKGlzRm4kMShhcmcueGZvcm0pKSByZXR1cm4gYXJnLnhmb3JtKGFyZy52YWx1ZSk7XG4gIGlmIChpc0ZuJDEoYXJnLnhmb3JtLmFzQXJndW1lbnQpKSByZXR1cm4gYXJnLnhmb3JtLmFzQXJndW1lbnQoYXJnLnZhbHVlKTtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaW52YXJpYW50JDEoZmFsc2UsIGBJbnZhbGlkIEFyZ3VtZW50YCwgYXJnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFyZ1Jlc29sdXRpb24oYXJnKSB7XG4gIGxldCBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMztcbiAgaW52YXJpYW50JDEoZGVwdGggPiAwLCBgQXJndW1lbnQgUmVzb2x2ZSBSZWN1cnNpb24gTGltaXQgRXhjZWVkZWQgZm9yIEFyZzogJHthcmcudGVtcElkfWApO1xuICBpZiAoaXNGbiQxKGFyZy5yZXNvbHZlQXJndW1lbnQpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRBcmcgPSBhd2FpdCBhcmcucmVzb2x2ZUFyZ3VtZW50KCk7XG4gICAgcmV0dXJuIGhhbmRsZUFyZ1Jlc29sdXRpb24ocmVzb2x2ZWRBcmcsIGRlcHRoIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3VtZW50cyhpeCkge1xuICBpZiAoaXNUcmFuc2FjdGlvbihpeCkgfHwgaXNTY3JpcHQoaXgpKSB7XG4gICAgZm9yIChsZXQgW2lkLCBhcmddIG9mIE9iamVjdC5lbnRyaWVzKGl4LmFyZ3VtZW50cykpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhhbmRsZUFyZ1Jlc29sdXRpb24oYXJnKTtcbiAgICAgIGl4LmFyZ3VtZW50c1tpZF0uYXNBcmd1bWVudCA9IGNhc3QocmVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl4O1xufVxuXG5jb25zdCBlbmNvZGVUcmFuc2FjdGlvblBheWxvYWQgPSB0eCA9PiBwcmVwZW5kVHJhbnNhY3Rpb25Eb21haW5UYWcocmxwRW5jb2RlKHByZXBhcmVQYXlsb2FkKHR4KSkpO1xuY29uc3QgZW5jb2RlVHJhbnNhY3Rpb25FbnZlbG9wZSA9IHR4ID0+IHByZXBlbmRUcmFuc2FjdGlvbkRvbWFpblRhZyhybHBFbmNvZGUocHJlcGFyZUVudmVsb3BlKHR4KSkpO1xuY29uc3QgZW5jb2RlVHhJZEZyb21Wb3VjaGVyID0gdm91Y2hlciA9PiBzaGEzXzI1NihybHBFbmNvZGUocHJlcGFyZVZvdWNoZXIodm91Y2hlcikpKTtcbmNvbnN0IHJpZ2h0UGFkZGVkSGV4QnVmZmVyID0gKHZhbHVlLCBwYWQpID0+IEJ1ZmZlci5mcm9tKHZhbHVlLnBhZEVuZChwYWQgKiAyLCAwKSwgXCJoZXhcIik7XG5jb25zdCBsZWZ0UGFkZGVkSGV4QnVmZmVyID0gKHZhbHVlLCBwYWQpID0+IEJ1ZmZlci5mcm9tKHZhbHVlLnBhZFN0YXJ0KHBhZCAqIDIsIDApLCBcImhleFwiKTtcbmNvbnN0IFRSQU5TQUNUSU9OX0RPTUFJTl9UQUcgPSByaWdodFBhZGRlZEhleEJ1ZmZlcihCdWZmZXIuZnJvbShcIkZMT1ctVjAuMC10cmFuc2FjdGlvblwiKS50b1N0cmluZyhcImhleFwiKSwgMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuY29uc3QgcHJlcGVuZFRyYW5zYWN0aW9uRG9tYWluVGFnID0gdHggPT4gVFJBTlNBQ1RJT05fRE9NQUlOX1RBRyArIHR4O1xuY29uc3QgYWRkcmVzc0J1ZmZlciA9IGFkZHIgPT4gbGVmdFBhZGRlZEhleEJ1ZmZlcihhZGRyLCA4KTtcbmNvbnN0IGJsb2NrQnVmZmVyID0gYmxvY2sgPT4gbGVmdFBhZGRlZEhleEJ1ZmZlcihibG9jaywgMzIpO1xuY29uc3QgYXJndW1lbnRUb1N0cmluZyA9IGFyZyA9PiBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShhcmcpLCBcInV0ZjhcIik7XG5jb25zdCBzY3JpcHRCdWZmZXIgPSBzY3JpcHQgPT4gQnVmZmVyLmZyb20oc2NyaXB0LCBcInV0ZjhcIik7XG5jb25zdCBzaWduYXR1cmVCdWZmZXIgPSBzaWduYXR1cmUgPT4gQnVmZmVyLmZyb20oc2lnbmF0dXJlLCBcImhleFwiKTtcbmNvbnN0IHJscEVuY29kZSA9IHYgPT4ge1xuICByZXR1cm4gZW5jb2RlKHYpLnRvU3RyaW5nKFwiaGV4XCIpO1xufTtcbmNvbnN0IHNoYTNfMjU2ID0gbXNnID0+IHtcbiAgY29uc3Qgc2hhID0gbmV3IFNIQTMoMjU2KTtcbiAgc2hhLnVwZGF0ZShCdWZmZXIuZnJvbShtc2csIFwiaGV4XCIpKTtcbiAgcmV0dXJuIHNoYS5kaWdlc3QoKS50b1N0cmluZyhcImhleFwiKTtcbn07XG5jb25zdCBwcmVwYXJlUGF5bG9hZCA9IHR4ID0+IHtcbiAgdmFsaWRhdGVQYXlsb2FkKHR4KTtcbiAgcmV0dXJuIFtzY3JpcHRCdWZmZXIodHguY2FkZW5jZSksIHR4LmFyZ3VtZW50cy5tYXAoYXJndW1lbnRUb1N0cmluZyksIGJsb2NrQnVmZmVyKHR4LnJlZkJsb2NrKSwgdHguY29tcHV0ZUxpbWl0LCBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgodHgucHJvcG9zYWxLZXkuYWRkcmVzcykpLCB0eC5wcm9wb3NhbEtleS5rZXlJZCwgdHgucHJvcG9zYWxLZXkuc2VxdWVuY2VOdW0sIGFkZHJlc3NCdWZmZXIoc2Fuc1ByZWZpeCh0eC5wYXllcikpLCB0eC5hdXRob3JpemVycy5tYXAoYXV0aG9yaXplciA9PiBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgoYXV0aG9yaXplcikpKV07XG59O1xuY29uc3QgcHJlcGFyZUVudmVsb3BlID0gdHggPT4ge1xuICB2YWxpZGF0ZUVudmVsb3BlKHR4KTtcbiAgcmV0dXJuIFtwcmVwYXJlUGF5bG9hZCh0eCksIHByZXBhcmVQYXlsb2FkU2lnbmF0dXJlcyh0eCldO1xufTtcbmNvbnN0IHByZXBhcmVQYXlsb2FkU2lnbmF0dXJlcyA9IHR4ID0+IHtcbiAgY29uc3Qgc2lnbmVycyA9IGNvbGxlY3RTaWduZXJzKHR4KTtcbiAgcmV0dXJuIHR4LnBheWxvYWRTaWdzLm1hcChzaWcgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzaWduZXJJbmRleDogc2lnbmVycy5nZXQoc2lnLmFkZHJlc3MpLFxuICAgICAga2V5SWQ6IHNpZy5rZXlJZCxcbiAgICAgIHNpZzogc2lnLnNpZ1xuICAgIH07XG4gIH0pLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5zaWduZXJJbmRleCA+IGIuc2lnbmVySW5kZXgpIHJldHVybiAxO1xuICAgIGlmIChhLnNpZ25lckluZGV4IDwgYi5zaWduZXJJbmRleCkgcmV0dXJuIC0xO1xuICAgIGlmIChhLmtleUlkID4gYi5rZXlJZCkgcmV0dXJuIDE7XG4gICAgaWYgKGEua2V5SWQgPCBiLmtleUlkKSByZXR1cm4gLTE7XG4gIH0pLm1hcChzaWcgPT4ge1xuICAgIHJldHVybiBbc2lnLnNpZ25lckluZGV4LCBzaWcua2V5SWQsIHNpZ25hdHVyZUJ1ZmZlcihzaWcuc2lnKV07XG4gIH0pO1xufTtcbmNvbnN0IGNvbGxlY3RTaWduZXJzID0gdHggPT4ge1xuICBjb25zdCBzaWduZXJzID0gbmV3IE1hcCgpO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGFkZFNpZ25lciA9IGFkZHIgPT4ge1xuICAgIGlmICghc2lnbmVycy5oYXMoYWRkcikpIHtcbiAgICAgIHNpZ25lcnMuc2V0KGFkZHIsIGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfTtcbiAgYWRkU2lnbmVyKHR4LnByb3Bvc2FsS2V5LmFkZHJlc3MpO1xuICBhZGRTaWduZXIodHgucGF5ZXIpO1xuICB0eC5hdXRob3JpemVycy5mb3JFYWNoKGFkZFNpZ25lcik7XG4gIHJldHVybiBzaWduZXJzO1xufTtcbmNvbnN0IHByZXBhcmVWb3VjaGVyID0gdm91Y2hlciA9PiB7XG4gIHZhbGlkYXRlVm91Y2hlcih2b3VjaGVyKTtcbiAgY29uc3Qgc2lnbmVycyA9IGNvbGxlY3RTaWduZXJzKHZvdWNoZXIpO1xuICBjb25zdCBwcmVwYXJlU2lncyA9IHNpZ3MgPT4ge1xuICAgIHJldHVybiBzaWdzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGtleUlkLFxuICAgICAgICBzaWdcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmVySW5kZXg6IHNpZ25lcnMuZ2V0KGFkZHJlc3MpLFxuICAgICAgICBrZXlJZCxcbiAgICAgICAgc2lnXG4gICAgICB9O1xuICAgIH0pLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLnNpZ25lckluZGV4ID4gYi5zaWduZXJJbmRleCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYS5zaWduZXJJbmRleCA8IGIuc2lnbmVySW5kZXgpIHJldHVybiAtMTtcbiAgICAgIGlmIChhLmtleUlkID4gYi5rZXlJZCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYS5rZXlJZCA8IGIua2V5SWQpIHJldHVybiAtMTtcbiAgICB9KS5tYXAoc2lnID0+IHtcbiAgICAgIHJldHVybiBbc2lnLnNpZ25lckluZGV4LCBzaWcua2V5SWQsIHNpZ25hdHVyZUJ1ZmZlcihzaWcuc2lnKV07XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBbW3NjcmlwdEJ1ZmZlcih2b3VjaGVyLmNhZGVuY2UpLCB2b3VjaGVyLmFyZ3VtZW50cy5tYXAoYXJndW1lbnRUb1N0cmluZyksIGJsb2NrQnVmZmVyKHZvdWNoZXIucmVmQmxvY2spLCB2b3VjaGVyLmNvbXB1dGVMaW1pdCwgYWRkcmVzc0J1ZmZlcihzYW5zUHJlZml4KHZvdWNoZXIucHJvcG9zYWxLZXkuYWRkcmVzcykpLCB2b3VjaGVyLnByb3Bvc2FsS2V5LmtleUlkLCB2b3VjaGVyLnByb3Bvc2FsS2V5LnNlcXVlbmNlTnVtLCBhZGRyZXNzQnVmZmVyKHNhbnNQcmVmaXgodm91Y2hlci5wYXllcikpLCB2b3VjaGVyLmF1dGhvcml6ZXJzLm1hcChhdXRob3JpemVyID0+IGFkZHJlc3NCdWZmZXIoc2Fuc1ByZWZpeChhdXRob3JpemVyKSkpXSwgcHJlcGFyZVNpZ3Modm91Y2hlci5wYXlsb2FkU2lncyksIHByZXBhcmVTaWdzKHZvdWNoZXIuZW52ZWxvcGVTaWdzKV07XG59O1xuY29uc3QgdmFsaWRhdGVQYXlsb2FkID0gdHggPT4ge1xuICBwYXlsb2FkRmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZCh0eCwgZmllbGQpKTtcbiAgcHJvcG9zYWxLZXlGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHR4LnByb3Bvc2FsS2V5LCBmaWVsZCwgXCJwcm9wb3NhbEtleVwiKSk7XG59O1xuY29uc3QgdmFsaWRhdGVFbnZlbG9wZSA9IHR4ID0+IHtcbiAgcGF5bG9hZFNpZ3NGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHR4LCBmaWVsZCkpO1xuICB0eC5wYXlsb2FkU2lncy5mb3JFYWNoKChzaWcsIGluZGV4KSA9PiB7XG4gICAgcGF5bG9hZFNpZ0ZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNoZWNrRmllbGQoc2lnLCBmaWVsZCwgXCJwYXlsb2FkU2lnc1wiLCBpbmRleCkpO1xuICB9KTtcbn07XG5jb25zdCB2YWxpZGF0ZVZvdWNoZXIgPSB2b3VjaGVyID0+IHtcbiAgcGF5bG9hZEZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNoZWNrRmllbGQodm91Y2hlciwgZmllbGQpKTtcbiAgcHJvcG9zYWxLZXlGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHZvdWNoZXIucHJvcG9zYWxLZXksIGZpZWxkLCBcInByb3Bvc2FsS2V5XCIpKTtcbiAgcGF5bG9hZFNpZ3NGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHZvdWNoZXIsIGZpZWxkKSk7XG4gIHZvdWNoZXIucGF5bG9hZFNpZ3MuZm9yRWFjaCgoc2lnLCBpbmRleCkgPT4ge1xuICAgIHBheWxvYWRTaWdGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBjaGVja0ZpZWxkKHNpZywgZmllbGQsIFwicGF5bG9hZFNpZ3NcIiwgaW5kZXgpKTtcbiAgfSk7XG4gIGVudmVsb3BlU2lnc0ZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IGNoZWNrRmllbGQodm91Y2hlciwgZmllbGQpKTtcbiAgdm91Y2hlci5lbnZlbG9wZVNpZ3MuZm9yRWFjaCgoc2lnLCBpbmRleCkgPT4ge1xuICAgIGVudmVsb3BlU2lnRmllbGRzLmZvckVhY2goZmllbGQgPT4gY2hlY2tGaWVsZChzaWcsIGZpZWxkLCBcImVudmVsb3BlU2lnc1wiLCBpbmRleCkpO1xuICB9KTtcbn07XG5jb25zdCBpc051bWJlciA9IHYgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG5jb25zdCBpc1N0cmluZyA9IHYgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc09iamVjdCA9IHYgPT4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzQXJyYXkgPSB2ID0+IGlzT2JqZWN0KHYpICYmIHYgaW5zdGFuY2VvZiBBcnJheTtcbmNvbnN0IHBheWxvYWRGaWVsZHMgPSBbe1xuICBuYW1lOiBcImNhZGVuY2VcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59LCB7XG4gIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gIGNoZWNrOiBpc0FycmF5XG59LCB7XG4gIG5hbWU6IFwicmVmQmxvY2tcIixcbiAgY2hlY2s6IGlzU3RyaW5nLFxuICBkZWZhdWx0VmFsOiBcIjBcIlxufSwge1xuICBuYW1lOiBcImNvbXB1dGVMaW1pdFwiLFxuICBjaGVjazogaXNOdW1iZXJcbn0sIHtcbiAgbmFtZTogXCJwcm9wb3NhbEtleVwiLFxuICBjaGVjazogaXNPYmplY3Rcbn0sIHtcbiAgbmFtZTogXCJwYXllclwiLFxuICBjaGVjazogaXNTdHJpbmdcbn0sIHtcbiAgbmFtZTogXCJhdXRob3JpemVyc1wiLFxuICBjaGVjazogaXNBcnJheVxufV07XG5jb25zdCBwcm9wb3NhbEtleUZpZWxkcyA9IFt7XG4gIG5hbWU6IFwiYWRkcmVzc1wiLFxuICBjaGVjazogaXNTdHJpbmdcbn0sIHtcbiAgbmFtZTogXCJrZXlJZFwiLFxuICBjaGVjazogaXNOdW1iZXJcbn0sIHtcbiAgbmFtZTogXCJzZXF1ZW5jZU51bVwiLFxuICBjaGVjazogaXNOdW1iZXJcbn1dO1xuY29uc3QgcGF5bG9hZFNpZ3NGaWVsZHMgPSBbe1xuICBuYW1lOiBcInBheWxvYWRTaWdzXCIsXG4gIGNoZWNrOiBpc0FycmF5XG59XTtcbmNvbnN0IHBheWxvYWRTaWdGaWVsZHMgPSBbe1xuICBuYW1lOiBcImFkZHJlc3NcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59LCB7XG4gIG5hbWU6IFwia2V5SWRcIixcbiAgY2hlY2s6IGlzTnVtYmVyXG59LCB7XG4gIG5hbWU6IFwic2lnXCIsXG4gIGNoZWNrOiBpc1N0cmluZ1xufV07XG5jb25zdCBlbnZlbG9wZVNpZ3NGaWVsZHMgPSBbe1xuICBuYW1lOiBcImVudmVsb3BlU2lnc1wiLFxuICBjaGVjazogaXNBcnJheVxufV07XG5jb25zdCBlbnZlbG9wZVNpZ0ZpZWxkcyA9IFt7XG4gIG5hbWU6IFwiYWRkcmVzc1wiLFxuICBjaGVjazogaXNTdHJpbmdcbn0sIHtcbiAgbmFtZTogXCJrZXlJZFwiLFxuICBjaGVjazogaXNOdW1iZXJcbn0sIHtcbiAgbmFtZTogXCJzaWdcIixcbiAgY2hlY2s6IGlzU3RyaW5nXG59XTtcbmNvbnN0IGNoZWNrRmllbGQgPSAob2JqLCBmaWVsZCwgYmFzZSwgaW5kZXgpID0+IHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgY2hlY2ssXG4gICAgZGVmYXVsdFZhbFxuICB9ID0gZmllbGQ7XG4gIGlmIChvYmpbbmFtZV0gPT0gbnVsbCAmJiBkZWZhdWx0VmFsICE9IG51bGwpIG9ialtuYW1lXSA9IGRlZmF1bHRWYWw7XG4gIGlmIChvYmpbbmFtZV0gPT0gbnVsbCkgdGhyb3cgbWlzc2luZ0ZpZWxkRXJyb3IobmFtZSwgYmFzZSwgaW5kZXgpO1xuICBpZiAoIWNoZWNrKG9ialtuYW1lXSkpIHRocm93IGludmFsaWRGaWVsZEVycm9yKG5hbWUsIGJhc2UsIGluZGV4KTtcbn07XG5jb25zdCBwcmludEZpZWxkTmFtZSA9IChmaWVsZCwgYmFzZSwgaW5kZXgpID0+IHtcbiAgaWYgKCEhYmFzZSkgcmV0dXJuIGluZGV4ID09IG51bGwgPyBgJHtiYXNlfS4ke2ZpZWxkfWAgOiBgJHtiYXNlfS4ke2luZGV4fS4ke2ZpZWxkfWA7XG4gIHJldHVybiBmaWVsZDtcbn07XG5jb25zdCBtaXNzaW5nRmllbGRFcnJvciA9IChmaWVsZCwgYmFzZSwgaW5kZXgpID0+IG5ldyBFcnJvcihgTWlzc2luZyBmaWVsZCAke3ByaW50RmllbGROYW1lKGZpZWxkLCBiYXNlLCBpbmRleCl9YCk7XG5jb25zdCBpbnZhbGlkRmllbGRFcnJvciA9IChmaWVsZCwgYmFzZSwgaW5kZXgpID0+IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCAke3ByaW50RmllbGROYW1lKGZpZWxkLCBiYXNlLCBpbmRleCl9YCk7XG5cbmZ1bmN0aW9uIGZpbmRJbnNpZGVTaWduZXJzKGl4KSB7XG4gIC8vIEluc2lkZSBTaWduZXJzIEFyZTogKGF1dGhvcml6ZXJzICsgcHJvcG9zZXIpIC0gcGF5ZXJcbiAgbGV0IGluc2lkZSA9IG5ldyBTZXQoaXguYXV0aG9yaXphdGlvbnMpO1xuICBpbnNpZGUuYWRkKGl4LnByb3Bvc2VyKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXgucGF5ZXIpKSB7XG4gICAgaXgucGF5ZXIuZm9yRWFjaChwID0+IGluc2lkZS5kZWxldGUocCkpO1xuICB9IGVsc2Uge1xuICAgIGluc2lkZS5kZWxldGUoaXgucGF5ZXIpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGluc2lkZSk7XG59XG5mdW5jdGlvbiBmaW5kT3V0c2lkZVNpZ25lcnMoaXgpIHtcbiAgLy8gT3V0c2lkZSBTaWduZXJzIEFyZTogKHBheWVyKVxuICBsZXQgb3V0c2lkZSA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheShpeC5wYXllcikgPyBpeC5wYXllciA6IFtpeC5wYXllcl0pO1xuICByZXR1cm4gQXJyYXkuZnJvbShvdXRzaWRlKTtcbn1cbmNvbnN0IGNyZWF0ZVNpZ25hYmxlVm91Y2hlciA9IGl4ID0+IHtcbiAgY29uc3QgYnVpbGRBdXRob3JpemVycyA9ICgpID0+IHtcbiAgICBjb25zdCBhdXRob3JpemF0aW9ucyA9IGl4LmF1dGhvcml6YXRpb25zLm1hcChjaWQgPT4gd2l0aFByZWZpeChpeC5hY2NvdW50c1tjaWRdLmFkZHIpKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgIHJldHVybiBwcmV2LmZpbmQoaXRlbSA9PiBpdGVtID09PSBjdXJyZW50KSA/IHByZXYgOiBbLi4ucHJldiwgY3VycmVudF07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uc1swXSA/IGF1dGhvcml6YXRpb25zIDogW107XG4gIH07XG4gIGNvbnN0IGJ1aWxkSW5zaWRlU2lnbmVycyA9ICgpID0+IGZpbmRJbnNpZGVTaWduZXJzKGl4KS5tYXAoaWQgPT4gKHtcbiAgICBhZGRyZXNzOiB3aXRoUHJlZml4KGl4LmFjY291bnRzW2lkXS5hZGRyKSxcbiAgICBrZXlJZDogaXguYWNjb3VudHNbaWRdLmtleUlkLFxuICAgIHNpZzogaXguYWNjb3VudHNbaWRdLnNpZ25hdHVyZVxuICB9KSk7XG4gIGNvbnN0IGJ1aWxkT3V0c2lkZVNpZ25lcnMgPSAoKSA9PiBmaW5kT3V0c2lkZVNpZ25lcnMoaXgpLm1hcChpZCA9PiAoe1xuICAgIGFkZHJlc3M6IHdpdGhQcmVmaXgoaXguYWNjb3VudHNbaWRdLmFkZHIpLFxuICAgIGtleUlkOiBpeC5hY2NvdW50c1tpZF0ua2V5SWQsXG4gICAgc2lnOiBpeC5hY2NvdW50c1tpZF0uc2lnbmF0dXJlXG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBjYWRlbmNlOiBpeC5tZXNzYWdlLmNhZGVuY2UsXG4gICAgcmVmQmxvY2s6IGl4Lm1lc3NhZ2UucmVmQmxvY2sgfHwgbnVsbCxcbiAgICBjb21wdXRlTGltaXQ6IGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0LFxuICAgIGFyZ3VtZW50czogaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGlkID0+IGl4LmFyZ3VtZW50c1tpZF0uYXNBcmd1bWVudCksXG4gICAgcHJvcG9zYWxLZXk6IHtcbiAgICAgIGFkZHJlc3M6IHdpdGhQcmVmaXgoaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmFkZHIpLFxuICAgICAga2V5SWQ6IGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5rZXlJZCxcbiAgICAgIHNlcXVlbmNlTnVtOiBpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uc2VxdWVuY2VOdW1cbiAgICB9LFxuICAgIHBheWVyOiB3aXRoUHJlZml4KGl4LmFjY291bnRzW0FycmF5LmlzQXJyYXkoaXgucGF5ZXIpID8gaXgucGF5ZXJbMF0gOiBpeC5wYXllcl0uYWRkciksXG4gICAgYXV0aG9yaXplcnM6IGJ1aWxkQXV0aG9yaXplcnMoKSxcbiAgICBwYXlsb2FkU2lnczogYnVpbGRJbnNpZGVTaWduZXJzKCksXG4gICAgZW52ZWxvcGVTaWdzOiBidWlsZE91dHNpZGVTaWduZXJzKClcbiAgfTtcbn07XG5jb25zdCB2b3VjaGVyVG9UeElkID0gdm91Y2hlciA9PiB7XG4gIHJldHVybiBlbmNvZGVUeElkRnJvbVZvdWNoZXIodm91Y2hlcik7XG59O1xuXG5jb25zdCBpZG9mJDEgPSBhY2N0ID0+IGAke3dpdGhQcmVmaXgoYWNjdC5hZGRyKX0tJHthY2N0LmtleUlkfWA7XG5jb25zdCBpc0ZuID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gYnVpbGRQcmVTaWduYWJsZShhY2N0LCBpeCkge1xuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICBmX3R5cGU6IFwiUHJlU2lnbmFibGVcIixcbiAgICAgIGZfdnNuOiBcIjEuMC4xXCIsXG4gICAgICByb2xlczogYWNjdC5yb2xlLFxuICAgICAgY2FkZW5jZTogaXgubWVzc2FnZS5jYWRlbmNlLFxuICAgICAgYXJnczogaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGQgPT4gaXguYXJndW1lbnRzW2RdLmFzQXJndW1lbnQpLFxuICAgICAgZGF0YToge30sXG4gICAgICBpbnRlcmFjdGlvbjogaXgsXG4gICAgICB2b3VjaGVyOiBjcmVhdGVTaWduYWJsZVZvdWNoZXIoaXgpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiYnVpbGRQcmVTaWduYWJsZVwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RBY2NvdW50cyhpeCwgYWNjb3VudHMsIGxhc3QpIHtcbiAgbGV0IGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAzO1xuICBpbnZhcmlhbnQkMShkZXB0aCwgXCJBY2NvdW50IFJlc29sdmUgUmVjdXJzaW9uIExpbWl0IEV4Y2VlZGVkXCIsIHtcbiAgICBpeCxcbiAgICBhY2NvdW50c1xuICB9KTtcbiAgbGV0IGF1dGhvcml6YXRpb25zID0gW107XG4gIGZvciAobGV0IGF4IG9mIGFjY291bnRzKSB7XG4gICAgbGV0IHJlc29sdmUgPSBheC5yZXNvbHZlO1xuICAgIGF4LnJlc29sdmUgPSBudWxsO1xuICAgIHZhciBvbGQgPSBsYXN0IHx8IGF4O1xuICAgIGlmIChpc0ZuKHJlc29sdmUpKSBheCA9IGF3YWl0IHJlc29sdmUoYXgsIGJ1aWxkUHJlU2lnbmFibGUoYXgsIGl4KSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXgpKSB7XG4gICAgICBhd2FpdCBjb2xsZWN0QWNjb3VudHMoaXgsIGF4LCBvbGQsIGRlcHRoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChheC5hZGRyKSB7XG4gICAgICAgIGF4LmFkZHIgPSBzYW5zUHJlZml4KGF4LmFkZHIpO1xuICAgICAgfVxuICAgICAgaWYgKGF4LmFkZHIgIT0gbnVsbCAmJiBheC5rZXlJZCAhPSBudWxsKSB7XG4gICAgICAgIGF4LnRlbXBJZCA9IGlkb2YkMShheCk7XG4gICAgICB9XG4gICAgICBpeC5hY2NvdW50c1theC50ZW1wSWRdID0gaXguYWNjb3VudHNbYXgudGVtcElkXSB8fCBheDtcbiAgICAgIGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5wcm9wb3NlciA9IGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5wcm9wb3NlciB8fCBheC5yb2xlLnByb3Bvc2VyO1xuICAgICAgaXguYWNjb3VudHNbYXgudGVtcElkXS5yb2xlLnBheWVyID0gaXguYWNjb3VudHNbYXgudGVtcElkXS5yb2xlLnBheWVyIHx8IGF4LnJvbGUucGF5ZXI7XG4gICAgICBpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUuYXV0aG9yaXplciA9IGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5hdXRob3JpemVyIHx8IGF4LnJvbGUuYXV0aG9yaXplcjtcbiAgICAgIGlmIChpeC5hY2NvdW50c1theC50ZW1wSWRdLnJvbGUucHJvcG9zZXIgJiYgaXgucHJvcG9zZXIgPT09IG9sZC50ZW1wSWQpIHtcbiAgICAgICAgaXgucHJvcG9zZXIgPSBheC50ZW1wSWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXguYWNjb3VudHNbYXgudGVtcElkXS5yb2xlLnBheWVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl4LnBheWVyKSkge1xuICAgICAgICAgIGl4LnBheWVyID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5peC5wYXllciwgYXgudGVtcElkXS5tYXAoZCA9PiBkID09PSBvbGQudGVtcElkID8gYXgudGVtcElkIDogZCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpeC5wYXllciA9IEFycmF5LmZyb20obmV3IFNldChbaXgucGF5ZXIsIGF4LnRlbXBJZF0ubWFwKGQgPT4gZCA9PT0gb2xkLnRlbXBJZCA/IGF4LnRlbXBJZCA6IGQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl4LnBheWVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyByZW1vdmUgcGF5ZXIgZHVwcyBiYXNlZCBvbiBhZGRyIGFuZCBrZXlJZFxuICAgICAgICAgIGNvbnN0IGR1cExpc3QgPSBbXTtcbiAgICAgICAgICBjb25zdCBwYXllckFjY3RzID0gW107XG4gICAgICAgICAgaXgucGF5ZXIgPSBpeC5wYXllci5yZWR1Y2UoKGcsIHRlbXBJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhZGRyXG4gICAgICAgICAgICB9ID0gaXguYWNjb3VudHNbdGVtcElkXTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlkb2YkMShpeC5hY2NvdW50c1t0ZW1wSWRdKTtcbiAgICAgICAgICAgIHBheWVyQWNjdHMucHVzaChhZGRyKTtcbiAgICAgICAgICAgIGlmIChkdXBMaXN0LmluY2x1ZGVzKGtleSkpIHJldHVybiBnO1xuICAgICAgICAgICAgZHVwTGlzdC5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmcsIHRlbXBJZF07XG4gICAgICAgICAgfSwgW10pO1xuICAgICAgICAgIGNvbnN0IG11bHRpQWNjdHMgPSBBcnJheS5mcm9tKG5ldyBTZXQocGF5ZXJBY2N0cykpO1xuICAgICAgICAgIGlmIChtdWx0aUFjY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBheWVyIGNhbiBub3QgYmUgZGlmZmVyZW50IGFjY291bnRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl4LmFjY291bnRzW2F4LnRlbXBJZF0ucm9sZS5hdXRob3JpemVyKSB7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgLy8gZG8gZ3JvdXAgcmVwbGFjZW1lbnRcbiAgICAgICAgICBhdXRob3JpemF0aW9ucyA9IEFycmF5LmZyb20obmV3IFNldChbLi4uYXV0aG9yaXphdGlvbnMsIGF4LnRlbXBJZF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkbyAxLTEgcmVwbGFjZW1lbnRcbiAgICAgICAgICBpeC5hdXRob3JpemF0aW9ucyA9IGl4LmF1dGhvcml6YXRpb25zLm1hcChkID0+IGQgPT09IG9sZC50ZW1wSWQgPyBheC50ZW1wSWQgOiBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkLnRlbXBJZCAhPSBheC50ZW1wSWQpIGRlbGV0ZSBpeC5hY2NvdW50c1tvbGQudGVtcElkXTtcbiAgfVxuICBpZiAobGFzdCkge1xuICAgIC8vIGNvbXBsZXRlIChmbGF0bWFwKSBncm91cCByZXBsYWNlbWVudFxuICAgIGl4LmF1dGhvcml6YXRpb25zID0gaXguYXV0aG9yaXphdGlvbnMubWFwKGQgPT4gZCA9PT0gbGFzdC50ZW1wSWQgPyBhdXRob3JpemF0aW9ucyA6IGQpLnJlZHVjZSgocHJldiwgY3VycikgPT4gQXJyYXkuaXNBcnJheShjdXJyKSA/IFsuLi5wcmV2LCAuLi5jdXJyXSA6IFsuLi5wcmV2LCBjdXJyXSwgW10pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQWNjb3VudHMoaXgpIHtcbiAgaWYgKGlzVHJhbnNhY3Rpb24oaXgpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl4LnBheWVyKSkge1xuICAgICAgbG9nLmRlcHJlY2F0ZSh7XG4gICAgICAgIHBrZzogXCJGQ0xcIixcbiAgICAgICAgc3ViamVjdDogJ1wiaXgucGF5ZXJcIiBtdXN0IGJlIGFuIGFycmF5LiBTdXBwb3J0IGZvciBpeC5wYXllciBhcyBhIHNpbmd1bGFyJyxcbiAgICAgICAgbWVzc2FnZTogXCJTZWUgY2hhbmdlbG9nIGZvciBtb3JlIGluZm8uXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29sbGVjdEFjY291bnRzKGl4LCBPYmplY3QudmFsdWVzKGl4LmFjY291bnRzKSk7XG4gICAgICBhd2FpdCBjb2xsZWN0QWNjb3VudHMoaXgsIE9iamVjdC52YWx1ZXMoaXguYWNjb3VudHMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIj09PSBTQUQgUEFOREEgPT09XFxuXFxuXCIsIGVycm9yLCBcIlxcblxcbj09PSBTQUQgUEFOREEgPT09XCIpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBpeDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVNpZ25hdHVyZXMoaXgpIHtcbiAgaWYgKGlzVHJhbnNhY3Rpb24oaXgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBpbnNpZGVTaWduZXJzID0gZmluZEluc2lkZVNpZ25lcnMoaXgpO1xuICAgICAgY29uc3QgaW5zaWRlUGF5bG9hZCA9IGVuY29kZVRyYW5zYWN0aW9uUGF5bG9hZChwcmVwRm9yRW5jb2RpbmcoaXgpKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc2lkZVNpZ25lcnMubWFwKGZldGNoU2lnbmF0dXJlKGl4LCBpbnNpZGVQYXlsb2FkKSkpO1xuICAgICAgbGV0IG91dHNpZGVTaWduZXJzID0gZmluZE91dHNpZGVTaWduZXJzKGl4KTtcbiAgICAgIGNvbnN0IG91dHNpZGVQYXlsb2FkID0gZW5jb2RlVHJhbnNhY3Rpb25FbnZlbG9wZSh7XG4gICAgICAgIC4uLnByZXBGb3JFbmNvZGluZyhpeCksXG4gICAgICAgIHBheWxvYWRTaWdzOiBpbnNpZGVTaWduZXJzLm1hcChpZCA9PiAoe1xuICAgICAgICAgIGFkZHJlc3M6IGl4LmFjY291bnRzW2lkXS5hZGRyLFxuICAgICAgICAgIGtleUlkOiBpeC5hY2NvdW50c1tpZF0ua2V5SWQsXG4gICAgICAgICAgc2lnOiBpeC5hY2NvdW50c1tpZF0uc2lnbmF0dXJlXG4gICAgICAgIH0pKVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChvdXRzaWRlU2lnbmVycy5tYXAoZmV0Y2hTaWduYXR1cmUoaXgsIG91dHNpZGVQYXlsb2FkKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2lnbmF0dXJlc1wiLCBlcnJvciwge1xuICAgICAgICBpeFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl4O1xufVxuZnVuY3Rpb24gZmV0Y2hTaWduYXR1cmUoaXgsIHBheWxvYWQpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIGlubmVyRmV0Y2hTaWduYXR1cmUoaWQpIHtcbiAgICBjb25zdCBhY2N0ID0gaXguYWNjb3VudHNbaWRdO1xuICAgIGlmIChhY2N0LnNpZ25hdHVyZSAhPSBudWxsKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlXG4gICAgfSA9IGF3YWl0IGFjY3Quc2lnbmluZ0Z1bmN0aW9uKGJ1aWxkU2lnbmFibGUoYWNjdCwgcGF5bG9hZCwgaXgpKTtcbiAgICBpeC5hY2NvdW50c1tpZF0uc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRTaWduYWJsZShhY2N0LCBtZXNzYWdlLCBpeCkge1xuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICBmX3R5cGU6IFwiU2lnbmFibGVcIixcbiAgICAgIGZfdnNuOiBcIjEuMC4xXCIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgYWRkcjogc2Fuc1ByZWZpeChhY2N0LmFkZHIpLFxuICAgICAga2V5SWQ6IGFjY3Qua2V5SWQsXG4gICAgICByb2xlczogYWNjdC5yb2xlLFxuICAgICAgY2FkZW5jZTogaXgubWVzc2FnZS5jYWRlbmNlLFxuICAgICAgYXJnczogaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGQgPT4gaXguYXJndW1lbnRzW2RdLmFzQXJndW1lbnQpLFxuICAgICAgZGF0YToge30sXG4gICAgICBpbnRlcmFjdGlvbjogaXgsXG4gICAgICB2b3VjaGVyOiBjcmVhdGVTaWduYWJsZVZvdWNoZXIoaXgpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiYnVpbGRTaWduYWJsZVwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBGb3JFbmNvZGluZyhpeCkge1xuICBjb25zdCBwYXllckFkZHJlc3MgPSBzYW5zUHJlZml4KChBcnJheS5pc0FycmF5KGl4LnBheWVyKSA/IGl4LmFjY291bnRzW2l4LnBheWVyWzBdXSA6IGl4LmFjY291bnRzW2l4LnBheWVyXSkuYWRkcik7XG4gIHJldHVybiB7XG4gICAgY2FkZW5jZTogaXgubWVzc2FnZS5jYWRlbmNlLFxuICAgIHJlZkJsb2NrOiBpeC5tZXNzYWdlLnJlZkJsb2NrIHx8IG51bGwsXG4gICAgY29tcHV0ZUxpbWl0OiBpeC5tZXNzYWdlLmNvbXB1dGVMaW1pdCxcbiAgICBhcmd1bWVudHM6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChpZCA9PiBpeC5hcmd1bWVudHNbaWRdLmFzQXJndW1lbnQpLFxuICAgIHByb3Bvc2FsS2V5OiB7XG4gICAgICBhZGRyZXNzOiBzYW5zUHJlZml4KGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5hZGRyKSxcbiAgICAgIGtleUlkOiBpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0ua2V5SWQsXG4gICAgICBzZXF1ZW5jZU51bTogaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLnNlcXVlbmNlTnVtXG4gICAgfSxcbiAgICBwYXllcjogcGF5ZXJBZGRyZXNzLFxuICAgIGF1dGhvcml6ZXJzOiBpeC5hdXRob3JpemF0aW9ucy5tYXAoY2lkID0+IHNhbnNQcmVmaXgoaXguYWNjb3VudHNbY2lkXS5hZGRyKSkucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICByZXR1cm4gcHJldi5maW5kKGl0ZW0gPT4gaXRlbSA9PT0gY3VycmVudCkgPyBwcmV2IDogWy4uLnByZXYsIGN1cnJlbnRdO1xuICAgIH0sIFtdKVxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVmFsaWRhdG9ycyhpeCkge1xuICBjb25zdCB2YWxpZGF0b3JzID0gZ2V0KGl4LCBcIml4LnZhbGlkYXRvcnNcIiwgW10pO1xuICByZXR1cm4gcGlwZShpeCwgdmFsaWRhdG9ycy5tYXAoY2IgPT4gaXggPT4gY2IoaXgsIHtcbiAgICBPayxcbiAgICBCYWRcbiAgfSkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUZpbmFsTm9ybWFsaXphdGlvbihpeCkge1xuICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoaXguYWNjb3VudHMpKSB7XG4gICAgaXguYWNjb3VudHNba2V5XS5hZGRyID0gc2Fuc1ByZWZpeChpeC5hY2NvdW50c1trZXldLmFkZHIpO1xuICB9XG4gIHJldHVybiBpeDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVZvdWNoZXJJbnRlcmNlcHQoaXgpIHtcbiAgY29uc3QgZm4gPSBnZXQoaXgsIFwiaXgudm91Y2hlci1pbnRlcmNlcHRcIik7XG4gIGlmIChpc0ZuJDMoZm4pKSB7XG4gICAgYXdhaXQgZm4oY3JlYXRlU2lnbmFibGVWb3VjaGVyKGl4KSk7XG4gIH1cbiAgcmV0dXJuIGl4O1xufVxuXG5jb25zdCBERUZBVUxUX0NPTVBVVEVfTElNSVQgPSAxMDA7XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ29tcHV0ZUxpbWl0KGl4KSB7XG4gIGlmIChpc1RyYW5zYWN0aW9uKGl4KSkge1xuICAgIGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0ID0gaXgubWVzc2FnZS5jb21wdXRlTGltaXQgfHwgKGF3YWl0IGNvbmZpZy5nZXQoXCJmY2wubGltaXRcIikpO1xuICAgIGlmICghaXgubWVzc2FnZS5jb21wdXRlTGltaXQpIHtcbiAgICAgIGxvZ2dlci5sb2cuZGVwcmVjYXRlKHtcbiAgICAgICAgcGtnOiBcIkZDTC9TREtcIixcbiAgICAgICAgc3ViamVjdDogXCJUaGUgYnVpbHQtaW4gZGVmYXVsdCBjb21wdXRlIGxpbWl0IChERUZBVUxUX0NPTVBVVEVfTElNSVQ9MTApXCIsXG4gICAgICAgIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9zZGsvVFJBTlNJVElPTlMubWQjMDAwOS1kZXByZWNhdGUtZGVmYXVsdC1jb21wdXRlLWxpbWl0XCJcbiAgICAgIH0pO1xuICAgICAgaXgubWVzc2FnZS5jb21wdXRlTGltaXQgPSBERUZBVUxUX0NPTVBVVEVfTElNSVQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpeDtcbn1cblxuY29uc3Qgbm9vcCA9IHYgPT4gdjtcbmNvbnN0IGRlYnVnID0gZnVuY3Rpb24gKGtleSkge1xuICBsZXQgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gIHJldHVybiBhc3luYyBpeCA9PiB7XG4gICAgY29uc3QgYWNjdHMgPSBpeCA9PiBbXCJcXG5BY2NvdW50czpcIiwge1xuICAgICAgcHJvcG9zZXI6IGl4LnByb3Bvc2VyLFxuICAgICAgYXV0aG9yaXphdGlvbnM6IGl4LmF1dGhvcml6YXRpb25zLFxuICAgICAgcGF5ZXI6IGl4LnBheWVyXG4gICAgfSwgXCJcXG5cXG5EZXRhaWxzOlwiLCBpeC5hY2NvdW50c10uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtc2cgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG1zZ1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBkZWJ1Z1ske2tleX1dIC0tLVxcbmAsIC4uLm1zZywgXCJcXG5cXG5cXG4tLS1cIik7XG4gICAgfTtcbiAgICBpZiAoYXdhaXQgY29uZmlnLmdldChgZGVidWcuJHtrZXl9YCkpIGF3YWl0IGZuKGl4LCBsb2csIGFjY3RzKTtcbiAgICByZXR1cm4gaXg7XG4gIH07XG59O1xuY29uc3QgcmVzb2x2ZSA9IHBpcGUoW3Jlc29sdmVDYWRlbmNlLCBkZWJ1ZyhcImNhZGVuY2VcIiwgKGl4LCBsb2cpID0+IGxvZyhpeC5tZXNzYWdlLmNhZGVuY2UpKSwgcmVzb2x2ZUNvbXB1dGVMaW1pdCwgZGVidWcoXCJjb21wdXRlIGxpbWl0XCIsIChpeCwgbG9nKSA9PiBsb2coaXgubWVzc2FnZS5jb21wdXRlTGltaXQpKSwgcmVzb2x2ZUFyZ3VtZW50cywgZGVidWcoXCJhcmd1bWVudHNcIiwgKGl4LCBsb2cpID0+IGxvZyhpeC5tZXNzYWdlLmFyZ3VtZW50cywgaXgubWVzc2FnZSkpLCByZXNvbHZlQWNjb3VudHMsIGRlYnVnKFwiYWNjb3VudHNcIiwgKGl4LCBsb2csIGFjY3RzKSA9PiBsb2coLi4uYWNjdHMoaXgpKSksIC8qIHNwZWNpYWwgKi9leGVjRmV0Y2hSZWYsIC8qIHNwZWNpYWwgKi9leGVjRmV0Y2hTZXF1ZW5jZU51bWJlciwgcmVzb2x2ZVNpZ25hdHVyZXMsIGRlYnVnKFwic2lnbmF0dXJlc1wiLCAoaXgsIGxvZywgYWNjdHMpID0+IGxvZyguLi5hY2N0cyhpeCkpKSwgcmVzb2x2ZUZpbmFsTm9ybWFsaXphdGlvbiwgcmVzb2x2ZVZhbGlkYXRvcnMsIHJlc29sdmVWb3VjaGVySW50ZXJjZXB0LCBkZWJ1ZyhcInJlc29sdmVkXCIsIChpeCwgbG9nKSA9PiBsb2coaXgpKV0pO1xuYXN5bmMgZnVuY3Rpb24gZXhlY0ZldGNoUmVmKGl4KSB7XG4gIGlmIChpc1RyYW5zYWN0aW9uKGl4KSAmJiBpeC5tZXNzYWdlLnJlZkJsb2NrID09IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gYXdhaXQgY29uZmlnKCkuZ2V0KFwiYWNjZXNzTm9kZS5hcGlcIik7XG4gICAgY29uc3Qgc2VuZEZuID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcInNkay50cmFuc3BvcnRcIiwgXCJzZGsuc2VuZFwiXSwgc2VuZCQxKTtcbiAgICBpbnZhcmlhbnQkMShzZW5kRm4sIGBSZXF1aXJlZCB2YWx1ZSBmb3Igc2RrLnRyYW5zcG9ydCBpcyBub3QgZGVmaW5lZCBpbiBjb25maWcuIFNlZTogJHtcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmNsLWpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9DSEFOR0VMT0cubWQjMDA1Ny1hbHBoYTEtLS0tMjAyMi0wMS0yMVwifWApO1xuICAgIGl4Lm1lc3NhZ2UucmVmQmxvY2sgPSAoYXdhaXQgc2VuZEZuKGJ1aWxkKFtnZXRCbG9jaygpXSksIHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgQnVmZmVyLFxuICAgICAgaXg6IGl4TW9kdWxlXG4gICAgfSwge1xuICAgICAgbm9kZVxuICAgIH0pLnRoZW4oZGVjb2RlUmVzcG9uc2UpKS5pZDtcbiAgfVxuICByZXR1cm4gaXg7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjRmV0Y2hTZXF1ZW5jZU51bWJlcihpeCkge1xuICBpZiAoaXNUcmFuc2FjdGlvbihpeCkpIHtcbiAgICB2YXIgYWNjdCA9IE9iamVjdC52YWx1ZXMoaXguYWNjb3VudHMpLmZpbmQoYSA9PiBhLnJvbGUucHJvcG9zZXIpO1xuICAgIGludmFyaWFudCQxKGFjY3QsIGBUcmFuc2FjdGlvbnMgcmVxdWlyZSBhIHByb3Bvc2VyYCk7XG4gICAgaWYgKGFjY3Quc2VxdWVuY2VOdW0gPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IGNvbmZpZygpLmdldChcImFjY2Vzc05vZGUuYXBpXCIpO1xuICAgICAgY29uc3Qgc2VuZEZuID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcInNkay50cmFuc3BvcnRcIiwgXCJzZGsuc2VuZFwiXSwgc2VuZCQxKTtcbiAgICAgIGludmFyaWFudCQxKHNlbmRGbiwgYFJlcXVpcmVkIHZhbHVlIGZvciBzZGsudHJhbnNwb3J0IGlzIG5vdCBkZWZpbmVkIGluIGNvbmZpZy4gU2VlOiAke1wiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mY2wtanMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL0NIQU5HRUxPRy5tZCMwMDU3LWFscGhhMS0tLS0yMDIyLTAxLTIxXCJ9YCk7XG4gICAgICBpeC5hY2NvdW50c1thY2N0LnRlbXBJZF0uc2VxdWVuY2VOdW0gPSBhd2FpdCBzZW5kRm4oYXdhaXQgYnVpbGQoW2dldEFjY291bnQoYWNjdC5hZGRyKV0pLCB7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIEJ1ZmZlcixcbiAgICAgICAgaXg6IGl4TW9kdWxlXG4gICAgICB9LCB7XG4gICAgICAgIG5vZGVcbiAgICAgIH0pLnRoZW4oZGVjb2RlUmVzcG9uc2UpLnRoZW4oYWNjdCA9PiBhY2N0LmtleXMpLnRoZW4oa2V5cyA9PiBrZXlzLmZpbmQoa2V5ID0+IGtleS5pbmRleCA9PT0gYWNjdC5rZXlJZCkpLnRoZW4oa2V5ID0+IGtleS5zZXF1ZW5jZU51bWJlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBpeDtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBbcHJlZGljYXRlLCBtZXNzYWdlXSA9IGFyZ3M7XG4gICAgcmV0dXJuIGludmFyaWFudCgoaXgsIF9yZWYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIE9rLFxuICAgICAgICBCYWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIHByZWRpY2F0ZSA/IE9rKGl4KSA6IEJhZChpeCwgbWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgW2ZuXSA9IGFyZ3M7XG4gIHJldHVybiBpeCA9PiBmbihpeCwge1xuICAgIE9rLFxuICAgIEJhZFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBTZW5kcyBhcmJpdHJhcnkgc2NyaXB0cywgdHJhbnNhY3Rpb25zLCBhbmQgcmVxdWVzdHMgdG8gRmxvd1xuICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBhcmdzIC0gQW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgdGFrZSBpbnRlcmFjdGlvbiBhbmQgcmV0dXJuIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgcmVzcG9uc2VcbiAqL1xuY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHNlbmRGbiA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJzZGsudHJhbnNwb3J0XCIsIFwic2RrLnNlbmRcIl0sIG9wdHMuc2VuZCB8fCBzZW5kJDEpO1xuICBpbnZhcmlhbnQoc2VuZEZuLCBgUmVxdWlyZWQgdmFsdWUgZm9yIHNkay50cmFuc3BvcnQgaXMgbm90IGRlZmluZWQgaW4gY29uZmlnLiBTZWU6ICR7XCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2ZjbC1qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy9zZGsvQ0hBTkdFTE9HLm1kIzAwNTctYWxwaGExLS0tLTIwMjItMDEtMjFcIn1gKTtcbiAgY29uc3QgcmVzb2x2ZUZuID0gYXdhaXQgY29uZmlnLmZpcnN0KFtcInNkay5yZXNvbHZlXCJdLCBvcHRzLnJlc29sdmUgfHwgcmVzb2x2ZSk7XG4gIG9wdHMubm9kZSA9IG9wdHMubm9kZSB8fCAoYXdhaXQgY29uZmlnKCkuZ2V0KFwiYWNjZXNzTm9kZS5hcGlcIikpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkgYXJncyA9IHBpcGUoaW50ZXJhY3Rpb24oKSwgYXJncyk7XG4gIHJldHVybiBzZW5kRm4oYXdhaXQgcmVzb2x2ZUZuKGFyZ3MpLCB7XG4gICAgY29uZmlnLFxuICAgIHJlc3BvbnNlLFxuICAgIGl4OiBpeE1vZHVsZSxcbiAgICBCdWZmZXJcbiAgfSwgb3B0cyk7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBkZWNvZGUocmVzcG9uc2UpIHtcbiAgY29uc3QgZGVjb2RlcnNGcm9tQ29uZmlnID0gYXdhaXQgY29uZmlnKCkud2hlcmUoL15kZWNvZGVyXFwuLyk7XG4gIGNvbnN0IGRlY29kZXJzID0gT2JqZWN0LmVudHJpZXMoZGVjb2RlcnNGcm9tQ29uZmlnKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IFtwYXR0ZXJuLCB4Zm9ybV0gPSBfcmVmO1xuICAgIHBhdHRlcm4gPSBgLyR7cGF0dGVybi5yZXBsYWNlKC9eZGVjb2RlclxcLi8sIFwiXCIpfSQvYDtcbiAgICByZXR1cm4gW3BhdHRlcm4sIHhmb3JtXTtcbiAgfSk7XG4gIHJldHVybiBkZWNvZGVSZXNwb25zZShyZXNwb25zZSwgT2JqZWN0LmZyb21FbnRyaWVzKGRlY29kZXJzKSk7XG59XG5cbmNvbnN0IGZpbmRQYXlsb2FkU2lnbmVycyA9IHZvdWNoZXIgPT4ge1xuICAvLyBQYXlsb2FkIFNpZ25lcnMgQXJlOiAoYXV0aG9yaXplcnMgKyBwcm9wb3NlcikgLSBwYXllclxuICBsZXQgcGF5bG9hZCA9IG5ldyBTZXQodm91Y2hlci5hdXRob3JpemVycyk7XG4gIHBheWxvYWQuYWRkKHZvdWNoZXIucHJvcG9zYWxLZXkuYWRkcmVzcyk7XG4gIHBheWxvYWQuZGVsZXRlKHZvdWNoZXIucGF5ZXIpO1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXlsb2FkKS5tYXAod2l0aFByZWZpeCk7XG59O1xuY29uc3QgZmluZEVudmVsb3BlU2lnbmVycyA9IHZvdWNoZXIgPT4ge1xuICAvLyBFbnZlbG9wZSBTaWduZXJzIEFyZTogKHBheWVyKVxuICBsZXQgZW52ZWxvcGUgPSBuZXcgU2V0KFt2b3VjaGVyLnBheWVyXSk7XG4gIHJldHVybiBBcnJheS5mcm9tKGVudmVsb3BlKS5tYXAod2l0aFByZWZpeCk7XG59O1xuY2xhc3MgVW5hYmxlVG9EZXRlcm1pbmVNZXNzYWdlRW5jb2RpbmdUeXBlRm9yU2lnbmVyQWRkcmVzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmVyQWRkcmVzcykge1xuICAgIGNvbnN0IG1zZyA9IGBcbiAgICAgICAgRW5jb2RlIE1lc3NhZ2UgRnJvbSBTaWduYWJsZSBFcnJvcjogVW5hYmxlIHRvIGRldGVybWluZSBtZXNzYWdlIGVuY29kaW5nIGZvciBzaWduZXIgYWRkcmVzc3M6ICR7c2lnbmVyQWRkcmVzc30uIFxuICAgICAgICBQbGVhc2UgZW5zdXJlIHRoZSBhZGRyZXNzOiAke3NpZ25lckFkZHJlc3N9IGlzIGludGVuZGVkIHRvIHNpZ24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIGFzIHNwZWNpZmllZCBieSB0aGUgdHJhbnNhY3Rpb24gc2lnbmFibGUuXG4gICAgICBgLnRyaW0oKTtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMubmFtZSA9IFwiVW5hYmxlIFRvIERldGVybWluZSBNZXNzYWdlIEVuY29kaW5nIEZvciBTaWduZXIgQWRkcmVzc3NcIjtcbiAgfVxufVxuY29uc3QgZW5jb2RlTWVzc2FnZUZyb21TaWduYWJsZSA9IChzaWduYWJsZSwgc2lnbmVyQWRkcmVzcykgPT4ge1xuICBsZXQgcGF5bG9hZFNpZ25lcnMgPSBmaW5kUGF5bG9hZFNpZ25lcnMoc2lnbmFibGUudm91Y2hlcik7XG4gIGxldCBlbnZlbG9wZVNpZ25lcnMgPSBmaW5kRW52ZWxvcGVTaWduZXJzKHNpZ25hYmxlLnZvdWNoZXIpO1xuICBjb25zdCBpc1BheWxvYWRTaWduZXIgPSBwYXlsb2FkU2lnbmVycy5pbmNsdWRlcyh3aXRoUHJlZml4KHNpZ25lckFkZHJlc3MpKTtcbiAgY29uc3QgaXNFbnZlbG9wZVNpZ25lciA9IGVudmVsb3BlU2lnbmVycy5pbmNsdWRlcyh3aXRoUHJlZml4KHNpZ25lckFkZHJlc3MpKTtcbiAgaWYgKCFpc1BheWxvYWRTaWduZXIgJiYgIWlzRW52ZWxvcGVTaWduZXIpIHtcbiAgICB0aHJvdyBuZXcgVW5hYmxlVG9EZXRlcm1pbmVNZXNzYWdlRW5jb2RpbmdUeXBlRm9yU2lnbmVyQWRkcmVzcyhzaWduZXJBZGRyZXNzKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0ge1xuICAgIGNhZGVuY2U6IHNpZ25hYmxlLnZvdWNoZXIuY2FkZW5jZSxcbiAgICByZWZCbG9jazogc2lnbmFibGUudm91Y2hlci5yZWZCbG9jayxcbiAgICBjb21wdXRlTGltaXQ6IHNpZ25hYmxlLnZvdWNoZXIuY29tcHV0ZUxpbWl0LFxuICAgIGFyZ3VtZW50czogc2lnbmFibGUudm91Y2hlci5hcmd1bWVudHMsXG4gICAgcHJvcG9zYWxLZXk6IHtcbiAgICAgIC4uLnNpZ25hYmxlLnZvdWNoZXIucHJvcG9zYWxLZXksXG4gICAgICBhZGRyZXNzOiBzYW5zUHJlZml4KHNpZ25hYmxlLnZvdWNoZXIucHJvcG9zYWxLZXkuYWRkcmVzcylcbiAgICB9LFxuICAgIHBheWVyOiBzYW5zUHJlZml4KHNpZ25hYmxlLnZvdWNoZXIucGF5ZXIpLFxuICAgIGF1dGhvcml6ZXJzOiBzaWduYWJsZS52b3VjaGVyLmF1dGhvcml6ZXJzLm1hcChzYW5zUHJlZml4KSxcbiAgICBwYXlsb2FkU2lnczogc2lnbmFibGUudm91Y2hlci5wYXlsb2FkU2lncy5tYXAocHMgPT4gKHtcbiAgICAgIC4uLnBzLFxuICAgICAgYWRkcmVzczogc2Fuc1ByZWZpeChwcy5hZGRyZXNzKVxuICAgIH0pKVxuICB9O1xuICByZXR1cm4gaXNQYXlsb2FkU2lnbmVyID8gZW5jb2RlVHJhbnNhY3Rpb25QYXlsb2FkKG1lc3NhZ2UpIDogZW5jb2RlVHJhbnNhY3Rpb25FbnZlbG9wZShtZXNzYWdlKTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRvcihjYikge1xuICByZXR1cm4gdXBkYXRlKFwiaXgudmFsaWRhdG9yc1wiLCB2YWxpZGF0b3JzID0+IEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzLnB1c2goY2IpIDogW2NiXSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhcnRpYWwgaW50ZXJhY3Rpb24gdG8gYSBibG9jayBhdCBhIHNwZWNpZmljIGhlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGJsb2NrIHRvIGdldFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgcGFydGlhbCBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXRCbG9ja0hlaWdodChoZWlnaHQpIHtcbiAgcmV0dXJuIHBpcGUoW2l4ID0+IHtcbiAgICBpeC5ibG9jay5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGl4O1xuICB9LCB2YWxpZGF0b3IoaXggPT4ge1xuICAgIGlmICh0eXBlb2YgaXguYmxvY2suaXNTZWFsZWQgPT09IFwiYm9vbGVhblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc3BlY2lmeSBib3RoIGJsb2NrIGhlaWdodCBhbmQgaXNTZWFsZWQuXCIpO1xuICAgIGlmIChpeC5ibG9jay5pZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNwZWNpZnkgYm90aCBibG9jayBoZWlnaHQgYW5kIGJsb2NrIGlkLlwiKTtcbiAgICByZXR1cm4gaXg7XG4gIH0pXSk7XG59XG5cbmZ1bmN0aW9uIGF0QmxvY2tJZChpZCkge1xuICByZXR1cm4gcGlwZShbaXggPT4ge1xuICAgIGl4LmJsb2NrLmlkID0gaWQ7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfSwgdmFsaWRhdG9yKChpeCwgX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICBPayxcbiAgICAgIEJhZFxuICAgIH0gPSBfcmVmO1xuICAgIGlmIChpc0dldEFjY291bnQoaXgpKSByZXR1cm4gQmFkKGl4LCBcIlVuYWJsZSB0byBzcGVjaWZ5IGEgYmxvY2sgaWQgd2l0aCBhIEdldCBBY2NvdW50IGludGVyYWN0aW9uLlwiKTtcbiAgICBpZiAodHlwZW9mIGl4LmJsb2NrLmlzU2VhbGVkID09PSBcImJvb2xlYW5cIikgcmV0dXJuIEJhZChpeCwgXCJVbmFibGUgdG8gc3BlY2lmeSBib3RoIGJsb2NrIGlkIGFuZCBpc1NlYWxlZC5cIik7XG4gICAgaWYgKGl4LmJsb2NrLmhlaWdodCkgcmV0dXJuIEJhZChpeCwgXCJVbmFibGUgdG8gc3BlY2lmeSBib3RoIGJsb2NrIGlkIGFuZCBibG9jayBoZWlnaHQuXCIpO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH0pXSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuQWNjb3VudH0gQWNjb3VudFxuICovXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uICBSZXR1cm5zIHRoZSBkZXRhaWxzIG9mIGFuIGFjY291bnQgZnJvbSB0aGVpciBwdWJsaWMgYWRkcmVzc1xuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBhY2NvdW50XG4gKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5T3B0aW9uc10gLSBRdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW3F1ZXJ5T3B0aW9ucy5oZWlnaHRdIC0gQmxvY2sgaGVpZ2h0IHRvIHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5T3B0aW9ucy5pZF0gLSBCbG9jayBJRCB0byBxdWVyeVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnQ+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFjY291bnQgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWNjb3VudChhZGRyZXNzKSB7XG4gIGxldCB7XG4gICAgaGVpZ2h0LFxuICAgIGlkXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICBpbnZhcmlhbnQkMSghKGlkICYmIGhlaWdodCksIGBNZXRob2Q6IGFjY291bnQgLS0gQ2Fubm90IHBhc3MgXCJpZFwiIGFuZCBcImhlaWdodFwiIHNpbXVsdGFuZW91c2x5YCk7XG5cbiAgLy8gR2V0IGFjY291bnQgYnkgSURcbiAgaWYgKGlkKSByZXR1cm4gc2VuZChbZ2V0QWNjb3VudChhZGRyZXNzKSwgYXRCbG9ja0lkKGlkKV0sIG9wdHMpLnRoZW4oZGVjb2RlUmVzcG9uc2UpO1xuXG4gIC8vIEdldCBhY2NvdW50IGJ5IGhlaWdodFxuICBpZiAoaGVpZ2h0KSByZXR1cm4gc2VuZChbZ2V0QWNjb3VudChhZGRyZXNzKSwgYXRCbG9ja0hlaWdodChoZWlnaHQpXSwgb3B0cykudGhlbihkZWNvZGVSZXNwb25zZSk7XG4gIHJldHVybiBzZW5kKFtnZXRBY2NvdW50KGFkZHJlc3MpXSwgb3B0cykudGhlbihkZWNvZGVSZXNwb25zZSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIkBvbmZsb3cvdHlwZWRlZnNcIikuQmxvY2t9IEJsb2NrXG4gKi9cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgbGF0ZXN0IGJsb2NrIChvcHRpb25hbGx5IHNlYWxlZCBvciBub3QpLCBieSBpZCwgb3IgYnkgaGVpZ2h0XG4gKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5T3B0aW9uc10gLSBRdWVyeSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtxdWVyeU9wdGlvbnMuc2VhbGVkPWZhbHNlXSAtIFdoZXRoZXIgdG8gcXVlcnkgZm9yIGEgc2VhbGVkIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gW3F1ZXJ5T3B0aW9ucy5oZWlnaHRdIC0gQmxvY2sgaGVpZ2h0IHRvIHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5T3B0aW9ucy5pZF0gLSBCbG9jayBJRCB0byBxdWVyeVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2NrPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJsb2NrIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGJsb2NrKCkge1xuICBsZXQge1xuICAgIHNlYWxlZCA9IGZhbHNlLFxuICAgIGlkLFxuICAgIGhlaWdodFxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpbnZhcmlhbnQkMSghKHNlYWxlZCAmJiBpZCB8fCBzZWFsZWQgJiYgaGVpZ2h0KSwgYE1ldGhvZDogYmxvY2sgLS0gQ2Fubm90IHBhc3MgXCJzZWFsZWRcIiB3aXRoIFwiaWRcIiBvciBcImhlaWdodFwiYCk7XG4gIGludmFyaWFudCQxKCEoaWQgJiYgaGVpZ2h0KSwgYE1ldGhvZDogYmxvY2sgLS0gQ2Fubm90IHBhc3MgXCJpZFwiIGFuZCBcImhlaWdodFwiIHNpbXVsdGFuZW91c2x5YCk7XG5cbiAgLy8gR2V0IGJsb2NrIGJ5IElEXG4gIGlmIChpZCkgcmV0dXJuIHNlbmQoW2dldEJsb2NrKCksIGF0QmxvY2tJZChpZCldLCBvcHRzKS50aGVuKGRlY29kZVJlc3BvbnNlKTtcblxuICAvLyBHZXQgYmxvY2sgYnkgaGVpZ2h0XG4gIGlmIChoZWlnaHQpIHJldHVybiBzZW5kKFtnZXRCbG9jaygpLCBhdEJsb2NrSGVpZ2h0KGhlaWdodCldLCBvcHRzKS50aGVuKGRlY29kZVJlc3BvbnNlKTtcblxuICAvLyBHZXQgbGF0ZXN0IGJsb2NrXG4gIHJldHVybiBzZW5kKFtnZXRCbG9jayhzZWFsZWQpXSwgb3B0cykudGhlbihkZWNvZGVSZXNwb25zZSk7XG59XG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb25zKCkge1xuICBsZXQgYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gcGlwZShheC5tYXAoYXV0aHogPT4ge1xuICAgIHJldHVybiBwcmVwQWNjb3VudChhdXRoeiwge1xuICAgICAgcm9sZTogQVVUSE9SSVpFUlxuICAgIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBhdXRob3JpemF0aW9uKGFkZHIsIHNpZ25pbmdGdW5jdGlvbiwga2V5SWQsIHNlcXVlbmNlTnVtKSB7XG4gIHJldHVybiB7XG4gICAgYWRkcixcbiAgICBzaWduaW5nRnVuY3Rpb24sXG4gICAga2V5SWQsXG4gICAgc2VxdWVuY2VOdW1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRzKGV2ZW50VHlwZSwgc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbmQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBsb2dnZXIubG9nLmRlcHJlY2F0ZSh7XG4gICAgICBwa2c6IFwiRkNML1NES1wiLFxuICAgICAgc3ViamVjdDogXCJQYXNzaW5nIGEgc3RhcnQgYW5kIGVuZCBpbnRvIGdldEV2ZW50c1wiLFxuICAgICAgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3Nkay9UUkFOU0lUSU9OUy5tZCMwMDA1LWRlcHJlY2F0ZS1zdGFydC1lbmQtZ2V0LWV2ZW50cy1idWlsZGVyXCJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGlwZShbbWFrZUdldEV2ZW50cywgaXggPT4ge1xuICAgIGl4LmV2ZW50cy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgaXguZXZlbnRzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgaXguZXZlbnRzLmVuZCA9IGVuZDtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgaW5zdGFuY2VzIG9mIGEgcGFydGljdWxhciBldmVudCAoYnkgbmFtZSkgd2l0aGluIGEgaGVpZ2h0IHJhbmdlXG4gKiBOT1RFOlxuICogLSBUaGUgYmxvY2sgcmFuZ2UgcHJvdmlkZWQgbXVzdCBiZSBmcm9tIHRoZSBjdXJyZW50IHNwb3JrLlxuICogLSBUaGUgYmxvY2sgcmFuZ2UgcHJvdmlkZWQgbXVzdCBiZSAyNTAgYmxvY2tzIG9yIGxvd2VyIHBlciByZXF1ZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tQmxvY2tIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBibG9jayB0byBzdGFydCBsb29raW5nIGZvciBldmVudHMgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0Jsb2NrSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgYmxvY2sgdG8gc3RvcCBsb29raW5nIGZvciBldmVudHMgKGluY2x1c2l2ZSlcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBbiBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRzQXRCbG9ja0hlaWdodFJhbmdlKGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0KSB7XG4gIHJldHVybiBwaXBlKFttYWtlR2V0RXZlbnRzLCBpeCA9PiB7XG4gICAgaXguZXZlbnRzLmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcbiAgICBpeC5ldmVudHMuc3RhcnQgPSBmcm9tQmxvY2tIZWlnaHQ7XG4gICAgaXguZXZlbnRzLmVuZCA9IHRvQmxvY2tIZWlnaHQ7XG4gICAgcmV0dXJuIE9rKGl4KTtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWxsIGluc3RhbmNlcyBvZiBhIHBhcnRpY3VsYXIgZXZlbnQgKGJ5IG5hbWUpIHdpdGhpbiBhIHNldCBvZiBibG9ja3MsIHNwZWNpZmllZCBieSBibG9jayBpZHNcbiAqIE5PVEU6XG4gKiAtIFRoZSBibG9jayByYW5nZSBwcm92aWRlZCBtdXN0IGJlIGZyb20gdGhlIGN1cnJlbnQgc3BvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGdldFxuICogQHBhcmFtIHtudW1iZXJbXX0gYmxvY2tJZHMgLSBUaGUgaWRzIG9mIHRoZSBibG9ja3MgdG8gbG9vayBmb3IgZXZlbnRzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50c0F0QmxvY2tJZHMoZXZlbnROYW1lKSB7XG4gIGxldCBibG9ja0lkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHJldHVybiBwaXBlKFttYWtlR2V0RXZlbnRzLCBpeCA9PiB7XG4gICAgaXguZXZlbnRzLmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcbiAgICBpeC5ldmVudHMuYmxvY2tJZHMgPSBibG9ja0lkcztcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaW50ZXJhY3Rpb24gdG8gZ2V0IGEgYmxvY2sgaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NlYWxlZF0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgYmxvY2sgc2hvdWxkIGJlIHNlYWxlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEFuIGludGVyYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRCbG9ja0hlYWRlcigpIHtcbiAgbGV0IGlzU2VhbGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICByZXR1cm4gcGlwZShbbWFrZUdldEJsb2NrSGVhZGVyLCBpeCA9PiB7XG4gICAgaXguYmxvY2suaXNTZWFsZWQgPSBpc1NlYWxlZDtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gQSBidWlsZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgYSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHRyYW5zYWN0aW9uIGlkcyBieSBpdHMgY29sbGVjdGlvbiBpZFxuICogTk9URTpcbiAqIC0gVGhlIGJsb2NrIHJhbmdlIHByb3ZpZGVkIG11c3QgYmUgZnJvbSB0aGUgY3VycmVudCBzcG9yay4gQWxsIGV2ZW50cyBlbWl0dGVkIGR1cmluZyBwYXN0IHNwb3JrcyBpcyBjdXJyZW50IHVuYXZhaWxhYmxlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtpZF0gLSBUaGUgaWQgb2YgdGhlIGNvbGxlY3Rpb24gdG8gZ2V0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldENvbGxlY3Rpb24oKSB7XG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgcmV0dXJuIHBpcGUoW21ha2VHZXRDb2xsZWN0aW9uLCBpeCA9PiB7XG4gICAgaXguY29sbGVjdGlvbi5pZCA9IGlkO1xuICAgIHJldHVybiBpeDtcbiAgfV0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHN0YXR1cyBvZiB0cmFuc2FjdGlvblxuICogTk9URTogVGhlIHRyYW5zYWN0aW9uSUQgcHJvdmlkZWQgbXVzdCBiZSBmcm9tIHRoZSBjdXJyZW50IHNwb3JrLlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgLSBUaGUgaWQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGdldCBzdGF0dXNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBbiBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25JZCkge1xuICByZXR1cm4gcGlwZShbbWFrZUdldFRyYW5zYWN0aW9uU3RhdHVzLCBpeCA9PiB7XG4gICAgaXgudHJhbnNhY3Rpb24uaWQgPSB0cmFuc2FjdGlvbklkO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH1dKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIGJ1aWxkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbiAqIE5PVEU6IFRoZSB0cmFuc2FjdGlvbklEIHByb3ZpZGVkIG11c3QgYmUgZnJvbSB0aGUgY3VycmVudCBzcG9yay5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvbklkIC0gVGhlIGlkIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBnZXRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBBbiBpbnRlcmFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JZCkge1xuICByZXR1cm4gcGlwZShbbWFrZUdldFRyYW5zYWN0aW9uLCBpeCA9PiB7XG4gICAgaXgudHJhbnNhY3Rpb24uaWQgPSB0cmFuc2FjdGlvbklkO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH1dKTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV0d29ya1BhcmFtZXRlcnMoKSB7XG4gIHJldHVybiBwaXBlKFttYWtlR2V0TmV0d29ya1BhcmFtZXRlcnMsIGl4ID0+IHtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbmZ1bmN0aW9uIGxpbWl0KGNvbXB1dGVMaW1pdCkge1xuICByZXR1cm4gaXggPT4ge1xuICAgIGl4Lm1lc3NhZ2UuY29tcHV0ZUxpbWl0ID0gY29tcHV0ZUxpbWl0O1xuICAgIHJldHVybiBpeDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIHV0aWxpdHkgYnVpbGRlciB0byBiZSB1c2VkIHdpdGggb3RoZXIgYnVpbGRlcnMgdG8gcGFzcyBpbiBhcmd1bWVudHMgd2l0aCBhIHZhbHVlIGFuZCBzdXBwb3J0ZWQgdHlwZVxuICogQHBhcmFtIHtBcnJheS48Kj59IGF4IC0gQW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFyZ3MoKSB7XG4gIGxldCBheCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHJldHVybiBwaXBlKGF4Lm1hcChtYWtlQXJndW1lbnQpKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBBIHV0aWxpdHkgYnVpbGRlciB0byBiZSB1c2VkIHdpdGggZmNsLmFyZ3NbLi4uXSB0byBjcmVhdGUgRkNMIHN1cHBvcnRlZCBhcmd1bWVudHMgZm9yIGludGVyYWN0aW9uc1xuICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0geGZvcm0gLSBBIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgdmFsdWVcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQW4gYXJndW1lbnQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFyZyh2YWx1ZSwgeGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB4Zm9ybVxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcm9wb3NlcihhdXRoeikge1xuICByZXR1cm4gcHJlcEFjY291bnQoYXV0aHosIHtcbiAgICByb2xlOiBQUk9QT1NFUlxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcGF5ZXIoYXV0aHopIHtcbiAgcmV0dXJuIHByZXBBY2NvdW50KGF1dGh6LCB7XG4gICAgcm9sZTogUEFZRVJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBpbmcoKSB7XG4gIHJldHVybiBtYWtlUGluZztcbn1cblxuZnVuY3Rpb24gcmVmKHJlZkJsb2NrKSB7XG4gIHJldHVybiBwaXBlKFtpeCA9PiB7XG4gICAgaXgubWVzc2FnZS5yZWZCbG9jayA9IHJlZkJsb2NrO1xuICAgIHJldHVybiBPayhpeCk7XG4gIH1dKTtcbn1cblxuZnVuY3Rpb24gc2NyaXB0KCkge1xuICByZXR1cm4gcGlwZShbbWFrZVNjcmlwdCwgcHV0KFwiaXguY2FkZW5jZVwiLCB0ZW1wbGF0ZSguLi5hcmd1bWVudHMpKV0pO1xufVxuXG5jb25zdCBERUZBVUxUX1NDUklQVF9BQ0NPVU5UUyA9IFtdO1xuY29uc3QgREVGVUFMVF9SRUYgPSBudWxsO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEEgdGVtcGxhdGUgYnVpbGRlciB0byB1c2UgYSBDYWRlbmNlIHRyYW5zYWN0aW9uIGZvciBhbiBpbnRlcmFjdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQW4gaW50ZXJhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4gcGlwZShbbWFrZVRyYW5zYWN0aW9uLCBwdXQoXCJpeC5jYWRlbmNlXCIsIHRlbXBsYXRlKC4uLmFyZ3VtZW50cykpLCBpeCA9PiB7XG4gICAgaXgubWVzc2FnZS5yZWZCbG9jayA9IGl4Lm1lc3NhZ2UucmVmQmxvY2sgfHwgREVGVUFMVF9SRUY7XG4gICAgaXguYXV0aG9yaXphdGlvbnMgPSBpeC5hdXRob3JpemF0aW9ucyB8fCBERUZBVUxUX1NDUklQVF9BQ0NPVU5UUztcbiAgICByZXR1cm4gT2soaXgpO1xuICB9XSk7XG59XG5cbmZ1bmN0aW9uIHZvdWNoZXJJbnRlcmNlcHQoZm4pIHtcbiAgcmV0dXJuIHB1dChcIml4LnZvdWNoZXItaW50ZXJjZXB0XCIsIGZuKTtcbn1cblxuY29uc3QgcmVzb2x2ZVByb3Bvc2VyU2VxdWVuY2VOdW1iZXIgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBub2RlXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gYXN5bmMgaXggPT4ge1xuICAgIGlmICghaXNUcmFuc2FjdGlvbihpeCkpIHJldHVybiBPayhpeCk7XG4gICAgaWYgKGl4LmFjY291bnRzW2l4LnByb3Bvc2VyXS5zZXF1ZW5jZU51bSkgcmV0dXJuIE9rKGl4KTtcbiAgICBjb25zdCBzZW5kRm4gPSBhd2FpdCBjb25maWcuZmlyc3QoW1wic2RrLnRyYW5zcG9ydFwiLCBcInNkay5zZW5kXCJdLCBzZW5kJDEpO1xuICAgIGludmFyaWFudCQxKHNlbmRGbiwgYFJlcXVpcmVkIHZhbHVlIGZvciBzZGsudHJhbnNwb3J0IGlzIG5vdCBkZWZpbmVkIGluIGNvbmZpZy4gU2VlOiAke1wiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mY2wtanMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL0NIQU5HRUxPRy5tZCMwMDU3LWFscGhhMS0tLS0yMDIyLTAxLTIxXCJ9YCk7XG4gICAgY29uc3QgcmVzcG9uc2UkMSA9IGF3YWl0IHNlbmRGbihhd2FpdCBidWlsZChbZ2V0QWNjb3VudChpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uYWRkcildKSwge1xuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgQnVmZmVyLFxuICAgICAgaXg6IGl4TW9kdWxlXG4gICAgfSwge1xuICAgICAgbm9kZVxuICAgIH0pO1xuICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVSZXNwb25zZShyZXNwb25zZSQxKTtcbiAgICBpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uc2VxdWVuY2VOdW0gPSBkZWNvZGVkLmtleXNbaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmtleUlkXS5zZXF1ZW5jZU51bWJlcjtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9O1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVmSWQob3B0cykge1xuICBjb25zdCBub2RlID0gYXdhaXQgY29uZmlnKCkuZ2V0KFwiYWNjZXNzTm9kZS5hcGlcIik7XG4gIGNvbnN0IHNlbmRGbiA9IGF3YWl0IGNvbmZpZy5maXJzdChbXCJzZGsudHJhbnNwb3J0XCIsIFwic2RrLnNlbmRcIl0sIHNlbmQkMSk7XG4gIGludmFyaWFudCQxKHNlbmRGbiwgYFJlcXVpcmVkIHZhbHVlIGZvciBzZGsudHJhbnNwb3J0IGlzIG5vdCBkZWZpbmVkIGluIGNvbmZpZy4gU2VlOiAke1wiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mY2wtanMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL0NIQU5HRUxPRy5tZCMwMDU3LWFscGhhMS0tLS0yMDIyLTAxLTIxXCJ9YCk7XG4gIHZhciBpeDtcbiAgaXggPSBhd2FpdCBwaXBlKGludGVyYWN0aW9uKCksIFtnZXRCbG9jaygpXSk7XG4gIGl4ID0gYXdhaXQgc2VuZEZuKGl4LCB7XG4gICAgY29uZmlnLFxuICAgIHJlc3BvbnNlLFxuICAgIEJ1ZmZlcixcbiAgICBpeDogaXhNb2R1bGVcbiAgfSwge1xuICAgIG5vZGVcbiAgfSk7XG4gIGl4ID0gYXdhaXQgZGVjb2RlUmVzcG9uc2UoaXgpO1xuICByZXR1cm4gaXguaWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVmQmxvY2tJZChvcHRzKSB7XG4gIHJldHVybiBhc3luYyBpeCA9PiB7XG4gICAgaWYgKCFpc1RyYW5zYWN0aW9uKGl4KSkgcmV0dXJuIE9rKGl4KTtcbiAgICBpZiAoaXgubWVzc2FnZS5yZWZCbG9jaykgcmV0dXJuIE9rKGl4KTtcbiAgICBpeC5tZXNzYWdlLnJlZkJsb2NrID0gYXdhaXQgZ2V0UmVmSWQoKTtcbiAgICByZXR1cm4gT2soaXgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtb2NrQWNjb3VudFJlc3BvbnNlKGl4KSB7XG4gIGxldCBudW1iZXJPZktleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDU7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQkMShpeC5hY2NvdW50LCBcIm1vY2tBY2NvdW50UmVzcG9uc2UoaXgpIC0tIGl4LmFjY291bnQgaXMgbWlzc2luZ1wiLCBpeCk7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBpbnZhcmlhbnQkMShpeC5hY2NvdW50LmFkZHIsIFwibW9ja0FjY291bnRSZXNwb25zZShpeCkgLS0gaXguYWNjb3VudC5hZGRyIGlzIG1pc3NpbmdcIiwgaXgpO1xuICBjb25zdCBhZGRyZXNzID0gaXguYWNjb3VudC5hZGRyO1xuICByZXR1cm4ge1xuICAgIGFjY291bnQ6IHtcbiAgICAgIGFkZHI6IGFkZHJlc3MsXG4gICAgICBrZXlzOiBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBudW1iZXJPZktleXNcbiAgICAgIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VxdWVuY2VOdW1iZXI6IDQyXG4gICAgICB9KSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb2NrR2V0QmxvY2tSZXNwb25zZShpeCkge1xuICByZXR1cm4ge1xuICAgIHRhZzogXCJHRVRfQkxPQ0tcIixcbiAgICBibG9jazoge1xuICAgICAgaWQ6IFwiMzJcIlxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlkZW50aXR5ID0gdiA9PiB2O1xuZnVuY3Rpb24gbW9ja1NlbmQoKSB7XG4gIGxldCBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogaWRlbnRpdHk7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBleGVjU2VuZChpeCkge1xuICAgIGl4ID0gYXdhaXQgaXg7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlzR2V0QWNjb3VudChpeCk6XG4gICAgICAgIHJldHVybiBtb2NrQWNjb3VudFJlc3BvbnNlKGl4KTtcbiAgICAgIGNhc2UgaXNHZXRCbG9jayhpeCk6XG4gICAgICAgIHJldHVybiBtb2NrR2V0QmxvY2tSZXNwb25zZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKGl4KTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGlkb2YgPSBhY2N0ID0+IGAke3dpdGhQcmVmaXgoYWNjdC5hZGRyKX0tJHthY2N0LmtleUlkfWA7XG5mdW5jdGlvbiBzaWcob3B0cykge1xuICByZXR1cm4gW1wiU0lHTkFUVVJFXCIsIG9wdHMuYWRkciwgb3B0cy5rZXlJZF0uam9pbihcIi5cIik7XG59XG5mdW5jdGlvbiBhdXRoekZuKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgIGNvbnN0IGFjY3QgPSB7XG4gICAgICAuLi5hY2NvdW50LFxuICAgICAgLi4ub3B0cyxcbiAgICAgIHNpZ25pbmdGdW5jdGlvbjogb3B0cy5zaWduaW5nRnVuY3Rpb24gfHwgYWNjb3VudC5zaWduaW5nRnVuY3Rpb24gfHwgZmFsbGJhY2tTaWduaW5nRnVuY3Rpb25cbiAgICB9O1xuICAgIHJldHVybiBhY2N0O1xuICAgIGZ1bmN0aW9uIGZhbGxiYWNrU2lnbmluZ0Z1bmN0aW9uKHNpZ25hYmxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyOiBhY2N0LmFkZHIsXG4gICAgICAgIGtleUlkOiBhY2N0LmtleUlkLFxuICAgICAgICBzaWduYXR1cmU6IHNpZyhhY2N0KVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhdXRoelJlc29sdmUoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdGVtcElkLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBvcHRzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2NvdW50LFxuICAgICAgdGVtcElkOiB0ZW1wSWQgfHwgXCJXSVRIX1JFU09MVkVcIixcbiAgICAgIHJlc29sdmU6IGF1dGh6Rm4ocmVzdClcbiAgICB9O1xuICB9O1xufVxuY29uc3QgUk9MRSA9IHtcbiAgcHJvcG9zZXI6IGZhbHNlLFxuICBhdXRob3JpemVyOiBmYWxzZSxcbiAgcGF5ZXI6IGZhbHNlXG59O1xuZnVuY3Rpb24gYXV0aHpSZXNvbHZlTWFueSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICBjb25zdCB0ZW1wSWQgPSBvcHRzLnRlbXBJZCB8fCBcIkFVVEhaX1JFU09MVkVfTUFOWVwiO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2NvdW50LFxuICAgICAgdGVtcElkLFxuICAgICAgcmVzb2x2ZTogKCkgPT4gW29wdHMucHJvcG9zZXIgJiYgYXV0aHpGbihvcHRzLnByb3Bvc2VyKSh7XG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAuLi5ST0xFLFxuICAgICAgICAgIHByb3Bvc2VyOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pLCAuLi5vcHRzLmF1dGhvcml6YXRpb25zLm1hcChhdXRoekZuKS5tYXAoZCA9PiBkKHtcbiAgICAgICAgcm9sZToge1xuICAgICAgICAgIC4uLlJPTEUsXG4gICAgICAgICAgYXV0aG9yaXplcjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KSksIG9wdHMucGF5ZXIgJiYgYXV0aHpGbihvcHRzLnBheWVyKSh7XG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAuLi5ST0xFLFxuICAgICAgICAgIHBheWVyOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXS5maWx0ZXIoQm9vbGVhbilcbiAgICB9O1xuICB9O1xufVxuXG5jb25zdCBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBmbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gYnVpbGQoW3JlZihcIjEyM1wiKSwgLi4uZm5zXSkudGhlbihyZXNvbHZlKTtcbn07XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBtb2NrU2VuZDogbW9ja1NlbmQsXG4gIGF1dGh6Rm46IGF1dGh6Rm4sXG4gIGF1dGh6UmVzb2x2ZTogYXV0aHpSZXNvbHZlLFxuICBhdXRoelJlc29sdmVNYW55OiBhdXRoelJlc29sdmVNYW55LFxuICBzaWc6IHNpZyxcbiAgaWRvZjogaWRvZixcbiAgcnVuOiBydW5cbn0pO1xuXG5jb25zdCBWRVJTSU9OID0gXCIxLjIuMlwiIDtcblxuLy8gRGVwcmVjYXRlZFxuY29uc3QgcGFyYW1zID0gcGFyYW1zID0+IGxvZ2dlci5sb2cuZGVwcmVjYXRlKHtcbiAgcGtnOiBcIkZDTC9TREtcIixcbiAgbWVzc2FnZTogYFRoZSBwYXJhbXMgYnVpbGRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIEZsb3cgSlMtU0RLL0ZDTC5gLFxuICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL1RSQU5TSVRJT05TLm1kIzAwMDEtZGVwcmVjYXRlLXBhcmFtc1wiLFxuICBsZXZlbDogbG9nZ2VyLkxFVkVMUy5lcnJvclxufSk7XG5jb25zdCBwYXJhbSA9IHBhcmFtcyA9PiBsb2dnZXIubG9nLmRlcHJlY2F0ZSh7XG4gIHBrZzogXCJGQ0wvU0RLXCIsXG4gIG1lc3NhZ2U6IGBUaGUgcGFyYW0gYnVpbGRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIEZsb3cgSlMtU0RLL0ZDTC5gLFxuICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL1RSQU5TSVRJT05TLm1kIzAwMDEtZGVwcmVjYXRlLXBhcmFtc1wiLFxuICBsZXZlbDogbG9nZ2VyLkxFVkVMUy5lcnJvclxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIFRlc3RVdGlscywgVkVSU0lPTiwgYWNjb3VudCwgYXJnLCBhcmdzLCBhdEJsb2NrSGVpZ2h0LCBhdEJsb2NrSWQsIGF1dGhvcml6YXRpb24sIGF1dGhvcml6YXRpb25zLCBibG9jaywgYnVpbGQsIGNyZWF0ZVNpZ25hYmxlVm91Y2hlciwgZGVjb2RlLCBkZXN0cm95LCBlbmNvZGVNZXNzYWdlRnJvbVNpZ25hYmxlLCBlbmNvZGVUcmFuc2FjdGlvbkVudmVsb3BlLCBlbmNvZGVUcmFuc2FjdGlvblBheWxvYWQsIGVuY29kZVR4SWRGcm9tVm91Y2hlciwgZ2V0LCBnZXRBY2NvdW50LCBnZXRCbG9jaywgZ2V0QmxvY2tIZWFkZXIsIGdldENvbGxlY3Rpb24sIGdldEV2ZW50cywgZ2V0RXZlbnRzQXRCbG9ja0hlaWdodFJhbmdlLCBnZXRFdmVudHNBdEJsb2NrSWRzLCBnZXROZXR3b3JrUGFyYW1ldGVycywgZ2V0VHJhbnNhY3Rpb24sIGdldFRyYW5zYWN0aW9uU3RhdHVzLCBpbnRlcmFjdGlvbiwgaW52YXJpYW50LCBpc0JhZCwgaXNHZXRBY2NvdW50LCBpc0dldEJsb2NrLCBpc0dldEJsb2NrSGVhZGVyLCBpc0dldENvbGxlY3Rpb24sIGlzR2V0RXZlbnRzLCBpc0dldE5ldHdvcmtQYXJhbWV0ZXJzLCBpc0dldFRyYW5zYWN0aW9uLCBpc0dldFRyYW5zYWN0aW9uU3RhdHVzLCBpc09rLCBpc1BpbmcsIGlzU2NyaXB0LCBpc1RyYW5zYWN0aW9uLCBpc1Vua25vd24sIGxpbWl0LCBwYXJhbSwgcGFyYW1zLCBwYXllciwgcGluZywgcGlwZSwgcHJvcG9zZXIsIHB1dCwgcmVmLCByZXNvbHZlLCByZXNvbHZlQWNjb3VudHMsIHJlc29sdmVBcmd1bWVudHMsIHJlc29sdmVDYWRlbmNlLCByZXNvbHZlRmluYWxOb3JtYWxpemF0aW9uLCByZXNvbHZlUHJvcG9zZXJTZXF1ZW5jZU51bWJlciwgcmVzb2x2ZVJlZkJsb2NrSWQsIHJlc29sdmVTaWduYXR1cmVzLCByZXNvbHZlVmFsaWRhdG9ycywgcmVzb2x2ZVZvdWNoZXJJbnRlcmNlcHQsIHJlc3BvbnNlLCBzY3JpcHQsIHNlbmQsIHRyYW5zYWN0aW9uLCB1cGRhdGUsIHZhbGlkYXRvciwgdm91Y2hlckludGVyY2VwdCwgdm91Y2hlclRvVHhJZCwgd2h5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZGsubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/sdk/dist/sdk.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/transport-http/dist/sdk-send-http.module.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@onflow/transport-http/dist/sdk-send-http.module.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   sendExecuteScript: function() { return /* binding */ sendExecuteScript; },\n/* harmony export */   sendGetAccount: function() { return /* binding */ sendGetAccount; },\n/* harmony export */   sendGetBlock: function() { return /* binding */ sendGetBlock; },\n/* harmony export */   sendGetBlockHeader: function() { return /* binding */ sendGetBlockHeader; },\n/* harmony export */   sendGetCollection: function() { return /* binding */ sendGetCollection; },\n/* harmony export */   sendGetEvents: function() { return /* binding */ sendGetEvents; },\n/* harmony export */   sendGetNetworkParameters: function() { return /* binding */ sendGetNetworkParameters; },\n/* harmony export */   sendGetTransaction: function() { return /* binding */ sendGetTransaction; },\n/* harmony export */   sendGetTransactionStatus: function() { return /* binding */ sendGetTransactionStatus; },\n/* harmony export */   sendPing: function() { return /* binding */ sendPing; },\n/* harmony export */   sendTransaction: function() { return /* binding */ sendTransaction; }\n/* harmony export */ });\n/* harmony import */ var _onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @onflow/util-invariant */ \"../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js\");\n/* harmony import */ var _onflow_rlp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @onflow/rlp */ \"../../node_modules/@onflow/rlp/dist/rlp.module.js\");\n/* harmony import */ var _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @onflow/util-logger */ \"../../node_modules/@onflow/util-logger/dist/util-logger.module.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cross-fetch */ \"../../node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _onflow_util_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @onflow/util-address */ \"../../node_modules/@onflow/util-address/dist/util-address.module.js\");\n\n\n\n\n\n\nconst AbortController = globalThis.AbortController || __webpack_require__(/*! abort-controller */ \"../../node_modules/abort-controller/browser.js\");\nclass HTTPRequestError extends Error {\n  constructor(_ref) {\n    let {\n      error,\n      hostname,\n      path,\n      method,\n      requestBody,\n      responseBody,\n      responseStatusText,\n      statusCode\n    } = _ref;\n    const msg = `\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      ${error ? `error=${error}` : \"\"}\n      ${hostname ? `hostname=${hostname}` : \"\"}\n      ${path ? `path=${path}` : \"\"}\n      ${method ? `method=${method}` : \"\"}\n      ${requestBody ? `requestBody=${requestBody}` : \"\"}\n      ${responseBody ? `responseBody=${responseBody}` : \"\"}\n      ${responseStatusText ? `responseStatusText=${responseStatusText}` : \"\"}\n      ${statusCode ? `statusCode=${statusCode}` : \"\"}\n    `;\n    super(msg);\n    this.name = \"HTTP Request Error\";\n    this.statusCode = statusCode;\n    this.errorMessage = error;\n  }\n}\n\n/**\n * Creates an HTTP Request to be sent to a REST Access API via Fetch API.\n *\n * @param {object} options - Options for the HTTP Request\n * @param {String} options.hostname - Access API Hostname\n * @param {String} options.path - Path to the resource on the Access API\n * @param {String} options.method - HTTP Method\n * @param {object} options.body - HTTP Request Body\n * @param {object} [options.headers] - HTTP Request Headers\n * @param {boolean} [options.enableRequestLogging=true] - Enable/Disable request logging\n * @param {number} [options.retryLimit=5] - Number of times to retry request\n * @param {number} [options.retryIntervalMs=1000] - Time in milliseconds to wait before retrying request\n * @param {number} [options.timeoutLimit=30000] - Time in milliseconds to wait before timing out request\n *\n * @returns JSON object response from Access API.\n */\nasync function httpRequest(_ref2) {\n  let {\n    hostname,\n    path,\n    method,\n    body,\n    headers,\n    retryLimit = 5,\n    retryIntervalMs = 1000,\n    timeoutLimit = 30000,\n    enableRequestLogging = true\n  } = _ref2;\n  const bodyJSON = body ? JSON.stringify(body) : null;\n  function makeRequest() {\n    const controller = new AbortController();\n    const fetchTimeout = setTimeout(() => {\n      controller.abort();\n    }, timeoutLimit);\n    return cross_fetch__WEBPACK_IMPORTED_MODULE_3___default()(`${hostname}${path}`, {\n      method: method,\n      body: bodyJSON,\n      headers,\n      signal: controller.signal\n    }).then(async res => {\n      if (res.ok) {\n        return res.json();\n      }\n      const responseText = await res.text().catch(() => null);\n      const response = safeParseJSON(responseText);\n      throw new HTTPRequestError({\n        error: response?.message,\n        hostname,\n        path,\n        method,\n        requestBody: bodyJSON,\n        responseBody: responseText,\n        responseStatusText: res.statusText,\n        statusCode: res.status\n      });\n    }).catch(async e => {\n      if (e instanceof HTTPRequestError) {\n        throw e;\n      }\n      if (e.name === \"AbortError\") {\n        throw e;\n      }\n\n      // Show AN error for all network errors\n      if (enableRequestLogging) {\n        await _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__.log({\n          title: \"Access Node Error\",\n          message: `The provided access node ${hostname} does not appear to be a valid REST/HTTP access node.\n  Please verify that you are not unintentionally using a GRPC access node.\n  See more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect`,\n          level: _onflow_util_logger__WEBPACK_IMPORTED_MODULE_2__.LEVELS.error\n        });\n      }\n      throw new HTTPRequestError({\n        error: e?.message,\n        hostname,\n        path,\n        method,\n        requestBody: bodyJSON\n      });\n    }).finally(() => {\n      clearTimeout(fetchTimeout);\n    });\n  }\n  async function requestLoop() {\n    let retryAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    try {\n      const resp = await makeRequest();\n      return resp;\n    } catch (error) {\n      const retryStatusCodes = [408, 429, 500, 502, 503, 504];\n      if (error.name === \"AbortError\" || retryStatusCodes.includes(error.statusCode)) {\n        return await new Promise((resolve, reject) => {\n          if (retryAttempt < retryLimit) {\n            if (enableRequestLogging) {\n              console.warn(`Access node unavailable, retrying in ${retryIntervalMs} ms...`);\n            }\n            setTimeout(() => {\n              resolve(requestLoop(retryAttempt + 1));\n            }, retryIntervalMs);\n          } else {\n            reject(error);\n          }\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  // Keep retrying request until server available or max attempts exceeded\n  return await requestLoop();\n}\nfunction safeParseJSON(data) {\n  try {\n    return JSON.parse(data);\n  } catch {\n    return null;\n  }\n}\n\nasync function sendExecuteScriptAtBlockIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_id=${ix.block.id}`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nasync function sendExecuteScriptAtBlockHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_height=${ix.block.height}`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nasync function sendExecuteScriptAtLatestBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/scripts?block_height=sealed`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))\n    }\n  });\n  return constructResponse$4(ix, context, res);\n}\nfunction constructResponse$4(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.encodedData = JSON.parse(context.Buffer.from(res, \"base64\").toString());\n  return ret;\n}\nasync function sendExecuteScript(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Execute Script Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Execute Script Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Execute Script Error: context.Buffer must be defined.`);\n  ix = await ix;\n  if (ix.block.id) {\n    return await sendExecuteScriptAtBlockIDRequest(ix, context, opts);\n  } else if (ix.block.height) {\n    return await sendExecuteScriptAtBlockHeightRequest(ix, context, opts);\n  } else {\n    return await sendExecuteScriptAtLatestBlockRequest(ix, context, opts);\n  }\n}\n\nconst HashAlgorithmIDs = {\n  SHA2_256: 1,\n  SHA2_384: 2,\n  SHA3_256: 3,\n  SHA3_384: 4,\n  KMAC128_BLS_BLS12_381: 5\n};\nconst SignatureAlgorithmIDs = {\n  ECDSA_P256: 1,\n  ECDSA_secp256k1: 2,\n  BLS_BLS12_381: 3\n};\nasync function sendGetAccountAtBlockHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/accounts/${ix.account.addr}?block_height=${ix.block.height}&expand=contracts,keys`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$3(ix, context, res);\n}\nasync function sendGetAccountAtLatestBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/accounts/${ix.account.addr}?block_height=sealed&expand=contracts,keys`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$3(ix, context, res);\n}\nfunction constructResponse$3(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  const unwrapContracts = contracts => {\n    const c = {};\n    if (!contracts) return c;\n    for (let key of Object.keys(contracts)) {\n      c[key] = context.Buffer.from(contracts[key], \"base64\").toString();\n    }\n    return c;\n  };\n  ret.account = {\n    address: res.address,\n    balance: Number(res.balance),\n    code: \"\",\n    contracts: unwrapContracts(res.contracts),\n    keys: res.keys?.map(key => ({\n      index: Number(key.index),\n      publicKey: key.public_key.replace(/^0x/, \"\"),\n      signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],\n      signAlgoString: key.signing_algorithm,\n      hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],\n      hashAlgoString: key.hashing_algorithm,\n      sequenceNumber: Number(key.sequence_number),\n      weight: Number(key.weight),\n      revoked: key.revoked\n    })) ?? []\n  };\n  return ret;\n}\nasync function sendGetAccount(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Account Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Account Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Account Error: context.Buffer must be defined.`);\n  ix = await ix;\n  if (ix.block.height !== null) {\n    return await sendGetAccountAtBlockHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetAccountAtLatestBlockRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetBlockHeaderByIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks/${ix.block.id}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nasync function sendGetBlockHeaderByHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${ix.block.height}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nasync function sendGetLatestBlockHeaderRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const height = ix.block?.isSealed ? \"sealed\" : \"final\";\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${height}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$2(ix, context, res);\n}\nfunction constructResponse$2(ix, context, res) {\n  const block = res.length ? res[0] : null;\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.blockHeader = {\n    id: block.header.id,\n    parentId: block.header.parent_id,\n    height: Number(block.header.height),\n    timestamp: block.header.timestamp\n  };\n  return ret;\n}\nasync function sendGetBlockHeader(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Block Header Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Block Header Error: context.response must be defined.`);\n  ix = await ix;\n  const interactionHasBlockID = ix.block.id !== null;\n  const interactionHasBlockHeight = ix.block.height !== null;\n  if (interactionHasBlockID) {\n    return await sendGetBlockHeaderByIDRequest(ix, context, opts);\n  } else if (interactionHasBlockHeight) {\n    return await sendGetBlockHeaderByHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetLatestBlockHeaderRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetBlockByIDRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks/${ix.block.id}?expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nasync function sendGetBlockByHeightRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${ix.block.height}&expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nasync function sendGetBlockRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const height = ix.block?.isSealed ? \"sealed\" : \"final\";\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/blocks?height=${height}&expand=payload`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse$1(ix, context, res);\n}\nfunction constructResponse$1(ix, context, res) {\n  const block = res.length ? res[0] : null;\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.block = {\n    id: block.header.id,\n    parentId: block.header.parent_id,\n    height: Number(block.header.height),\n    timestamp: block.header.timestamp,\n    collectionGuarantees: block.payload.collection_guarantees.map(collectionGuarantee => ({\n      collectionId: collectionGuarantee.collection_id,\n      signerIds: collectionGuarantee.signer_ids\n    })),\n    blockSeals: block.payload.block_seals.map(blockSeal => ({\n      blockId: blockSeal.block_id,\n      executionReceiptId: blockSeal.result_id\n    }))\n  };\n  return ret;\n}\nasync function sendGetBlock(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Block Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Block Error: context.response must be defined.`);\n  ix = await ix;\n  const interactionHasBlockID = ix.block.id !== null;\n  const interactionHasBlockHeight = ix.block.height !== null;\n  if (interactionHasBlockID) {\n    return await sendGetBlockByIDRequest(ix, context, opts);\n  } else if (interactionHasBlockHeight) {\n    return await sendGetBlockByHeightRequest(ix, context, opts);\n  } else {\n    return await sendGetBlockRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetCollection(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Collection Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Collection Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/collections/${ix.collection.id}?expand=transactions`,\n    method: \"GET\",\n    body: null\n  });\n  const ret = context.response();\n  ret.tag = ix.tag;\n  ret.collection = {\n    id: res.id,\n    transactionIds: res.transactions.map(transaction => transaction.id)\n  };\n  return ret;\n}\n\nasync function sendGetEventsForHeightRangeRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/events?type=${ix.events.eventType}&start_height=${ix.events.start}&end_height=${ix.events.end}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse(ix, context, res);\n}\nasync function sendGetEventsForBlockIDsRequest(ix, context, opts) {\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/events?type=${ix.events.eventType}&block_ids=${ix.events.blockIds.join(\",\")}`,\n    method: \"GET\",\n    body: null\n  });\n  return constructResponse(ix, context, res);\n}\nfunction constructResponse(ix, context, res) {\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.events = [];\n  res.forEach(block => block.events ? block.events.forEach(event => ret.events.push({\n    blockId: block.block_id,\n    blockHeight: Number(block.block_height),\n    blockTimestamp: block.block_timestamp,\n    type: event.type,\n    transactionId: event.transaction_id,\n    transactionIndex: Number(event.transaction_index),\n    eventIndex: Number(event.event_index),\n    payload: JSON.parse(context.Buffer.from(event.payload, \"base64\").toString())\n  })) : null);\n  return ret;\n}\nasync function sendGetEvents(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Events Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Events Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Events Error: context.Buffer must be defined.`);\n  ix = await ix;\n  const interactionContainsBlockHeightRange = ix.events.start !== null;\n  const interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, \"SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.\");\n  if (interactionContainsBlockHeightRange) {\n    return await sendGetEventsForHeightRangeRequest(ix, context, opts);\n  } else {\n    return await sendGetEventsForBlockIDsRequest(ix, context, opts);\n  }\n}\n\nasync function sendGetTransaction(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Transaction Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Transaction Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Transaction Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transactions/${ix.transaction.id}`,\n    method: \"GET\",\n    body: null\n  });\n  const unwrapKey = key => ({\n    address: key.address,\n    keyId: Number(key.key_id),\n    sequenceNumber: Number(key.sequence_number)\n  });\n  const unwrapSignature = sig => ({\n    address: sig.address,\n    keyId: Number(sig.key_index),\n    signature: sig.signature\n  });\n  const unwrapArg = arg => JSON.parse(context.Buffer.from(arg, \"base64\").toString());\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transaction = {\n    script: context.Buffer.from(res.script, \"base64\").toString(),\n    args: [...res.arguments.map(unwrapArg)],\n    referenceBlockId: res.reference_block_id,\n    gasLimit: Number(res.gas_limit),\n    payer: res.payer,\n    proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,\n    authorizers: res.authorizers,\n    payloadSignatures: [...res.payload_signatures.map(unwrapSignature)],\n    envelopeSignatures: [...res.envelope_signatures.map(unwrapSignature)]\n  };\n  return ret;\n}\n\nconst STATUS_MAP = {\n  UNKNOWN: 0,\n  PENDING: 1,\n  FINALIZED: 2,\n  EXECUTED: 3,\n  SEALED: 4,\n  EXPIRED: 5\n};\nasync function sendGetTransactionStatus(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Transaction Status Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Transaction Status Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Get Transaction Status Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transaction_results/${ix.transaction.id}`,\n    method: \"GET\",\n    body: null\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transactionStatus = {\n    blockId: res.block_id,\n    status: STATUS_MAP[res.status.toUpperCase()] || \"\",\n    statusString: res.status.toUpperCase(),\n    statusCode: res.status_code,\n    errorMessage: res.error_message,\n    events: res.events.map(event => ({\n      type: event.type,\n      transactionId: event.transaction_id,\n      transactionIndex: Number(event.transaction_index),\n      eventIndex: Number(event.event_index),\n      payload: JSON.parse(context.Buffer.from(event.payload, \"base64\").toString())\n    }))\n  };\n  return ret;\n}\n\nasync function sendPing(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Ping Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Ping Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  await httpRequest$1({\n    hostname: opts.node,\n    path: \"/v1/blocks?height=sealed\",\n    method: \"GET\",\n    body: null\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  return ret;\n}\n\nconst idof = acct => `${withPrefix(acct.addr)}-${acct.keyId}`;\nasync function sendTransaction(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Transaction Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Transaction Error: context.response must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.Buffer, `SDK Send Transaction Error: context.Buffer must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n\n  // Apply Non Payer Signatures to Payload Signatures\n  let payloadSignatures = [];\n  for (let acct of Object.values(ix.accounts)) {\n    try {\n      if (!acct.role.payer && acct.signature != null) {\n        payloadSignatures.push({\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(acct.addr),\n          key_index: String(acct.keyId),\n          signature: context.Buffer.from(acct.signature, \"hex\").toString(\"base64\")\n        });\n      }\n    } catch (error) {\n      console.error(\"SDK HTTP Send Error: Trouble applying payload signature\", {\n        acct,\n        ix\n      });\n      throw error;\n    }\n  }\n\n  // Apply Payer Signatures to Envelope Signatures\n  let envelopeSignatures = {};\n  for (let acct of Object.values(ix.accounts)) {\n    try {\n      if (acct.role.payer && acct.signature != null) {\n        let id = acct.tempId || idof(acct);\n        envelopeSignatures[id] = envelopeSignatures[id] || {\n          address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(acct.addr),\n          key_index: String(acct.keyId),\n          signature: context.Buffer.from(acct.signature, \"hex\").toString(\"base64\")\n        };\n      }\n    } catch (error) {\n      console.error(\"SDK HTTP Send Error: Trouble applying envelope signature\", {\n        acct,\n        ix\n      });\n      throw error;\n    }\n  }\n  envelopeSignatures = Object.values(envelopeSignatures);\n  var t1 = Date.now();\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/transactions`,\n    method: \"POST\",\n    body: {\n      script: context.Buffer.from(ix.message.cadence).toString(\"base64\"),\n      arguments: [...ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString(\"base64\"))],\n      reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,\n      gas_limit: String(ix.message.computeLimit),\n      payer: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),\n      proposal_key: {\n        address: (0,_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix)(ix.accounts[ix.proposer].addr),\n        key_index: String(ix.accounts[ix.proposer].keyId),\n        sequence_number: String(ix.accounts[ix.proposer].sequenceNum)\n      },\n      authorizers: ix.authorizations.map(tempId => ix.accounts[tempId].addr).reduce((prev, current) => {\n        return prev.find(item => item === current) ? prev : [...prev, current];\n      }, []).map(_onflow_util_address__WEBPACK_IMPORTED_MODULE_4__.sansPrefix),\n      payload_signatures: payloadSignatures,\n      envelope_signatures: envelopeSignatures\n    }\n  });\n  var t2 = Date.now();\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.transactionId = res.id;\n  if (typeof window !== \"undefined\" && typeof CustomEvent !== \"undefined\") {\n    window.dispatchEvent(new CustomEvent(\"FLOW::TX\", {\n      detail: {\n        txId: ret.transactionId,\n        delta: t2 - t1\n      }\n    }));\n  }\n  return ret;\n}\n\nasync function sendGetNetworkParameters(ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Get Network Parameters Error: opts.node must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.response, `SDK Send Get Network Parameters Error: context.response must be defined.`);\n  const httpRequest$1 = opts.httpRequest || httpRequest;\n  ix = await ix;\n  const res = await httpRequest$1({\n    hostname: opts.node,\n    path: `/v1/network/parameters`,\n    method: \"GET\",\n    body: null,\n    enableRequestLogging: opts.enableRequestLogging ?? true\n  });\n  let ret = context.response();\n  ret.tag = ix.tag;\n  ret.networkParameters = {\n    chainId: res.chain_id\n  };\n  return ret;\n}\n\nconst send = async function (ix) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(opts.node, `SDK Send Error: Either opts.node or \"accessNode.api\" in config must be defined.`);\n  (0,_onflow_util_invariant__WEBPACK_IMPORTED_MODULE_0__.invariant)(context.ix, `SDK Send Error: context.ix must be defined.`);\n  ix = await ix;\n\n  // prettier-ignore\n  switch (true) {\n    case context.ix.isTransaction(ix):\n      return opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts);\n    case context.ix.isGetTransactionStatus(ix):\n      return opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts);\n    case context.ix.isGetTransaction(ix):\n      return opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts);\n    case context.ix.isScript(ix):\n      return opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts);\n    case context.ix.isGetAccount(ix):\n      return opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts);\n    case context.ix.isGetEvents(ix):\n      return opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts);\n    case context.ix.isGetBlock(ix):\n      return opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts);\n    case context.ix.isGetBlockHeader(ix):\n      return opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts);\n    case context.ix.isGetCollection(ix):\n      return opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts);\n    case context.ix.isPing(ix):\n      return opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts);\n    case context.ix.isGetNetworkParameters(ix):\n      return opts.sendGetNetworkParameters ? opts.sendGetNetworkParameters(ix, context, opts) : sendGetNetworkParameters(ix, context, opts);\n    default:\n      return ix;\n  }\n};\n\n\n//# sourceMappingURL=sdk-send-http.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdHJhbnNwb3J0LWh0dHAvZGlzdC9zZGstc2VuZC1odHRwLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDOUI7QUFDeUI7QUFDTDtBQUNTOztBQUVsRCxzREFBc0QsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUSxpQkFBaUIsTUFBTTtBQUMvQixRQUFRLHVCQUF1QixTQUFTO0FBQ3hDLFFBQVEsZUFBZSxLQUFLO0FBQzVCLFFBQVEsbUJBQW1CLE9BQU87QUFDbEMsUUFBUSw2QkFBNkIsWUFBWTtBQUNqRCxRQUFRLCtCQUErQixhQUFhO0FBQ3BELFFBQVEsMkNBQTJDLG1CQUFtQjtBQUN0RSxRQUFRLDJCQUEyQixXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxrREFBYyxJQUFJLFNBQVMsRUFBRSxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRUFBVTtBQUN2QjtBQUNBLGlCQUFpQixnRUFBVTtBQUMzQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPLFVBQVUsNERBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlFQUFTO0FBQ1gsRUFBRSxpRUFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBUztBQUNYLEVBQUUsaUVBQVM7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFME47QUFDMU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Ab25mbG93L3RyYW5zcG9ydC1odHRwL2Rpc3Qvc2RrLXNlbmQtaHR0cC5tb2R1bGUuanM/NDIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdAb25mbG93L3V0aWwtaW52YXJpYW50JztcbmltcG9ydCAnQG9uZmxvdy9ybHAnO1xuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ0BvbmZsb3cvdXRpbC1sb2dnZXInO1xuaW1wb3J0IGZldGNoVHJhbnNwb3J0IGZyb20gJ2Nyb3NzLWZldGNoJztcbmltcG9ydCB7IHNhbnNQcmVmaXggfSBmcm9tICdAb25mbG93L3V0aWwtYWRkcmVzcyc7XG5cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoXCJhYm9ydC1jb250cm9sbGVyXCIpO1xuY2xhc3MgSFRUUFJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBlcnJvcixcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcGF0aCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgcmVzcG9uc2VTdGF0dXNUZXh0LFxuICAgICAgc3RhdHVzQ29kZVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IG1zZyA9IGBcbiAgICAgIEhUVFAgUmVxdWVzdCBFcnJvcjogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBpbnRlcmFjdGluZyB3aXRoIHRoZSBBY2Nlc3MgQVBJLlxuICAgICAgJHtlcnJvciA/IGBlcnJvcj0ke2Vycm9yfWAgOiBcIlwifVxuICAgICAgJHtob3N0bmFtZSA/IGBob3N0bmFtZT0ke2hvc3RuYW1lfWAgOiBcIlwifVxuICAgICAgJHtwYXRoID8gYHBhdGg9JHtwYXRofWAgOiBcIlwifVxuICAgICAgJHttZXRob2QgPyBgbWV0aG9kPSR7bWV0aG9kfWAgOiBcIlwifVxuICAgICAgJHtyZXF1ZXN0Qm9keSA/IGByZXF1ZXN0Qm9keT0ke3JlcXVlc3RCb2R5fWAgOiBcIlwifVxuICAgICAgJHtyZXNwb25zZUJvZHkgPyBgcmVzcG9uc2VCb2R5PSR7cmVzcG9uc2VCb2R5fWAgOiBcIlwifVxuICAgICAgJHtyZXNwb25zZVN0YXR1c1RleHQgPyBgcmVzcG9uc2VTdGF0dXNUZXh0PSR7cmVzcG9uc2VTdGF0dXNUZXh0fWAgOiBcIlwifVxuICAgICAgJHtzdGF0dXNDb2RlID8gYHN0YXR1c0NvZGU9JHtzdGF0dXNDb2RlfWAgOiBcIlwifVxuICAgIGA7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLm5hbWUgPSBcIkhUVFAgUmVxdWVzdCBFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRUUCBSZXF1ZXN0IHRvIGJlIHNlbnQgdG8gYSBSRVNUIEFjY2VzcyBBUEkgdmlhIEZldGNoIEFQSS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBIVFRQIFJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3RuYW1lIC0gQWNjZXNzIEFQSSBIb3N0bmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCAtIFBhdGggdG8gdGhlIHJlc291cmNlIG9uIHRoZSBBY2Nlc3MgQVBJXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5tZXRob2QgLSBIVFRQIE1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYm9keSAtIEhUVFAgUmVxdWVzdCBCb2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gLSBIVFRQIFJlcXVlc3QgSGVhZGVyc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXF1ZXN0TG9nZ2luZz10cnVlXSAtIEVuYWJsZS9EaXNhYmxlIHJlcXVlc3QgbG9nZ2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJldHJ5TGltaXQ9NV0gLSBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJldHJ5SW50ZXJ2YWxNcz0xMDAwXSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIHJlcXVlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50aW1lb3V0TGltaXQ9MzAwMDBdIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgdGltaW5nIG91dCByZXF1ZXN0XG4gKlxuICogQHJldHVybnMgSlNPTiBvYmplY3QgcmVzcG9uc2UgZnJvbSBBY2Nlc3MgQVBJLlxuICovXG5hc3luYyBmdW5jdGlvbiBodHRwUmVxdWVzdChfcmVmMikge1xuICBsZXQge1xuICAgIGhvc3RuYW1lLFxuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICByZXRyeUxpbWl0ID0gNSxcbiAgICByZXRyeUludGVydmFsTXMgPSAxMDAwLFxuICAgIHRpbWVvdXRMaW1pdCA9IDMwMDAwLFxuICAgIGVuYWJsZVJlcXVlc3RMb2dnaW5nID0gdHJ1ZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IGJvZHlKU09OID0gYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogbnVsbDtcbiAgZnVuY3Rpb24gbWFrZVJlcXVlc3QoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBmZXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0TGltaXQpO1xuICAgIHJldHVybiBmZXRjaFRyYW5zcG9ydChgJHtob3N0bmFtZX0ke3BhdGh9YCwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBib2R5OiBib2R5SlNPTixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkudGhlbihhc3luYyByZXMgPT4ge1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlcy50ZXh0KCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHNhZmVQYXJzZUpTT04ocmVzcG9uc2VUZXh0KTtcbiAgICAgIHRocm93IG5ldyBIVFRQUmVxdWVzdEVycm9yKHtcbiAgICAgICAgZXJyb3I6IHJlc3BvbnNlPy5tZXNzYWdlLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZXF1ZXN0Qm9keTogYm9keUpTT04sXG4gICAgICAgIHJlc3BvbnNlQm9keTogcmVzcG9uc2VUZXh0LFxuICAgICAgICByZXNwb25zZVN0YXR1c1RleHQ6IHJlcy5zdGF0dXNUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzXG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChhc3luYyBlID0+IHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgSFRUUFJlcXVlc3RFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGUubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdyBBTiBlcnJvciBmb3IgYWxsIG5ldHdvcmsgZXJyb3JzXG4gICAgICBpZiAoZW5hYmxlUmVxdWVzdExvZ2dpbmcpIHtcbiAgICAgICAgYXdhaXQgbG9nZ2VyLmxvZyh7XG4gICAgICAgICAgdGl0bGU6IFwiQWNjZXNzIE5vZGUgRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgVGhlIHByb3ZpZGVkIGFjY2VzcyBub2RlICR7aG9zdG5hbWV9IGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIFJFU1QvSFRUUCBhY2Nlc3Mgbm9kZS5cbiAgUGxlYXNlIHZlcmlmeSB0aGF0IHlvdSBhcmUgbm90IHVuaW50ZW50aW9uYWxseSB1c2luZyBhIEdSUEMgYWNjZXNzIG5vZGUuXG4gIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2ZjbC9yZWZlcmVuY2Uvc2RrLWd1aWRlbGluZXMvI2Nvbm5lY3RgLFxuICAgICAgICAgIGxldmVsOiBsb2dnZXIuTEVWRUxTLmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEhUVFBSZXF1ZXN0RXJyb3Ioe1xuICAgICAgICBlcnJvcjogZT8ubWVzc2FnZSxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlKU09OXG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChmZXRjaFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RMb29wKCkge1xuICAgIGxldCByZXRyeUF0dGVtcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBtYWtlUmVxdWVzdCgpO1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJldHJ5U3RhdHVzQ29kZXMgPSBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF07XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgcmV0cnlTdGF0dXNDb2Rlcy5pbmNsdWRlcyhlcnJvci5zdGF0dXNDb2RlKSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGlmIChyZXRyeUF0dGVtcHQgPCByZXRyeUxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlUmVxdWVzdExvZ2dpbmcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBY2Nlc3Mgbm9kZSB1bmF2YWlsYWJsZSwgcmV0cnlpbmcgaW4gJHtyZXRyeUludGVydmFsTXN9IG1zLi4uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0TG9vcChyZXRyeUF0dGVtcHQgKyAxKSk7XG4gICAgICAgICAgICB9LCByZXRyeUludGVydmFsTXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBLZWVwIHJldHJ5aW5nIHJlcXVlc3QgdW50aWwgc2VydmVyIGF2YWlsYWJsZSBvciBtYXggYXR0ZW1wdHMgZXhjZWVkZWRcbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3RMb29wKCk7XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEV4ZWN1dGVTY3JpcHRBdEJsb2NrSURSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvc2NyaXB0cz9ibG9ja19pZD0ke2l4LmJsb2NrLmlkfWAsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiB7XG4gICAgICBzY3JpcHQ6IGNvbnRleHQuQnVmZmVyLmZyb20oaXgubWVzc2FnZS5jYWRlbmNlKS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgIGFyZ3VtZW50czogaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGFyZyA9PiBjb250ZXh0LkJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGl4LmFyZ3VtZW50c1thcmddLmFzQXJndW1lbnQpKS50b1N0cmluZyhcImJhc2U2NFwiKSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkNChpeCwgY29udGV4dCwgcmVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFeGVjdXRlU2NyaXB0QXRCbG9ja0hlaWdodFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9zY3JpcHRzP2Jsb2NrX2hlaWdodD0ke2l4LmJsb2NrLmhlaWdodH1gLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keToge1xuICAgICAgc2NyaXB0OiBjb250ZXh0LkJ1ZmZlci5mcm9tKGl4Lm1lc3NhZ2UuY2FkZW5jZSkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICBhcmd1bWVudHM6IGl4Lm1lc3NhZ2UuYXJndW1lbnRzLm1hcChhcmcgPT4gY29udGV4dC5CdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShpeC5hcmd1bWVudHNbYXJnXS5hc0FyZ3VtZW50KSkudG9TdHJpbmcoXCJiYXNlNjRcIikpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDQoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kRXhlY3V0ZVNjcmlwdEF0TGF0ZXN0QmxvY2tSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvc2NyaXB0cz9ibG9ja19oZWlnaHQ9c2VhbGVkYCxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IHtcbiAgICAgIHNjcmlwdDogY29udGV4dC5CdWZmZXIuZnJvbShpeC5tZXNzYWdlLmNhZGVuY2UpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgICAgYXJndW1lbnRzOiBpeC5tZXNzYWdlLmFyZ3VtZW50cy5tYXAoYXJnID0+IGNvbnRleHQuQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoaXguYXJndW1lbnRzW2FyZ10uYXNBcmd1bWVudCkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQ0KGl4LCBjb250ZXh0LCByZXMpO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UmVzcG9uc2UkNChpeCwgY29udGV4dCwgcmVzKSB7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5lbmNvZGVkRGF0YSA9IEpTT04ucGFyc2UoY29udGV4dC5CdWZmZXIuZnJvbShyZXMsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gcmV0O1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEV4ZWN1dGVTY3JpcHQoaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBFeGVjdXRlIFNjcmlwdCBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBFeGVjdXRlIFNjcmlwdCBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LkJ1ZmZlciwgYFNESyBTZW5kIEV4ZWN1dGUgU2NyaXB0IEVycm9yOiBjb250ZXh0LkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGl4ID0gYXdhaXQgaXg7XG4gIGlmIChpeC5ibG9jay5pZCkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kRXhlY3V0ZVNjcmlwdEF0QmxvY2tJRFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9IGVsc2UgaWYgKGl4LmJsb2NrLmhlaWdodCkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kRXhlY3V0ZVNjcmlwdEF0QmxvY2tIZWlnaHRSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEV4ZWN1dGVTY3JpcHRBdExhdGVzdEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH1cbn1cblxuY29uc3QgSGFzaEFsZ29yaXRobUlEcyA9IHtcbiAgU0hBMl8yNTY6IDEsXG4gIFNIQTJfMzg0OiAyLFxuICBTSEEzXzI1NjogMyxcbiAgU0hBM18zODQ6IDQsXG4gIEtNQUMxMjhfQkxTX0JMUzEyXzM4MTogNVxufTtcbmNvbnN0IFNpZ25hdHVyZUFsZ29yaXRobUlEcyA9IHtcbiAgRUNEU0FfUDI1NjogMSxcbiAgRUNEU0Ffc2VjcDI1NmsxOiAyLFxuICBCTFNfQkxTMTJfMzgxOiAzXG59O1xuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEFjY291bnRBdEJsb2NrSGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2FjY291bnRzLyR7aXguYWNjb3VudC5hZGRyfT9ibG9ja19oZWlnaHQ9JHtpeC5ibG9jay5oZWlnaHR9JmV4cGFuZD1jb250cmFjdHMsa2V5c2AsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQzKGl4LCBjb250ZXh0LCByZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEFjY291bnRBdExhdGVzdEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2FjY291bnRzLyR7aXguYWNjb3VudC5hZGRyfT9ibG9ja19oZWlnaHQ9c2VhbGVkJmV4cGFuZD1jb250cmFjdHMsa2V5c2AsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZSQzKGl4LCBjb250ZXh0LCByZXMpO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UmVzcG9uc2UkMyhpeCwgY29udGV4dCwgcmVzKSB7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIGNvbnN0IHVud3JhcENvbnRyYWN0cyA9IGNvbnRyYWN0cyA9PiB7XG4gICAgY29uc3QgYyA9IHt9O1xuICAgIGlmICghY29udHJhY3RzKSByZXR1cm4gYztcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29udHJhY3RzKSkge1xuICAgICAgY1trZXldID0gY29udGV4dC5CdWZmZXIuZnJvbShjb250cmFjdHNba2V5XSwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH07XG4gIHJldC5hY2NvdW50ID0ge1xuICAgIGFkZHJlc3M6IHJlcy5hZGRyZXNzLFxuICAgIGJhbGFuY2U6IE51bWJlcihyZXMuYmFsYW5jZSksXG4gICAgY29kZTogXCJcIixcbiAgICBjb250cmFjdHM6IHVud3JhcENvbnRyYWN0cyhyZXMuY29udHJhY3RzKSxcbiAgICBrZXlzOiByZXMua2V5cz8ubWFwKGtleSA9PiAoe1xuICAgICAgaW5kZXg6IE51bWJlcihrZXkuaW5kZXgpLFxuICAgICAgcHVibGljS2V5OiBrZXkucHVibGljX2tleS5yZXBsYWNlKC9eMHgvLCBcIlwiKSxcbiAgICAgIHNpZ25BbGdvOiBTaWduYXR1cmVBbGdvcml0aG1JRHNba2V5LnNpZ25pbmdfYWxnb3JpdGhtXSxcbiAgICAgIHNpZ25BbGdvU3RyaW5nOiBrZXkuc2lnbmluZ19hbGdvcml0aG0sXG4gICAgICBoYXNoQWxnbzogSGFzaEFsZ29yaXRobUlEc1trZXkuaGFzaGluZ19hbGdvcml0aG1dLFxuICAgICAgaGFzaEFsZ29TdHJpbmc6IGtleS5oYXNoaW5nX2FsZ29yaXRobSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiBOdW1iZXIoa2V5LnNlcXVlbmNlX251bWJlciksXG4gICAgICB3ZWlnaHQ6IE51bWJlcihrZXkud2VpZ2h0KSxcbiAgICAgIHJldm9rZWQ6IGtleS5yZXZva2VkXG4gICAgfSkpID8/IFtdXG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0QWNjb3VudChpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBBY2NvdW50IEVycm9yOiBvcHRzLm5vZGUgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5yZXNwb25zZSwgYFNESyBTZW5kIEdldCBBY2NvdW50IEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQuQnVmZmVyLCBgU0RLIFNlbmQgR2V0IEFjY291bnQgRXJyb3I6IGNvbnRleHQuQnVmZmVyIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaXggPSBhd2FpdCBpeDtcbiAgaWYgKGl4LmJsb2NrLmhlaWdodCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kR2V0QWNjb3VudEF0QmxvY2tIZWlnaHRSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEFjY291bnRBdExhdGVzdEJsb2NrUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEJsb2NrSGVhZGVyQnlJRFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9ibG9ja3MvJHtpeC5ibG9jay5pZH1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMihpeCwgY29udGV4dCwgcmVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9ja0hlYWRlckJ5SGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2Jsb2Nrcz9oZWlnaHQ9JHtpeC5ibG9jay5oZWlnaHR9YCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDIoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0TGF0ZXN0QmxvY2tIZWFkZXJSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCBoZWlnaHQgPSBpeC5ibG9jaz8uaXNTZWFsZWQgPyBcInNlYWxlZFwiIDogXCJmaW5hbFwiO1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvYmxvY2tzP2hlaWdodD0ke2hlaWdodH1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMihpeCwgY29udGV4dCwgcmVzKTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc3BvbnNlJDIoaXgsIGNvbnRleHQsIHJlcykge1xuICBjb25zdCBibG9jayA9IHJlcy5sZW5ndGggPyByZXNbMF0gOiBudWxsO1xuICBjb25zdCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5ibG9ja0hlYWRlciA9IHtcbiAgICBpZDogYmxvY2suaGVhZGVyLmlkLFxuICAgIHBhcmVudElkOiBibG9jay5oZWFkZXIucGFyZW50X2lkLFxuICAgIGhlaWdodDogTnVtYmVyKGJsb2NrLmhlYWRlci5oZWlnaHQpLFxuICAgIHRpbWVzdGFtcDogYmxvY2suaGVhZGVyLnRpbWVzdGFtcFxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEJsb2NrSGVhZGVyKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgR2V0IEJsb2NrIEhlYWRlciBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgQmxvY2sgSGVhZGVyIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaXggPSBhd2FpdCBpeDtcbiAgY29uc3QgaW50ZXJhY3Rpb25IYXNCbG9ja0lEID0gaXguYmxvY2suaWQgIT09IG51bGw7XG4gIGNvbnN0IGludGVyYWN0aW9uSGFzQmxvY2tIZWlnaHQgPSBpeC5ibG9jay5oZWlnaHQgIT09IG51bGw7XG4gIGlmIChpbnRlcmFjdGlvbkhhc0Jsb2NrSUQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEJsb2NrSGVhZGVyQnlJRFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9IGVsc2UgaWYgKGludGVyYWN0aW9uSGFzQmxvY2tIZWlnaHQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEJsb2NrSGVhZGVyQnlIZWlnaHRSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldExhdGVzdEJsb2NrSGVhZGVyUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldEJsb2NrQnlJRFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9ibG9ja3MvJHtpeC5ibG9jay5pZH0/ZXhwYW5kPXBheWxvYWRgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMShpeCwgY29udGV4dCwgcmVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9ja0J5SGVpZ2h0UmVxdWVzdChpeCwgY29udGV4dCwgb3B0cykge1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL2Jsb2Nrcz9oZWlnaHQ9JHtpeC5ibG9jay5oZWlnaHR9JmV4cGFuZD1wYXlsb2FkYCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgYm9keTogbnVsbFxuICB9KTtcbiAgcmV0dXJuIGNvbnN0cnVjdFJlc3BvbnNlJDEoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0QmxvY2tSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCBoZWlnaHQgPSBpeC5ibG9jaz8uaXNTZWFsZWQgPyBcInNlYWxlZFwiIDogXCJmaW5hbFwiO1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvYmxvY2tzP2hlaWdodD0ke2hlaWdodH0mZXhwYW5kPXBheWxvYWRgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UkMShpeCwgY29udGV4dCwgcmVzKTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc3BvbnNlJDEoaXgsIGNvbnRleHQsIHJlcykge1xuICBjb25zdCBibG9jayA9IHJlcy5sZW5ndGggPyByZXNbMF0gOiBudWxsO1xuICBjb25zdCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5ibG9jayA9IHtcbiAgICBpZDogYmxvY2suaGVhZGVyLmlkLFxuICAgIHBhcmVudElkOiBibG9jay5oZWFkZXIucGFyZW50X2lkLFxuICAgIGhlaWdodDogTnVtYmVyKGJsb2NrLmhlYWRlci5oZWlnaHQpLFxuICAgIHRpbWVzdGFtcDogYmxvY2suaGVhZGVyLnRpbWVzdGFtcCxcbiAgICBjb2xsZWN0aW9uR3VhcmFudGVlczogYmxvY2sucGF5bG9hZC5jb2xsZWN0aW9uX2d1YXJhbnRlZXMubWFwKGNvbGxlY3Rpb25HdWFyYW50ZWUgPT4gKHtcbiAgICAgIGNvbGxlY3Rpb25JZDogY29sbGVjdGlvbkd1YXJhbnRlZS5jb2xsZWN0aW9uX2lkLFxuICAgICAgc2lnbmVySWRzOiBjb2xsZWN0aW9uR3VhcmFudGVlLnNpZ25lcl9pZHNcbiAgICB9KSksXG4gICAgYmxvY2tTZWFsczogYmxvY2sucGF5bG9hZC5ibG9ja19zZWFscy5tYXAoYmxvY2tTZWFsID0+ICh7XG4gICAgICBibG9ja0lkOiBibG9ja1NlYWwuYmxvY2tfaWQsXG4gICAgICBleGVjdXRpb25SZWNlaXB0SWQ6IGJsb2NrU2VhbC5yZXN1bHRfaWRcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRCbG9jayhpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBCbG9jayBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgQmxvY2sgRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpeCA9IGF3YWl0IGl4O1xuICBjb25zdCBpbnRlcmFjdGlvbkhhc0Jsb2NrSUQgPSBpeC5ibG9jay5pZCAhPT0gbnVsbDtcbiAgY29uc3QgaW50ZXJhY3Rpb25IYXNCbG9ja0hlaWdodCA9IGl4LmJsb2NrLmhlaWdodCAhPT0gbnVsbDtcbiAgaWYgKGludGVyYWN0aW9uSGFzQmxvY2tJRCkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kR2V0QmxvY2tCeUlEUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25IYXNCbG9ja0hlaWdodCkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kR2V0QmxvY2tCeUhlaWdodFJlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhd2FpdCBzZW5kR2V0QmxvY2tSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0Q29sbGVjdGlvbihpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEdldCBDb2xsZWN0aW9uIEVycm9yOiBvcHRzLm5vZGUgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5yZXNwb25zZSwgYFNESyBTZW5kIEdldCBDb2xsZWN0aW9uIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9jb2xsZWN0aW9ucy8ke2l4LmNvbGxlY3Rpb24uaWR9P2V4cGFuZD10cmFuc2FjdGlvbnNgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICBjb25zdCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5jb2xsZWN0aW9uID0ge1xuICAgIGlkOiByZXMuaWQsXG4gICAgdHJhbnNhY3Rpb25JZHM6IHJlcy50cmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmlkKVxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0RXZlbnRzRm9ySGVpZ2h0UmFuZ2VSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKSB7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvZXZlbnRzP3R5cGU9JHtpeC5ldmVudHMuZXZlbnRUeXBlfSZzdGFydF9oZWlnaHQ9JHtpeC5ldmVudHMuc3RhcnR9JmVuZF9oZWlnaHQ9JHtpeC5ldmVudHMuZW5kfWAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RSZXNwb25zZShpeCwgY29udGV4dCwgcmVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRHZXRFdmVudHNGb3JCbG9ja0lEc1JlcXVlc3QoaXgsIGNvbnRleHQsIG9wdHMpIHtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9ldmVudHM/dHlwZT0ke2l4LmV2ZW50cy5ldmVudFR5cGV9JmJsb2NrX2lkcz0ke2l4LmV2ZW50cy5ibG9ja0lkcy5qb2luKFwiLFwiKX1gLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsXG4gIH0pO1xuICByZXR1cm4gY29uc3RydWN0UmVzcG9uc2UoaXgsIGNvbnRleHQsIHJlcyk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RSZXNwb25zZShpeCwgY29udGV4dCwgcmVzKSB7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5ldmVudHMgPSBbXTtcbiAgcmVzLmZvckVhY2goYmxvY2sgPT4gYmxvY2suZXZlbnRzID8gYmxvY2suZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gcmV0LmV2ZW50cy5wdXNoKHtcbiAgICBibG9ja0lkOiBibG9jay5ibG9ja19pZCxcbiAgICBibG9ja0hlaWdodDogTnVtYmVyKGJsb2NrLmJsb2NrX2hlaWdodCksXG4gICAgYmxvY2tUaW1lc3RhbXA6IGJsb2NrLmJsb2NrX3RpbWVzdGFtcCxcbiAgICB0eXBlOiBldmVudC50eXBlLFxuICAgIHRyYW5zYWN0aW9uSWQ6IGV2ZW50LnRyYW5zYWN0aW9uX2lkLFxuICAgIHRyYW5zYWN0aW9uSW5kZXg6IE51bWJlcihldmVudC50cmFuc2FjdGlvbl9pbmRleCksXG4gICAgZXZlbnRJbmRleDogTnVtYmVyKGV2ZW50LmV2ZW50X2luZGV4KSxcbiAgICBwYXlsb2FkOiBKU09OLnBhcnNlKGNvbnRleHQuQnVmZmVyLmZyb20oZXZlbnQucGF5bG9hZCwgXCJiYXNlNjRcIikudG9TdHJpbmcoKSlcbiAgfSkpIDogbnVsbCk7XG4gIHJldHVybiByZXQ7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0RXZlbnRzKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgR2V0IEV2ZW50cyBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgRXZlbnRzIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQuQnVmZmVyLCBgU0RLIFNlbmQgR2V0IEV2ZW50cyBFcnJvcjogY29udGV4dC5CdWZmZXIgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpeCA9IGF3YWl0IGl4O1xuICBjb25zdCBpbnRlcmFjdGlvbkNvbnRhaW5zQmxvY2tIZWlnaHRSYW5nZSA9IGl4LmV2ZW50cy5zdGFydCAhPT0gbnVsbDtcbiAgY29uc3QgaW50ZXJhY3Rpb25Db250YWluc0Jsb2NrSURzTGlzdCA9IEFycmF5LmlzQXJyYXkoaXguZXZlbnRzLmJsb2NrSWRzKSAmJiBpeC5ldmVudHMuYmxvY2tJZHMubGVuZ3RoID4gMDtcbiAgaW52YXJpYW50KGludGVyYWN0aW9uQ29udGFpbnNCbG9ja0hlaWdodFJhbmdlIHx8IGludGVyYWN0aW9uQ29udGFpbnNCbG9ja0lEc0xpc3QsIFwiU2VuZEdldEV2ZW50c0Vycm9yOiBVbmFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIGdldCBldmVudHMgcmVxdWVzdCB0byBzZW5kLiBFaXRoZXIgYSBibG9jayBoZWlnaHQgcmFuZ2UsIG9yIGJsb2NrIElEcyBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gIGlmIChpbnRlcmFjdGlvbkNvbnRhaW5zQmxvY2tIZWlnaHRSYW5nZSkge1xuICAgIHJldHVybiBhd2FpdCBzZW5kR2V0RXZlbnRzRm9ySGVpZ2h0UmFuZ2VSZXF1ZXN0KGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VuZEdldEV2ZW50c0ZvckJsb2NrSURzUmVxdWVzdChpeCwgY29udGV4dCwgb3B0cyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldFRyYW5zYWN0aW9uKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgR2V0IFRyYW5zYWN0aW9uIEVycm9yOiBvcHRzLm5vZGUgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5yZXNwb25zZSwgYFNESyBTZW5kIEdldCBUcmFuc2FjdGlvbiBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LkJ1ZmZlciwgYFNESyBTZW5kIEdldCBUcmFuc2FjdGlvbiBFcnJvcjogY29udGV4dC5CdWZmZXIgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBjb25zdCBodHRwUmVxdWVzdCQxID0gb3B0cy5odHRwUmVxdWVzdCB8fCBodHRwUmVxdWVzdDtcbiAgaXggPSBhd2FpdCBpeDtcbiAgY29uc3QgcmVzID0gYXdhaXQgaHR0cFJlcXVlc3QkMSh7XG4gICAgaG9zdG5hbWU6IG9wdHMubm9kZSxcbiAgICBwYXRoOiBgL3YxL3RyYW5zYWN0aW9ucy8ke2l4LnRyYW5zYWN0aW9uLmlkfWAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIGNvbnN0IHVud3JhcEtleSA9IGtleSA9PiAoe1xuICAgIGFkZHJlc3M6IGtleS5hZGRyZXNzLFxuICAgIGtleUlkOiBOdW1iZXIoa2V5LmtleV9pZCksXG4gICAgc2VxdWVuY2VOdW1iZXI6IE51bWJlcihrZXkuc2VxdWVuY2VfbnVtYmVyKVxuICB9KTtcbiAgY29uc3QgdW53cmFwU2lnbmF0dXJlID0gc2lnID0+ICh7XG4gICAgYWRkcmVzczogc2lnLmFkZHJlc3MsXG4gICAga2V5SWQ6IE51bWJlcihzaWcua2V5X2luZGV4KSxcbiAgICBzaWduYXR1cmU6IHNpZy5zaWduYXR1cmVcbiAgfSk7XG4gIGNvbnN0IHVud3JhcEFyZyA9IGFyZyA9PiBKU09OLnBhcnNlKGNvbnRleHQuQnVmZmVyLmZyb20oYXJnLCBcImJhc2U2NFwiKS50b1N0cmluZygpKTtcbiAgbGV0IHJldCA9IGNvbnRleHQucmVzcG9uc2UoKTtcbiAgcmV0LnRhZyA9IGl4LnRhZztcbiAgcmV0LnRyYW5zYWN0aW9uID0ge1xuICAgIHNjcmlwdDogY29udGV4dC5CdWZmZXIuZnJvbShyZXMuc2NyaXB0LCBcImJhc2U2NFwiKS50b1N0cmluZygpLFxuICAgIGFyZ3M6IFsuLi5yZXMuYXJndW1lbnRzLm1hcCh1bndyYXBBcmcpXSxcbiAgICByZWZlcmVuY2VCbG9ja0lkOiByZXMucmVmZXJlbmNlX2Jsb2NrX2lkLFxuICAgIGdhc0xpbWl0OiBOdW1iZXIocmVzLmdhc19saW1pdCksXG4gICAgcGF5ZXI6IHJlcy5wYXllcixcbiAgICBwcm9wb3NhbEtleTogcmVzLnByb3Bvc2FsX2tleSA/IHVud3JhcEtleShyZXMucHJvcG9zYWxfa2V5KSA6IHJlcy5wcm9wb3NhbF9rZXksXG4gICAgYXV0aG9yaXplcnM6IHJlcy5hdXRob3JpemVycyxcbiAgICBwYXlsb2FkU2lnbmF0dXJlczogWy4uLnJlcy5wYXlsb2FkX3NpZ25hdHVyZXMubWFwKHVud3JhcFNpZ25hdHVyZSldLFxuICAgIGVudmVsb3BlU2lnbmF0dXJlczogWy4uLnJlcy5lbnZlbG9wZV9zaWduYXR1cmVzLm1hcCh1bndyYXBTaWduYXR1cmUpXVxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBTVEFUVVNfTUFQID0ge1xuICBVTktOT1dOOiAwLFxuICBQRU5ESU5HOiAxLFxuICBGSU5BTElaRUQ6IDIsXG4gIEVYRUNVVEVEOiAzLFxuICBTRUFMRUQ6IDQsXG4gIEVYUElSRUQ6IDVcbn07XG5hc3luYyBmdW5jdGlvbiBzZW5kR2V0VHJhbnNhY3Rpb25TdGF0dXMoaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBHZXQgVHJhbnNhY3Rpb24gU3RhdHVzIEVycm9yOiBvcHRzLm5vZGUgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5yZXNwb25zZSwgYFNESyBTZW5kIEdldCBUcmFuc2FjdGlvbiBTdGF0dXMgRXJyb3I6IGNvbnRleHQucmVzcG9uc2UgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5CdWZmZXIsIGBTREsgU2VuZCBHZXQgVHJhbnNhY3Rpb24gU3RhdHVzIEVycm9yOiBjb250ZXh0LkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBpeCA9IGF3YWl0IGl4O1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvdHJhbnNhY3Rpb25fcmVzdWx0cy8ke2l4LnRyYW5zYWN0aW9uLmlkfWAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC50cmFuc2FjdGlvblN0YXR1cyA9IHtcbiAgICBibG9ja0lkOiByZXMuYmxvY2tfaWQsXG4gICAgc3RhdHVzOiBTVEFUVVNfTUFQW3Jlcy5zdGF0dXMudG9VcHBlckNhc2UoKV0gfHwgXCJcIixcbiAgICBzdGF0dXNTdHJpbmc6IHJlcy5zdGF0dXMudG9VcHBlckNhc2UoKSxcbiAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzX2NvZGUsXG4gICAgZXJyb3JNZXNzYWdlOiByZXMuZXJyb3JfbWVzc2FnZSxcbiAgICBldmVudHM6IHJlcy5ldmVudHMubWFwKGV2ZW50ID0+ICh7XG4gICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgdHJhbnNhY3Rpb25JZDogZXZlbnQudHJhbnNhY3Rpb25faWQsXG4gICAgICB0cmFuc2FjdGlvbkluZGV4OiBOdW1iZXIoZXZlbnQudHJhbnNhY3Rpb25faW5kZXgpLFxuICAgICAgZXZlbnRJbmRleDogTnVtYmVyKGV2ZW50LmV2ZW50X2luZGV4KSxcbiAgICAgIHBheWxvYWQ6IEpTT04ucGFyc2UoY29udGV4dC5CdWZmZXIuZnJvbShldmVudC5wYXlsb2FkLCBcImJhc2U2NFwiKS50b1N0cmluZygpKVxuICAgIH0pKVxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kUGluZyhpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIFBpbmcgRXJyb3I6IG9wdHMubm9kZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LnJlc3BvbnNlLCBgU0RLIFNlbmQgUGluZyBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IFwiL3YxL2Jsb2Nrcz9oZWlnaHQ9c2VhbGVkXCIsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGJvZHk6IG51bGxcbiAgfSk7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGlkb2YgPSBhY2N0ID0+IGAke3dpdGhQcmVmaXgoYWNjdC5hZGRyKX0tJHthY2N0LmtleUlkfWA7XG5hc3luYyBmdW5jdGlvbiBzZW5kVHJhbnNhY3Rpb24oaXgpIHtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGludmFyaWFudChvcHRzLm5vZGUsIGBTREsgU2VuZCBUcmFuc2FjdGlvbiBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBUcmFuc2FjdGlvbiBFcnJvcjogY29udGV4dC5yZXNwb25zZSBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGludmFyaWFudChjb250ZXh0LkJ1ZmZlciwgYFNESyBTZW5kIFRyYW5zYWN0aW9uIEVycm9yOiBjb250ZXh0LkJ1ZmZlciBtdXN0IGJlIGRlZmluZWQuYCk7XG4gIGNvbnN0IGh0dHBSZXF1ZXN0JDEgPSBvcHRzLmh0dHBSZXF1ZXN0IHx8IGh0dHBSZXF1ZXN0O1xuICBpeCA9IGF3YWl0IGl4O1xuXG4gIC8vIEFwcGx5IE5vbiBQYXllciBTaWduYXR1cmVzIHRvIFBheWxvYWQgU2lnbmF0dXJlc1xuICBsZXQgcGF5bG9hZFNpZ25hdHVyZXMgPSBbXTtcbiAgZm9yIChsZXQgYWNjdCBvZiBPYmplY3QudmFsdWVzKGl4LmFjY291bnRzKSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWFjY3Qucm9sZS5wYXllciAmJiBhY2N0LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHBheWxvYWRTaWduYXR1cmVzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3M6IHNhbnNQcmVmaXgoYWNjdC5hZGRyKSxcbiAgICAgICAgICBrZXlfaW5kZXg6IFN0cmluZyhhY2N0LmtleUlkKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGNvbnRleHQuQnVmZmVyLmZyb20oYWNjdC5zaWduYXR1cmUsIFwiaGV4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU0RLIEhUVFAgU2VuZCBFcnJvcjogVHJvdWJsZSBhcHBseWluZyBwYXlsb2FkIHNpZ25hdHVyZVwiLCB7XG4gICAgICAgIGFjY3QsXG4gICAgICAgIGl4XG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGx5IFBheWVyIFNpZ25hdHVyZXMgdG8gRW52ZWxvcGUgU2lnbmF0dXJlc1xuICBsZXQgZW52ZWxvcGVTaWduYXR1cmVzID0ge307XG4gIGZvciAobGV0IGFjY3Qgb2YgT2JqZWN0LnZhbHVlcyhpeC5hY2NvdW50cykpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFjY3Qucm9sZS5wYXllciAmJiBhY2N0LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIGxldCBpZCA9IGFjY3QudGVtcElkIHx8IGlkb2YoYWNjdCk7XG4gICAgICAgIGVudmVsb3BlU2lnbmF0dXJlc1tpZF0gPSBlbnZlbG9wZVNpZ25hdHVyZXNbaWRdIHx8IHtcbiAgICAgICAgICBhZGRyZXNzOiBzYW5zUHJlZml4KGFjY3QuYWRkciksXG4gICAgICAgICAga2V5X2luZGV4OiBTdHJpbmcoYWNjdC5rZXlJZCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBjb250ZXh0LkJ1ZmZlci5mcm9tKGFjY3Quc2lnbmF0dXJlLCBcImhleFwiKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU0RLIEhUVFAgU2VuZCBFcnJvcjogVHJvdWJsZSBhcHBseWluZyBlbnZlbG9wZSBzaWduYXR1cmVcIiwge1xuICAgICAgICBhY2N0LFxuICAgICAgICBpeFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgZW52ZWxvcGVTaWduYXR1cmVzID0gT2JqZWN0LnZhbHVlcyhlbnZlbG9wZVNpZ25hdHVyZXMpO1xuICB2YXIgdDEgPSBEYXRlLm5vdygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBodHRwUmVxdWVzdCQxKHtcbiAgICBob3N0bmFtZTogb3B0cy5ub2RlLFxuICAgIHBhdGg6IGAvdjEvdHJhbnNhY3Rpb25zYCxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IHtcbiAgICAgIHNjcmlwdDogY29udGV4dC5CdWZmZXIuZnJvbShpeC5tZXNzYWdlLmNhZGVuY2UpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgICAgYXJndW1lbnRzOiBbLi4uaXgubWVzc2FnZS5hcmd1bWVudHMubWFwKGFyZyA9PiBjb250ZXh0LkJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGl4LmFyZ3VtZW50c1thcmddLmFzQXJndW1lbnQpKS50b1N0cmluZyhcImJhc2U2NFwiKSldLFxuICAgICAgcmVmZXJlbmNlX2Jsb2NrX2lkOiBpeC5tZXNzYWdlLnJlZkJsb2NrID8gaXgubWVzc2FnZS5yZWZCbG9jayA6IG51bGwsXG4gICAgICBnYXNfbGltaXQ6IFN0cmluZyhpeC5tZXNzYWdlLmNvbXB1dGVMaW1pdCksXG4gICAgICBwYXllcjogc2Fuc1ByZWZpeChpeC5hY2NvdW50c1tBcnJheS5pc0FycmF5KGl4LnBheWVyKSA/IGl4LnBheWVyWzBdIDogaXgucGF5ZXJdLmFkZHIpLFxuICAgICAgcHJvcG9zYWxfa2V5OiB7XG4gICAgICAgIGFkZHJlc3M6IHNhbnNQcmVmaXgoaXguYWNjb3VudHNbaXgucHJvcG9zZXJdLmFkZHIpLFxuICAgICAgICBrZXlfaW5kZXg6IFN0cmluZyhpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0ua2V5SWQpLFxuICAgICAgICBzZXF1ZW5jZV9udW1iZXI6IFN0cmluZyhpeC5hY2NvdW50c1tpeC5wcm9wb3Nlcl0uc2VxdWVuY2VOdW0pXG4gICAgICB9LFxuICAgICAgYXV0aG9yaXplcnM6IGl4LmF1dGhvcml6YXRpb25zLm1hcCh0ZW1wSWQgPT4gaXguYWNjb3VudHNbdGVtcElkXS5hZGRyKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYuZmluZChpdGVtID0+IGl0ZW0gPT09IGN1cnJlbnQpID8gcHJldiA6IFsuLi5wcmV2LCBjdXJyZW50XTtcbiAgICAgIH0sIFtdKS5tYXAoc2Fuc1ByZWZpeCksXG4gICAgICBwYXlsb2FkX3NpZ25hdHVyZXM6IHBheWxvYWRTaWduYXR1cmVzLFxuICAgICAgZW52ZWxvcGVfc2lnbmF0dXJlczogZW52ZWxvcGVTaWduYXR1cmVzXG4gICAgfVxuICB9KTtcbiAgdmFyIHQyID0gRGF0ZS5ub3coKTtcbiAgbGV0IHJldCA9IGNvbnRleHQucmVzcG9uc2UoKTtcbiAgcmV0LnRhZyA9IGl4LnRhZztcbiAgcmV0LnRyYW5zYWN0aW9uSWQgPSByZXMuaWQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBDdXN0b21FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIkZMT1c6OlRYXCIsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0eElkOiByZXQudHJhbnNhY3Rpb25JZCxcbiAgICAgICAgZGVsdGE6IHQyIC0gdDFcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2VuZEdldE5ldHdvcmtQYXJhbWV0ZXJzKGl4KSB7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpbnZhcmlhbnQob3B0cy5ub2RlLCBgU0RLIFNlbmQgR2V0IE5ldHdvcmsgUGFyYW1ldGVycyBFcnJvcjogb3B0cy5ub2RlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaW52YXJpYW50KGNvbnRleHQucmVzcG9uc2UsIGBTREsgU2VuZCBHZXQgTmV0d29yayBQYXJhbWV0ZXJzIEVycm9yOiBjb250ZXh0LnJlc3BvbnNlIG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgY29uc3QgaHR0cFJlcXVlc3QkMSA9IG9wdHMuaHR0cFJlcXVlc3QgfHwgaHR0cFJlcXVlc3Q7XG4gIGl4ID0gYXdhaXQgaXg7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHBSZXF1ZXN0JDEoe1xuICAgIGhvc3RuYW1lOiBvcHRzLm5vZGUsXG4gICAgcGF0aDogYC92MS9uZXR3b3JrL3BhcmFtZXRlcnNgLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBudWxsLFxuICAgIGVuYWJsZVJlcXVlc3RMb2dnaW5nOiBvcHRzLmVuYWJsZVJlcXVlc3RMb2dnaW5nID8/IHRydWVcbiAgfSk7XG4gIGxldCByZXQgPSBjb250ZXh0LnJlc3BvbnNlKCk7XG4gIHJldC50YWcgPSBpeC50YWc7XG4gIHJldC5uZXR3b3JrUGFyYW1ldGVycyA9IHtcbiAgICBjaGFpbklkOiByZXMuY2hhaW5faWRcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChpeCkge1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaW52YXJpYW50KG9wdHMubm9kZSwgYFNESyBTZW5kIEVycm9yOiBFaXRoZXIgb3B0cy5ub2RlIG9yIFwiYWNjZXNzTm9kZS5hcGlcIiBpbiBjb25maWcgbXVzdCBiZSBkZWZpbmVkLmApO1xuICBpbnZhcmlhbnQoY29udGV4dC5peCwgYFNESyBTZW5kIEVycm9yOiBjb250ZXh0Lml4IG11c3QgYmUgZGVmaW5lZC5gKTtcbiAgaXggPSBhd2FpdCBpeDtcblxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzVHJhbnNhY3Rpb24oaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZFRyYW5zYWN0aW9uID8gb3B0cy5zZW5kVHJhbnNhY3Rpb24oaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZFRyYW5zYWN0aW9uKGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXRUcmFuc2FjdGlvblN0YXR1cyhpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0VHJhbnNhY3Rpb25TdGF0dXMgPyBvcHRzLnNlbmRHZXRUcmFuc2FjdGlvblN0YXR1cyhpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0VHJhbnNhY3Rpb25TdGF0dXMoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldFRyYW5zYWN0aW9uKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRHZXRUcmFuc2FjdGlvbiA/IG9wdHMuc2VuZEdldFRyYW5zYWN0aW9uKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXRUcmFuc2FjdGlvbihpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzU2NyaXB0KGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRFeGVjdXRlU2NyaXB0ID8gb3B0cy5zZW5kRXhlY3V0ZVNjcmlwdChpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kRXhlY3V0ZVNjcmlwdChpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzR2V0QWNjb3VudChpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0QWNjb3VudCA/IG9wdHMuc2VuZEdldEFjY291bnQoaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZEdldEFjY291bnQoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldEV2ZW50cyhpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kR2V0RXZlbnRzID8gb3B0cy5zZW5kR2V0RXZlbnRzKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXRFdmVudHMoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldEJsb2NrKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRHZXRCbG9jayA/IG9wdHMuc2VuZEdldEJsb2NrKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXRCbG9jayhpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzR2V0QmxvY2tIZWFkZXIoaXgpOlxuICAgICAgcmV0dXJuIG9wdHMuc2VuZEdldEJsb2NrSGVhZGVyID8gb3B0cy5zZW5kR2V0QmxvY2tIZWFkZXIoaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZEdldEJsb2NrSGVhZGVyKGl4LCBjb250ZXh0LCBvcHRzKTtcbiAgICBjYXNlIGNvbnRleHQuaXguaXNHZXRDb2xsZWN0aW9uKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRHZXRDb2xsZWN0aW9uID8gb3B0cy5zZW5kR2V0Q29sbGVjdGlvbihpeCwgY29udGV4dCwgb3B0cykgOiBzZW5kR2V0Q29sbGVjdGlvbihpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgY2FzZSBjb250ZXh0Lml4LmlzUGluZyhpeCk6XG4gICAgICByZXR1cm4gb3B0cy5zZW5kUGluZyA/IG9wdHMuc2VuZFBpbmcoaXgsIGNvbnRleHQsIG9wdHMpIDogc2VuZFBpbmcoaXgsIGNvbnRleHQsIG9wdHMpO1xuICAgIGNhc2UgY29udGV4dC5peC5pc0dldE5ldHdvcmtQYXJhbWV0ZXJzKGl4KTpcbiAgICAgIHJldHVybiBvcHRzLnNlbmRHZXROZXR3b3JrUGFyYW1ldGVycyA/IG9wdHMuc2VuZEdldE5ldHdvcmtQYXJhbWV0ZXJzKGl4LCBjb250ZXh0LCBvcHRzKSA6IHNlbmRHZXROZXR3b3JrUGFyYW1ldGVycyhpeCwgY29udGV4dCwgb3B0cyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpeDtcbiAgfVxufTtcblxuZXhwb3J0IHsgc2VuZCwgc2VuZEV4ZWN1dGVTY3JpcHQsIHNlbmRHZXRBY2NvdW50LCBzZW5kR2V0QmxvY2ssIHNlbmRHZXRCbG9ja0hlYWRlciwgc2VuZEdldENvbGxlY3Rpb24sIHNlbmRHZXRFdmVudHMsIHNlbmRHZXROZXR3b3JrUGFyYW1ldGVycywgc2VuZEdldFRyYW5zYWN0aW9uLCBzZW5kR2V0VHJhbnNhY3Rpb25TdGF0dXMsIHNlbmRQaW5nLCBzZW5kVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay1zZW5kLWh0dHAubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/transport-http/dist/sdk-send-http.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/types/dist/types.module.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@onflow/types/dist/types.module.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: function() { return /* binding */ Address; },\n/* harmony export */   Array: function() { return /* binding */ _Array; },\n/* harmony export */   Bool: function() { return /* binding */ Bool; },\n/* harmony export */   Character: function() { return /* binding */ Character; },\n/* harmony export */   Dictionary: function() { return /* binding */ Dictionary; },\n/* harmony export */   Enum: function() { return /* binding */ Enum; },\n/* harmony export */   Event: function() { return /* binding */ Event; },\n/* harmony export */   Fix64: function() { return /* binding */ Fix64; },\n/* harmony export */   Identity: function() { return /* binding */ Identity; },\n/* harmony export */   Int: function() { return /* binding */ Int; },\n/* harmony export */   Int128: function() { return /* binding */ Int128; },\n/* harmony export */   Int16: function() { return /* binding */ Int16; },\n/* harmony export */   Int256: function() { return /* binding */ Int256; },\n/* harmony export */   Int32: function() { return /* binding */ Int32; },\n/* harmony export */   Int64: function() { return /* binding */ Int64; },\n/* harmony export */   Int8: function() { return /* binding */ Int8; },\n/* harmony export */   Optional: function() { return /* binding */ Optional; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   Reference: function() { return /* binding */ Reference; },\n/* harmony export */   Resource: function() { return /* binding */ Resource; },\n/* harmony export */   String: function() { return /* binding */ String; },\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   UFix64: function() { return /* binding */ UFix64; },\n/* harmony export */   UInt: function() { return /* binding */ UInt; },\n/* harmony export */   UInt128: function() { return /* binding */ UInt128; },\n/* harmony export */   UInt16: function() { return /* binding */ UInt16; },\n/* harmony export */   UInt256: function() { return /* binding */ UInt256; },\n/* harmony export */   UInt32: function() { return /* binding */ UInt32; },\n/* harmony export */   UInt64: function() { return /* binding */ UInt64; },\n/* harmony export */   UInt8: function() { return /* binding */ UInt8; },\n/* harmony export */   Void: function() { return /* binding */ Void; },\n/* harmony export */   Word16: function() { return /* binding */ Word16; },\n/* harmony export */   Word32: function() { return /* binding */ Word32; },\n/* harmony export */   Word64: function() { return /* binding */ Word64; },\n/* harmony export */   Word8: function() { return /* binding */ Word8; },\n/* harmony export */   _Array: function() { return /* binding */ _Array; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED$1 = \"UPDATED\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED$1);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS.warn : LEVELS.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\nconst type = (label, asArgument, asInjection) => ({\n  label,\n  asArgument,\n  asInjection\n});\nconst isArray = d => Array.isArray(d);\nconst isObj = d => typeof d === \"object\";\nconst isNull = d => d == null;\nconst isBoolean = d => typeof d === \"boolean\";\nconst isNumber = d => typeof d === \"number\";\nconst isInteger = d => Number.isInteger(d);\nconst isString = d => typeof d === \"string\";\nconst throwTypeError = msg => {\n  throw new Error(\"Type Error: \" + msg);\n};\nconst numberValuesDeprecationNotice = type => {\n  log.deprecate({\n    pkg: \"@onflow/types\",\n    subject: `Passing in Number as value for ${type}`,\n    message: `Going forward, use String as value for ${type}.`,\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number\"\n  });\n};\nconst Identity = type(\"Identity\", v => v, v => v);\nconst UInt = type(\"UInt\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt\");\n    return {\n      type: \"UInt\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected Positive Integer for type Unsigned Int\");\n}, v => v);\nconst Int = type(\"Int\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int\");\n    return {\n      type: \"Int\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected Integer for type Int\");\n}, v => v);\nconst UInt8 = type(\"UInt8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt8\");\n    return {\n      type: \"UInt8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt8\");\n}, v => v);\nconst Int8 = type(\"Int8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int8\");\n    return {\n      type: \"Int8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int8\");\n}, v => v);\nconst UInt16 = type(\"UInt16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt16\");\n    return {\n      type: \"UInt16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt16\");\n}, v => v);\nconst Int16 = type(\"Int16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int16\");\n    return {\n      type: \"Int16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int16\");\n}, v => v);\nconst UInt32 = type(\"UInt32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt32\");\n    return {\n      type: \"UInt32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt32\");\n}, v => v);\nconst Int32 = type(\"Int32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int32\");\n    return {\n      type: \"Int32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int32\");\n}, v => v);\nconst UInt64 = type(\"UInt64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt64\");\n    return {\n      type: \"UInt64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt64\");\n}, v => v);\nconst Int64 = type(\"Int64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int64\");\n    return {\n      type: \"Int64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int64\");\n}, v => v);\nconst UInt128 = type(\"UInt128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt128\");\n    return {\n      type: \"UInt128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt128\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt128\");\n}, v => v);\nconst Int128 = type(\"Int128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int128\");\n    return {\n      type: \"Int128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int128\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive integer for Int128\");\n}, v => v);\nconst UInt256 = type(\"UInt256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt256\");\n    return {\n      type: \"UInt256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt256\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for UInt256\");\n}, v => v);\nconst Int256 = type(\"Int256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int256\");\n    return {\n      type: \"Int256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int256\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected integer for Int256\");\n}, v => v);\nconst Word8 = type(\"Word8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word8\");\n    return {\n      type: \"Word8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word8\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word8\");\n}, v => v);\nconst Word16 = type(\"Word16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word16\");\n    return {\n      type: \"Word16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word16\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word16\");\n}, v => v);\nconst Word32 = type(\"Word32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word32\");\n    return {\n      type: \"Word32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word32\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word32\");\n}, v => v);\nconst Word64 = type(\"Word64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word64\");\n    return {\n      type: \"Word64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word64\",\n      value: v\n    };\n  }\n  throwTypeError(\"Expected positive number for Word64\");\n}, v => v);\nconst UFix64AndFix64NumberDeprecationNotice = () => {\n  log.deprecate({\n    subject: \"Passing in Numbers as values for Fix64 and UFix64 types\",\n    pkg: \"@onflow/types\",\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\"\n  });\n};\nconst UFix64 = type(\"UFix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"UFix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"UFix64\",\n      value: v.toString()\n    };\n  }\n  throwTypeError(\"Expected String for UFix64\");\n}, v => v);\nconst Fix64 = type(\"Fix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      throwTypeError(`Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`);\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"Fix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"Fix64\",\n      value: v.toString()\n    };\n  }\n  throwTypeError(\"Expected String for Fix64\");\n}, v => v);\nconst String = type(\"String\", v => {\n  if (isString(v)) return {\n    type: \"String\",\n    value: v\n  };\n  throwTypeError(\"Expected String for type String\");\n}, v => v);\nconst Character = type(\"Character\", v => {\n  if (isString(v)) return {\n    type: \"Character\",\n    value: v\n  };\n  throwTypeError(\"Expected Character for type Character\");\n}, v => v);\nconst Bool = type(\"Bool\", v => {\n  if (isBoolean(v)) return {\n    type: \"Bool\",\n    value: v\n  };\n  throwTypeError(\"Expected Boolean for type Bool\");\n}, v => v);\nconst Address = type(\"Address\", v => {\n  if (isString(v)) return {\n    type: \"Address\",\n    value: v\n  };\n  throwTypeError(\"Expected Address for type Address\");\n}, v => v);\nconst Void = type(\"Void\", v => {\n  if (!v || isNull(v)) return {\n    type: \"Void\"\n  };\n  throwTypeError(\"Expected Void for type Void\");\n}, v => v);\nconst Optional = children => type(\"Optional\", v => ({\n  type: \"Optional\",\n  value: isNull(v) ? null : children.asArgument(v)\n}), v => v);\nconst Reference = type(\"Reference\", v => {\n  if (isObj(v)) return {\n    type: \"Reference\",\n    value: v\n  };\n  throwTypeError(\"Expected Object for type Reference\");\n}, v => v);\nconst _Array = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return type(\"Array\", v => {\n    return {\n      type: \"Array\",\n      value: isArray(children) ? children.map((c, i) => c.asArgument(v[i])) : v.map(x => children.asArgument(x))\n    };\n  }, v => v);\n};\nconst Dictionary = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return type(\"Dictionary\", v => {\n    if (isObj(v)) return {\n      type: \"Dictionary\",\n      value: isArray(children) ? children.map((c, i) => ({\n        key: c.key.asArgument(v[i].key),\n        value: c.value.asArgument(v[i].value)\n      })) : isArray(v) ? v.map(x => ({\n        key: children.key.asArgument(x.key),\n        value: children.value.asArgument(x.value)\n      })) : [{\n        key: children.key.asArgument(v.key),\n        value: children.value.asArgument(v.value)\n      }]\n    };\n    throwTypeError(\"Expected Object for type Dictionary\");\n  }, v => v);\n};\nconst Event = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Event\", v => {\n    if (isObj(v)) return {\n      type: \"Event\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Event\");\n  }, v => v);\n};\nconst Resource = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Resource\", v => {\n    if (isObj(v)) return {\n      type: \"Resource\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Resource\");\n  }, v => v);\n};\nconst Struct = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Struct\", v => {\n    if (isObj(v)) return {\n      type: \"Struct\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Struct\");\n  }, v => v);\n};\nconst Enum = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return type(\"Enum\", v => {\n    if (isObj(v)) return {\n      type: \"Enum\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    throwTypeError(\"Expected Object for type Enum\");\n  }, v => v);\n};\nconst Path = type(\"Path\", v => {\n  if (isObj(v)) {\n    if (!isString(v.domain)) {\n      throwTypeError(`Expected a string for the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    if (!(v.domain === \"storage\" || v.domain === \"private\" || v.domain === \"public\")) {\n      throwTypeError(`Expected either \"storage\", \"private\" or \"public\" as the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    if (!isString(v.identifier)) {\n      throwTypeError(`Expected a string for the Path identifier but found ${v.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`);\n    }\n    return {\n      type: \"Path\",\n      value: {\n        domain: v.domain,\n        identifier: v.identifier\n      }\n    };\n  }\n  throwTypeError(\"Expected Object for type Path\");\n}, v => v);\n\n\n//# sourceMappingURL=types.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdHlwZXMvZGlzdC90eXBlcy5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0hBQXNILHFCQUFNLG1CQUFtQixxQkFBTTs7QUFFcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBTSxpQkFBaUIscUJBQU0sWUFBWSxxQkFBTSxJQUFJLHFCQUFNO0FBQ3ZJLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsUUFBUTtBQUNSLHlCQUF5QixZQUFZO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBLGdJQUFnSSxrQkFBa0I7QUFDbEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0EsZ0lBQWdJLGtCQUFrQjtBQUNsSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBLHNHQUFzRyxTQUFTO0FBQy9HO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRStTO0FBQ2hUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy90eXBlcy9kaXN0L3R5cGVzLm1vZHVsZS5qcz9iZTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4vKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5sZXQgcHJvbWlzZTtcbnZhciBxdWV1ZU1pY3JvdGFza18xID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nID8gcXVldWVNaWNyb3Rhc2suYmluZCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGNvbW1vbmpzR2xvYmFsKVxuLy8gcmV1c2UgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIGFsbG9jYXRlIGl0IGxhemlseVxuOiBjYiA9PiAocHJvbWlzZSB8fCAocHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSkudGhlbihjYikuY2F0Y2goZXJyID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICB0aHJvdyBlcnI7XG59LCAwKSk7XG5cbmNvbnN0IG1haWxib3ggPSAoKSA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gW107XG4gIHZhciBuZXh0O1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGRlbGl2ZXIobXNnKSB7XG4gICAgICBxdWV1ZS5wdXNoKG1zZyk7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0KHF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBpbm5lclJlY2VpdmUocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBtc2cgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAobXNnKSByZXR1cm4gcmVzb2x2ZShtc2cpO1xuICAgICAgICBuZXh0ID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBJTklUID0gXCJJTklUXCI7XG5jb25zdCBTVUJTQ1JJQkUgPSBcIlNVQlNDUklCRVwiO1xuY29uc3QgVU5TVUJTQ1JJQkUgPSBcIlVOU1VCU0NSSUJFXCI7XG5jb25zdCBVUERBVEVEJDEgPSBcIlVQREFURURcIjtcbmNvbnN0IEVYSVQgPSBcIkVYSVRcIjtcbmNvbnN0IFRFUk1JTkFURSA9IFwiVEVSTUlOQVRFXCI7XG5jb25zdCByb290ID0gdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHwgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvdztcbnJvb3QuRkNMX1JFR0lTVFJZID0gcm9vdC5GQ0xfUkVHSVNUUlkgPT0gbnVsbCA/IHt9IDogcm9vdC5GQ0xfUkVHSVNUUlk7XG52YXIgcGlkID0gMGIwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IHNlbmQgPSBmdW5jdGlvbiAoYWRkciwgdGFnLCBkYXRhKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXBseSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZXhwZWN0UmVwbHkgPSBvcHRzLmV4cGVjdFJlcGx5IHx8IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgIT0gbnVsbCA/IG9wdHMudGltZW91dCA6IERFRkFVTFRfVElNRU9VVDtcbiAgICBpZiAoZXhwZWN0UmVwbHkgJiYgdGltZW91dCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0OiAke3RpbWVvdXR9bXMgcGFzc2VkIHdpdGhvdXQgYSByZXNwb25zZS5gKSksIHRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgdG86IGFkZHIsXG4gICAgICBmcm9tOiBvcHRzLmZyb20sXG4gICAgICB0YWcsXG4gICAgICBkYXRhLFxuICAgICAgdGltZW91dCxcbiAgICAgIHJlcGx5LFxuICAgICAgcmVqZWN0XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ubWFpbGJveC5kZWxpdmVyKHBheWxvYWQpO1xuICAgICAgaWYgKCFleHBlY3RSZXBseSkgcmVwbHkodHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGQ0wuQWN0b3IgLS0gQ291bGQgTm90IERlbGl2ZXIgTWVzc2FnZVwiLCBwYXlsb2FkLCByb290LkZDTF9SRUdJU1RSWVthZGRyXSwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3Qga2lsbCA9IGFkZHIgPT4ge1xuICBkZWxldGUgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl07XG59O1xuY29uc3QgZnJvbUhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICBsZXQgaGFuZGxlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gYXN5bmMgY3R4ID0+IHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXJzW0lOSVRdID09PSBcImZ1bmN0aW9uXCIpIGF3YWl0IGhhbmRsZXJzW0lOSVRdKGN0eCk7XG4gICAgX19sb29wOiB3aGlsZSAoMSkge1xuICAgICAgY29uc3QgbGV0dGVyID0gYXdhaXQgY3R4LnJlY2VpdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChsZXR0ZXIudGFnID09PSBFWElUKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyc1tURVJNSU5BVEVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXJzW1RFUk1JTkFURV0oY3R4LCBsZXR0ZXIsIGxldHRlci5kYXRhIHx8IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWsgX19sb29wO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZXJzW2xldHRlci50YWddKGN0eCwgbGV0dGVyLCBsZXR0ZXIuZGF0YSB8fCB7fSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2N0eC5zZWxmKCl9IEVycm9yYCwgbGV0dGVyLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250aW51ZSBfX2xvb3A7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IHNwYXduID0gZnVuY3Rpb24gKGZuKSB7XG4gIGxldCBhZGRyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICBpZiAoYWRkciA9PSBudWxsKSBhZGRyID0gKytwaWQ7XG4gIGlmIChyb290LkZDTF9SRUdJU1RSWVthZGRyXSAhPSBudWxsKSByZXR1cm4gYWRkcjtcbiAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gPSB7XG4gICAgYWRkcixcbiAgICBtYWlsYm94OiBtYWlsYm94KCksXG4gICAgc3ViczogbmV3IFNldCgpLFxuICAgIGt2czoge30sXG4gICAgZXJyb3I6IG51bGxcbiAgfTtcbiAgY29uc3QgY3R4ID0ge1xuICAgIHNlbGY6ICgpID0+IGFkZHIsXG4gICAgcmVjZWl2ZTogKCkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ubWFpbGJveC5yZWNlaXZlKCksXG4gICAgc2VuZDogZnVuY3Rpb24gKHRvLCB0YWcsIGRhdGEpIHtcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIG9wdHMuZnJvbSA9IGFkZHI7XG4gICAgICByZXR1cm4gc2VuZCh0bywgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIHNlbmRTZWxmOiAodGFnLCBkYXRhLCBvcHRzKSA9PiB7XG4gICAgICBpZiAocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0pIHNlbmQoYWRkciwgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24gKHRhZywgZGF0YSkge1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgb3B0cy5mcm9tID0gYWRkcjtcbiAgICAgIGZvciAobGV0IHRvIG9mIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMpIHNlbmQodG8sIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IHN1YiA9PiBzdWIgIT0gbnVsbCAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLmFkZChzdWIpLFxuICAgIHVuc3Vic2NyaWJlOiBzdWIgPT4gc3ViICE9IG51bGwgJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5kZWxldGUoc3ViKSxcbiAgICBzdWJzY3JpYmVyQ291bnQ6ICgpID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuc2l6ZSxcbiAgICBoYXNTdWJzOiAoKSA9PiAhIXJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuc2l6ZSxcbiAgICBwdXQ6IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQ6IChrZXksIGZhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldO1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBmYWxsYmFjayA6IHZhbHVlO1xuICAgIH0sXG4gICAgZGVsZXRlOiBrZXkgPT4ge1xuICAgICAgZGVsZXRlIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoa2V5LCBmbikgPT4ge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IGZuKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldKTtcbiAgICB9LFxuICAgIGtleXM6ICgpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnMpO1xuICAgIH0sXG4gICAgYWxsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzO1xuICAgIH0sXG4gICAgd2hlcmU6IHBhdHRlcm4gPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KGtleSkgPyB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtrZXldOiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XVxuICAgICAgICB9IDogYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gZGF0YVtrZXldKTtcbiAgICB9LFxuICAgIGZhdGFsRXJyb3I6IGVycm9yID0+IHtcbiAgICAgIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmVycm9yID0gZXJyb3I7XG4gICAgICBmb3IgKGxldCB0byBvZiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzKSBzZW5kKHRvLCBVUERBVEVEJDEpO1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIikgZm4gPSBmcm9tSGFuZGxlcnMoZm4pO1xuICBxdWV1ZU1pY3JvdGFza18xKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmbihjdHgpO1xuICAgIGtpbGwoYWRkcik7XG4gIH0pO1xuICByZXR1cm4gYWRkcjtcbn07XG5cbi8vIFJldHVybnMgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb25cbi8vIEEgU1VCU0NSSUJFIGhhbmRsZXIgd2lsbCBuZWVkIHRvIGJlIGNyZWF0ZWQgdG8gaGFuZGxlIHRoZSBzdWJzY3JpcHRpb24gZXZlbnRcbi8vXG4vLyAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuLy8gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSlcbi8vICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBVUERBVEVELCBjdHguYWxsKCkpXG4vLyAgfVxuLy9cbmZ1bmN0aW9uIHN1YnNjcmliZXIoYWRkcmVzcywgc3Bhd25GbiwgY2FsbGJhY2spIHtcbiAgc3Bhd25GbihhZGRyZXNzKTtcbiAgY29uc3QgRVhJVCA9IFwiQEVYSVRcIjtcbiAgY29uc3Qgc2VsZiA9IHNwYXduKGFzeW5jIGN0eCA9PiB7XG4gICAgY3R4LnNlbmQoYWRkcmVzcywgU1VCU0NSSUJFKTtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgY29uc3QgbGV0dGVyID0gYXdhaXQgY3R4LnJlY2VpdmUoKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcmVzc10uZXJyb3I7XG4gICAgICBpZiAobGV0dGVyLnRhZyA9PT0gRVhJVCkge1xuICAgICAgICBjdHguc2VuZChhZGRyZXNzLCBVTlNVQlNDUklCRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBlcnJvcik7XG4gICAgICAgIGN0eC5zZW5kKGFkZHJlc3MsIFVOU1VCU0NSSUJFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobGV0dGVyLmRhdGEsIG51bGwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiBzZW5kKHNlbGYsIEVYSVQpO1xufVxuXG4vKipcbiAqIEFzc2VydHMgZmFjdCBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3Igd2l0aCBpbnZhcmlhbnQgbWVzc2FnZVxuICogQHBhcmFtIHtib29sZWFufSBmYWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKiBAcGFyYW0ge0FycmF5fSByZXN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW52YXJpYW50KGZhY3QsIG1zZykge1xuICBpZiAoIWZhY3QpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSU5WQVJJQU5UICR7bXNnfWApO1xuICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGQgPT4gIS9hdCBpbnZhcmlhbnQvLnRlc3QoZCkpLmpvaW4oXCJcXG5cIik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJcXG5cXG4tLS1cXG5cXG5cIiwgZXJyb3IsIFwiXFxuXFxuXCIsIC4uLnJlc3QsIFwiXFxuXFxuLS0tXFxuXFxuXCIpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5jb25zdCBwaXBlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmMocmVzKTtcbiAgICB9LCB2KTtcbiAgfTtcbn07XG5cbi8qKipcbiAqIE1lcmdlIG11bHRpcGxlIGZ1bmN0aW9ucyByZXR1cm5pbmcgb2JqZWN0cyBpbnRvIG9uZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLmZ1bmN0aW9uKCopOiBvYmplY3R9IGZ1bmNzIC0gRnVuY3Rpb25zIHRvIG1lcmdlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBmdW5jc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIHJldHVybiB2ID0+IHtcbiAgICByZXR1cm4gZnVuY3MucmVkdWNlKChyZXMsIGZ1bmMpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlcyxcbiAgICAgICAgLi4uZnVuYyh2KVxuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH07XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBPYmplY3QgY2hlY2tcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSXMgb2JqZWN0IHN0YXR1c1xuICovXG5jb25zdCBpc09iamVjdCA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gey4uLm9iamVjdFtdfSBzb3VyY2VzIC0gU291cmNlIG9iamVjdHNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZURlZXAgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc291cmNlc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICBpZiAoIXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XToge31cbiAgICAgICAgfSk7XG4gICAgICAgIG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XTogc291cmNlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZURlZXAodGFyZ2V0LCAuLi5zb3VyY2VzKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgRmxvdyBKU09OLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHZhbHVlIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIEZsb3cgSlNPTlxuICovXG5jb25zdCBtZXJnZUZsb3dKU09OcyA9IHZhbHVlID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gbWVyZ2VEZWVwKHt9LCAuLi52YWx1ZSkgOiB2YWx1ZTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRmlsdGVyIG91dCBjb250cmFjdHMgc2VjdGlvbiBvZiBmbG93Lmpzb24uXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gb2JqIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3RzIHNlY3Rpb24gb2YgRmxvdyBKU09OXG4gKi9cbmNvbnN0IGZpbHRlckNvbnRyYWN0cyA9IG9iaiA9PiBvYmouY29udHJhY3RzID8gb2JqLmNvbnRyYWN0cyA6IHt9O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHYXRoZXJzIGNvbnRyYWN0IGFkZHJlc3NlcyBieSBuZXR3b3JrXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IG1hcENvbnRyYWN0QWxpYXNlc1RvTmV0d29ya0FkZHJlc3MgPSBuZXR3b3JrID0+IGNvbnRyYWN0cyA9PiB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjb250cmFjdHMpLnJlZHVjZSgoYywgX3JlZikgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgIGNvbnN0IG5ldHdvcmtDb250cmFjdEFsaWFzID0gdmFsdWU/LmFsaWFzZXM/LltuZXR3b3JrXTtcbiAgICBpZiAobmV0d29ya0NvbnRyYWN0QWxpYXMpIHtcbiAgICAgIGNba2V5XSA9IG5ldHdvcmtDb250cmFjdEFsaWFzO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwge30pO1xufTtcbmNvbnN0IG1hcERlcGxveW1lbnRzVG9OZXR3b3JrQWRkcmVzcyA9IG5ldHdvcmsgPT4gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGRlcGxveW1lbnRzID0ge30sXG4gICAgYWNjb3VudHMgPSB7fVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IG5ldHdvcmtEZXBsb3ltZW50ID0gZGVwbG95bWVudHM/LltuZXR3b3JrXTtcbiAgaWYgKCFuZXR3b3JrRGVwbG95bWVudCkgcmV0dXJuIHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobmV0d29ya0RlcGxveW1lbnQpLnJlZHVjZSgoYywgX3JlZjMpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgLy8gUmVzb2x2ZSBhY2NvdW50IGFkZHJlc3NcbiAgICBjb25zdCBhY2NvdW50QWRkcmVzcyA9IGFjY291bnRzW2tleV0/LmFkZHJlc3M7XG4gICAgaWYgKCFhY2NvdW50QWRkcmVzcykgcmV0dXJuIGM7XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IGFzc2lnbmluZyB0aGUgYWRkcmVzcyB0byB0aGUgY29udHJhY3QgbmFtZS5cbiAgICByZXR1cm4gdmFsdWUucmVkdWNlKChjLCBjb250cmFjdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgW2NvbnRyYWN0XTogYWNjb3VudEFkZHJlc3NcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGluIGZsb3cuanNvbiBmaWxlcyBhbmQgcmV0dXJuIGNvbnRyYWN0IHRvIGFkZHJlc3MgbWFwcGluZyBieSBuZXR3b3JrXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0ganNvbnMgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGdhdGhlciBhZGRyZXNzZXMgZm9yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0IG5hbWVzIGJ5IGFkZHJlc3NlcyBtYXBwaW5nIGUuZyB7IFwiSGVsbG9Xb3JsZFwiOiBcIjB4MTIzXCIgfVxuICovXG5jb25zdCBnZXRDb250cmFjdHMgPSAoanNvbnMsIG5ldHdvcmspID0+IHtcbiAgcmV0dXJuIHBpcGUobWVyZ2VGbG93SlNPTnMsIG1lcmdlUGlwZShtYXBEZXBsb3ltZW50c1RvTmV0d29ya0FkZHJlc3MobmV0d29yayksIHBpcGUoZmlsdGVyQ29udHJhY3RzLCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzKG5ldHdvcmspKSkpKGpzb25zKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiBzdHJpbmcgaXMgaGV4aWRlY2ltYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIGhleGlkZWNpbWFsIHN0YXR1c1xuICovXG5jb25zdCBpc0hleGlkZWNpbWFsID0gc3RyID0+IHtcbiAgLy8gQ2hlY2sgdGhhdCBpdCBpcyBhIHN0cmluZ1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gL15bMC05QS1GYS1mXSskLy50ZXN0KHN0cik7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDaGVja3MgZmxvdy5qc29uIGZpbGUgZm9yIHByaXZhdGUga2V5c1xuICogQHBhcmFtIHtvYmplY3R9IGZsb3dKU09OIC0gRmxvdyBKU09OXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBIYXMgcHJpdmF0ZSBrZXlzIHN0YXR1c1xuICovXG5jb25zdCBoYXNQcml2YXRlS2V5cyA9IGZsb3dKU09OID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZsb3dKU09OPy5hY2NvdW50cykucmVkdWNlKChoYXNQcml2YXRlS2V5LCBfcmVmNCkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmNDtcbiAgICBpZiAoaGFzUHJpdmF0ZUtleSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHZhbHVlPy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSAmJiBpc0hleGlkZWNpbWFsKHZhbHVlPy5rZXkpO1xuICB9LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNoZWNrcyBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gdmFsdWUgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgYW55SGFzUHJpdmF0ZUtleXMgPSB2YWx1ZSA9PiB7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHJldHVybiBoYXNQcml2YXRlS2V5cyh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZS5zb21lKGhhc1ByaXZhdGVLZXlzKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZvcm1hdCBuZXR3b3JrIHRvIGFsd2F5cyBiZSAnZW11bGF0b3InLCAndGVzdG5ldCcsIG9yICdtYWlubmV0J1xuICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBOZXR3b3JrIHRvIGZvcm1hdFxuICogQHJldHVybnMge3N0cmluZ30gLSBGb3JtYXR0ZWQgbmV0d29yayBuYW1lIChlaXRoZXIgJ2VtdWxhdG9yJywgJ3Rlc3RuZXQnLCBvciAnbWFpbm5ldCcpXG4gKi9cbmNvbnN0IGNsZWFuTmV0d29yayA9IG5ldHdvcmsgPT4gbmV0d29yaz8udG9Mb3dlckNhc2UoKSA9PT0gXCJsb2NhbFwiID8gXCJlbXVsYXRvclwiIDogbmV0d29yaz8udG9Mb3dlckNhc2UoKTtcbmNvbnN0IE5BTUUgPSBcImNvbmZpZ1wiO1xuY29uc3QgUFVUID0gXCJQVVRfQ09ORklHXCI7XG5jb25zdCBHRVQgPSBcIkdFVF9DT05GSUdcIjtcbmNvbnN0IEdFVF9BTEwgPSBcIkdFVF9BTExfQ09ORklHXCI7XG5jb25zdCBVUERBVEUgPSBcIlVQREFURV9DT05GSUdcIjtcbmNvbnN0IERFTEVURSA9IFwiREVMRVRFX0NPTkZJR1wiO1xuY29uc3QgQ0xFQVIgPSBcIkNMRUFSX0NPTkZJR1wiO1xuY29uc3QgV0hFUkUgPSBcIldIRVJFX0NPTkZJR1wiO1xuY29uc3QgVVBEQVRFRCA9IFwiQ09ORklHL1VQREFURURcIjtcbmNvbnN0IGlkZW50aXR5ID0gdiA9PiB2O1xuY29uc3QgSEFORExFUlMgPSB7XG4gIFtQVVRdOiAoY3R4LCBfbGV0dGVyLCBfcmVmKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvcHV0LlwiKTtcbiAgICBjdHgucHV0KGtleSwgdmFsdWUpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtHRVRdOiAoY3R4LCBsZXR0ZXIsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZhbGxiYWNrXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL2dldFwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LmdldChrZXksIGZhbGxiYWNrKSk7XG4gIH0sXG4gIFtHRVRfQUxMXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0dGVyLnJlcGx5KHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVVBEQVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmMykgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmblxuICAgIH0gPSBfcmVmMztcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy91cGRhdGVcIik7XG4gICAgY3R4LnVwZGF0ZShrZXksIGZuIHx8IGlkZW50aXR5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbREVMRVRFXTogKGN0eCwgbGV0dGVyLCBfcmVmNCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXlcbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZGVsZXRlXCIpO1xuICAgIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbQ0xFQVJdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGN0eC5hbGwoKSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbV0hFUkVdOiAoY3R4LCBsZXR0ZXIsIF9yZWY1KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdHRlcm5cbiAgICB9ID0gX3JlZjU7XG4gICAgaWYgKHBhdHRlcm4gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAncGF0dGVybicgZm9yIGNvbmZpZy93aGVyZVwiKTtcbiAgICBsZXR0ZXIucmVwbHkoY3R4LndoZXJlKHBhdHRlcm4pKTtcbiAgfSxcbiAgW1NVQlNDUklCRV06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICAgIGN0eC5zZW5kKGxldHRlci5mcm9tLCBVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VOU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnVuc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgfVxufTtcbnNwYXduKEhBTkRMRVJTLCBOQU1FKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQWRkcyBhIGtleS12YWx1ZSBwYWlyIHRvIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGRcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gIHNlbmQoTkFNRSwgUFVULCB7XG4gICAga2V5LFxuICAgIHZhbHVlXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgYSBrZXktdmFsdWUgcGFpciB3aXRoIGEgZmFsbGJhY2sgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gW2ZhbGxiYWNrXSAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXQoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gc2VuZChOQU1FLCBHRVQsIHtcbiAgICBrZXksXG4gICAgZmFsbGJhY2tcbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCBjb25maWcgdmFsdWUgb3IgdGhlIGZhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YW50cyAtIFRoZSBrZXlzIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7Kn0gZmFsbGJhY2sgLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGxldCB3YW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGxldCBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBpZiAoIXdhbnRzLmxlbmd0aCkgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCBbaGVhZCwgLi4ucmVzdF0gPSB3YW50cztcbiAgY29uc3QgcmV0ID0gYXdhaXQgZ2V0KGhlYWQpO1xuICBpZiAocmV0ID09IG51bGwpIHJldHVybiBmaXJzdChyZXN0LCBmYWxsYmFjayk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGwoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIEdFVF9BTEwsIG51bGwsIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVXBkYXRlcyBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWx1ZSB3aXRoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiB1cGRhdGUoa2V5KSB7XG4gIGxldCBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWRlbnRpdHk7XG4gIHNlbmQoTkFNRSwgVVBEQVRFLCB7XG4gICAga2V5LFxuICAgIGZuXG4gIH0pO1xuICByZXR1cm4gY29uZmlnKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlbGV0ZXMgYSBrZXktdmFsdWUgcGFpciBmcm9tIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGRlbGV0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgc2VuZChOQU1FLCBERUxFVEUsIHtcbiAgICBrZXlcbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgY29uZmlnIGJhc2VkIG9uIGEgcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCBrZXlzIGFnYWluc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIHN1YnNldCBvZiB0aGUgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHdoZXJlKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgV0hFUkUsIHtcbiAgICBwYXR0ZXJuXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gU3Vic2NyaWJlcyB0byBjb25maWcgdXBkYXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGNvbmZpZyBpcyB1cGRhdGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICByZXR1cm4gc3Vic2NyaWJlcihOQU1FLCAoKSA9PiBzcGF3bihIQU5ETEVSUywgTkFNRSksIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2xlYXJzIHRoZSBjb25maWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBjbGVhckNvbmZpZygpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgQ0xFQVIpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXNldHMgdGhlIGNvbmZpZyB0byBhIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkQ29uZmlnIC0gVGhlIHByZXZpb3VzIGNvbmZpZyBzdGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb25maWcob2xkQ29uZmlnKSB7XG4gIHJldHVybiBjbGVhckNvbmZpZygpLnRoZW4oY29uZmlnKG9sZENvbmZpZykpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUYWtlcyBpbiBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzIGFuZCBjcmVhdGVzIGNvbnRyYWN0IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgLSBUaGUgZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWQoZGF0YSkge1xuICBjb25zdCBuZXR3b3JrID0gYXdhaXQgZ2V0KFwiZmxvdy5uZXR3b3JrXCIpO1xuICBjb25zdCBjbGVhbmVkTmV0d29yayA9IGNsZWFuTmV0d29yayhuZXR3b3JrKTtcbiAgY29uc3Qge1xuICAgIGZsb3dKU09OXG4gIH0gPSBkYXRhO1xuICBpbnZhcmlhbnQoQm9vbGVhbihmbG93SlNPTiksIFwiY29uZmlnLmxvYWQgLS0gJ2Zsb3dKU09OJyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIGludmFyaWFudChjbGVhbmVkTmV0d29yaywgYEZsb3cgTmV0d29yayBSZXF1aXJlZCAtLSBJbiBvcmRlciBmb3IgRkNMIHRvIGxvYWQgeW91ciBjb250cmFjdHMgcGxlYXNlIGRlZmluZSBcImZsb3cubmV0d29ya1wiIHRvIFwiZW11bGF0b3JcIiwgXCJsb2NhbFwiLCBcInRlc3RuZXRcIiwgb3IgXCJtYWlubmV0XCIgaW4geW91ciBjb25maWcuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mY2wtanMvcmVmZXJlbmNlL2NvbmZpZ3VyZS1mY2xgKTtcbiAgaWYgKGFueUhhc1ByaXZhdGVLZXlzKGZsb3dKU09OKSkge1xuICAgIGNvbnN0IGlzRW11bGF0b3IgPSBjbGVhbmVkTmV0d29yayA9PT0gXCJlbXVsYXRvclwiO1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogXCJQcml2YXRlIEtleXMgRGV0ZWN0ZWRcIixcbiAgICAgIG1lc3NhZ2U6IGBQcml2YXRlIGtleXMgc2hvdWxkIGJlIHN0b3JlZCBpbiBhIHNlcGFyYXRlIGZsb3cuanNvbiBmaWxlIGZvciBzZWN1cml0eS4gU2VlIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmZsb3cuY29tL3Rvb2xzL2Zsb3ctY2xpL3NlY3VyaXR5YCxcbiAgICAgIGxldmVsOiBpc0VtdWxhdG9yID8gTEVWRUxTLndhcm4gOiBMRVZFTFMuZXJyb3JcbiAgICB9KTtcbiAgICBpZiAoIWlzRW11bGF0b3IpIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnZXRDb250cmFjdHMoZmxvd0pTT04sIGNsZWFuZWROZXR3b3JrKSkpIHtcbiAgICBjb25zdCBjb250cmFjdENvbmZpZ0tleSA9IGAweCR7a2V5fWA7XG4gICAgY29uc3QgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSA9IGF3YWl0IGdldChjb250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgJiYgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBMRVZFTFMud2FyblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dChjb250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBzeXN0ZW1Db250cmFjdENvbmZpZ0tleSA9IGBzeXN0ZW0uY29udHJhY3RzLiR7a2V5fWA7XG4gICAgY29uc3Qgc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlID0gYXdhaXQgZ2V0KHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5KTtcbiAgICBpZiAoc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlICYmIHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyh7XG4gICAgICAgIHRpdGxlOiBcIkNvbnRyYWN0IFBsYWNlaG9sZGVyIENvbmZsaWN0IERldGVjdGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBIGdlbmVyYXRlZCBjb250cmFjdCBwbGFjZWhvbGRlciBmcm9tIGNvbmZpZy5sb2FkIGNvbmZsaWN0cyB3aXRoIGEgcGxhY2Vob2xkZXIgeW91J3ZlIHNldCBtYW51YWxseSBpbiBjb25maWcgaGF2ZSB0aGUgc2FtZSBuYW1lLmAsXG4gICAgICAgIGxldmVsOiBMRVZFTFMud2FyblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dChzeXN0ZW1Db250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1yZXR1cm5zXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXSAtIFRoZSB2YWx1ZXMgdG8gc2V0XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZyh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLm1hcChkID0+IHB1dChkLCB2YWx1ZXNbZF0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHB1dCxcbiAgICBnZXQsXG4gICAgYWxsLFxuICAgIGZpcnN0LFxuICAgIHVwZGF0ZSxcbiAgICBkZWxldGU6IF9kZWxldGUsXG4gICAgd2hlcmUsXG4gICAgc3Vic2NyaWJlLFxuICAgIG92ZXJsb2FkLFxuICAgIGxvYWRcbiAgfTtcbn1cbmNvbmZpZy5wdXQgPSBwdXQ7XG5jb25maWcuZ2V0ID0gZ2V0O1xuY29uZmlnLmFsbCA9IGFsbDtcbmNvbmZpZy5maXJzdCA9IGZpcnN0O1xuY29uZmlnLnVwZGF0ZSA9IHVwZGF0ZTtcbmNvbmZpZy5kZWxldGUgPSBfZGVsZXRlO1xuY29uZmlnLndoZXJlID0gd2hlcmU7XG5jb25maWcuc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuY29uZmlnLm92ZXJsb2FkID0gb3ZlcmxvYWQ7XG5jb25maWcubG9hZCA9IGxvYWQ7XG5jb25zdCBub29wID0gdiA9PiB2O1xuZnVuY3Rpb24gb3ZlcmxvYWQoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG9sZENvbmZpZyA9IGF3YWl0IGFsbCgpO1xuICAgIHRyeSB7XG4gICAgICBjb25maWcob3B0cyk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soYXdhaXQgYWxsKCkpO1xuICAgICAgYXdhaXQgcmVzZXRDb25maWcob2xkQ29uZmlnKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgcmVzZXRDb25maWcob2xkQ29uZmlnKTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgbGV2ZWxzIG9mIHRoZSBsb2dnZXJcbiAqIFxuICogQHR5cGVkZWYge09iamVjdH0gTEVWRUxTXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVidWcgLSBUaGUgZGVidWcgbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmZvIC0gVGhlIGluZm8gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb2cgLSBUaGUgbG9nIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2FybiAtIFRoZSB3YXJuIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXJyb3IgLSBUaGUgZXJyb3IgbGV2ZWxcbiAqIFxuICovXG5jb25zdCBMRVZFTFMgPSBPYmplY3QuZnJlZXplKHtcbiAgZGVidWc6IDUsXG4gIGluZm86IDQsXG4gIGxvZzogMyxcbiAgd2FybjogMixcbiAgZXJyb3I6IDFcbn0pO1xuXG4vKipcbiAqIEJ1aWxkcyBhIG1lc3NhZ2UgZm9ybWF0dGVkIGZvciB0aGUgbG9nZ2VyXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSBUaGUgbWVzc2FnZSBmb3JtYXR0ZWQgZm9yIHRoZSBsb2dnZXJcbiAqIFxuICogQGV4YW1wbGVcbiAqIGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3MoeyB0aXRsZTogXCJNeSBUaXRsZVwiLCBtZXNzYWdlOiBcIk15IE1lc3NhZ2VcIiB9KVxuICovXG5jb25zdCBidWlsZExvZ2dlck1lc3NhZ2VBcmdzID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFtgXG4gICAgJWMke3RpdGxlfVxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICR7bWVzc2FnZX1cblxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBgLnJlcGxhY2UoL1xcblteXFxTXFxyXFxuXSsvZywgXCJcXG5cIikudHJpbSgpLCwgXCJmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcIl07XG59O1xuXG4vKipcbiAqIExvZ3MgbWVzc2FnZXMgYmFzZWQgb24gdGhlIGxldmVsIG9mIHRoZSBtZXNzYWdlIGFuZCB0aGUgbGV2ZWwgc2V0IGluIHRoZSBjb25maWdcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hbHdheXMgLSBXaGV0aGVyIHRvIGFsd2F5cyBzaG93IHRoZSBsb2dcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICogXG4gKiBAZXhhbXBsZVxuICogbG9nKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIsIGxldmVsOiBMRVZFTFMud2FybiwgYWx3YXlzOiBmYWxzZSB9KVxuICogXG4gKi9cbmNvbnN0IGxvZyA9IGFzeW5jIF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlLFxuICAgIGxldmVsLFxuICAgIGFsd2F5cyA9IGZhbHNlXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgY29uZmlnTG9nZ2VyTGV2ZWwgPSBhd2FpdCBjb25maWcuZ2V0KFwibG9nZ2VyLmxldmVsXCIsIExFVkVMUy53YXJuKTtcblxuICAvLyBJZiBjb25maWcgbGV2ZWwgaXMgYmVsb3cgbWVzc2FnZSBsZXZlbCB0aGVuIGRvbid0IHNob3cgaXRcbiAgaWYgKCFhbHdheXMgJiYgY29uZmlnTG9nZ2VyTGV2ZWwgPCBsZXZlbCkgcmV0dXJuO1xuICBjb25zdCBsb2dnZXJNZXNzYWdlQXJncyA9IGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3Moe1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSk7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIExFVkVMUy5kZWJ1ZzpcbiAgICAgIGNvbnNvbGUuZGVidWcoLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMuaW5mbzpcbiAgICAgIGNvbnNvbGUuaW5mbyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy53YXJuOlxuICAgICAgY29uc29sZS53YXJuKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLmVycm9yOlxuICAgICAgY29uc29sZS5lcnJvciguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS5sb2coLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIExvZ3MgYSBkZXByZWNhdGlvbiBub3RpY2VcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucGtnIC0gVGhlIHBhY2thZ2UgdGhhdCBpcyBiZWluZyBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJqZWN0IC0gVGhlIHN1YmplY3Qgb2YgdGhlIGRlcHJlY2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50cmFuc2l0aW9uIC0gVGhlIHRyYW5zaXRpb24gcGF0aCBmb3IgdGhlIGRlcHJlY2F0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIGFmdGVyIHRoZSBsb2dcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICogXG4gKiBAZXhhbXBsZVxuICogbG9nLmRlcHJlY2F0ZSh7IHBrZzogXCJAb25mbG93L2ZjbFwiLCBzdWJqZWN0OiBcIlNvbWUgaXRlbVwiLCB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGtcIiwgbWVzc2FnZTogXCJEZXNjcmlwdGl2ZSBtZXNzYWdlXCIsIGxldmVsOiBMRVZFTFMud2FybiwgY2FsbGJhY2s6ICgpID0+IHt9IH0pXG4gKiBcbiAqL1xubG9nLmRlcHJlY2F0ZSA9IF9yZWYzID0+IHtcbiAgbGV0IHtcbiAgICBwa2csXG4gICAgc3ViamVjdCxcbiAgICB0cmFuc2l0aW9uLFxuICAgIGxldmVsID0gTEVWRUxTLndhcm4sXG4gICAgbWVzc2FnZSA9IFwiXCIsXG4gICAgY2FsbGJhY2sgPSBudWxsXG4gIH0gPSBfcmVmMztcbiAgY29uc3QgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyID0gc3RyaW5nID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9O1xuICBjb25zdCBsb2dNZXNzYWdlID0gKCkgPT4gbG9nKHtcbiAgICB0aXRsZTogYCR7cGtnID8gcGtnICsgXCIgXCIgOiBcIlwifURlcHJlY2F0aW9uIE5vdGljZWAsXG4gICAgbWVzc2FnZTogYFxuICAgICAgJHtzdWJqZWN0ID8gYCR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN1YmplY3QpfSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGNlYXNlIHRvIHdvcmsgaW4gZnV0dXJlIHJlbGVhc2VzJHtwa2cgPyBcIiBvZiBcIiArIHBrZyA6IFwiXCJ9LmAgOiBcIlwifSR7bWVzc2FnZSA/IFwiXFxuXCIgKyBtZXNzYWdlIDogXCJcIn0ke3RyYW5zaXRpb24gPyBgXFxuWW91IGNhbiBsZWFybiBtb3JlIChpbmNsdWRpbmcgYSBndWlkZSBvbiBjb21tb24gdHJhbnNpdGlvbiBwYXRocykgaGVyZTogJHt0cmFuc2l0aW9ufWAgOiBcIlwifVxuICAgIGAudHJpbSgpLFxuICAgIGxldmVsXG4gIH0pO1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgYXdhaXQgbG9nTWVzc2FnZSgpO1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKC4uLmFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbG9nTWVzc2FnZSgpO1xufTtcblxuY29uc3QgdHlwZSA9IChsYWJlbCwgYXNBcmd1bWVudCwgYXNJbmplY3Rpb24pID0+ICh7XG4gIGxhYmVsLFxuICBhc0FyZ3VtZW50LFxuICBhc0luamVjdGlvblxufSk7XG5jb25zdCBpc0FycmF5ID0gZCA9PiBBcnJheS5pc0FycmF5KGQpO1xuY29uc3QgaXNPYmogPSBkID0+IHR5cGVvZiBkID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNOdWxsID0gZCA9PiBkID09IG51bGw7XG5jb25zdCBpc0Jvb2xlYW4gPSBkID0+IHR5cGVvZiBkID09PSBcImJvb2xlYW5cIjtcbmNvbnN0IGlzTnVtYmVyID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJudW1iZXJcIjtcbmNvbnN0IGlzSW50ZWdlciA9IGQgPT4gTnVtYmVyLmlzSW50ZWdlcihkKTtcbmNvbnN0IGlzU3RyaW5nID0gZCA9PiB0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IHRocm93VHlwZUVycm9yID0gbXNnID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBFcnJvcjogXCIgKyBtc2cpO1xufTtcbmNvbnN0IG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlID0gdHlwZSA9PiB7XG4gIGxvZy5kZXByZWNhdGUoe1xuICAgIHBrZzogXCJAb25mbG93L3R5cGVzXCIsXG4gICAgc3ViamVjdDogYFBhc3NpbmcgaW4gTnVtYmVyIGFzIHZhbHVlIGZvciAke3R5cGV9YCxcbiAgICBtZXNzYWdlOiBgR29pbmcgZm9yd2FyZCwgdXNlIFN0cmluZyBhcyB2YWx1ZSBmb3IgJHt0eXBlfS5gLFxuICAgIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy90eXBlcy9XQVJOSU5HUy5tZCMwMDAyLVtVXUludCotYW5kLVdvcmQqLWFzLU51bWJlclwiXG4gIH0pO1xufTtcbmNvbnN0IElkZW50aXR5ID0gdHlwZShcIklkZW50aXR5XCIsIHYgPT4gdiwgdiA9PiB2KTtcbmNvbnN0IFVJbnQgPSB0eXBlKFwiVUludFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiVUludFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBQb3NpdGl2ZSBJbnRlZ2VyIGZvciB0eXBlIFVuc2lnbmVkIEludFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBJbnQgPSB0eXBlKFwiSW50XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnRcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIEludGVnZXIgZm9yIHR5cGUgSW50XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQ4ID0gdHlwZShcIlVJbnQ4XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJVSW50OFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50OFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUludDhcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIGludGVnZXIgZm9yIFVJbnQ4XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDggPSB0eXBlKFwiSW50OFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiSW50OFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQ4XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQ4XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyIGZvciBJbnQ4XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQxNiA9IHR5cGUoXCJVSW50MTZcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnQxNlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MTZcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVJbnQxNlwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgVUludDE2XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDE2ID0gdHlwZShcIkludDE2XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnQxNlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgZm9yIEludDE2XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQzMiA9IHR5cGUoXCJVSW50MzJcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnQzMlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MzJcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVJbnQzMlwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgVUludDMyXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDMyID0gdHlwZShcIkludDMyXCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnQzMlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQzMlwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50MzJcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgZm9yIEludDMyXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQ2NCA9IHR5cGUoXCJVSW50NjRcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIlVJbnQ2NFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50NjRcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlVJbnQ2NFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgVUludDY0XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDY0ID0gdHlwZShcIkludDY0XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJJbnQ2NFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQ2NFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW50NjRcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgZm9yIEludDY0XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQxMjggPSB0eXBlKFwiVUludDEyOFwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiVUludDEyOFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MTI4XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MTI4XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnRlZ2VyIGZvciBVSW50MTI4XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDEyOCA9IHR5cGUoXCJJbnQxMjhcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIkludDEyOFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQxMjhcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludDEyOFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlciBmb3IgSW50MTI4XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFVJbnQyNTYgPSB0eXBlKFwiVUludDI1NlwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiVUludDI1NlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MjU2XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJVSW50MjU2XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnRlZ2VyIGZvciBVSW50MjU2XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEludDI1NiA9IHR5cGUoXCJJbnQyNTZcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIkludDI1NlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJbnQyNTZcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkludDI1NlwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgaW50ZWdlciBmb3IgSW50MjU2XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFdvcmQ4ID0gdHlwZShcIldvcmQ4XCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJXb3JkOFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJXb3JkOFwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDhcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciBmb3IgV29yZDhcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgV29yZDE2ID0gdHlwZShcIldvcmQxNlwiLCB2ID0+IHtcbiAgaWYgKGlzTnVtYmVyKHYpICYmIGlzSW50ZWdlcih2KSkge1xuICAgIG51bWJlclZhbHVlc0RlcHJlY2F0aW9uTm90aWNlKFwiV29yZDE2XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIldvcmQxNlwiLFxuICAgICAgdmFsdWU6IHYudG9TdHJpbmcoKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDE2XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH1cbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIgZm9yIFdvcmQxNlwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBXb3JkMzIgPSB0eXBlKFwiV29yZDMyXCIsIHYgPT4ge1xuICBpZiAoaXNOdW1iZXIodikgJiYgaXNJbnRlZ2VyKHYpKSB7XG4gICAgbnVtYmVyVmFsdWVzRGVwcmVjYXRpb25Ob3RpY2UoXCJXb3JkMzJcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiV29yZDMyXCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJXb3JkMzJcIixcbiAgICAgIHZhbHVlOiB2XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciBmb3IgV29yZDMyXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IFdvcmQ2NCA9IHR5cGUoXCJXb3JkNjRcIiwgdiA9PiB7XG4gIGlmIChpc051bWJlcih2KSAmJiBpc0ludGVnZXIodikpIHtcbiAgICBudW1iZXJWYWx1ZXNEZXByZWNhdGlvbk5vdGljZShcIldvcmQ2NFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJXb3JkNjRcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIGlmIChpc1N0cmluZyh2KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIldvcmQ2NFwiLFxuICAgICAgdmFsdWU6IHZcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyIGZvciBXb3JkNjRcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgVUZpeDY0QW5kRml4NjROdW1iZXJEZXByZWNhdGlvbk5vdGljZSA9ICgpID0+IHtcbiAgbG9nLmRlcHJlY2F0ZSh7XG4gICAgc3ViamVjdDogXCJQYXNzaW5nIGluIE51bWJlcnMgYXMgdmFsdWVzIGZvciBGaXg2NCBhbmQgVUZpeDY0IHR5cGVzXCIsXG4gICAgcGtnOiBcIkBvbmZsb3cvdHlwZXNcIixcbiAgICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvdHlwZXMvV0FSTklOR1MubWQjMDAwMS1bVV1GaXg2NC1hcy1OdW1iZXJcIlxuICB9KTtcbn07XG5jb25zdCBVRml4NjQgPSB0eXBlKFwiVUZpeDY0XCIsIHYgPT4ge1xuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICBjb25zdCB2UGFydHMgPSB2LnNwbGl0KFwiLlwiKTtcbiAgICBpZiAodlBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3dUeXBlRXJyb3IoYEV4cGVjdGVkIG9uZSBkZWNpbWFsIGJ1dCBmb3VuZCAke3ZQYXJ0cy5sZW5ndGh9IGluIHRoZSBbVV1GaXg2NCB2YWx1ZS4gRmluZCBvdXQgbW9yZSBhYm91dCBbVV1GaXg2NCB0eXBlcyBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNmaXhlZC1wb2ludC1udW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICh2UGFydHNbMV0ubGVuZ3RoID09IDAgfHwgdlBhcnRzWzFdLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgZGlnaXQsIGFuZCBhdCBtb3N0IDggZGlnaXRzIGZvbGxvd2luZyB0aGUgZGVjaW1hbCBvZiB0aGUgW1VdRml4NjQgdmFsdWUgYnV0IGZvdW5kICR7dlBhcnRzWzFdLmxlbmd0aH0gZGlnaXRzLiBGaW5kIG91dCBtb3JlIGFib3V0IFtVXUZpeDY0IHR5cGVzIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2NhZGVuY2UvanNvbi1jYWRlbmNlLXNwZWMvI2ZpeGVkLXBvaW50LW51bWJlcnNgKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIG51bWJlciBpcyBleHRlbmRlZCB0byA4IGRlY2ltYWwgcGxhY2VzIHNvIGl0IG1hdGNoZXMgY2FkZW5jZSBlbmNvZGluZyBvZiBVRml4IHZhbHVlc1xuICAgIHZQYXJ0c1sxXSA9IHZQYXJ0c1sxXS5wYWRFbmQoOCwgXCIwXCIpO1xuICAgIHYgPSB2UGFydHMuam9pbihcIi5cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUZpeDY0XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIodikpIHtcbiAgICBVRml4NjRBbmRGaXg2NE51bWJlckRlcHJlY2F0aW9uTm90aWNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVUZpeDY0XCIsXG4gICAgICB2YWx1ZTogdi50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZyBmb3IgVUZpeDY0XCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEZpeDY0ID0gdHlwZShcIkZpeDY0XCIsIHYgPT4ge1xuICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICBjb25zdCB2UGFydHMgPSB2LnNwbGl0KFwiLlwiKTtcbiAgICBpZiAodlBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3dUeXBlRXJyb3IoYEV4cGVjdGVkIG9uZSBkZWNpbWFsIGJ1dCBmb3VuZCAke3ZQYXJ0cy5sZW5ndGh9IGluIHRoZSBbVV1GaXg2NCB2YWx1ZS4gRmluZCBvdXQgbW9yZSBhYm91dCBbVV1GaXg2NCB0eXBlcyBoZXJlOiBodHRwczovL2RvY3Mub25mbG93Lm9yZy9jYWRlbmNlL2pzb24tY2FkZW5jZS1zcGVjLyNmaXhlZC1wb2ludC1udW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICh2UGFydHNbMV0ubGVuZ3RoID09IDAgfHwgdlBhcnRzWzFdLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgZGlnaXQsIGFuZCBhdCBtb3N0IDggZGlnaXRzIGZvbGxvd2luZyB0aGUgZGVjaW1hbCBvZiB0aGUgW1VdRml4NjQgdmFsdWUgYnV0IGZvdW5kICR7dlBhcnRzWzFdLmxlbmd0aH0gZGlnaXRzLiBGaW5kIG91dCBtb3JlIGFib3V0IFtVXUZpeDY0IHR5cGVzIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2NhZGVuY2UvanNvbi1jYWRlbmNlLXNwZWMvI2ZpeGVkLXBvaW50LW51bWJlcnNgKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIG51bWJlciBpcyBleHRlbmRlZCB0byA4IGRlY2ltYWwgcGxhY2VzIHNvIGl0IG1hdGNoZXMgY2FkZW5jZSBlbmNvZGluZyBvZiBGaXg2NCB2YWx1ZXNcbiAgICB2UGFydHNbMV0gPSB2UGFydHNbMV0ucGFkRW5kKDgsIFwiMFwiKTtcbiAgICB2ID0gdlBhcnRzLmpvaW4oXCIuXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZpeDY0XCIsXG4gICAgICB2YWx1ZTogdlxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIodikpIHtcbiAgICBVRml4NjRBbmRGaXg2NE51bWJlckRlcHJlY2F0aW9uTm90aWNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRml4NjRcIixcbiAgICAgIHZhbHVlOiB2LnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nIGZvciBGaXg2NFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBTdHJpbmcgPSB0eXBlKFwiU3RyaW5nXCIsIHYgPT4ge1xuICBpZiAoaXNTdHJpbmcodikpIHJldHVybiB7XG4gICAgdHlwZTogXCJTdHJpbmdcIixcbiAgICB2YWx1ZTogdlxuICB9O1xuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZyBmb3IgdHlwZSBTdHJpbmdcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgQ2hhcmFjdGVyID0gdHlwZShcIkNoYXJhY3RlclwiLCB2ID0+IHtcbiAgaWYgKGlzU3RyaW5nKHYpKSByZXR1cm4ge1xuICAgIHR5cGU6IFwiQ2hhcmFjdGVyXCIsXG4gICAgdmFsdWU6IHZcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBDaGFyYWN0ZXIgZm9yIHR5cGUgQ2hhcmFjdGVyXCIpO1xufSwgdiA9PiB2KTtcbmNvbnN0IEJvb2wgPSB0eXBlKFwiQm9vbFwiLCB2ID0+IHtcbiAgaWYgKGlzQm9vbGVhbih2KSkgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkJvb2xcIixcbiAgICB2YWx1ZTogdlxuICB9O1xuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIEJvb2xlYW4gZm9yIHR5cGUgQm9vbFwiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBBZGRyZXNzID0gdHlwZShcIkFkZHJlc3NcIiwgdiA9PiB7XG4gIGlmIChpc1N0cmluZyh2KSkgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkFkZHJlc3NcIixcbiAgICB2YWx1ZTogdlxuICB9O1xuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIEFkZHJlc3MgZm9yIHR5cGUgQWRkcmVzc1wiKTtcbn0sIHYgPT4gdik7XG5jb25zdCBWb2lkID0gdHlwZShcIlZvaWRcIiwgdiA9PiB7XG4gIGlmICghdiB8fCBpc051bGwodikpIHJldHVybiB7XG4gICAgdHlwZTogXCJWb2lkXCJcbiAgfTtcbiAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBWb2lkIGZvciB0eXBlIFZvaWRcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgT3B0aW9uYWwgPSBjaGlsZHJlbiA9PiB0eXBlKFwiT3B0aW9uYWxcIiwgdiA9PiAoe1xuICB0eXBlOiBcIk9wdGlvbmFsXCIsXG4gIHZhbHVlOiBpc051bGwodikgPyBudWxsIDogY2hpbGRyZW4uYXNBcmd1bWVudCh2KVxufSksIHYgPT4gdik7XG5jb25zdCBSZWZlcmVuY2UgPSB0eXBlKFwiUmVmZXJlbmNlXCIsIHYgPT4ge1xuICBpZiAoaXNPYmoodikpIHJldHVybiB7XG4gICAgdHlwZTogXCJSZWZlcmVuY2VcIixcbiAgICB2YWx1ZTogdlxuICB9O1xuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIE9iamVjdCBmb3IgdHlwZSBSZWZlcmVuY2VcIik7XG59LCB2ID0+IHYpO1xuY29uc3QgX0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgY2hpbGRyZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gdHlwZShcIkFycmF5XCIsIHYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICB2YWx1ZTogaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoKGMsIGkpID0+IGMuYXNBcmd1bWVudCh2W2ldKSkgOiB2Lm1hcCh4ID0+IGNoaWxkcmVuLmFzQXJndW1lbnQoeCkpXG4gICAgfTtcbiAgfSwgdiA9PiB2KTtcbn07XG5jb25zdCBEaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgY2hpbGRyZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gdHlwZShcIkRpY3Rpb25hcnlcIiwgdiA9PiB7XG4gICAgaWYgKGlzT2JqKHYpKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICB2YWx1ZTogaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoKGMsIGkpID0+ICh7XG4gICAgICAgIGtleTogYy5rZXkuYXNBcmd1bWVudCh2W2ldLmtleSksXG4gICAgICAgIHZhbHVlOiBjLnZhbHVlLmFzQXJndW1lbnQodltpXS52YWx1ZSlcbiAgICAgIH0pKSA6IGlzQXJyYXkodikgPyB2Lm1hcCh4ID0+ICh7XG4gICAgICAgIGtleTogY2hpbGRyZW4ua2V5LmFzQXJndW1lbnQoeC5rZXkpLFxuICAgICAgICB2YWx1ZTogY2hpbGRyZW4udmFsdWUuYXNBcmd1bWVudCh4LnZhbHVlKVxuICAgICAgfSkpIDogW3tcbiAgICAgICAga2V5OiBjaGlsZHJlbi5rZXkuYXNBcmd1bWVudCh2LmtleSksXG4gICAgICAgIHZhbHVlOiBjaGlsZHJlbi52YWx1ZS5hc0FyZ3VtZW50KHYudmFsdWUpXG4gICAgICB9XVxuICAgIH07XG4gICAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgRGljdGlvbmFyeVwiKTtcbiAgfSwgdiA9PiB2KTtcbn07XG5jb25zdCBFdmVudCA9IGZ1bmN0aW9uIChpZCkge1xuICBsZXQgZmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJFdmVudFwiLCB2ID0+IHtcbiAgICBpZiAoaXNPYmoodikpIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkV2ZW50XCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGZpZWxkczogaXNBcnJheShmaWVsZHMpID8gZmllbGRzLm1hcCgoYywgaSkgPT4gKHtcbiAgICAgICAgICBuYW1lOiB2LmZpZWxkc1tpXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBjLnZhbHVlLmFzQXJndW1lbnQodi5maWVsZHNbaV0udmFsdWUpXG4gICAgICAgIH0pKSA6IHYuZmllbGRzLm1hcCh4ID0+ICh7XG4gICAgICAgICAgbmFtZTogeC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMudmFsdWUuYXNBcmd1bWVudCh4LnZhbHVlKVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRocm93VHlwZUVycm9yKFwiRXhwZWN0ZWQgT2JqZWN0IGZvciB0eXBlIEV2ZW50XCIpO1xuICB9LCB2ID0+IHYpO1xufTtcbmNvbnN0IFJlc291cmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gIGxldCBmaWVsZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICByZXR1cm4gdHlwZShcIlJlc291cmNlXCIsIHYgPT4ge1xuICAgIGlmIChpc09iaih2KSkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUmVzb3VyY2VcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZmllbGRzOiBpc0FycmF5KGZpZWxkcykgPyBmaWVsZHMubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IHYuZmllbGRzW2ldLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGMudmFsdWUuYXNBcmd1bWVudCh2LmZpZWxkc1tpXS52YWx1ZSlcbiAgICAgICAgfSkpIDogdi5maWVsZHMubWFwKHggPT4gKHtcbiAgICAgICAgICBuYW1lOiB4Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcy52YWx1ZS5hc0FyZ3VtZW50KHgudmFsdWUpXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH07XG4gICAgdGhyb3dUeXBlRXJyb3IoXCJFeHBlY3RlZCBPYmplY3QgZm9yIHR5cGUgUmVzb3VyY2VcIik7XG4gIH0sIHYgPT4gdik7XG59O1xuY29uc3QgU3RydWN0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIGxldCBmaWVsZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICByZXR1cm4gdHlwZShcIlN0cnVjdFwiLCB2ID0+IHtcbiAgICBpZiAoaXNPYmoodikpIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlN0cnVjdFwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmaWVsZHM6IGlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcy5tYXAoKGMsIGkpID0+ICh7XG4gICAgICAgICAgbmFtZTogdi5maWVsZHNbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogYy52YWx1ZS5hc0FyZ3VtZW50KHYuZmllbGRzW2ldLnZhbHVlKVxuICAgICAgICB9KSkgOiB2LmZpZWxkcy5tYXAoeCA9PiAoe1xuICAgICAgICAgIG5hbWU6IHgubmFtZSxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzLnZhbHVlLmFzQXJndW1lbnQoeC52YWx1ZSlcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfTtcbiAgICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIE9iamVjdCBmb3IgdHlwZSBTdHJ1Y3RcIik7XG4gIH0sIHYgPT4gdik7XG59O1xuY29uc3QgRW51bSA9IGZ1bmN0aW9uIChpZCkge1xuICBsZXQgZmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIHR5cGUoXCJFbnVtXCIsIHYgPT4ge1xuICAgIGlmIChpc09iaih2KSkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRW51bVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBmaWVsZHM6IGlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcy5tYXAoKGMsIGkpID0+ICh7XG4gICAgICAgICAgbmFtZTogdi5maWVsZHNbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogYy52YWx1ZS5hc0FyZ3VtZW50KHYuZmllbGRzW2ldLnZhbHVlKVxuICAgICAgICB9KSkgOiB2LmZpZWxkcy5tYXAoeCA9PiAoe1xuICAgICAgICAgIG5hbWU6IHgubmFtZSxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzLnZhbHVlLmFzQXJndW1lbnQoeC52YWx1ZSlcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfTtcbiAgICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIE9iamVjdCBmb3IgdHlwZSBFbnVtXCIpO1xuICB9LCB2ID0+IHYpO1xufTtcbmNvbnN0IFBhdGggPSB0eXBlKFwiUGF0aFwiLCB2ID0+IHtcbiAgaWYgKGlzT2JqKHYpKSB7XG4gICAgaWYgKCFpc1N0cmluZyh2LmRvbWFpbikpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBmb3IgdGhlIFBhdGggZG9tYWluIGJ1dCBmb3VuZCAke3YuZG9tYWlufS4gRmluZCBvdXQgbW9yZSBhYm91dCB0aGUgUGF0aCB0eXBlIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2NhZGVuY2UvanNvbi1jYWRlbmNlLXNwZWMvI3BhdGhgKTtcbiAgICB9XG4gICAgaWYgKCEodi5kb21haW4gPT09IFwic3RvcmFnZVwiIHx8IHYuZG9tYWluID09PSBcInByaXZhdGVcIiB8fCB2LmRvbWFpbiA9PT0gXCJwdWJsaWNcIikpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKGBFeHBlY3RlZCBlaXRoZXIgXCJzdG9yYWdlXCIsIFwicHJpdmF0ZVwiIG9yIFwicHVibGljXCIgYXMgdGhlIFBhdGggZG9tYWluIGJ1dCBmb3VuZCAke3YuZG9tYWlufS4gRmluZCBvdXQgbW9yZSBhYm91dCB0aGUgUGF0aCB0eXBlIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2NhZGVuY2UvanNvbi1jYWRlbmNlLXNwZWMvI3BhdGhgKTtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyh2LmlkZW50aWZpZXIpKSB7XG4gICAgICB0aHJvd1R5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yIHRoZSBQYXRoIGlkZW50aWZpZXIgYnV0IGZvdW5kICR7di5pZGVudGlmaWVyfS4gRmluZCBvdXQgbW9yZSBhYm91dCB0aGUgUGF0aCB0eXBlIGhlcmU6IGh0dHBzOi8vZG9jcy5vbmZsb3cub3JnL2NhZGVuY2UvanNvbi1jYWRlbmNlLXNwZWMvI3BhdGhgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGF0aFwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZG9tYWluOiB2LmRvbWFpbixcbiAgICAgICAgaWRlbnRpZmllcjogdi5pZGVudGlmaWVyXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0aHJvd1R5cGVFcnJvcihcIkV4cGVjdGVkIE9iamVjdCBmb3IgdHlwZSBQYXRoXCIpO1xufSwgdiA9PiB2KTtcblxuZXhwb3J0IHsgQWRkcmVzcywgX0FycmF5IGFzIEFycmF5LCBCb29sLCBDaGFyYWN0ZXIsIERpY3Rpb25hcnksIEVudW0sIEV2ZW50LCBGaXg2NCwgSWRlbnRpdHksIEludCwgSW50MTI4LCBJbnQxNiwgSW50MjU2LCBJbnQzMiwgSW50NjQsIEludDgsIE9wdGlvbmFsLCBQYXRoLCBSZWZlcmVuY2UsIFJlc291cmNlLCBTdHJpbmcsIFN0cnVjdCwgVUZpeDY0LCBVSW50LCBVSW50MTI4LCBVSW50MTYsIFVJbnQyNTYsIFVJbnQzMiwgVUludDY0LCBVSW50OCwgVm9pZCwgV29yZDE2LCBXb3JkMzIsIFdvcmQ2NCwgV29yZDgsIF9BcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/types/dist/types.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-actor/dist/actor.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@onflow/util-actor/dist/actor.module.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXIT: function() { return /* binding */ EXIT; },\n/* harmony export */   INIT: function() { return /* binding */ INIT; },\n/* harmony export */   SNAPSHOT: function() { return /* binding */ SNAPSHOT; },\n/* harmony export */   SUBSCRIBE: function() { return /* binding */ SUBSCRIBE; },\n/* harmony export */   TERMINATE: function() { return /* binding */ TERMINATE; },\n/* harmony export */   UNSUBSCRIBE: function() { return /* binding */ UNSUBSCRIBE; },\n/* harmony export */   UPDATED: function() { return /* binding */ UPDATED; },\n/* harmony export */   kill: function() { return /* binding */ kill; },\n/* harmony export */   send: function() { return /* binding */ send; },\n/* harmony export */   snapshoter: function() { return /* binding */ snapshoter; },\n/* harmony export */   spawn: function() { return /* binding */ spawn; },\n/* harmony export */   subscriber: function() { return /* binding */ subscriber; }\n/* harmony export */ });\n/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! queue-microtask */ \"../../node_modules/queue-microtask/index.js\");\n/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(queue_microtask__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\n\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED = \"UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queue_microtask__WEBPACK_IMPORTED_MODULE_0___default()(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nfunction snapshoter(address, spawnFn) {\n  spawnFn(address);\n  return send(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\n\n\n//# sourceMappingURL=actor.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1hY3Rvci9kaXN0L2FjdG9yLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUscUJBQU0saUJBQWlCLHFCQUFNLFlBQVkscUJBQU0sSUFBSSxxQkFBTTtBQUN2SSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLFFBQVE7QUFDUix5QkFBeUIsWUFBWTtBQUNyQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTyxJQUFJO0FBQ1gsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNEQUFjO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRXVIO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWFjdG9yL2Rpc3QvYWN0b3IubW9kdWxlLmpzPzhjYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHF1ZXVlTWljcm90YXNrIGZyb20gJ3F1ZXVlLW1pY3JvdGFzayc7XG5cbmNvbnN0IG1haWxib3ggPSAoKSA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gW107XG4gIHZhciBuZXh0O1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGRlbGl2ZXIobXNnKSB7XG4gICAgICBxdWV1ZS5wdXNoKG1zZyk7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0KHF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBpbm5lclJlY2VpdmUocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBtc2cgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAobXNnKSByZXR1cm4gcmVzb2x2ZShtc2cpO1xuICAgICAgICBuZXh0ID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IElOSVQgPSBcIklOSVRcIjtcbmNvbnN0IFNVQlNDUklCRSA9IFwiU1VCU0NSSUJFXCI7XG5jb25zdCBVTlNVQlNDUklCRSA9IFwiVU5TVUJTQ1JJQkVcIjtcbmNvbnN0IFVQREFURUQgPSBcIlVQREFURURcIjtcbmNvbnN0IFNOQVBTSE9UID0gXCJTTkFQU0hPVFwiO1xuY29uc3QgRVhJVCA9IFwiRVhJVFwiO1xuY29uc3QgVEVSTUlOQVRFID0gXCJURVJNSU5BVEVcIjtcbmNvbnN0IHJvb3QgPSB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fCB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3cgJiYgd2luZG93O1xucm9vdC5GQ0xfUkVHSVNUUlkgPSByb290LkZDTF9SRUdJU1RSWSA9PSBudWxsID8ge30gOiByb290LkZDTF9SRUdJU1RSWTtcbnZhciBwaWQgPSAwYjA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA1MDAwO1xuY29uc3Qgc2VuZCA9IGZ1bmN0aW9uIChhZGRyLCB0YWcsIGRhdGEpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcGx5LCByZWplY3QpID0+IHtcbiAgICBjb25zdCBleHBlY3RSZXBseSA9IG9wdHMuZXhwZWN0UmVwbHkgfHwgZmFsc2U7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdHMudGltZW91dCAhPSBudWxsID8gb3B0cy50aW1lb3V0IDogREVGQVVMVF9USU1FT1VUO1xuICAgIGlmIChleHBlY3RSZXBseSAmJiB0aW1lb3V0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQ6ICR7dGltZW91dH1tcyBwYXNzZWQgd2l0aG91dCBhIHJlc3BvbnNlLmApKSwgdGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0bzogYWRkcixcbiAgICAgIGZyb206IG9wdHMuZnJvbSxcbiAgICAgIHRhZyxcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lb3V0LFxuICAgICAgcmVwbHksXG4gICAgICByZWplY3RcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByb290LkZDTF9SRUdJU1RSWVthZGRyXSAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5tYWlsYm94LmRlbGl2ZXIocGF5bG9hZCk7XG4gICAgICBpZiAoIWV4cGVjdFJlcGx5KSByZXBseSh0cnVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZDTC5BY3RvciAtLSBDb3VsZCBOb3QgRGVsaXZlciBNZXNzYWdlXCIsIHBheWxvYWQsIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLCBlcnJvcik7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBraWxsID0gYWRkciA9PiB7XG4gIGRlbGV0ZSByb290LkZDTF9SRUdJU1RSWVthZGRyXTtcbn07XG5jb25zdCBmcm9tSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBoYW5kbGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiBhc3luYyBjdHggPT4ge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlcnNbSU5JVF0gPT09IFwiZnVuY3Rpb25cIikgYXdhaXQgaGFuZGxlcnNbSU5JVF0oY3R4KTtcbiAgICBfX2xvb3A6IHdoaWxlICgxKSB7XG4gICAgICBjb25zdCBsZXR0ZXIgPSBhd2FpdCBjdHgucmVjZWl2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJzW1RFUk1JTkFURV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlcnNbVEVSTUlOQVRFXShjdHgsIGxldHRlciwgbGV0dGVyLmRhdGEgfHwge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhayBfX2xvb3A7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaGFuZGxlcnNbbGV0dGVyLnRhZ10oY3R4LCBsZXR0ZXIsIGxldHRlci5kYXRhIHx8IHt9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7Y3R4LnNlbGYoKX0gRXJyb3JgLCBsZXR0ZXIsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRpbnVlIF9fbG9vcDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuY29uc3Qgc3Bhd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgbGV0IGFkZHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGlmIChhZGRyID09IG51bGwpIGFkZHIgPSArK3BpZDtcbiAgaWYgKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdICE9IG51bGwpIHJldHVybiBhZGRyO1xuICByb290LkZDTF9SRUdJU1RSWVthZGRyXSA9IHtcbiAgICBhZGRyLFxuICAgIG1haWxib3g6IG1haWxib3goKSxcbiAgICBzdWJzOiBuZXcgU2V0KCksXG4gICAga3ZzOiB7fSxcbiAgICBlcnJvcjogbnVsbFxuICB9O1xuICBjb25zdCBjdHggPSB7XG4gICAgc2VsZjogKCkgPT4gYWRkcixcbiAgICByZWNlaXZlOiAoKSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5tYWlsYm94LnJlY2VpdmUoKSxcbiAgICBzZW5kOiBmdW5jdGlvbiAodG8sIHRhZywgZGF0YSkge1xuICAgICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgb3B0cy5mcm9tID0gYWRkcjtcbiAgICAgIHJldHVybiBzZW5kKHRvLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgc2VuZFNlbGY6ICh0YWcsIGRhdGEsIG9wdHMpID0+IHtcbiAgICAgIGlmIChyb290LkZDTF9SRUdJU1RSWVthZGRyXSkgc2VuZChhZGRyLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgYnJvYWRjYXN0OiBmdW5jdGlvbiAodGFnLCBkYXRhKSB7XG4gICAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICBvcHRzLmZyb20gPSBhZGRyO1xuICAgICAgZm9yIChsZXQgdG8gb2Ygcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicykgc2VuZCh0bywgdGFnLCBkYXRhLCBvcHRzKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogc3ViID0+IHN1YiAhPSBudWxsICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuYWRkKHN1YiksXG4gICAgdW5zdWJzY3JpYmU6IHN1YiA9PiBzdWIgIT0gbnVsbCAmJiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLmRlbGV0ZShzdWIpLFxuICAgIHN1YnNjcmliZXJDb3VudDogKCkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5zaXplLFxuICAgIGhhc1N1YnM6ICgpID0+ICEhcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5zaXplLFxuICAgIHB1dDogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogKGtleSwgZmFsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV07XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IGZhbGxiYWNrIDogdmFsdWU7XG4gICAgfSxcbiAgICBkZWxldGU6IGtleSA9PiB7XG4gICAgICBkZWxldGUgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV07XG4gICAgfSxcbiAgICB1cGRhdGU6IChrZXksIGZuKSA9PiB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldID0gZm4ocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0pO1xuICAgIH0sXG4gICAga2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cyk7XG4gICAgfSxcbiAgICBhbGw6ICgpID0+IHtcbiAgICAgIHJldHVybiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnM7XG4gICAgfSxcbiAgICB3aGVyZTogcGF0dGVybiA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoa2V5KSA/IHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW2tleV06IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2c1trZXldXG4gICAgICAgIH0gOiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSxcbiAgICBtZXJnZTogZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4gcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSBkYXRhW2tleV0pO1xuICAgIH0sXG4gICAgZmF0YWxFcnJvcjogZXJyb3IgPT4ge1xuICAgICAgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uZXJyb3IgPSBlcnJvcjtcbiAgICAgIGZvciAobGV0IHRvIG9mIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMpIHNlbmQodG8sIFVQREFURUQpO1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIikgZm4gPSBmcm9tSGFuZGxlcnMoZm4pO1xuICBxdWV1ZU1pY3JvdGFzayhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZm4oY3R4KTtcbiAgICBraWxsKGFkZHIpO1xuICB9KTtcbiAgcmV0dXJuIGFkZHI7XG59O1xuXG4vLyBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4vLyBBIFNVQlNDUklCRSBoYW5kbGVyIHdpbGwgbmVlZCB0byBiZSBjcmVhdGVkIHRvIGhhbmRsZSB0aGUgc3Vic2NyaXB0aW9uIGV2ZW50XG4vL1xuLy8gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbi8vICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pXG4vLyAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCwgY3R4LmFsbCgpKVxuLy8gIH1cbi8vXG5mdW5jdGlvbiBzdWJzY3JpYmVyKGFkZHJlc3MsIHNwYXduRm4sIGNhbGxiYWNrKSB7XG4gIHNwYXduRm4oYWRkcmVzcyk7XG4gIGNvbnN0IEVYSVQgPSBcIkBFWElUXCI7XG4gIGNvbnN0IHNlbGYgPSBzcGF3bihhc3luYyBjdHggPT4ge1xuICAgIGN0eC5zZW5kKGFkZHJlc3MsIFNVQlNDUklCRSk7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGF3YWl0IGN0eC5yZWNlaXZlKCk7XG4gICAgICBjb25zdCBlcnJvciA9IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJlc3NdLmVycm9yO1xuICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgY3R4LnNlbmQoYWRkcmVzcywgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZXJyb3IpO1xuICAgICAgICBjdHguc2VuZChhZGRyZXNzLCBVTlNVQlNDUklCRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGxldHRlci5kYXRhLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gc2VuZChzZWxmLCBFWElUKTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXR1cm5zIGEgcmVzdWx0XG4vLyBBIFNOQVBTSE9UIGhhbmRsZXIgd2lsbCBuZWVkIHRvIGJlIGNyZWF0ZWQgdG8gaGFuZGxlIHRoZSBzbmFwc2hvdCBldmVudFxuLy9cbi8vICBbU05BUFNIT1RdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbi8vICAgIGxldHRlci5yZXBseShjdHguYWxsKCkpXG4vLyAgfVxuLy9cbmZ1bmN0aW9uIHNuYXBzaG90ZXIoYWRkcmVzcywgc3Bhd25Gbikge1xuICBzcGF3bkZuKGFkZHJlc3MpO1xuICByZXR1cm4gc2VuZChhZGRyZXNzLCBTTkFQU0hPVCwgbnVsbCwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDBcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEVYSVQsIElOSVQsIFNOQVBTSE9ULCBTVUJTQ1JJQkUsIFRFUk1JTkFURSwgVU5TVUJTQ1JJQkUsIFVQREFURUQsIGtpbGwsIHNlbmQsIHNuYXBzaG90ZXIsIHNwYXduLCBzdWJzY3JpYmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rvci5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-actor/dist/actor.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-address/dist/util-address.module.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@onflow/util-address/dist/util-address.module.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   display: function() { return /* binding */ display; },\n/* harmony export */   sansPrefix: function() { return /* binding */ sansPrefix; },\n/* harmony export */   withPrefix: function() { return /* binding */ withPrefix; }\n/* harmony export */ });\n/**\n * @description Removes 0x from address if present\n * @param {string} address - Flow address\n * @returns {string} - Flow address without 0x prefix\n */\nfunction sansPrefix(address) {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\").replace(/^Fx/, \"\");\n}\n\n/**\n * @description Adds 0x to address if not already present\n * @param {string} address - Flow address\n * @returns {string} - Flow address with 0x prefix\n */\nfunction withPrefix(address) {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n}\n\n/**\n * @description Adds 0x to address if not already present\n * @param {string} address - Flow address\n * @returns {string} - Flow address with 0x prefix\n */\nfunction display(address) {\n  return withPrefix(address);\n}\n\n\n//# sourceMappingURL=util-address.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1hZGRyZXNzL2Rpc3QvdXRpbC1hZGRyZXNzLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWFkZHJlc3MvZGlzdC91dGlsLWFkZHJlc3MubW9kdWxlLmpzP2FhMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyAweCBmcm9tIGFkZHJlc3MgaWYgcHJlc2VudFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBGbG93IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRmxvdyBhZGRyZXNzIHdpdGhvdXQgMHggcHJlZml4XG4gKi9cbmZ1bmN0aW9uIHNhbnNQcmVmaXgoYWRkcmVzcykge1xuICBpZiAoYWRkcmVzcyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgvXjB4LywgXCJcIikucmVwbGFjZSgvXkZ4LywgXCJcIik7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEFkZHMgMHggdG8gYWRkcmVzcyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEZsb3cgYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ30gLSBGbG93IGFkZHJlc3Mgd2l0aCAweCBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gd2l0aFByZWZpeChhZGRyZXNzKSB7XG4gIGlmIChhZGRyZXNzID09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gXCIweFwiICsgc2Fuc1ByZWZpeChhZGRyZXNzKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQWRkcyAweCB0byBhZGRyZXNzIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gRmxvdyBhZGRyZXNzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZsb3cgYWRkcmVzcyB3aXRoIDB4IHByZWZpeFxuICovXG5mdW5jdGlvbiBkaXNwbGF5KGFkZHJlc3MpIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXgoYWRkcmVzcyk7XG59XG5cbmV4cG9ydCB7IGRpc3BsYXksIHNhbnNQcmVmaXgsIHdpdGhQcmVmaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwtYWRkcmVzcy5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-address/dist/util-address.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   invariant: function() { return /* binding */ invariant; }\n/* harmony export */ });\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\n\n\n//# sourceMappingURL=util-invariant.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1pbnZhcmlhbnQvZGlzdC91dGlsLWludmFyaWFudC5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWludmFyaWFudC9kaXN0L3V0aWwtaW52YXJpYW50Lm1vZHVsZS5qcz9mYjIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXNzZXJ0cyBmYWN0IGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvciB3aXRoIGludmFyaWFudCBtZXNzYWdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbnZhcmlhbnQoZmFjdCwgbXNnKSB7XG4gIGlmICghZmFjdCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBJTlZBUklBTlQgJHttc2d9YCk7XG4gICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoZCA9PiAhL2F0IGludmFyaWFudC8udGVzdChkKSkuam9pbihcIlxcblwiKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihcIlxcblxcbi0tLVxcblxcblwiLCBlcnJvciwgXCJcXG5cXG5cIiwgLi4ucmVzdCwgXCJcXG5cXG4tLS1cXG5cXG5cIik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IHsgaW52YXJpYW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLWludmFyaWFudC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-invariant/dist/util-invariant.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-logger/dist/util-logger.module.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@onflow/util-logger/dist/util-logger.module.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LEVELS: function() { return /* binding */ LEVELS; },\n/* harmony export */   log: function() { return /* binding */ log; },\n/* harmony export */   setConfig: function() { return /* binding */ setConfig; }\n/* harmony export */ });\n// Config dependency injected into logger to break circular dependency\nlet config = null;\nconst setConfig = _config => {\n  config = _config;\n};\n\n/**\n * The levels of the logger\n *\n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n *\n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n *\n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n *\n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n *\n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n *\n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n *\n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = (await config?.()?.get(\"logger.level\")) ?? LEVELS.warn;\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n *\n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n *\n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n *\n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\n\n//# sourceMappingURL=util-logger.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC1sb2dnZXIvZGlzdC91dGlsLWxvZ2dlci5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNOztBQUVOO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyw2RUFBNkU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUJBQW1CLHVLQUF1SztBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsUUFBUSxhQUFhLGdDQUFnQyx5REFBeUQsd0JBQXdCLFFBQVEsRUFBRSw4QkFBOEIsRUFBRSwwRkFBMEYsV0FBVztBQUNyUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG9uZmxvdy91dGlsLWxvZ2dlci9kaXN0L3V0aWwtbG9nZ2VyLm1vZHVsZS5qcz9kYzIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbmZpZyBkZXBlbmRlbmN5IGluamVjdGVkIGludG8gbG9nZ2VyIHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3lcbmxldCBjb25maWcgPSBudWxsO1xuY29uc3Qgc2V0Q29uZmlnID0gX2NvbmZpZyA9PiB7XG4gIGNvbmZpZyA9IF9jb25maWc7XG59O1xuXG4vKipcbiAqIFRoZSBsZXZlbHMgb2YgdGhlIGxvZ2dlclxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExFVkVMU1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlYnVnIC0gVGhlIGRlYnVnIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5mbyAtIFRoZSBpbmZvIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG9nIC0gVGhlIGxvZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdhcm4gLSBUaGUgd2FybiBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVycm9yIC0gVGhlIGVycm9yIGxldmVsXG4gKlxuICovXG5jb25zdCBMRVZFTFMgPSBPYmplY3QuZnJlZXplKHtcbiAgZGVidWc6IDUsXG4gIGluZm86IDQsXG4gIGxvZzogMyxcbiAgd2FybjogMixcbiAgZXJyb3I6IDFcbn0pO1xuXG4vKipcbiAqIEJ1aWxkcyBhIG1lc3NhZ2UgZm9ybWF0dGVkIGZvciB0aGUgbG9nZ2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIFRoZSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICpcbiAqIEBleGFtcGxlXG4gKiBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIgfSlcbiAqL1xuY29uc3QgYnVpbGRMb2dnZXJNZXNzYWdlQXJncyA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbYFxuICAgICVjJHt0aXRsZX1cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAke21lc3NhZ2V9XG5cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgYC5yZXBsYWNlKC9cXG5bXlxcU1xcclxcbl0rL2csIFwiXFxuXCIpLnRyaW0oKSwsIFwiZm9udC13ZWlnaHQ6Ym9sZDtmb250LWZhbWlseTptb25vc3BhY2U7XCJdO1xufTtcblxuLyoqXG4gKiBMb2dzIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGxldmVsIHNldCBpbiB0aGUgY29uZmlnXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hbHdheXMgLSBXaGV0aGVyIHRvIGFsd2F5cyBzaG93IHRoZSBsb2dcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2coeyB0aXRsZTogXCJNeSBUaXRsZVwiLCBtZXNzYWdlOiBcIk15IE1lc3NhZ2VcIiwgbGV2ZWw6IExFVkVMUy53YXJuLCBhbHdheXM6IGZhbHNlIH0pXG4gKlxuICovXG5jb25zdCBsb2cgPSBhc3luYyBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZSxcbiAgICBsZXZlbCxcbiAgICBhbHdheXMgPSBmYWxzZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IGNvbmZpZ0xvZ2dlckxldmVsID0gKGF3YWl0IGNvbmZpZz8uKCk/LmdldChcImxvZ2dlci5sZXZlbFwiKSkgPz8gTEVWRUxTLndhcm47XG5cbiAgLy8gSWYgY29uZmlnIGxldmVsIGlzIGJlbG93IG1lc3NhZ2UgbGV2ZWwgdGhlbiBkb24ndCBzaG93IGl0XG4gIGlmICghYWx3YXlzICYmIGNvbmZpZ0xvZ2dlckxldmVsIDwgbGV2ZWwpIHJldHVybjtcbiAgY29uc3QgbG9nZ2VyTWVzc2FnZUFyZ3MgPSBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlXG4gIH0pO1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBMRVZFTFMuZGVidWc6XG4gICAgICBjb25zb2xlLmRlYnVnKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLmluZm86XG4gICAgICBjb25zb2xlLmluZm8oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMud2FybjpcbiAgICAgIGNvbnNvbGUud2FybiguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy5lcnJvcjpcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUubG9nKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGEgZGVwcmVjYXRpb24gbm90aWNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucGtnIC0gVGhlIHBhY2thZ2UgdGhhdCBpcyBiZWluZyBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJqZWN0IC0gVGhlIHN1YmplY3Qgb2YgdGhlIGRlcHJlY2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50cmFuc2l0aW9uIC0gVGhlIHRyYW5zaXRpb24gcGF0aCBmb3IgdGhlIGRlcHJlY2F0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIGFmdGVyIHRoZSBsb2dcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICpcbiAqIEBleGFtcGxlXG4gKiBsb2cuZGVwcmVjYXRlKHsgcGtnOiBcIkBvbmZsb3cvZmNsXCIsIHN1YmplY3Q6IFwiU29tZSBpdGVtXCIsIHRyYW5zaXRpb246IFwiaHR0cHM6Ly9naXRodWIuY29tL29uZmxvdy9mbG93LWpzLXNka1wiLCBtZXNzYWdlOiBcIkRlc2NyaXB0aXZlIG1lc3NhZ2VcIiwgbGV2ZWw6IExFVkVMUy53YXJuLCBjYWxsYmFjazogKCkgPT4ge30gfSlcbiAqXG4gKi9cbmxvZy5kZXByZWNhdGUgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgcGtnLFxuICAgIHN1YmplY3QsXG4gICAgdHJhbnNpdGlvbixcbiAgICBsZXZlbCA9IExFVkVMUy53YXJuLFxuICAgIG1lc3NhZ2UgPSBcIlwiLFxuICAgIGNhbGxiYWNrID0gbnVsbFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgfTtcbiAgY29uc3QgbG9nTWVzc2FnZSA9ICgpID0+IGxvZyh7XG4gICAgdGl0bGU6IGAke3BrZyA/IHBrZyArIFwiIFwiIDogXCJcIn1EZXByZWNhdGlvbiBOb3RpY2VgLFxuICAgIG1lc3NhZ2U6IGBcbiAgICAgICR7c3ViamVjdCA/IGAke2NhcGl0YWxpemVGaXJzdExldHRlcihzdWJqZWN0KX0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBjZWFzZSB0byB3b3JrIGluIGZ1dHVyZSByZWxlYXNlcyR7cGtnID8gXCIgb2YgXCIgKyBwa2cgOiBcIlwifS5gIDogXCJcIn0ke21lc3NhZ2UgPyBcIlxcblwiICsgbWVzc2FnZSA6IFwiXCJ9JHt0cmFuc2l0aW9uID8gYFxcbllvdSBjYW4gbGVhcm4gbW9yZSAoaW5jbHVkaW5nIGEgZ3VpZGUgb24gY29tbW9uIHRyYW5zaXRpb24gcGF0aHMpIGhlcmU6ICR7dHJhbnNpdGlvbn1gIDogXCJcIn1cbiAgICBgLnRyaW0oKSxcbiAgICBsZXZlbFxuICB9KTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGxvZ01lc3NhZ2UoKTtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayguLi5hcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGxvZ01lc3NhZ2UoKTtcbn07XG5cbmV4cG9ydCB7IExFVkVMUywgbG9nLCBzZXRDb25maWcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwtbG9nZ2VyLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-logger/dist/util-logger.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-template/dist/template.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@onflow/util-template/dist/template.module.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   interleave: function() { return /* binding */ interleave; },\n/* harmony export */   template: function() { return /* binding */ template; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\n\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED$2 = \"UPDATED\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof __webpack_require__.g === \"object\" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED$2);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant$1(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe$1 = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe$1 = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject$1 = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep$1 = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject$1(target) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep$1(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep$1(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs$1 = value => Array.isArray(value) ? mergeDeep$1({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts$1 = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress$1 = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress$1 = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts$1 = (jsons, network) => {\n  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal$1 = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys$1 = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal$1(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys$1 = value => {\n  if (isObject$1(value)) return hasPrivateKeys$1(value);\n  return value.some(hasPrivateKeys$1);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork$1 = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME$1 = \"config\";\nconst PUT$1 = \"PUT_CONFIG\";\nconst GET$1 = \"GET_CONFIG\";\nconst GET_ALL$1 = \"GET_ALL_CONFIG\";\nconst UPDATE$1 = \"UPDATE_CONFIG\";\nconst DELETE$1 = \"DELETE_CONFIG\";\nconst CLEAR$1 = \"CLEAR_CONFIG\";\nconst WHERE$1 = \"WHERE_CONFIG\";\nconst UPDATED$1 = \"CONFIG/UPDATED\";\nconst identity$1 = v => v;\nconst HANDLERS$1 = {\n  [PUT$1]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [GET$1]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL$1]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE$1]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity$1);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [DELETE$1]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR$1]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [WHERE$1]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS$1, NAME$1);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put$1(key, value) {\n  send(NAME$1, PUT$1, {\n    key,\n    value\n  });\n  return config$1();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get$1(key, fallback) {\n  return send(NAME$1, GET$1, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first$1() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get$1(head);\n  if (ret == null) return first$1(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all$1() {\n  return send(NAME$1, GET_ALL$1, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update$1(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  send(NAME$1, UPDATE$1, {\n    key,\n    fn\n  });\n  return config$1();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete$1(key) {\n  send(NAME$1, DELETE$1, {\n    key\n  });\n  return config$1();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where$1(pattern) {\n  return send(NAME$1, WHERE$1, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe$1(callback) {\n  return subscriber(NAME$1, () => spawn(HANDLERS$1, NAME$1), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig$1() {\n  return send(NAME$1, CLEAR$1);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig$1(oldConfig) {\n  return clearConfig$1().then(config$1(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load$1(data) {\n  const network = await get$1(\"flow.network\");\n  const cleanedNetwork = cleanNetwork$1(network);\n  const {\n    flowJSON\n  } = data;\n  invariant$1(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant$1(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys$1(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts$1(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get$1(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get$1(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config$1(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put$1(d, values[d]));\n  }\n  return {\n    put: put$1,\n    get: get$1,\n    all: all$1,\n    first: first$1,\n    update: update$1,\n    delete: _delete$1,\n    where: where$1,\n    subscribe: subscribe$1,\n    overload: overload$1,\n    load: load$1\n  };\n}\nconfig$1.put = put$1;\nconfig$1.get = get$1;\nconfig$1.all = all$1;\nconfig$1.first = first$1;\nconfig$1.update = update$1;\nconfig$1.delete = _delete$1;\nconfig$1.where = where$1;\nconfig$1.subscribe = subscribe$1;\nconfig$1.overload = overload$1;\nconfig$1.load = load$1;\nconst noop$1 = v => v;\nfunction overload$1() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all$1();\n    try {\n      config$1(opts);\n      var result = await callback(await all$1());\n      await resetConfig$1(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig$1(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS$1 = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs$1 = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log$1 = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config$1.get(\"logger.level\", LEVELS$1.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs$1({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS$1.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS$1.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS$1.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS$1.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog$1.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS$1.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log$1({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\nfunction interleave() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!a.length && !b.length) return c;\n  if (!a.length) return c;\n  if (!b.length) return [...c, a[0]];\n  const [aHead, ...aRest] = a;\n  const [bHead, ...bRest] = b;\n  if (aHead !== undefined) c.push(aHead);\n  if (bHead !== undefined) c.push(bHead);\n  return interleave(aRest, bRest, c);\n}\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\"\n      });\n      return recApply(d)(arg1(d));\n    }\n    return String(arg1);\n  };\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nfunction template(head) {\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n  if (typeof head === \"string\") return () => head;\n  if (Array.isArray(head)) {\n    return d => interleave(head, rest.map(recApply(d))).join(\"\").trim();\n  }\n  return head;\n}\n\n\n//# sourceMappingURL=template.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC10ZW1wbGF0ZS9kaXN0L3RlbXBsYXRlLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHNIQUFzSCxxQkFBTSxtQkFBbUIscUJBQU07O0FBRXJKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUscUJBQU0saUJBQWlCLHFCQUFNLFlBQVkscUJBQU0sSUFBSSxxQkFBTTtBQUN2SSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLFFBQVE7QUFDUix5QkFBeUIsWUFBWTtBQUNyQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsUUFBUSxhQUFhLGdDQUFnQyx5REFBeUQsd0JBQXdCLFFBQVEsRUFBRSw4QkFBOEIsRUFBRSwwRkFBMEYsV0FBVztBQUNyUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxXQUFXO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Ab25mbG93L3V0aWwtdGVtcGxhdGUvZGlzdC90ZW1wbGF0ZS5tb2R1bGUuanM/NzAwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2U7XG52YXIgcXVldWVNaWNyb3Rhc2tfMSA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBjb21tb25qc0dsb2JhbClcbi8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbjogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpLnRoZW4oY2IpLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgdGhyb3cgZXJyO1xufSwgMCkpO1xuXG5jb25zdCBtYWlsYm94ID0gKCkgPT4ge1xuICBjb25zdCBxdWV1ZSA9IFtdO1xuICB2YXIgbmV4dDtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBkZWxpdmVyKG1zZykge1xuICAgICAgcXVldWUucHVzaChtc2cpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dChxdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlY2VpdmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gaW5uZXJSZWNlaXZlKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgbXNnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG1zZykgcmV0dXJuIHJlc29sdmUobXNnKTtcbiAgICAgICAgbmV4dCA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgSU5JVCA9IFwiSU5JVFwiO1xuY29uc3QgU1VCU0NSSUJFID0gXCJTVUJTQ1JJQkVcIjtcbmNvbnN0IFVOU1VCU0NSSUJFID0gXCJVTlNVQlNDUklCRVwiO1xuY29uc3QgVVBEQVRFRCQyID0gXCJVUERBVEVEXCI7XG5jb25zdCBFWElUID0gXCJFWElUXCI7XG5jb25zdCBURVJNSU5BVEUgPSBcIlRFUk1JTkFURVwiO1xuY29uc3Qgcm9vdCA9IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fCB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvdyAmJiB3aW5kb3c7XG5yb290LkZDTF9SRUdJU1RSWSA9IHJvb3QuRkNMX1JFR0lTVFJZID09IG51bGwgPyB7fSA6IHJvb3QuRkNMX1JFR0lTVFJZO1xudmFyIHBpZCA9IDBiMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBzZW5kID0gZnVuY3Rpb24gKGFkZHIsIHRhZywgZGF0YSkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVwbHksIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGV4cGVjdFJlcGx5ID0gb3B0cy5leHBlY3RSZXBseSB8fCBmYWxzZTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0cy50aW1lb3V0ICE9IG51bGwgPyBvcHRzLnRpbWVvdXQgOiBERUZBVUxUX1RJTUVPVVQ7XG4gICAgaWYgKGV4cGVjdFJlcGx5ICYmIHRpbWVvdXQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dDogJHt0aW1lb3V0fW1zIHBhc3NlZCB3aXRob3V0IGEgcmVzcG9uc2UuYCkpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHRvOiBhZGRyLFxuICAgICAgZnJvbTogb3B0cy5mcm9tLFxuICAgICAgdGFnLFxuICAgICAgZGF0YSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICByZXBseSxcbiAgICAgIHJlamVjdFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLm1haWxib3guZGVsaXZlcihwYXlsb2FkKTtcbiAgICAgIGlmICghZXhwZWN0UmVwbHkpIHJlcGx5KHRydWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRkNMLkFjdG9yIC0tIENvdWxkIE5vdCBEZWxpdmVyIE1lc3NhZ2VcIiwgcGF5bG9hZCwgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0sIGVycm9yKTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGtpbGwgPSBhZGRyID0+IHtcbiAgZGVsZXRlIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdO1xufTtcbmNvbnN0IGZyb21IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGhhbmRsZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIGFzeW5jIGN0eCA9PiB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyc1tJTklUXSA9PT0gXCJmdW5jdGlvblwiKSBhd2FpdCBoYW5kbGVyc1tJTklUXShjdHgpO1xuICAgIF9fbG9vcDogd2hpbGUgKDEpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGF3YWl0IGN0eC5yZWNlaXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobGV0dGVyLnRhZyA9PT0gRVhJVCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlcnNbVEVSTUlOQVRFXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyc1tURVJNSU5BVEVdKGN0eCwgbGV0dGVyLCBsZXR0ZXIuZGF0YSB8fCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrIF9fbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBoYW5kbGVyc1tsZXR0ZXIudGFnXShjdHgsIGxldHRlciwgbGV0dGVyLmRhdGEgfHwge30pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgJHtjdHguc2VsZigpfSBFcnJvcmAsIGxldHRlciwgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29udGludWUgX19sb29wO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBzcGF3biA9IGZ1bmN0aW9uIChmbikge1xuICBsZXQgYWRkciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgaWYgKGFkZHIgPT0gbnVsbCkgYWRkciA9ICsrcGlkO1xuICBpZiAocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0gIT0gbnVsbCkgcmV0dXJuIGFkZHI7XG4gIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdID0ge1xuICAgIGFkZHIsXG4gICAgbWFpbGJveDogbWFpbGJveCgpLFxuICAgIHN1YnM6IG5ldyBTZXQoKSxcbiAgICBrdnM6IHt9LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBzZWxmOiAoKSA9PiBhZGRyLFxuICAgIHJlY2VpdmU6ICgpID0+IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLm1haWxib3gucmVjZWl2ZSgpLFxuICAgIHNlbmQ6IGZ1bmN0aW9uICh0bywgdGFnLCBkYXRhKSB7XG4gICAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICBvcHRzLmZyb20gPSBhZGRyO1xuICAgICAgcmV0dXJuIHNlbmQodG8sIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBzZW5kU2VsZjogKHRhZywgZGF0YSwgb3B0cykgPT4ge1xuICAgICAgaWYgKHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdKSBzZW5kKGFkZHIsIHRhZywgZGF0YSwgb3B0cyk7XG4gICAgfSxcbiAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uICh0YWcsIGRhdGEpIHtcbiAgICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIG9wdHMuZnJvbSA9IGFkZHI7XG4gICAgICBmb3IgKGxldCB0byBvZiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzKSBzZW5kKHRvLCB0YWcsIGRhdGEsIG9wdHMpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBzdWIgPT4gc3ViICE9IG51bGwgJiYgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicy5hZGQoc3ViKSxcbiAgICB1bnN1YnNjcmliZTogc3ViID0+IHN1YiAhPSBudWxsICYmIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLnN1YnMuZGVsZXRlKHN1YiksXG4gICAgc3Vic2NyaWJlckNvdW50OiAoKSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLnNpemUsXG4gICAgaGFzU3ViczogKCkgPT4gISFyb290LkZDTF9SRUdJU1RSWVthZGRyXS5zdWJzLnNpemUsXG4gICAgcHV0OiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiAoa2V5LCBmYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gZmFsbGJhY2sgOiB2YWx1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZToga2V5ID0+IHtcbiAgICAgIGRlbGV0ZSByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XTtcbiAgICB9LFxuICAgIHVwZGF0ZTogKGtleSwgZm4pID0+IHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkgcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV0gPSBmbihyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSk7XG4gICAgfSxcbiAgICBrZXlzOiAoKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzKTtcbiAgICB9LFxuICAgIGFsbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJdLmt2cztcbiAgICB9LFxuICAgIHdoZXJlOiBwYXR0ZXJuID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChrZXkpID8ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBba2V5XTogcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0ua3ZzW2tleV1cbiAgICAgICAgfSA6IGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiByb290LkZDTF9SRUdJU1RSWVthZGRyXS5rdnNba2V5XSA9IGRhdGFba2V5XSk7XG4gICAgfSxcbiAgICBmYXRhbEVycm9yOiBlcnJvciA9PiB7XG4gICAgICByb290LkZDTF9SRUdJU1RSWVthZGRyXS5lcnJvciA9IGVycm9yO1xuICAgICAgZm9yIChsZXQgdG8gb2Ygcm9vdC5GQ0xfUkVHSVNUUllbYWRkcl0uc3Vicykgc2VuZCh0bywgVVBEQVRFRCQyKTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgZm4gPT09IFwib2JqZWN0XCIpIGZuID0gZnJvbUhhbmRsZXJzKGZuKTtcbiAgcXVldWVNaWNyb3Rhc2tfMShhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZm4oY3R4KTtcbiAgICBraWxsKGFkZHIpO1xuICB9KTtcbiAgcmV0dXJuIGFkZHI7XG59O1xuXG4vLyBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4vLyBBIFNVQlNDUklCRSBoYW5kbGVyIHdpbGwgbmVlZCB0byBiZSBjcmVhdGVkIHRvIGhhbmRsZSB0aGUgc3Vic2NyaXB0aW9uIGV2ZW50XG4vL1xuLy8gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbi8vICAgIGN0eC5zdWJzY3JpYmUobGV0dGVyLmZyb20pXG4vLyAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCwgY3R4LmFsbCgpKVxuLy8gIH1cbi8vXG5mdW5jdGlvbiBzdWJzY3JpYmVyKGFkZHJlc3MsIHNwYXduRm4sIGNhbGxiYWNrKSB7XG4gIHNwYXduRm4oYWRkcmVzcyk7XG4gIGNvbnN0IEVYSVQgPSBcIkBFWElUXCI7XG4gIGNvbnN0IHNlbGYgPSBzcGF3bihhc3luYyBjdHggPT4ge1xuICAgIGN0eC5zZW5kKGFkZHJlc3MsIFNVQlNDUklCRSk7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGF3YWl0IGN0eC5yZWNlaXZlKCk7XG4gICAgICBjb25zdCBlcnJvciA9IHJvb3QuRkNMX1JFR0lTVFJZW2FkZHJlc3NdLmVycm9yO1xuICAgICAgaWYgKGxldHRlci50YWcgPT09IEVYSVQpIHtcbiAgICAgICAgY3R4LnNlbmQoYWRkcmVzcywgVU5TVUJTQ1JJQkUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZXJyb3IpO1xuICAgICAgICBjdHguc2VuZChhZGRyZXNzLCBVTlNVQlNDUklCRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGxldHRlci5kYXRhLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gc2VuZChzZWxmLCBFWElUKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIGZhY3QgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yIHdpdGggaW52YXJpYW50IG1lc3NhZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZmFjdFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICogQHBhcmFtIHtBcnJheX0gcmVzdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudCQxKGZhY3QsIG1zZykge1xuICBpZiAoIWZhY3QpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSU5WQVJJQU5UICR7bXNnfWApO1xuICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGQgPT4gIS9hdCBpbnZhcmlhbnQvLnRlc3QoZCkpLmpvaW4oXCJcXG5cIik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJcXG5cXG4tLS1cXG5cXG5cIiwgZXJyb3IsIFwiXFxuXFxuXCIsIC4uLnJlc3QsIFwiXFxuXFxuLS0tXFxuXFxuXCIpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5jb25zdCBwaXBlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4gZnVuYyhyZXMpO1xuICAgIH0sIHYpO1xuICB9O1xufTtcblxuLyoqKlxuICogTWVyZ2UgbXVsdGlwbGUgZnVuY3Rpb25zIHJldHVybmluZyBvYmplY3RzIGludG8gb25lIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb24oKik6IG9iamVjdH0gZnVuY3MgLSBGdW5jdGlvbnMgdG8gbWVyZ2VcbiAqIEByZXR1cm4ge29iamVjdH0gLSBNZXJnZWQgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlUGlwZSQxID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIC4uLmZ1bmModilcbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gT2JqZWN0IGNoZWNrXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIElzIG9iamVjdCBzdGF0dXNcbiAqL1xuY29uc3QgaXNPYmplY3QkMSA9IHZhbHVlID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gey4uLm9iamVjdFtdfSBzb3VyY2VzIC0gU291cmNlIG9iamVjdHNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIG9iamVjdFxuICovXG5jb25zdCBtZXJnZURlZXAkMSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBzb3VyY2VzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgaWYgKGlzT2JqZWN0JDEodGFyZ2V0KSAmJiBpc09iamVjdCQxKHNvdXJjZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChpc09iamVjdCQxKHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIXRhcmdldFtrZXldKSBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VEZWVwJDEodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG4gICAgICAgICAgW2tleV06IHNvdXJjZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VEZWVwJDEodGFyZ2V0LCAuLi5zb3VyY2VzKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZXAgbWVyZ2UgbXVsdGlwbGUgRmxvdyBKU09OLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHZhbHVlIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gTWVyZ2VkIEZsb3cgSlNPTlxuICovXG5jb25zdCBtZXJnZUZsb3dKU09OcyQxID0gdmFsdWUgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBtZXJnZURlZXAkMSh7fSwgLi4udmFsdWUpIDogdmFsdWU7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZpbHRlciBvdXQgY29udHJhY3RzIHNlY3Rpb24gb2YgZmxvdy5qc29uLlxuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IG9iaiAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIENvbnRyYWN0cyBzZWN0aW9uIG9mIEZsb3cgSlNPTlxuICovXG5jb25zdCBmaWx0ZXJDb250cmFjdHMkMSA9IG9iaiA9PiBvYmouY29udHJhY3RzID8gb2JqLmNvbnRyYWN0cyA6IHt9O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHYXRoZXJzIGNvbnRyYWN0IGFkZHJlc3NlcyBieSBuZXR3b3JrXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IG1hcENvbnRyYWN0QWxpYXNlc1RvTmV0d29ya0FkZHJlc3MkMSA9IG5ldHdvcmsgPT4gY29udHJhY3RzID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNvbnRyYWN0cykucmVkdWNlKChjLCBfcmVmKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgY29uc3QgbmV0d29ya0NvbnRyYWN0QWxpYXMgPSB2YWx1ZT8uYWxpYXNlcz8uW25ldHdvcmtdO1xuICAgIGlmIChuZXR3b3JrQ29udHJhY3RBbGlhcykge1xuICAgICAgY1trZXldID0gbmV0d29ya0NvbnRyYWN0QWxpYXM7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9LCB7fSk7XG59O1xuY29uc3QgbWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzJDEgPSBuZXR3b3JrID0+IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICBkZXBsb3ltZW50cyA9IHt9LFxuICAgIGFjY291bnRzID0ge31cbiAgfSA9IF9yZWYyO1xuICBjb25zdCBuZXR3b3JrRGVwbG95bWVudCA9IGRlcGxveW1lbnRzPy5bbmV0d29ya107XG4gIGlmICghbmV0d29ya0RlcGxveW1lbnQpIHJldHVybiB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG5ldHdvcmtEZXBsb3ltZW50KS5yZWR1Y2UoKGMsIF9yZWYzKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYzO1xuICAgIC8vIFJlc29sdmUgYWNjb3VudCBhZGRyZXNzXG4gICAgY29uc3QgYWNjb3VudEFkZHJlc3MgPSBhY2NvdW50c1trZXldPy5hZGRyZXNzO1xuICAgIGlmICghYWNjb3VudEFkZHJlc3MpIHJldHVybiBjO1xuXG4gICAgLy8gQ3JlYXRlIGFuIG9iamVjdCBhc3NpZ25pbmcgdGhlIGFkZHJlc3MgdG8gdGhlIGNvbnRyYWN0IG5hbWUuXG4gICAgcmV0dXJuIHZhbHVlLnJlZHVjZSgoYywgY29udHJhY3QpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIFtjb250cmFjdF06IGFjY291bnRBZGRyZXNzXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBpbiBmbG93Lmpzb24gZmlsZXMgYW5kIHJldHVybiBjb250cmFjdCB0byBhZGRyZXNzIG1hcHBpbmcgYnkgbmV0d29ya1xuICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGpzb25zIC0gRmxvdyBKU09OIG9yIGFycmF5IG9mIEZsb3cgSlNPTnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBnYXRoZXIgYWRkcmVzc2VzIGZvclxuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdCBuYW1lcyBieSBhZGRyZXNzZXMgbWFwcGluZyBlLmcgeyBcIkhlbGxvV29ybGRcIjogXCIweDEyM1wiIH1cbiAqL1xuY29uc3QgZ2V0Q29udHJhY3RzJDEgPSAoanNvbnMsIG5ldHdvcmspID0+IHtcbiAgcmV0dXJuIHBpcGUkMShtZXJnZUZsb3dKU09OcyQxLCBtZXJnZVBpcGUkMShtYXBEZXBsb3ltZW50c1RvTmV0d29ya0FkZHJlc3MkMShuZXR3b3JrKSwgcGlwZSQxKGZpbHRlckNvbnRyYWN0cyQxLCBtYXBDb250cmFjdEFsaWFzZXNUb05ldHdvcmtBZGRyZXNzJDEobmV0d29yaykpKSkoanNvbnMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHN0cmluZyBpcyBoZXhpZGVjaW1hbFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSXMgaGV4aWRlY2ltYWwgc3RhdHVzXG4gKi9cbmNvbnN0IGlzSGV4aWRlY2ltYWwkMSA9IHN0ciA9PiB7XG4gIC8vIENoZWNrIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIC9eWzAtOUEtRmEtZl0rJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGZsb3cuanNvbiBmaWxlIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBmbG93SlNPTiAtIEZsb3cgSlNPTlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gSGFzIHByaXZhdGUga2V5cyBzdGF0dXNcbiAqL1xuY29uc3QgaGFzUHJpdmF0ZUtleXMkMSA9IGZsb3dKU09OID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZsb3dKU09OPy5hY2NvdW50cykucmVkdWNlKChoYXNQcml2YXRlS2V5LCBfcmVmNCkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmNDtcbiAgICBpZiAoaGFzUHJpdmF0ZUtleSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHZhbHVlPy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSAmJiBpc0hleGlkZWNpbWFsJDEodmFsdWU/LmtleSk7XG4gIH0sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlcyBhbmQgY2hlY2tzIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBIYXMgcHJpdmF0ZSBrZXlzIHN0YXR1c1xuICovXG5jb25zdCBhbnlIYXNQcml2YXRlS2V5cyQxID0gdmFsdWUgPT4ge1xuICBpZiAoaXNPYmplY3QkMSh2YWx1ZSkpIHJldHVybiBoYXNQcml2YXRlS2V5cyQxKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlLnNvbWUoaGFzUHJpdmF0ZUtleXMkMSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGb3JtYXQgbmV0d29yayB0byBhbHdheXMgYmUgJ2VtdWxhdG9yJywgJ3Rlc3RuZXQnLCBvciAnbWFpbm5ldCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBmb3JtYXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRm9ybWF0dGVkIG5ldHdvcmsgbmFtZSAoZWl0aGVyICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnKVxuICovXG5jb25zdCBjbGVhbk5ldHdvcmskMSA9IG5ldHdvcmsgPT4gbmV0d29yaz8udG9Mb3dlckNhc2UoKSA9PT0gXCJsb2NhbFwiID8gXCJlbXVsYXRvclwiIDogbmV0d29yaz8udG9Mb3dlckNhc2UoKTtcbmNvbnN0IE5BTUUkMSA9IFwiY29uZmlnXCI7XG5jb25zdCBQVVQkMSA9IFwiUFVUX0NPTkZJR1wiO1xuY29uc3QgR0VUJDEgPSBcIkdFVF9DT05GSUdcIjtcbmNvbnN0IEdFVF9BTEwkMSA9IFwiR0VUX0FMTF9DT05GSUdcIjtcbmNvbnN0IFVQREFURSQxID0gXCJVUERBVEVfQ09ORklHXCI7XG5jb25zdCBERUxFVEUkMSA9IFwiREVMRVRFX0NPTkZJR1wiO1xuY29uc3QgQ0xFQVIkMSA9IFwiQ0xFQVJfQ09ORklHXCI7XG5jb25zdCBXSEVSRSQxID0gXCJXSEVSRV9DT05GSUdcIjtcbmNvbnN0IFVQREFURUQkMSA9IFwiQ09ORklHL1VQREFURURcIjtcbmNvbnN0IGlkZW50aXR5JDEgPSB2ID0+IHY7XG5jb25zdCBIQU5ETEVSUyQxID0ge1xuICBbUFVUJDFdOiAoY3R4LCBfbGV0dGVyLCBfcmVmKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvcHV0LlwiKTtcbiAgICBjdHgucHV0KGtleSwgdmFsdWUpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCQxLCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0dFVCQxXTogKGN0eCwgbGV0dGVyLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBmYWxsYmFja1xuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9nZXRcIik7XG4gICAgbGV0dGVyLnJlcGx5KGN0eC5nZXQoa2V5LCBmYWxsYmFjaykpO1xuICB9LFxuICBbR0VUX0FMTCQxXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgbGV0dGVyLnJlcGx5KHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVVBEQVRFJDFdOiAoY3R4LCBsZXR0ZXIsIF9yZWYzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZuXG4gICAgfSA9IF9yZWYzO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL3VwZGF0ZVwiKTtcbiAgICBjdHgudXBkYXRlKGtleSwgZm4gfHwgaWRlbnRpdHkkMSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVEJDEsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbREVMRVRFJDFdOiAoY3R4LCBsZXR0ZXIsIF9yZWY0KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmNDtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9kZWxldGVcIik7XG4gICAgY3R4LmRlbGV0ZShrZXkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCQxLCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0NMRUFSJDFdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGN0eC5hbGwoKSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIGN0eC5kZWxldGUoa2V5KTtcbiAgICBjdHguYnJvYWRjYXN0KFVQREFURUQkMSwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtXSEVSRSQxXTogKGN0eCwgbGV0dGVyLCBfcmVmNSkgPT4ge1xuICAgIGxldCB7XG4gICAgICBwYXR0ZXJuXG4gICAgfSA9IF9yZWY1O1xuICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ3BhdHRlcm4nIGZvciBjb25maWcvd2hlcmVcIik7XG4gICAgbGV0dGVyLnJlcGx5KGN0eC53aGVyZShwYXR0ZXJuKSk7XG4gIH0sXG4gIFtTVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHguc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgICBjdHguc2VuZChsZXR0ZXIuZnJvbSwgVVBEQVRFRCQxLCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW1VOU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnVuc3Vic2NyaWJlKGxldHRlci5mcm9tKTtcbiAgfVxufTtcbnNwYXduKEhBTkRMRVJTJDEsIE5BTUUkMSk7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEFkZHMgYSBrZXktdmFsdWUgcGFpciB0byB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYWRkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBwdXQkMShrZXksIHZhbHVlKSB7XG4gIHNlbmQoTkFNRSQxLCBQVVQkMSwge1xuICAgIGtleSxcbiAgICB2YWx1ZVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZyQxKCk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgYSBrZXktdmFsdWUgcGFpciB3aXRoIGEgZmFsbGJhY2sgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7Kn0gW2ZhbGxiYWNrXSAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXQkMShrZXksIGZhbGxiYWNrKSB7XG4gIHJldHVybiBzZW5kKE5BTUUkMSwgR0VUJDEsIHtcbiAgICBrZXksXG4gICAgZmFsbGJhY2tcbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCBjb25maWcgdmFsdWUgb3IgdGhlIGZhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YW50cyAtIFRoZSBrZXlzIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7Kn0gZmFsbGJhY2sgLSBUaGUgZmFsbGJhY2sgdmFsdWUgdG8gcmV0dXJuIGlmIGtleSBpcyBub3QgZm91bmRcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSAtIFRoZSB2YWx1ZSBmb3VuZCBhdCBrZXkgb3IgZmFsbGJhY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlyc3QkMSgpIHtcbiAgbGV0IHdhbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIGlmICghd2FudHMubGVuZ3RoKSByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IFtoZWFkLCAuLi5yZXN0XSA9IHdhbnRzO1xuICBjb25zdCByZXQgPSBhd2FpdCBnZXQkMShoZWFkKTtcbiAgaWYgKHJldCA9PSBudWxsKSByZXR1cm4gZmlyc3QkMShyZXN0LCBmYWxsYmFjayk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGwkMSgpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSQxLCBHRVRfQUxMJDEsIG51bGwsIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVXBkYXRlcyBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB2YWx1ZSB3aXRoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiB1cGRhdGUkMShrZXkpIHtcbiAgbGV0IGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZGVudGl0eSQxO1xuICBzZW5kKE5BTUUkMSwgVVBEQVRFJDEsIHtcbiAgICBrZXksXG4gICAgZm5cbiAgfSk7XG4gIHJldHVybiBjb25maWckMSgpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBEZWxldGVzIGEga2V5LXZhbHVlIHBhaXIgZnJvbSB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBkZWxldGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIF9kZWxldGUkMShrZXkpIHtcbiAgc2VuZChOQU1FJDEsIERFTEVURSQxLCB7XG4gICAga2V5XG4gIH0pO1xuICByZXR1cm4gY29uZmlnJDEoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgY29uZmlnIGJhc2VkIG9uIGEgcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCBrZXlzIGFnYWluc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIHN1YnNldCBvZiB0aGUgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHdoZXJlJDEocGF0dGVybikge1xuICByZXR1cm4gc2VuZChOQU1FJDEsIFdIRVJFJDEsIHtcbiAgICBwYXR0ZXJuXG4gIH0sIHtcbiAgICBleHBlY3RSZXBseTogdHJ1ZSxcbiAgICB0aW1lb3V0OiAxMFxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gU3Vic2NyaWJlcyB0byBjb25maWcgdXBkYXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGNvbmZpZyBpcyB1cGRhdGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHN1YnNjcmliZSQxKGNhbGxiYWNrKSB7XG4gIHJldHVybiBzdWJzY3JpYmVyKE5BTUUkMSwgKCkgPT4gc3Bhd24oSEFORExFUlMkMSwgTkFNRSQxKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDbGVhcnMgdGhlIGNvbmZpZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNsZWFyQ29uZmlnJDEoKSB7XG4gIHJldHVybiBzZW5kKE5BTUUkMSwgQ0xFQVIkMSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgY29uZmlnIHRvIGEgcHJldmlvdXMgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRDb25maWcgLSBUaGUgcHJldmlvdXMgY29uZmlnIHN0YXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiByZXNldENvbmZpZyQxKG9sZENvbmZpZykge1xuICByZXR1cm4gY2xlYXJDb25maWckMSgpLnRoZW4oY29uZmlnJDEob2xkQ29uZmlnKSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2VzIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNyZWF0ZXMgY29udHJhY3QgcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSAtIFRoZSBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZCQxKGRhdGEpIHtcbiAgY29uc3QgbmV0d29yayA9IGF3YWl0IGdldCQxKFwiZmxvdy5uZXR3b3JrXCIpO1xuICBjb25zdCBjbGVhbmVkTmV0d29yayA9IGNsZWFuTmV0d29yayQxKG5ldHdvcmspO1xuICBjb25zdCB7XG4gICAgZmxvd0pTT05cbiAgfSA9IGRhdGE7XG4gIGludmFyaWFudCQxKEJvb2xlYW4oZmxvd0pTT04pLCBcImNvbmZpZy5sb2FkIC0tICdmbG93SlNPTicgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICBpbnZhcmlhbnQkMShjbGVhbmVkTmV0d29yaywgYEZsb3cgTmV0d29yayBSZXF1aXJlZCAtLSBJbiBvcmRlciBmb3IgRkNMIHRvIGxvYWQgeW91ciBjb250cmFjdHMgcGxlYXNlIGRlZmluZSBcImZsb3cubmV0d29ya1wiIHRvIFwiZW11bGF0b3JcIiwgXCJsb2NhbFwiLCBcInRlc3RuZXRcIiwgb3IgXCJtYWlubmV0XCIgaW4geW91ciBjb25maWcuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mY2wtanMvcmVmZXJlbmNlL2NvbmZpZ3VyZS1mY2xgKTtcbiAgaWYgKGFueUhhc1ByaXZhdGVLZXlzJDEoZmxvd0pTT04pKSB7XG4gICAgY29uc3QgaXNFbXVsYXRvciA9IGNsZWFuZWROZXR3b3JrID09PSBcImVtdWxhdG9yXCI7XG4gICAgbG9nJDEoe1xuICAgICAgdGl0bGU6IFwiUHJpdmF0ZSBLZXlzIERldGVjdGVkXCIsXG4gICAgICBtZXNzYWdlOiBgUHJpdmF0ZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBmbG93Lmpzb24gZmlsZSBmb3Igc2VjdXJpdHkuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mbG93LWNsaS9zZWN1cml0eWAsXG4gICAgICBsZXZlbDogaXNFbXVsYXRvciA/IExFVkVMUyQxLndhcm4gOiBMRVZFTFMkMS5lcnJvclxuICAgIH0pO1xuICAgIGlmICghaXNFbXVsYXRvcikgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGdldENvbnRyYWN0cyQxKGZsb3dKU09OLCBjbGVhbmVkTmV0d29yaykpKSB7XG4gICAgY29uc3QgY29udHJhY3RDb25maWdLZXkgPSBgMHgke2tleX1gO1xuICAgIGNvbnN0IGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgPSBhd2FpdCBnZXQkMShjb250cmFjdENvbmZpZ0tleSk7XG4gICAgaWYgKGV4aXN0aW5nQ29udHJhY3RDb25maWdLZXkgJiYgZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyQxKHtcbiAgICAgICAgdGl0bGU6IFwiQ29udHJhY3QgUGxhY2Vob2xkZXIgQ29uZmxpY3QgRGV0ZWN0ZWRcIixcbiAgICAgICAgbWVzc2FnZTogYEEgZ2VuZXJhdGVkIGNvbnRyYWN0IHBsYWNlaG9sZGVyIGZyb20gY29uZmlnLmxvYWQgY29uZmxpY3RzIHdpdGggYSBwbGFjZWhvbGRlciB5b3UndmUgc2V0IG1hbnVhbGx5IGluIGNvbmZpZyBoYXZlIHRoZSBzYW1lIG5hbWUuYCxcbiAgICAgICAgbGV2ZWw6IExFVkVMUyQxLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQkMShjb250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBzeXN0ZW1Db250cmFjdENvbmZpZ0tleSA9IGBzeXN0ZW0uY29udHJhY3RzLiR7a2V5fWA7XG4gICAgY29uc3Qgc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlID0gYXdhaXQgZ2V0JDEoc3lzdGVtQ29udHJhY3RDb25maWdLZXkpO1xuICAgIGlmIChzeXN0ZW1FeGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5VmFsdWUgJiYgc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgbG9nJDEoe1xuICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBDb25mbGljdCBEZXRlY3RlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQSBnZW5lcmF0ZWQgY29udHJhY3QgcGxhY2Vob2xkZXIgZnJvbSBjb25maWcubG9hZCBjb25mbGljdHMgd2l0aCBhIHBsYWNlaG9sZGVyIHlvdSd2ZSBzZXQgbWFudWFsbHkgaW4gY29uZmlnIGhhdmUgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICBsZXZlbDogTEVWRUxTJDEud2FyblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dCQxKHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLXJldHVybnNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdIC0gVGhlIHZhbHVlcyB0byBzZXRcbiAqL1xuZnVuY3Rpb24gY29uZmlnJDEodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZCA9PiBwdXQkMShkLCB2YWx1ZXNbZF0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHB1dDogcHV0JDEsXG4gICAgZ2V0OiBnZXQkMSxcbiAgICBhbGw6IGFsbCQxLFxuICAgIGZpcnN0OiBmaXJzdCQxLFxuICAgIHVwZGF0ZTogdXBkYXRlJDEsXG4gICAgZGVsZXRlOiBfZGVsZXRlJDEsXG4gICAgd2hlcmU6IHdoZXJlJDEsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUkMSxcbiAgICBvdmVybG9hZDogb3ZlcmxvYWQkMSxcbiAgICBsb2FkOiBsb2FkJDFcbiAgfTtcbn1cbmNvbmZpZyQxLnB1dCA9IHB1dCQxO1xuY29uZmlnJDEuZ2V0ID0gZ2V0JDE7XG5jb25maWckMS5hbGwgPSBhbGwkMTtcbmNvbmZpZyQxLmZpcnN0ID0gZmlyc3QkMTtcbmNvbmZpZyQxLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuY29uZmlnJDEuZGVsZXRlID0gX2RlbGV0ZSQxO1xuY29uZmlnJDEud2hlcmUgPSB3aGVyZSQxO1xuY29uZmlnJDEuc3Vic2NyaWJlID0gc3Vic2NyaWJlJDE7XG5jb25maWckMS5vdmVybG9hZCA9IG92ZXJsb2FkJDE7XG5jb25maWckMS5sb2FkID0gbG9hZCQxO1xuY29uc3Qgbm9vcCQxID0gdiA9PiB2O1xuZnVuY3Rpb24gb3ZlcmxvYWQkMSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3AkMTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbGRDb25maWcgPSBhd2FpdCBhbGwkMSgpO1xuICAgIHRyeSB7XG4gICAgICBjb25maWckMShvcHRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhd2FpdCBjYWxsYmFjayhhd2FpdCBhbGwkMSgpKTtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnJDEob2xkQ29uZmlnKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgcmVzZXRDb25maWckMShvbGRDb25maWcpO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBsZXZlbHMgb2YgdGhlIGxvZ2dlclxuICogXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMRVZFTFNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWJ1ZyAtIFRoZSBkZWJ1ZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZm8gLSBUaGUgaW5mbyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvZyAtIFRoZSBsb2cgbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3YXJuIC0gVGhlIHdhcm4gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcnJvciAtIFRoZSBlcnJvciBsZXZlbFxuICogXG4gKi9cbmNvbnN0IExFVkVMUyQxID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGRlYnVnOiA1LFxuICBpbmZvOiA0LFxuICBsb2c6IDMsXG4gIHdhcm46IDIsXG4gIGVycm9yOiAxXG59KTtcblxuLyoqXG4gKiBCdWlsZHMgYSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IC0gVGhlIG1lc3NhZ2UgZm9ybWF0dGVkIGZvciB0aGUgbG9nZ2VyXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIgfSlcbiAqL1xuY29uc3QgYnVpbGRMb2dnZXJNZXNzYWdlQXJncyQxID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFtgXG4gICAgJWMke3RpdGxlfVxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICR7bWVzc2FnZX1cblxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBgLnJlcGxhY2UoL1xcblteXFxTXFxyXFxuXSsvZywgXCJcXG5cIikudHJpbSgpLCwgXCJmb250LXdlaWdodDpib2xkO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtcIl07XG59O1xuXG4vKipcbiAqIExvZ3MgbWVzc2FnZXMgYmFzZWQgb24gdGhlIGxldmVsIG9mIHRoZSBtZXNzYWdlIGFuZCB0aGUgbGV2ZWwgc2V0IGluIHRoZSBjb25maWdcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hbHdheXMgLSBXaGV0aGVyIHRvIGFsd2F5cyBzaG93IHRoZSBsb2dcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICogXG4gKiBAZXhhbXBsZVxuICogbG9nKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIsIGxldmVsOiBMRVZFTFMud2FybiwgYWx3YXlzOiBmYWxzZSB9KVxuICogXG4gKi9cbmNvbnN0IGxvZyQxID0gYXN5bmMgX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwsXG4gICAgYWx3YXlzID0gZmFsc2VcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBjb25maWdMb2dnZXJMZXZlbCA9IGF3YWl0IGNvbmZpZyQxLmdldChcImxvZ2dlci5sZXZlbFwiLCBMRVZFTFMkMS53YXJuKTtcblxuICAvLyBJZiBjb25maWcgbGV2ZWwgaXMgYmVsb3cgbWVzc2FnZSBsZXZlbCB0aGVuIGRvbid0IHNob3cgaXRcbiAgaWYgKCFhbHdheXMgJiYgY29uZmlnTG9nZ2VyTGV2ZWwgPCBsZXZlbCkgcmV0dXJuO1xuICBjb25zdCBsb2dnZXJNZXNzYWdlQXJncyA9IGJ1aWxkTG9nZ2VyTWVzc2FnZUFyZ3MkMSh7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZVxuICB9KTtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgTEVWRUxTJDEuZGVidWc6XG4gICAgICBjb25zb2xlLmRlYnVnKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTJDEuaW5mbzpcbiAgICAgIGNvbnNvbGUuaW5mbyguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUyQxLndhcm46XG4gICAgICBjb25zb2xlLndhcm4oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMkMS5lcnJvcjpcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUubG9nKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGEgZGVwcmVjYXRpb24gbm90aWNlXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBrZyAtIFRoZSBwYWNrYWdlIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdCAtIFRoZSBzdWJqZWN0IG9mIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHJhbnNpdGlvbiAtIFRoZSB0cmFuc2l0aW9uIHBhdGggZm9yIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBhZnRlciB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZy5kZXByZWNhdGUoeyBwa2c6IFwiQG9uZmxvdy9mY2xcIiwgc3ViamVjdDogXCJTb21lIGl0ZW1cIiwgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrXCIsIG1lc3NhZ2U6IFwiRGVzY3JpcHRpdmUgbWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGNhbGxiYWNrOiAoKSA9PiB7fSB9KVxuICogXG4gKi9cbmxvZyQxLmRlcHJlY2F0ZSA9IF9yZWYzID0+IHtcbiAgbGV0IHtcbiAgICBwa2csXG4gICAgc3ViamVjdCxcbiAgICB0cmFuc2l0aW9uLFxuICAgIGxldmVsID0gTEVWRUxTJDEud2FybixcbiAgICBtZXNzYWdlID0gXCJcIixcbiAgICBjYWxsYmFjayA9IG51bGxcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH07XG4gIGNvbnN0IGxvZ01lc3NhZ2UgPSAoKSA9PiBsb2ckMSh7XG4gICAgdGl0bGU6IGAke3BrZyA/IHBrZyArIFwiIFwiIDogXCJcIn1EZXByZWNhdGlvbiBOb3RpY2VgLFxuICAgIG1lc3NhZ2U6IGBcbiAgICAgICR7c3ViamVjdCA/IGAke2NhcGl0YWxpemVGaXJzdExldHRlcihzdWJqZWN0KX0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBjZWFzZSB0byB3b3JrIGluIGZ1dHVyZSByZWxlYXNlcyR7cGtnID8gXCIgb2YgXCIgKyBwa2cgOiBcIlwifS5gIDogXCJcIn0ke21lc3NhZ2UgPyBcIlxcblwiICsgbWVzc2FnZSA6IFwiXCJ9JHt0cmFuc2l0aW9uID8gYFxcbllvdSBjYW4gbGVhcm4gbW9yZSAoaW5jbHVkaW5nIGEgZ3VpZGUgb24gY29tbW9uIHRyYW5zaXRpb24gcGF0aHMpIGhlcmU6ICR7dHJhbnNpdGlvbn1gIDogXCJcIn1cbiAgICBgLnRyaW0oKSxcbiAgICBsZXZlbFxuICB9KTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGxvZ01lc3NhZ2UoKTtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayguLi5hcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGxvZ01lc3NhZ2UoKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBmYWN0IGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvciB3aXRoIGludmFyaWFudCBtZXNzYWdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbnZhcmlhbnQoZmFjdCwgbXNnKSB7XG4gIGlmICghZmFjdCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBJTlZBUklBTlQgJHttc2d9YCk7XG4gICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoZCA9PiAhL2F0IGludmFyaWFudC8udGVzdChkKSkuam9pbihcIlxcblwiKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihcIlxcblxcbi0tLVxcblxcblwiLCBlcnJvciwgXCJcXG5cXG5cIiwgLi4ucmVzdCwgXCJcXG5cXG4tLS1cXG5cXG5cIik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmNvbnN0IHBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gdiA9PiB7XG4gICAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgocmVzLCBmdW5jKSA9PiB7XG4gICAgICByZXR1cm4gZnVuYyhyZXMpO1xuICAgIH0sIHYpO1xuICB9O1xufTtcblxuLyoqKlxuICogTWVyZ2UgbXVsdGlwbGUgZnVuY3Rpb25zIHJldHVybmluZyBvYmplY3RzIGludG8gb25lIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb24oKik6IG9iamVjdH0gZnVuY3MgLSBGdW5jdGlvbnMgdG8gbWVyZ2VcbiAqIEByZXR1cm4ge29iamVjdH0gLSBNZXJnZWQgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlUGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGZ1bmNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIHYgPT4ge1xuICAgIHJldHVybiBmdW5jcy5yZWR1Y2UoKHJlcywgZnVuYykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICAuLi5mdW5jKHYpXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIE9iamVjdCBjaGVja1xuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBJcyBvYmplY3Qgc3RhdHVzXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVlcCBtZXJnZSBtdWx0aXBsZSBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7Li4ub2JqZWN0W119IHNvdXJjZXMgLSBTb3VyY2Ugb2JqZWN0c1xuICogQHJldHVybnMge29iamVjdH0gLSBNZXJnZWQgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlRGVlcCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBzb3VyY2VzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIXRhcmdldFtrZXldKSBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgIFtrZXldOiBzb3VyY2Vba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVlcCBtZXJnZSBtdWx0aXBsZSBGbG93IEpTT04uXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gdmFsdWUgLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge29iamVjdH0gLSBNZXJnZWQgRmxvdyBKU09OXG4gKi9cbmNvbnN0IG1lcmdlRmxvd0pTT05zID0gdmFsdWUgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBtZXJnZURlZXAoe30sIC4uLnZhbHVlKSA6IHZhbHVlO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBGaWx0ZXIgb3V0IGNvbnRyYWN0cyBzZWN0aW9uIG9mIGZsb3cuanNvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBvYmogLSBGbG93IEpTT04gb3IgYXJyYXkgb2YgRmxvdyBKU09Oc1xuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdHMgc2VjdGlvbiBvZiBGbG93IEpTT05cbiAqL1xuY29uc3QgZmlsdGVyQ29udHJhY3RzID0gb2JqID0+IG9iai5jb250cmFjdHMgPyBvYmouY29udHJhY3RzIDoge307XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdhdGhlcnMgY29udHJhY3QgYWRkcmVzc2VzIGJ5IG5ldHdvcmtcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gTmV0d29yayB0byBnYXRoZXIgYWRkcmVzc2VzIGZvclxuICogQHJldHVybnMge29iamVjdH0gLSBDb250cmFjdCBuYW1lcyBieSBhZGRyZXNzZXMgbWFwcGluZyBlLmcgeyBcIkhlbGxvV29ybGRcIjogXCIweDEyM1wiIH1cbiAqL1xuY29uc3QgbWFwQ29udHJhY3RBbGlhc2VzVG9OZXR3b3JrQWRkcmVzcyA9IG5ldHdvcmsgPT4gY29udHJhY3RzID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNvbnRyYWN0cykucmVkdWNlKChjLCBfcmVmKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgY29uc3QgbmV0d29ya0NvbnRyYWN0QWxpYXMgPSB2YWx1ZT8uYWxpYXNlcz8uW25ldHdvcmtdO1xuICAgIGlmIChuZXR3b3JrQ29udHJhY3RBbGlhcykge1xuICAgICAgY1trZXldID0gbmV0d29ya0NvbnRyYWN0QWxpYXM7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9LCB7fSk7XG59O1xuY29uc3QgbWFwRGVwbG95bWVudHNUb05ldHdvcmtBZGRyZXNzID0gbmV0d29yayA9PiBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgZGVwbG95bWVudHMgPSB7fSxcbiAgICBhY2NvdW50cyA9IHt9XG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgbmV0d29ya0RlcGxveW1lbnQgPSBkZXBsb3ltZW50cz8uW25ldHdvcmtdO1xuICBpZiAoIW5ldHdvcmtEZXBsb3ltZW50KSByZXR1cm4ge307XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhuZXR3b3JrRGVwbG95bWVudCkucmVkdWNlKChjLCBfcmVmMykgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMztcbiAgICAvLyBSZXNvbHZlIGFjY291bnQgYWRkcmVzc1xuICAgIGNvbnN0IGFjY291bnRBZGRyZXNzID0gYWNjb3VudHNba2V5XT8uYWRkcmVzcztcbiAgICBpZiAoIWFjY291bnRBZGRyZXNzKSByZXR1cm4gYztcblxuICAgIC8vIENyZWF0ZSBhbiBvYmplY3QgYXNzaWduaW5nIHRoZSBhZGRyZXNzIHRvIHRoZSBjb250cmFjdCBuYW1lLlxuICAgIHJldHVybiB2YWx1ZS5yZWR1Y2UoKGMsIGNvbnRyYWN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jLFxuICAgICAgICBbY29udHJhY3RdOiBhY2NvdW50QWRkcmVzc1xuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIGZpbGVzIGFuZCByZXR1cm4gY29udHJhY3QgdG8gYWRkcmVzcyBtYXBwaW5nIGJ5IG5ldHdvcmtcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBqc29ucyAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZ2F0aGVyIGFkZHJlc3NlcyBmb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gQ29udHJhY3QgbmFtZXMgYnkgYWRkcmVzc2VzIG1hcHBpbmcgZS5nIHsgXCJIZWxsb1dvcmxkXCI6IFwiMHgxMjNcIiB9XG4gKi9cbmNvbnN0IGdldENvbnRyYWN0cyA9IChqc29ucywgbmV0d29yaykgPT4ge1xuICByZXR1cm4gcGlwZShtZXJnZUZsb3dKU09OcywgbWVyZ2VQaXBlKG1hcERlcGxveW1lbnRzVG9OZXR3b3JrQWRkcmVzcyhuZXR3b3JrKSwgcGlwZShmaWx0ZXJDb250cmFjdHMsIG1hcENvbnRyYWN0QWxpYXNlc1RvTmV0d29ya0FkZHJlc3MobmV0d29yaykpKSkoanNvbnMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2hlY2tzIGlmIHN0cmluZyBpcyBoZXhpZGVjaW1hbFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gSXMgaGV4aWRlY2ltYWwgc3RhdHVzXG4gKi9cbmNvbnN0IGlzSGV4aWRlY2ltYWwgPSBzdHIgPT4ge1xuICAvLyBDaGVjayB0aGF0IGl0IGlzIGEgc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvXlswLTlBLUZhLWZdKyQvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENoZWNrcyBmbG93Lmpzb24gZmlsZSBmb3IgcHJpdmF0ZSBrZXlzXG4gKiBAcGFyYW0ge29iamVjdH0gZmxvd0pTT04gLSBGbG93IEpTT05cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIEhhcyBwcml2YXRlIGtleXMgc3RhdHVzXG4gKi9cbmNvbnN0IGhhc1ByaXZhdGVLZXlzID0gZmxvd0pTT04gPT4ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZmxvd0pTT04/LmFjY291bnRzKS5yZWR1Y2UoKGhhc1ByaXZhdGVLZXksIF9yZWY0KSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY0O1xuICAgIGlmIChoYXNQcml2YXRlS2V5KSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdmFsdWU/Lmhhc093blByb3BlcnR5KFwia2V5XCIpICYmIGlzSGV4aWRlY2ltYWwodmFsdWU/LmtleSk7XG4gIH0sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2UgaW4gZmxvdy5qc29uIG9yIGFycmF5IG9mIGZsb3cuanNvbiBmaWxlcyBhbmQgY2hlY2tzIGZvciBwcml2YXRlIGtleXNcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB2YWx1ZSAtIEZsb3cgSlNPTiBvciBhcnJheSBvZiBGbG93IEpTT05zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBIYXMgcHJpdmF0ZSBrZXlzIHN0YXR1c1xuICovXG5jb25zdCBhbnlIYXNQcml2YXRlS2V5cyA9IHZhbHVlID0+IHtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGhhc1ByaXZhdGVLZXlzKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlLnNvbWUoaGFzUHJpdmF0ZUtleXMpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRm9ybWF0IG5ldHdvcmsgdG8gYWx3YXlzIGJlICdlbXVsYXRvcicsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQnXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIE5ldHdvcmsgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEZvcm1hdHRlZCBuZXR3b3JrIG5hbWUgKGVpdGhlciAnZW11bGF0b3InLCAndGVzdG5ldCcsIG9yICdtYWlubmV0JylcbiAqL1xuY29uc3QgY2xlYW5OZXR3b3JrID0gbmV0d29yayA9PiBuZXR3b3JrPy50b0xvd2VyQ2FzZSgpID09PSBcImxvY2FsXCIgPyBcImVtdWxhdG9yXCIgOiBuZXR3b3JrPy50b0xvd2VyQ2FzZSgpO1xuY29uc3QgTkFNRSA9IFwiY29uZmlnXCI7XG5jb25zdCBQVVQgPSBcIlBVVF9DT05GSUdcIjtcbmNvbnN0IEdFVCA9IFwiR0VUX0NPTkZJR1wiO1xuY29uc3QgR0VUX0FMTCA9IFwiR0VUX0FMTF9DT05GSUdcIjtcbmNvbnN0IFVQREFURSA9IFwiVVBEQVRFX0NPTkZJR1wiO1xuY29uc3QgREVMRVRFID0gXCJERUxFVEVfQ09ORklHXCI7XG5jb25zdCBDTEVBUiA9IFwiQ0xFQVJfQ09ORklHXCI7XG5jb25zdCBXSEVSRSA9IFwiV0hFUkVfQ09ORklHXCI7XG5jb25zdCBVUERBVEVEID0gXCJDT05GSUcvVVBEQVRFRFwiO1xuY29uc3QgaWRlbnRpdHkgPSB2ID0+IHY7XG5jb25zdCBIQU5ETEVSUyA9IHtcbiAgW1BVVF06IChjdHgsIF9sZXR0ZXIsIF9yZWYpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9wdXQuXCIpO1xuICAgIGN0eC5wdXQoa2V5LCB2YWx1ZSk7XG4gICAgY3R4LmJyb2FkY2FzdChVUERBVEVELCB7XG4gICAgICAuLi5jdHguYWxsKClcbiAgICB9KTtcbiAgfSxcbiAgW0dFVF06IChjdHgsIGxldHRlciwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKGtleSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdrZXknIGZvciBjb25maWcvZ2V0XCIpO1xuICAgIGxldHRlci5yZXBseShjdHguZ2V0KGtleSwgZmFsbGJhY2spKTtcbiAgfSxcbiAgW0dFVF9BTExdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBsZXR0ZXIucmVwbHkoe1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtVUERBVEVdOiAoY3R4LCBsZXR0ZXIsIF9yZWYzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGZuXG4gICAgfSA9IF9yZWYzO1xuICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAna2V5JyBmb3IgY29uZmlnL3VwZGF0ZVwiKTtcbiAgICBjdHgudXBkYXRlKGtleSwgZm4gfHwgaWRlbnRpdHkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtERUxFVEVdOiAoY3R4LCBsZXR0ZXIsIF9yZWY0KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmNDtcbiAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgJ2tleScgZm9yIGNvbmZpZy9kZWxldGVcIik7XG4gICAgY3R4LmRlbGV0ZShrZXkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtDTEVBUl06IChjdHgsIGxldHRlcikgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoY3R4LmFsbCgpKTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykgY3R4LmRlbGV0ZShrZXkpO1xuICAgIGN0eC5icm9hZGNhc3QoVVBEQVRFRCwge1xuICAgICAgLi4uY3R4LmFsbCgpXG4gICAgfSk7XG4gIH0sXG4gIFtXSEVSRV06IChjdHgsIGxldHRlciwgX3JlZjUpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0dGVyblxuICAgIH0gPSBfcmVmNTtcbiAgICBpZiAocGF0dGVybiA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICdwYXR0ZXJuJyBmb3IgY29uZmlnL3doZXJlXCIpO1xuICAgIGxldHRlci5yZXBseShjdHgud2hlcmUocGF0dGVybikpO1xuICB9LFxuICBbU1VCU0NSSUJFXTogKGN0eCwgbGV0dGVyKSA9PiB7XG4gICAgY3R4LnN1YnNjcmliZShsZXR0ZXIuZnJvbSk7XG4gICAgY3R4LnNlbmQobGV0dGVyLmZyb20sIFVQREFURUQsIHtcbiAgICAgIC4uLmN0eC5hbGwoKVxuICAgIH0pO1xuICB9LFxuICBbVU5TVUJTQ1JJQkVdOiAoY3R4LCBsZXR0ZXIpID0+IHtcbiAgICBjdHgudW5zdWJzY3JpYmUobGV0dGVyLmZyb20pO1xuICB9XG59O1xuc3Bhd24oSEFORExFUlMsIE5BTUUpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBZGRzIGEga2V5LXZhbHVlIHBhaXIgdG8gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFkZFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgY3VycmVudCBjb25maWdcbiAqL1xuZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgc2VuZChOQU1FLCBQVVQsIHtcbiAgICBrZXksXG4gICAgdmFsdWVcbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyBhIGtleS12YWx1ZSBwYWlyIHdpdGggYSBmYWxsYmFjayBmcm9tIHRoZSBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHsqfSBbZmFsbGJhY2tdIC0gVGhlIGZhbGxiYWNrIHZhbHVlIHRvIHJldHVybiBpZiBrZXkgaXMgbm90IGZvdW5kXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gLSBUaGUgdmFsdWUgZm91bmQgYXQga2V5IG9yIGZhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGdldChrZXksIGZhbGxiYWNrKSB7XG4gIHJldHVybiBzZW5kKE5BTUUsIEdFVCwge1xuICAgIGtleSxcbiAgICBmYWxsYmFja1xuICB9LCB7XG4gICAgZXhwZWN0UmVwbHk6IHRydWUsXG4gICAgdGltZW91dDogMTBcbiAgfSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGZpcnN0IG5vbiBudWxsIGNvbmZpZyB2YWx1ZSBvciB0aGUgZmFsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nW119IHdhbnRzIC0gVGhlIGtleXMgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHsqfSBmYWxsYmFjayAtIFRoZSBmYWxsYmFjayB2YWx1ZSB0byByZXR1cm4gaWYga2V5IGlzIG5vdCBmb3VuZFxuICogQHJldHVybnMge1Byb21pc2U8Kj59IC0gVGhlIHZhbHVlIGZvdW5kIGF0IGtleSBvciBmYWxsYmFja1xuICovXG5hc3luYyBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgbGV0IHdhbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIGlmICghd2FudHMubGVuZ3RoKSByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IFtoZWFkLCAuLi5yZXN0XSA9IHdhbnRzO1xuICBjb25zdCByZXQgPSBhd2FpdCBnZXQoaGVhZCk7XG4gIGlmIChyZXQgPT0gbnVsbCkgcmV0dXJuIGZpcnN0KHJlc3QsIGZhbGxiYWNrKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgY3VycmVudCBjb25maWdcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbCgpIHtcbiAgcmV0dXJuIHNlbmQoTkFNRSwgR0VUX0FMTCwgbnVsbCwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIHZhbHVlIHdpdGhcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IC0gVGhlIGN1cnJlbnQgY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZShrZXkpIHtcbiAgbGV0IGZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBpZGVudGl0eTtcbiAgc2VuZChOQU1FLCBVUERBVEUsIHtcbiAgICBrZXksXG4gICAgZm5cbiAgfSk7XG4gIHJldHVybiBjb25maWcoKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRGVsZXRlcyBhIGtleS12YWx1ZSBwYWlyIGZyb20gdGhlIGNvbmZpZ1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gZGVsZXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICBzZW5kKE5BTUUsIERFTEVURSwge1xuICAgIGtleVxuICB9KTtcbiAgcmV0dXJuIGNvbmZpZygpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBjb25maWcgYmFzZWQgb24gYSBwYXR0ZXJuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIGtleXMgYWdhaW5zdFxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBUaGUgc3Vic2V0IG9mIHRoZSBjb25maWdcbiAqL1xuZnVuY3Rpb24gd2hlcmUocGF0dGVybikge1xuICByZXR1cm4gc2VuZChOQU1FLCBXSEVSRSwge1xuICAgIHBhdHRlcm5cbiAgfSwge1xuICAgIGV4cGVjdFJlcGx5OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDEwXG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTdWJzY3JpYmVzIHRvIGNvbmZpZyB1cGRhdGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gY29uZmlnIGlzIHVwZGF0ZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBUaGUgdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gIHJldHVybiBzdWJzY3JpYmVyKE5BTUUsICgpID0+IHNwYXduKEhBTkRMRVJTLCBOQU1FKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDbGVhcnMgdGhlIGNvbmZpZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNsZWFyQ29uZmlnKCkge1xuICByZXR1cm4gc2VuZChOQU1FLCBDTEVBUik7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgY29uZmlnIHRvIGEgcHJldmlvdXMgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRDb25maWcgLSBUaGUgcHJldmlvdXMgY29uZmlnIHN0YXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIFRoZSBjdXJyZW50IGNvbmZpZ1xuICovXG5mdW5jdGlvbiByZXNldENvbmZpZyhvbGRDb25maWcpIHtcbiAgcmV0dXJuIGNsZWFyQ29uZmlnKCkudGhlbihjb25maWcob2xkQ29uZmlnKSk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRha2VzIGluIGZsb3cuanNvbiBvciBhcnJheSBvZiBmbG93Lmpzb24gZmlsZXMgYW5kIGNyZWF0ZXMgY29udHJhY3QgcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSAtIFRoZSBmbG93Lmpzb24gb3IgYXJyYXkgb2YgZmxvdy5qc29uIGZpbGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZChkYXRhKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBnZXQoXCJmbG93Lm5ldHdvcmtcIik7XG4gIGNvbnN0IGNsZWFuZWROZXR3b3JrID0gY2xlYW5OZXR3b3JrKG5ldHdvcmspO1xuICBjb25zdCB7XG4gICAgZmxvd0pTT05cbiAgfSA9IGRhdGE7XG4gIGludmFyaWFudChCb29sZWFuKGZsb3dKU09OKSwgXCJjb25maWcubG9hZCAtLSAnZmxvd0pTT04nIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgaW52YXJpYW50KGNsZWFuZWROZXR3b3JrLCBgRmxvdyBOZXR3b3JrIFJlcXVpcmVkIC0tIEluIG9yZGVyIGZvciBGQ0wgdG8gbG9hZCB5b3VyIGNvbnRyYWN0cyBwbGVhc2UgZGVmaW5lIFwiZmxvdy5uZXR3b3JrXCIgdG8gXCJlbXVsYXRvclwiLCBcImxvY2FsXCIsIFwidGVzdG5ldFwiLCBvciBcIm1haW5uZXRcIiBpbiB5b3VyIGNvbmZpZy4gU2VlIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmZsb3cuY29tL3Rvb2xzL2ZjbC1qcy9yZWZlcmVuY2UvY29uZmlndXJlLWZjbGApO1xuICBpZiAoYW55SGFzUHJpdmF0ZUtleXMoZmxvd0pTT04pKSB7XG4gICAgY29uc3QgaXNFbXVsYXRvciA9IGNsZWFuZWROZXR3b3JrID09PSBcImVtdWxhdG9yXCI7XG4gICAgbG9nJDEoe1xuICAgICAgdGl0bGU6IFwiUHJpdmF0ZSBLZXlzIERldGVjdGVkXCIsXG4gICAgICBtZXNzYWdlOiBgUHJpdmF0ZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBmbG93Lmpzb24gZmlsZSBmb3Igc2VjdXJpdHkuIFNlZSBtb3JlIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVycy5mbG93LmNvbS90b29scy9mbG93LWNsaS9zZWN1cml0eWAsXG4gICAgICBsZXZlbDogaXNFbXVsYXRvciA/IExFVkVMUyQxLndhcm4gOiBMRVZFTFMkMS5lcnJvclxuICAgIH0pO1xuICAgIGlmICghaXNFbXVsYXRvcikgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGdldENvbnRyYWN0cyhmbG93SlNPTiwgY2xlYW5lZE5ldHdvcmspKSkge1xuICAgIGNvbnN0IGNvbnRyYWN0Q29uZmlnS2V5ID0gYDB4JHtrZXl9YDtcbiAgICBjb25zdCBleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ID0gYXdhaXQgZ2V0KGNvbnRyYWN0Q29uZmlnS2V5KTtcbiAgICBpZiAoZXhpc3RpbmdDb250cmFjdENvbmZpZ0tleSAmJiBleGlzdGluZ0NvbnRyYWN0Q29uZmlnS2V5ICE9PSB2YWx1ZSkge1xuICAgICAgbG9nJDEoe1xuICAgICAgICB0aXRsZTogXCJDb250cmFjdCBQbGFjZWhvbGRlciBDb25mbGljdCBEZXRlY3RlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQSBnZW5lcmF0ZWQgY29udHJhY3QgcGxhY2Vob2xkZXIgZnJvbSBjb25maWcubG9hZCBjb25mbGljdHMgd2l0aCBhIHBsYWNlaG9sZGVyIHlvdSd2ZSBzZXQgbWFudWFsbHkgaW4gY29uZmlnIGhhdmUgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICBsZXZlbDogTEVWRUxTJDEud2FyblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dChjb250cmFjdENvbmZpZ0tleSwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBzeXN0ZW1Db250cmFjdENvbmZpZ0tleSA9IGBzeXN0ZW0uY29udHJhY3RzLiR7a2V5fWA7XG4gICAgY29uc3Qgc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlID0gYXdhaXQgZ2V0KHN5c3RlbUNvbnRyYWN0Q29uZmlnS2V5KTtcbiAgICBpZiAoc3lzdGVtRXhpc3RpbmdDb250cmFjdENvbmZpZ0tleVZhbHVlICYmIHN5c3RlbUV4aXN0aW5nQ29udHJhY3RDb25maWdLZXlWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGxvZyQxKHtcbiAgICAgICAgdGl0bGU6IFwiQ29udHJhY3QgUGxhY2Vob2xkZXIgQ29uZmxpY3QgRGV0ZWN0ZWRcIixcbiAgICAgICAgbWVzc2FnZTogYEEgZ2VuZXJhdGVkIGNvbnRyYWN0IHBsYWNlaG9sZGVyIGZyb20gY29uZmlnLmxvYWQgY29uZmxpY3RzIHdpdGggYSBwbGFjZWhvbGRlciB5b3UndmUgc2V0IG1hbnVhbGx5IGluIGNvbmZpZyBoYXZlIHRoZSBzYW1lIG5hbWUuYCxcbiAgICAgICAgbGV2ZWw6IExFVkVMUyQxLndhcm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXQoc3lzdGVtQ29udHJhY3RDb25maWdLZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtcmV0dXJuc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgY29uZmlnXG4gKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc10gLSBUaGUgdmFsdWVzIHRvIHNldFxuICovXG5mdW5jdGlvbiBjb25maWcodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZCA9PiBwdXQoZCwgdmFsdWVzW2RdKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdXQsXG4gICAgZ2V0LFxuICAgIGFsbCxcbiAgICBmaXJzdCxcbiAgICB1cGRhdGUsXG4gICAgZGVsZXRlOiBfZGVsZXRlLFxuICAgIHdoZXJlLFxuICAgIHN1YnNjcmliZSxcbiAgICBvdmVybG9hZCxcbiAgICBsb2FkXG4gIH07XG59XG5jb25maWcucHV0ID0gcHV0O1xuY29uZmlnLmdldCA9IGdldDtcbmNvbmZpZy5hbGwgPSBhbGw7XG5jb25maWcuZmlyc3QgPSBmaXJzdDtcbmNvbmZpZy51cGRhdGUgPSB1cGRhdGU7XG5jb25maWcuZGVsZXRlID0gX2RlbGV0ZTtcbmNvbmZpZy53aGVyZSA9IHdoZXJlO1xuY29uZmlnLnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbmNvbmZpZy5vdmVybG9hZCA9IG92ZXJsb2FkO1xuY29uZmlnLmxvYWQgPSBsb2FkO1xuY29uc3Qgbm9vcCA9IHYgPT4gdjtcbmZ1bmN0aW9uIG92ZXJsb2FkKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbGRDb25maWcgPSBhd2FpdCBhbGwoKTtcbiAgICB0cnkge1xuICAgICAgY29uZmlnKG9wdHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGF3YWl0IGFsbCgpKTtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGF3YWl0IHJlc2V0Q29uZmlnKG9sZENvbmZpZyk7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGxldmVscyBvZiB0aGUgbG9nZ2VyXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExFVkVMU1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlYnVnIC0gVGhlIGRlYnVnIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5mbyAtIFRoZSBpbmZvIGxldmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG9nIC0gVGhlIGxvZyBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdhcm4gLSBUaGUgd2FybiBsZXZlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVycm9yIC0gVGhlIGVycm9yIGxldmVsXG4gKiBcbiAqL1xuY29uc3QgTEVWRUxTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGRlYnVnOiA1LFxuICBpbmZvOiA0LFxuICBsb2c6IDMsXG4gIHdhcm46IDIsXG4gIGVycm9yOiAxXG59KTtcblxuLyoqXG4gKiBCdWlsZHMgYSBtZXNzYWdlIGZvcm1hdHRlZCBmb3IgdGhlIGxvZ2dlclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGxvZ1xuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IC0gVGhlIG1lc3NhZ2UgZm9ybWF0dGVkIGZvciB0aGUgbG9nZ2VyXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHsgdGl0bGU6IFwiTXkgVGl0bGVcIiwgbWVzc2FnZTogXCJNeSBNZXNzYWdlXCIgfSlcbiAqL1xuY29uc3QgYnVpbGRMb2dnZXJNZXNzYWdlQXJncyA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIHRpdGxlLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBbYFxuICAgICVjJHt0aXRsZX1cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAke21lc3NhZ2V9XG5cbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgYC5yZXBsYWNlKC9cXG5bXlxcU1xcclxcbl0rL2csIFwiXFxuXCIpLnRyaW0oKSwsIFwiZm9udC13ZWlnaHQ6Ym9sZDtmb250LWZhbWlseTptb25vc3BhY2U7XCJdO1xufTtcblxuLyoqXG4gKiBMb2dzIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGxldmVsIHNldCBpbiB0aGUgY29uZmlnXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZXZlbCAtIFRoZSBsZXZlbCBvZiB0aGUgbG9nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYWx3YXlzIC0gV2hldGhlciB0byBhbHdheXMgc2hvdyB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZyh7IHRpdGxlOiBcIk15IFRpdGxlXCIsIG1lc3NhZ2U6IFwiTXkgTWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGFsd2F5czogZmFsc2UgfSlcbiAqIFxuICovXG5jb25zdCBsb2cgPSBhc3luYyBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgdGl0bGUsXG4gICAgbWVzc2FnZSxcbiAgICBsZXZlbCxcbiAgICBhbHdheXMgPSBmYWxzZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IGNvbmZpZ0xvZ2dlckxldmVsID0gYXdhaXQgY29uZmlnLmdldChcImxvZ2dlci5sZXZlbFwiLCBMRVZFTFMud2Fybik7XG5cbiAgLy8gSWYgY29uZmlnIGxldmVsIGlzIGJlbG93IG1lc3NhZ2UgbGV2ZWwgdGhlbiBkb24ndCBzaG93IGl0XG4gIGlmICghYWx3YXlzICYmIGNvbmZpZ0xvZ2dlckxldmVsIDwgbGV2ZWwpIHJldHVybjtcbiAgY29uc3QgbG9nZ2VyTWVzc2FnZUFyZ3MgPSBidWlsZExvZ2dlck1lc3NhZ2VBcmdzKHtcbiAgICB0aXRsZSxcbiAgICBtZXNzYWdlXG4gIH0pO1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBMRVZFTFMuZGVidWc6XG4gICAgICBjb25zb2xlLmRlYnVnKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTEVWRUxTLmluZm86XG4gICAgICBjb25zb2xlLmluZm8oLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMRVZFTFMud2FybjpcbiAgICAgIGNvbnNvbGUud2FybiguLi5sb2dnZXJNZXNzYWdlQXJncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIExFVkVMUy5lcnJvcjpcbiAgICAgIGNvbnNvbGUuZXJyb3IoLi4ubG9nZ2VyTWVzc2FnZUFyZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUubG9nKC4uLmxvZ2dlck1lc3NhZ2VBcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGEgZGVwcmVjYXRpb24gbm90aWNlXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBrZyAtIFRoZSBwYWNrYWdlIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdCAtIFRoZSBzdWJqZWN0IG9mIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHJhbnNpdGlvbiAtIFRoZSB0cmFuc2l0aW9uIHBhdGggZm9yIHRoZSBkZXByZWNhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIGxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBsb2dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBhZnRlciB0aGUgbG9nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxvZy5kZXByZWNhdGUoeyBwa2c6IFwiQG9uZmxvdy9mY2xcIiwgc3ViamVjdDogXCJTb21lIGl0ZW1cIiwgdHJhbnNpdGlvbjogXCJodHRwczovL2dpdGh1Yi5jb20vb25mbG93L2Zsb3ctanMtc2RrXCIsIG1lc3NhZ2U6IFwiRGVzY3JpcHRpdmUgbWVzc2FnZVwiLCBsZXZlbDogTEVWRUxTLndhcm4sIGNhbGxiYWNrOiAoKSA9PiB7fSB9KVxuICogXG4gKi9cbmxvZy5kZXByZWNhdGUgPSBfcmVmMyA9PiB7XG4gIGxldCB7XG4gICAgcGtnLFxuICAgIHN1YmplY3QsXG4gICAgdHJhbnNpdGlvbixcbiAgICBsZXZlbCA9IExFVkVMUy53YXJuLFxuICAgIG1lc3NhZ2UgPSBcIlwiLFxuICAgIGNhbGxiYWNrID0gbnVsbFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGNhcGl0YWxpemVGaXJzdExldHRlciA9IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgfTtcbiAgY29uc3QgbG9nTWVzc2FnZSA9ICgpID0+IGxvZyh7XG4gICAgdGl0bGU6IGAke3BrZyA/IHBrZyArIFwiIFwiIDogXCJcIn1EZXByZWNhdGlvbiBOb3RpY2VgLFxuICAgIG1lc3NhZ2U6IGBcbiAgICAgICR7c3ViamVjdCA/IGAke2NhcGl0YWxpemVGaXJzdExldHRlcihzdWJqZWN0KX0gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBjZWFzZSB0byB3b3JrIGluIGZ1dHVyZSByZWxlYXNlcyR7cGtnID8gXCIgb2YgXCIgKyBwa2cgOiBcIlwifS5gIDogXCJcIn0ke21lc3NhZ2UgPyBcIlxcblwiICsgbWVzc2FnZSA6IFwiXCJ9JHt0cmFuc2l0aW9uID8gYFxcbllvdSBjYW4gbGVhcm4gbW9yZSAoaW5jbHVkaW5nIGEgZ3VpZGUgb24gY29tbW9uIHRyYW5zaXRpb24gcGF0aHMpIGhlcmU6ICR7dHJhbnNpdGlvbn1gIDogXCJcIn1cbiAgICBgLnRyaW0oKSxcbiAgICBsZXZlbFxuICB9KTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGxvZ01lc3NhZ2UoKTtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayguLi5hcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGxvZ01lc3NhZ2UoKTtcbn07XG5cbmZ1bmN0aW9uIGludGVybGVhdmUoKSB7XG4gIGxldCBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgbGV0IGIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBsZXQgYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gIGlmICghYS5sZW5ndGggJiYgIWIubGVuZ3RoKSByZXR1cm4gYztcbiAgaWYgKCFhLmxlbmd0aCkgcmV0dXJuIGM7XG4gIGlmICghYi5sZW5ndGgpIHJldHVybiBbLi4uYywgYVswXV07XG4gIGNvbnN0IFthSGVhZCwgLi4uYVJlc3RdID0gYTtcbiAgY29uc3QgW2JIZWFkLCAuLi5iUmVzdF0gPSBiO1xuICBpZiAoYUhlYWQgIT09IHVuZGVmaW5lZCkgYy5wdXNoKGFIZWFkKTtcbiAgaWYgKGJIZWFkICE9PSB1bmRlZmluZWQpIGMucHVzaChiSGVhZCk7XG4gIHJldHVybiBpbnRlcmxlYXZlKGFSZXN0LCBiUmVzdCwgYyk7XG59XG5mdW5jdGlvbiByZWNBcHBseShkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnMSkge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsb2cuZGVwcmVjYXRlKHtcbiAgICAgICAgcGtnOiBcIkZDTC9TREtcIixcbiAgICAgICAgc3ViamVjdDogXCJJbnRlcm9wb2xhdGlvbiBvZiBmdW5jdGlvbnMgaW50byB0ZW1wbGF0ZSBsaXRlcmFsc1wiLFxuICAgICAgICB0cmFuc2l0aW9uOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbmZsb3cvZmxvdy1qcy1zZGsvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2RrL1RSQU5TSVRJT05TLm1kIzAwMDEtZGVwcmVjYXRlLXBhcmFtc1wiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWNBcHBseShkKShhcmcxKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhcmcxKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkuPCo+KX0gaGVhZFxuICogQHBhcmFtIHtBcnJheS48Kj59IHJlc3RcbiAqIEByZXR1cm5zIHt7ZnVuY3Rpb24oKTogc3RyaW5nfX1cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoaGVhZCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkID09PSBcInN0cmluZ1wiKSByZXR1cm4gKCkgPT4gaGVhZDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZCkpIHtcbiAgICByZXR1cm4gZCA9PiBpbnRlcmxlYXZlKGhlYWQsIHJlc3QubWFwKHJlY0FwcGx5KGQpKSkuam9pbihcIlwiKS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIGhlYWQ7XG59XG5cbmV4cG9ydCB7IGludGVybGVhdmUsIHRlbXBsYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-template/dist/template.module.js\n"));

/***/ }),

/***/ "../../node_modules/@onflow/util-uid/dist/util-uid.module.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@onflow/util-uid/dist/util-uid.module.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uid: function() { return /* binding */ uid; }\n/* harmony export */ });\n/**\n * Generates a unique identifier\n * @returns {string}\n */\nvar HEX = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nvar T = HEX.length;\nfunction uid() {\n  var str = \"\",\n    num = 32;\n  while (num--) str += HEX[Math.random() * T | 0];\n  return str;\n}\n\n\n//# sourceMappingURL=util-uid.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbmZsb3cvdXRpbC11aWQvZGlzdC91dGlsLXVpZC5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Ab25mbG93L3V0aWwtdWlkL2Rpc3QvdXRpbC11aWQubW9kdWxlLmpzPzI0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIEhFWCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODlcIjtcbnZhciBUID0gSEVYLmxlbmd0aDtcbmZ1bmN0aW9uIHVpZCgpIHtcbiAgdmFyIHN0ciA9IFwiXCIsXG4gICAgbnVtID0gMzI7XG4gIHdoaWxlIChudW0tLSkgc3RyICs9IEhFWFtNYXRoLnJhbmRvbSgpICogVCB8IDBdO1xuICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyB1aWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwtdWlkLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@onflow/util-uid/dist/util-uid.module.js\n"));

/***/ }),

/***/ "../../node_modules/abort-controller/browser.js":
/*!******************************************************!*\
  !*** ../../node_modules/abort-controller/browser.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*globals self, window */\n\n\n/*eslint-disable @mysticatea/prettier */\nconst { AbortController, AbortSignal } =\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    /* otherwise */ undefined\n/*eslint-enable @mysticatea/prettier */\n\nmodule.exports = AbortController\nmodule.exports.AbortSignal = AbortSignal\nmodule.exports[\"default\"] = AbortController\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Fib3J0LWNvbnRyb2xsZXIvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNZOztBQUVaO0FBQ0EsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9icm93c2VyLmpzP2Y3NDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWxzIHNlbGYsIHdpbmRvdyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuLyplc2xpbnQtZGlzYWJsZSBAbXlzdGljYXRlYS9wcmV0dGllciAqL1xuY29uc3QgeyBBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsIH0gPVxuICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6XG4gICAgLyogb3RoZXJ3aXNlICovIHVuZGVmaW5lZFxuLyplc2xpbnQtZW5hYmxlIEBteXN0aWNhdGVhL3ByZXR0aWVyICovXG5cbm1vZHVsZS5leHBvcnRzID0gQWJvcnRDb250cm9sbGVyXG5tb2R1bGUuZXhwb3J0cy5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQWJvcnRDb250cm9sbGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/abort-controller/browser.js\n"));

/***/ }),

/***/ "../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/NjAyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "../../node_modules/buffer/index.js":
/*!******************************************!*\
  !*** ../../node_modules/buffer/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"../../node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"../../node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsd0RBQVc7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQix5QkFBeUI7O0FBRXpCO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1C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TTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz8yODY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "../../node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***************************************************************!*\
  !*** ../../node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb255ZmlsbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDBCQUEwQixlQUFlO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQ7O0FBRUEsQ0FBQyxJQUFJO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQkFBZTtBQUNmLGFBQWEsbUNBQW1DLE9BQU87QUFDdkQsZUFBZTtBQUNmLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanM/MDNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXM7XG52YXIgX19zZWxmX18gPSAoZnVuY3Rpb24gKCkge1xuZnVuY3Rpb24gRigpIHtcbnRoaXMuZmV0Y2ggPSBmYWxzZTtcbnRoaXMuRE9NRXhjZXB0aW9uID0gZ2xvYmFsLkRPTUV4Y2VwdGlvblxufVxuRi5wcm90b3R5cGUgPSBnbG9iYWw7XG5yZXR1cm4gbmV3IEYoKTtcbn0pKCk7XG4oZnVuY3Rpb24oc2VsZikge1xuXG52YXIgaXJyZWxldmFudCA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOlxuICAgICAgJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiZcbiAgICAgICdCbG9iJyBpbiBzZWxmICYmXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbDtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbic7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcmJylcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gc2VsZi5ET01FeGNlcHRpb247XG4gIHRyeSB7XG4gICAgbmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKTtcbiAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9O1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLkRPTUV4Y2VwdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpO1xuICAgIH0pXG4gIH1cblxuICBmZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG5cbiAgaWYgKCFzZWxmLmZldGNoKSB7XG4gICAgc2VsZi5mZXRjaCA9IGZldGNoO1xuICAgIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIH1cblxuICBleHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBleHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBleHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIGV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KSh7fSk7XG59KShfX3NlbGZfXyk7XG5fX3NlbGZfXy5mZXRjaC5wb255ZmlsbCA9IHRydWU7XG4vLyBSZW1vdmUgXCJwb2x5ZmlsbFwiIHByb3BlcnR5IGFkZGVkIGJ5IHdoYXR3Zy1mZXRjaFxuZGVsZXRlIF9fc2VsZl9fLmZldGNoLnBvbHlmaWxsO1xuLy8gQ2hvb3NlIGJldHdlZW4gbmF0aXZlIGltcGxlbWVudGF0aW9uIChnbG9iYWwpIG9yIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiAoX19zZWxmX18pXG4vLyB2YXIgY3R4ID0gZ2xvYmFsLmZldGNoID8gZ2xvYmFsIDogX19zZWxmX187XG52YXIgY3R4ID0gX19zZWxmX187IC8vIHRoaXMgbGluZSBkaXNhYmxlIHNlcnZpY2Ugd29ya2VyIHN1cHBvcnQgdGVtcG9yYXJpbHlcbmV4cG9ydHMgPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQgZmV0Y2ggZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLmRlZmF1bHQgPSBjdHguZmV0Y2ggLy8gRm9yIFR5cGVTY3JpcHQgY29uc3VtZXJzIHdpdGhvdXQgZXNNb2R1bGVJbnRlcm9wLlxuZXhwb3J0cy5mZXRjaCA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCB7ZmV0Y2h9IGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5IZWFkZXJzID0gY3R4LkhlYWRlcnNcbmV4cG9ydHMuUmVxdWVzdCA9IGN0eC5SZXF1ZXN0XG5leHBvcnRzLlJlc3BvbnNlID0gY3R4LlJlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/cross-fetch/dist/browser-ponyfill.js\n"));

/***/ }),

/***/ "../../node_modules/ieee754/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/ieee754/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsU0FBUyxVQUFVOztBQUVuQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz81ZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "../../node_modules/queue-microtask/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/queue-microtask/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLHFCQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcXVldWUtbWljcm90YXNrL2luZGV4LmpzPzAzN2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuICAvLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG4gIDogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpXG4gICAgLnRoZW4oY2IpXG4gICAgLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyIH0sIDApKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/queue-microtask/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/index.js":
/*!****************************************!*\
  !*** ../../node_modules/sha3/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=exports.SHAKE=exports.SHA3Hash=exports.SHA3=exports.Keccak=void 0;var _buffer=__webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\");var _sponge=_interopRequireDefault(__webpack_require__(/*! ./sponge */ \"../../node_modules/sha3/sponge/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var createHash=function createHash(_ref){var allowedSizes=_ref.allowedSizes,defaultSize=_ref.defaultSize,padding=_ref.padding;return function Hash(){var _this=this;var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultSize;if(!this||this.constructor!==Hash){return new Hash(size)}if(allowedSizes&&!allowedSizes.includes(size)){throw new Error(\"Unsupported hash length\")}var sponge=new _sponge[\"default\"]({capacity:size});this.update=function(input){var encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"utf8\";if(_buffer.Buffer.isBuffer(input)){sponge.absorb(input);return _this}if(typeof input===\"string\"){return _this.update(_buffer.Buffer.from(input,encoding))}throw new TypeError(\"Not a string or buffer\")};this.digest=function(){var formatOrOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:\"binary\";var options=typeof formatOrOptions===\"string\"?{format:formatOrOptions}:formatOrOptions;var buffer=sponge.squeeze({buffer:options.buffer,padding:options.padding||padding});if(options.format&&options.format!==\"binary\"){return buffer.toString(options.format)}return buffer};this.reset=function(){sponge.reset();return _this};return this}};var Keccak=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:1});exports.Keccak=Keccak;var SHA3=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:6});exports.SHA3=SHA3;var SHAKE=createHash({allowedSizes:[128,256],defaultSize:256,padding:31});exports.SHAKE=SHAKE;var SHA3Hash=Keccak;exports.SHA3Hash=SHA3Hash;SHA3.SHA3Hash=SHA3Hash;var _default=SHA3;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxjQUFjLFFBQVEsWUFBWSxtQkFBTyxDQUFDLGtEQUFRLEVBQUUsbUNBQW1DLG1CQUFPLENBQUMseURBQVUsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUseUNBQXlDLHFGQUFxRix1QkFBdUIsZUFBZSwrRUFBK0UsbUNBQW1DLHNCQUFzQiwrQ0FBK0MsMkNBQTJDLG1DQUFtQyxjQUFjLEVBQUUsNEJBQTRCLDhFQUE4RSxtQ0FBbUMscUJBQXFCLGFBQWEsNEJBQTRCLHlEQUF5RCwrQ0FBK0MsdUJBQXVCLHVGQUF1RiwrQ0FBK0MsdUJBQXVCLGlCQUFpQiwyQkFBMkIsdURBQXVELEVBQUUsOENBQThDLHVDQUF1QyxlQUFlLHNCQUFzQixlQUFlLGNBQWMsY0FBYyx1QkFBdUIseURBQXlELEVBQUUsY0FBYyxRQUFRLHFCQUFxQix5REFBeUQsRUFBRSxZQUFZLE1BQU0sc0JBQXNCLGtEQUFrRCxFQUFFLGFBQWEsT0FBTyxvQkFBb0IsZ0JBQWdCLFVBQVUsdUJBQXVCLGtCQUFrQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL2luZGV4LmpzPzNjNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT1leHBvcnRzLlNIQUtFPWV4cG9ydHMuU0hBM0hhc2g9ZXhwb3J0cy5TSEEzPWV4cG9ydHMuS2VjY2FrPXZvaWQgMDt2YXIgX2J1ZmZlcj1yZXF1aXJlKFwiYnVmZmVyXCIpO3ZhciBfc3BvbmdlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3BvbmdlXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9fXZhciBjcmVhdGVIYXNoPWZ1bmN0aW9uIGNyZWF0ZUhhc2goX3JlZil7dmFyIGFsbG93ZWRTaXplcz1fcmVmLmFsbG93ZWRTaXplcyxkZWZhdWx0U2l6ZT1fcmVmLmRlZmF1bHRTaXplLHBhZGRpbmc9X3JlZi5wYWRkaW5nO3JldHVybiBmdW5jdGlvbiBIYXNoKCl7dmFyIF90aGlzPXRoaXM7dmFyIHNpemU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOmRlZmF1bHRTaXplO2lmKCF0aGlzfHx0aGlzLmNvbnN0cnVjdG9yIT09SGFzaCl7cmV0dXJuIG5ldyBIYXNoKHNpemUpfWlmKGFsbG93ZWRTaXplcyYmIWFsbG93ZWRTaXplcy5pbmNsdWRlcyhzaXplKSl7dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgaGFzaCBsZW5ndGhcIil9dmFyIHNwb25nZT1uZXcgX3Nwb25nZVtcImRlZmF1bHRcIl0oe2NhcGFjaXR5OnNpemV9KTt0aGlzLnVwZGF0ZT1mdW5jdGlvbihpbnB1dCl7dmFyIGVuY29kaW5nPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1sxXTpcInV0ZjhcIjtpZihfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpe3Nwb25nZS5hYnNvcmIoaW5wdXQpO3JldHVybiBfdGhpc31pZih0eXBlb2YgaW5wdXQ9PT1cInN0cmluZ1wiKXtyZXR1cm4gX3RoaXMudXBkYXRlKF9idWZmZXIuQnVmZmVyLmZyb20oaW5wdXQsZW5jb2RpbmcpKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgc3RyaW5nIG9yIGJ1ZmZlclwiKX07dGhpcy5kaWdlc3Q9ZnVuY3Rpb24oKXt2YXIgZm9ybWF0T3JPcHRpb25zPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTpcImJpbmFyeVwiO3ZhciBvcHRpb25zPXR5cGVvZiBmb3JtYXRPck9wdGlvbnM9PT1cInN0cmluZ1wiP3tmb3JtYXQ6Zm9ybWF0T3JPcHRpb25zfTpmb3JtYXRPck9wdGlvbnM7dmFyIGJ1ZmZlcj1zcG9uZ2Uuc3F1ZWV6ZSh7YnVmZmVyOm9wdGlvbnMuYnVmZmVyLHBhZGRpbmc6b3B0aW9ucy5wYWRkaW5nfHxwYWRkaW5nfSk7aWYob3B0aW9ucy5mb3JtYXQmJm9wdGlvbnMuZm9ybWF0IT09XCJiaW5hcnlcIil7cmV0dXJuIGJ1ZmZlci50b1N0cmluZyhvcHRpb25zLmZvcm1hdCl9cmV0dXJuIGJ1ZmZlcn07dGhpcy5yZXNldD1mdW5jdGlvbigpe3Nwb25nZS5yZXNldCgpO3JldHVybiBfdGhpc307cmV0dXJuIHRoaXN9fTt2YXIgS2VjY2FrPWNyZWF0ZUhhc2goe2FsbG93ZWRTaXplczpbMjI0LDI1NiwzODQsNTEyXSxkZWZhdWx0U2l6ZTo1MTIscGFkZGluZzoxfSk7ZXhwb3J0cy5LZWNjYWs9S2VjY2FrO3ZhciBTSEEzPWNyZWF0ZUhhc2goe2FsbG93ZWRTaXplczpbMjI0LDI1NiwzODQsNTEyXSxkZWZhdWx0U2l6ZTo1MTIscGFkZGluZzo2fSk7ZXhwb3J0cy5TSEEzPVNIQTM7dmFyIFNIQUtFPWNyZWF0ZUhhc2goe2FsbG93ZWRTaXplczpbMTI4LDI1Nl0sZGVmYXVsdFNpemU6MjU2LHBhZGRpbmc6MzF9KTtleHBvcnRzLlNIQUtFPVNIQUtFO3ZhciBTSEEzSGFzaD1LZWNjYWs7ZXhwb3J0cy5TSEEzSGFzaD1TSEEzSGFzaDtTSEEzLlNIQTNIYXNoPVNIQTNIYXNoO3ZhciBfZGVmYXVsdD1TSEEzO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/sha3/sponge/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _buffer=__webpack_require__(/*! buffer */ \"../../node_modules/buffer/index.js\");var _permute=_interopRequireDefault(__webpack_require__(/*! ./permute */ \"../../node_modules/sha3/sponge/permute/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var xorWords=function xorWords(I,O){for(var i=0;i<I.length;i+=8){var o=i/4;O[o]^=I[i+7]<<24|I[i+6]<<16|I[i+5]<<8|I[i+4];O[o+1]^=I[i+3]<<24|I[i+2]<<16|I[i+1]<<8|I[i]}return O};var readWords=function readWords(I,O){for(var o=0;o<O.length;o+=8){var i=o/4;O[o]=I[i+1];O[o+1]=I[i+1]>>>8;O[o+2]=I[i+1]>>>16;O[o+3]=I[i+1]>>>24;O[o+4]=I[i];O[o+5]=I[i]>>>8;O[o+6]=I[i]>>>16;O[o+7]=I[i]>>>24}return O};var Sponge=function Sponge(_ref){var _this=this;var capacity=_ref.capacity,padding=_ref.padding;var keccak=(0,_permute[\"default\"])();var stateSize=200;var blockSize=capacity/8;var queueSize=stateSize-capacity/4;var queueOffset=0;var state=new Uint32Array(stateSize/4);var queue=_buffer.Buffer.allocUnsafe(queueSize);this.absorb=function(buffer){for(var i=0;i<buffer.length;i++){queue[queueOffset]=buffer[i];queueOffset+=1;if(queueOffset>=queueSize){xorWords(queue,state);keccak(state);queueOffset=0}}return _this};this.squeeze=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var output={buffer:options.buffer||_buffer.Buffer.allocUnsafe(blockSize),padding:options.padding||padding,queue:_buffer.Buffer.allocUnsafe(queue.length),state:new Uint32Array(state.length)};queue.copy(output.queue);for(var i=0;i<state.length;i++){output.state[i]=state[i]}output.queue.fill(0,queueOffset);output.queue[queueOffset]|=output.padding;output.queue[queueSize-1]|=128;xorWords(output.queue,output.state);for(var offset=0;offset<output.buffer.length;offset+=queueSize){keccak(output.state);readWords(output.state,output.buffer.slice(offset,offset+queueSize))}return output.buffer};this.reset=function(){queue.fill(0);state.fill(0);queueOffset=0;return _this};return this};var _default=Sponge;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLFlBQVksbUJBQU8sQ0FBQyxrREFBUSxFQUFFLG9DQUFvQyxtQkFBTyxDQUFDLGtFQUFXLEdBQUcscUNBQXFDLGdDQUFnQyxlQUFlLG9DQUFvQyxZQUFZLFdBQVcsTUFBTSxVQUFVLDZDQUE2Qyw2Q0FBNkMsVUFBVSxzQ0FBc0MsWUFBWSxXQUFXLE1BQU0sVUFBVSxZQUFZLGtCQUFrQixtQkFBbUIsbUJBQW1CLFlBQVksZ0JBQWdCLGlCQUFpQixpQkFBaUIsVUFBVSxpQ0FBaUMsZUFBZSxnREFBZ0QscUNBQXFDLGtCQUFrQix5QkFBeUIsbUNBQW1DLGtCQUFrQix1Q0FBdUMsZ0RBQWdELDZCQUE2QixZQUFZLGdCQUFnQixLQUFLLDZCQUE2QixlQUFlLDJCQUEyQixzQkFBc0IsY0FBYyxlQUFlLGNBQWMsd0JBQXdCLHlFQUF5RSxZQUFZLGtMQUFrTCx5QkFBeUIsWUFBWSxlQUFlLEtBQUsseUJBQXlCLGlDQUFpQywwQ0FBMEMsK0JBQStCLG9DQUFvQyxpQkFBaUIsNEJBQTRCLG1CQUFtQixxQkFBcUIscUVBQXFFLHNCQUFzQixzQkFBc0IsY0FBYyxjQUFjLGNBQWMsY0FBYyxhQUFhLG9CQUFvQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9pbmRleC5qcz9kYzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfYnVmZmVyPXJlcXVpcmUoXCJidWZmZXJcIik7dmFyIF9wZXJtdXRlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGVybXV0ZVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfX12YXIgeG9yV29yZHM9ZnVuY3Rpb24geG9yV29yZHMoSSxPKXtmb3IodmFyIGk9MDtpPEkubGVuZ3RoO2krPTgpe3ZhciBvPWkvNDtPW29dXj1JW2krN108PDI0fElbaSs2XTw8MTZ8SVtpKzVdPDw4fElbaSs0XTtPW28rMV1ePUlbaSszXTw8MjR8SVtpKzJdPDwxNnxJW2krMV08PDh8SVtpXX1yZXR1cm4gT307dmFyIHJlYWRXb3Jkcz1mdW5jdGlvbiByZWFkV29yZHMoSSxPKXtmb3IodmFyIG89MDtvPE8ubGVuZ3RoO28rPTgpe3ZhciBpPW8vNDtPW29dPUlbaSsxXTtPW28rMV09SVtpKzFdPj4+ODtPW28rMl09SVtpKzFdPj4+MTY7T1tvKzNdPUlbaSsxXT4+PjI0O09bbys0XT1JW2ldO09bbys1XT1JW2ldPj4+ODtPW28rNl09SVtpXT4+PjE2O09bbys3XT1JW2ldPj4+MjR9cmV0dXJuIE99O3ZhciBTcG9uZ2U9ZnVuY3Rpb24gU3BvbmdlKF9yZWYpe3ZhciBfdGhpcz10aGlzO3ZhciBjYXBhY2l0eT1fcmVmLmNhcGFjaXR5LHBhZGRpbmc9X3JlZi5wYWRkaW5nO3ZhciBrZWNjYWs9KDAsX3Blcm11dGVbXCJkZWZhdWx0XCJdKSgpO3ZhciBzdGF0ZVNpemU9MjAwO3ZhciBibG9ja1NpemU9Y2FwYWNpdHkvODt2YXIgcXVldWVTaXplPXN0YXRlU2l6ZS1jYXBhY2l0eS80O3ZhciBxdWV1ZU9mZnNldD0wO3ZhciBzdGF0ZT1uZXcgVWludDMyQXJyYXkoc3RhdGVTaXplLzQpO3ZhciBxdWV1ZT1fYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShxdWV1ZVNpemUpO3RoaXMuYWJzb3JiPWZ1bmN0aW9uKGJ1ZmZlcil7Zm9yKHZhciBpPTA7aTxidWZmZXIubGVuZ3RoO2krKyl7cXVldWVbcXVldWVPZmZzZXRdPWJ1ZmZlcltpXTtxdWV1ZU9mZnNldCs9MTtpZihxdWV1ZU9mZnNldD49cXVldWVTaXplKXt4b3JXb3JkcyhxdWV1ZSxzdGF0ZSk7a2VjY2FrKHN0YXRlKTtxdWV1ZU9mZnNldD0wfX1yZXR1cm4gX3RoaXN9O3RoaXMuc3F1ZWV6ZT1mdW5jdGlvbigpe3ZhciBvcHRpb25zPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgb3V0cHV0PXtidWZmZXI6b3B0aW9ucy5idWZmZXJ8fF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2NrU2l6ZSkscGFkZGluZzpvcHRpb25zLnBhZGRpbmd8fHBhZGRpbmcscXVldWU6X2J1ZmZlci5CdWZmZXIuYWxsb2NVbnNhZmUocXVldWUubGVuZ3RoKSxzdGF0ZTpuZXcgVWludDMyQXJyYXkoc3RhdGUubGVuZ3RoKX07cXVldWUuY29weShvdXRwdXQucXVldWUpO2Zvcih2YXIgaT0wO2k8c3RhdGUubGVuZ3RoO2krKyl7b3V0cHV0LnN0YXRlW2ldPXN0YXRlW2ldfW91dHB1dC5xdWV1ZS5maWxsKDAscXVldWVPZmZzZXQpO291dHB1dC5xdWV1ZVtxdWV1ZU9mZnNldF18PW91dHB1dC5wYWRkaW5nO291dHB1dC5xdWV1ZVtxdWV1ZVNpemUtMV18PTEyODt4b3JXb3JkcyhvdXRwdXQucXVldWUsb3V0cHV0LnN0YXRlKTtmb3IodmFyIG9mZnNldD0wO29mZnNldDxvdXRwdXQuYnVmZmVyLmxlbmd0aDtvZmZzZXQrPXF1ZXVlU2l6ZSl7a2VjY2FrKG91dHB1dC5zdGF0ZSk7cmVhZFdvcmRzKG91dHB1dC5zdGF0ZSxvdXRwdXQuYnVmZmVyLnNsaWNlKG9mZnNldCxvZmZzZXQrcXVldWVTaXplKSl9cmV0dXJuIG91dHB1dC5idWZmZXJ9O3RoaXMucmVzZXQ9ZnVuY3Rpb24oKXtxdWV1ZS5maWxsKDApO3N0YXRlLmZpbGwoMCk7cXVldWVPZmZzZXQ9MDtyZXR1cm4gX3RoaXN9O3JldHVybiB0aGlzfTt2YXIgX2RlZmF1bHQ9U3BvbmdlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/chi/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/chi/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"../../node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var chi=function chi(_ref){var A=_ref.A,C=_ref.C;for(var y=0;y<25;y+=5){for(var x=0;x<5;x++){(0,_copy[\"default\"])(A,y+x)(C,x)}for(var _x=0;_x<5;_x++){var xy=(y+_x)*2;var x1=(_x+1)%5*2;var x2=(_x+2)%5*2;A[xy]^=~C[x1]&C[x2];A[xy+1]^=~C[x1+1]&C[x2+1]}}};var _default=chi;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvY2hpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLGlDQUFpQyxtQkFBTyxDQUFDLHFFQUFTLEdBQUcscUNBQXFDLGdDQUFnQyxlQUFlLDJCQUEyQixzQkFBc0IsWUFBWSxLQUFLLE1BQU0sWUFBWSxJQUFJLEtBQUssaUNBQWlDLGFBQWEsS0FBSyxNQUFNLGdCQUFnQixrQkFBa0Isa0JBQWtCLG9CQUFvQiw2QkFBNkIsaUJBQWlCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvY2hpL2luZGV4LmpzP2QxZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9jb3B5PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvcHlcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIGNoaT1mdW5jdGlvbiBjaGkoX3JlZil7dmFyIEE9X3JlZi5BLEM9X3JlZi5DO2Zvcih2YXIgeT0wO3k8MjU7eSs9NSl7Zm9yKHZhciB4PTA7eDw1O3grKyl7KDAsX2NvcHlbXCJkZWZhdWx0XCJdKShBLHkreCkoQyx4KX1mb3IodmFyIF94PTA7X3g8NTtfeCsrKXt2YXIgeHk9KHkrX3gpKjI7dmFyIHgxPShfeCsxKSU1KjI7dmFyIHgyPShfeCsyKSU1KjI7QVt4eV1ePX5DW3gxXSZDW3gyXTtBW3h5KzFdXj1+Q1t4MSsxXSZDW3gyKzFdfX19O3ZhciBfZGVmYXVsdD1jaGk7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/chi/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/copy/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/copy/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var copy=function copy(I,i){return function(O,o){var oi=o*2;var ii=i*2;O[oi]=I[ii];O[oi+1]=I[ii+1]}};module.exports=copy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvY29weS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw0QkFBNEIscUJBQXFCLFdBQVcsV0FBVyxZQUFZLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvY29weS9pbmRleC5qcz9jN2JhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO3ZhciBjb3B5PWZ1bmN0aW9uIGNvcHkoSSxpKXtyZXR1cm4gZnVuY3Rpb24oTyxvKXt2YXIgb2k9byoyO3ZhciBpaT1pKjI7T1tvaV09SVtpaV07T1tvaSsxXT1JW2lpKzFdfX07bW9kdWxlLmV4cG9ydHM9Y29weTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/copy/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _chi=_interopRequireDefault(__webpack_require__(/*! ./chi */ \"../../node_modules/sha3/sponge/permute/chi/index.js\"));var _iota=_interopRequireDefault(__webpack_require__(/*! ./iota */ \"../../node_modules/sha3/sponge/permute/iota/index.js\"));var _rhoPi=_interopRequireDefault(__webpack_require__(/*! ./rho-pi */ \"../../node_modules/sha3/sponge/permute/rho-pi/index.js\"));var _theta=_interopRequireDefault(__webpack_require__(/*! ./theta */ \"../../node_modules/sha3/sponge/permute/theta/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var permute=function permute(){var C=new Uint32Array(10);var D=new Uint32Array(10);var W=new Uint32Array(2);return function(A){for(var roundIndex=0;roundIndex<24;roundIndex++){(0,_theta[\"default\"])({A:A,C:C,D:D,W:W});(0,_rhoPi[\"default\"])({A:A,C:C,W:W});(0,_chi[\"default\"])({A:A,C:C});(0,_iota[\"default\"])({A:A,roundIndex:roundIndex})}C.fill(0);D.fill(0);W.fill(0)}};var _default=permute;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsZ0NBQWdDLG1CQUFPLENBQUMsa0VBQU8sR0FBRyxpQ0FBaUMsbUJBQU8sQ0FBQyxvRUFBUSxHQUFHLGtDQUFrQyxtQkFBTyxDQUFDLHdFQUFVLEdBQUcsa0NBQWtDLG1CQUFPLENBQUMsc0VBQVMsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUsK0JBQStCLDBCQUEwQiwwQkFBMEIseUJBQXlCLG1CQUFtQixxQkFBcUIsY0FBYyxjQUFjLHVCQUF1QixnQkFBZ0IsRUFBRSx1QkFBdUIsWUFBWSxFQUFFLHFCQUFxQixRQUFRLEVBQUUsc0JBQXNCLDBCQUEwQixFQUFFLFVBQVUsVUFBVSxZQUFZLHFCQUFxQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL2luZGV4LmpzPzBiZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9jaGk9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jaGlcIikpO3ZhciBfaW90YT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lvdGFcIikpO3ZhciBfcmhvUGk9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yaG8tcGlcIikpO3ZhciBfdGhldGE9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90aGV0YVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfX12YXIgcGVybXV0ZT1mdW5jdGlvbiBwZXJtdXRlKCl7dmFyIEM9bmV3IFVpbnQzMkFycmF5KDEwKTt2YXIgRD1uZXcgVWludDMyQXJyYXkoMTApO3ZhciBXPW5ldyBVaW50MzJBcnJheSgyKTtyZXR1cm4gZnVuY3Rpb24oQSl7Zm9yKHZhciByb3VuZEluZGV4PTA7cm91bmRJbmRleDwyNDtyb3VuZEluZGV4KyspeygwLF90aGV0YVtcImRlZmF1bHRcIl0pKHtBOkEsQzpDLEQ6RCxXOld9KTsoMCxfcmhvUGlbXCJkZWZhdWx0XCJdKSh7QTpBLEM6QyxXOld9KTsoMCxfY2hpW1wiZGVmYXVsdFwiXSkoe0E6QSxDOkN9KTsoMCxfaW90YVtcImRlZmF1bHRcIl0pKHtBOkEscm91bmRJbmRleDpyb3VuZEluZGV4fSl9Qy5maWxsKDApO0QuZmlsbCgwKTtXLmZpbGwoMCl9fTt2YXIgX2RlZmF1bHQ9cGVybXV0ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/iota/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/iota/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _roundConstants=_interopRequireDefault(__webpack_require__(/*! ./round-constants */ \"../../node_modules/sha3/sponge/permute/iota/round-constants/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var iota=function iota(_ref){var A=_ref.A,roundIndex=_ref.roundIndex;var i=roundIndex*2;A[0]^=_roundConstants[\"default\"][i];A[1]^=_roundConstants[\"default\"][i+1]};var _default=iota;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvaW90YS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxrQkFBa0IsUUFBUSwyQ0FBMkMsbUJBQU8sQ0FBQywrRkFBbUIsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUsNkJBQTZCLHdDQUF3QyxtQkFBbUIsb0NBQW9DLHVDQUF1QyxrQkFBa0Isa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9pb3RhL2luZGV4LmpzPzkxZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9yb3VuZENvbnN0YW50cz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JvdW5kLWNvbnN0YW50c1wiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfX12YXIgaW90YT1mdW5jdGlvbiBpb3RhKF9yZWYpe3ZhciBBPV9yZWYuQSxyb3VuZEluZGV4PV9yZWYucm91bmRJbmRleDt2YXIgaT1yb3VuZEluZGV4KjI7QVswXV49X3JvdW5kQ29uc3RhbnRzW1wiZGVmYXVsdFwiXVtpXTtBWzFdXj1fcm91bmRDb25zdGFudHNbXCJkZWZhdWx0XCJdW2krMV19O3ZhciBfZGVmYXVsdD1pb3RhO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/iota/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/iota/round-constants/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/iota/round-constants/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var ROUND_CONSTANTS=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);var _default=ROUND_CONSTANTS;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvaW90YS9yb3VuZC1jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsa1lBQWtZLDZCQUE2QixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL2lvdGEvcm91bmQtY29uc3RhbnRzL2luZGV4LmpzP2U2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIFJPVU5EX0NPTlNUQU5UUz1uZXcgVWludDMyQXJyYXkoWzAsMSwwLDMyODk4LDIxNDc0ODM2NDgsMzI5MDYsMjE0NzQ4MzY0OCwyMTQ3NTE2NDE2LDAsMzI5MDcsMCwyMTQ3NDgzNjQ5LDIxNDc0ODM2NDgsMjE0NzUxNjU0NSwyMTQ3NDgzNjQ4LDMyNzc3LDAsMTM4LDAsMTM2LDAsMjE0NzUxNjQyNSwwLDIxNDc0ODM2NTgsMCwyMTQ3NTE2NTU1LDIxNDc0ODM2NDgsMTM5LDIxNDc0ODM2NDgsMzI5MDUsMjE0NzQ4MzY0OCwzMjc3MSwyMTQ3NDgzNjQ4LDMyNzcwLDIxNDc0ODM2NDgsMTI4LDAsMzI3NzgsMjE0NzQ4MzY0OCwyMTQ3NDgzNjU4LDIxNDc0ODM2NDgsMjE0NzUxNjU0NSwyMTQ3NDgzNjQ4LDMyODk2LDAsMjE0NzQ4MzY0OSwyMTQ3NDgzNjQ4LDIxNDc1MTY0MjRdKTt2YXIgX2RlZmF1bHQ9Uk9VTkRfQ09OU1RBTlRTO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/iota/round-constants/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/rho-pi/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/rho-pi/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _piShuffles=_interopRequireDefault(__webpack_require__(/*! ./pi-shuffles */ \"../../node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js\"));var _rhoOffsets=_interopRequireDefault(__webpack_require__(/*! ./rho-offsets */ \"../../node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js\"));var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"../../node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var rhoPi=function rhoPi(_ref){var A=_ref.A,C=_ref.C,W=_ref.W;(0,_copy[\"default\"])(A,1)(W,0);var H=0;var L=0;var Wi=0;var ri=32;for(var i=0;i<24;i++){var j=_piShuffles[\"default\"][i];var r=_rhoOffsets[\"default\"][i];(0,_copy[\"default\"])(A,j)(C,0);H=W[0];L=W[1];ri=32-r;Wi=r<32?0:1;W[Wi]=H<<r|L>>>ri;W[(Wi+1)%2]=L<<r|H>>>ri;(0,_copy[\"default\"])(W,0)(A,j);(0,_copy[\"default\"])(C,0)(W,0)}};var _default=rhoPi;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvcmhvLXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLHVDQUF1QyxtQkFBTyxDQUFDLHlGQUFlLEdBQUcsdUNBQXVDLG1CQUFPLENBQUMseUZBQWUsR0FBRyxpQ0FBaUMsbUJBQU8sQ0FBQyxxRUFBUyxHQUFHLHFDQUFxQyxnQ0FBZ0MsZUFBZSwrQkFBK0IsK0JBQStCLCtCQUErQixRQUFRLFFBQVEsU0FBUyxVQUFVLFlBQVksS0FBSyxLQUFLLGdDQUFnQyxnQ0FBZ0MsK0JBQStCLE9BQU8sT0FBTyxRQUFRLFlBQVksa0JBQWtCLHdCQUF3QiwrQkFBK0IsaUNBQWlDLG1CQUFtQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL3Joby1waS9pbmRleC5qcz82NTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfcGlTaHVmZmxlcz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BpLXNodWZmbGVzXCIpKTt2YXIgX3Job09mZnNldHM9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yaG8tb2Zmc2V0c1wiKSk7dmFyIF9jb3B5PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvcHlcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIHJob1BpPWZ1bmN0aW9uIHJob1BpKF9yZWYpe3ZhciBBPV9yZWYuQSxDPV9yZWYuQyxXPV9yZWYuVzsoMCxfY29weVtcImRlZmF1bHRcIl0pKEEsMSkoVywwKTt2YXIgSD0wO3ZhciBMPTA7dmFyIFdpPTA7dmFyIHJpPTMyO2Zvcih2YXIgaT0wO2k8MjQ7aSsrKXt2YXIgaj1fcGlTaHVmZmxlc1tcImRlZmF1bHRcIl1baV07dmFyIHI9X3Job09mZnNldHNbXCJkZWZhdWx0XCJdW2ldOygwLF9jb3B5W1wiZGVmYXVsdFwiXSkoQSxqKShDLDApO0g9V1swXTtMPVdbMV07cmk9MzItcjtXaT1yPDMyPzA6MTtXW1dpXT1IPDxyfEw+Pj5yaTtXWyhXaSsxKSUyXT1MPDxyfEg+Pj5yaTsoMCxfY29weVtcImRlZmF1bHRcIl0pKFcsMCkoQSxqKTsoMCxfY29weVtcImRlZmF1bHRcIl0pKEMsMCkoVywwKX19O3ZhciBfZGVmYXVsdD1yaG9QaTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/rho-pi/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var PI_SHUFFLES=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1];var _default=PI_SHUFFLES;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvcmhvLXBpL3BpLXNodWZmbGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLGlGQUFpRix5QkFBeUIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvcGktc2h1ZmZsZXMvaW5kZXguanM/OTUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgUElfU0hVRkZMRVM9WzEwLDcsMTEsMTcsMTgsMyw1LDE2LDgsMjEsMjQsNCwxNSwyMywxOSwxMywxMiwyLDIwLDE0LDIyLDksNiwxXTt2YXIgX2RlZmF1bHQ9UElfU0hVRkZMRVM7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var RHO_OFFSETS=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44];var _default=RHO_OFFSETS;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvcmhvLXBpL3Joby1vZmZzZXRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLGtCQUFrQixRQUFRLHFGQUFxRix5QkFBeUIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvc2hhMy9zcG9uZ2UvcGVybXV0ZS9yaG8tcGkvcmhvLW9mZnNldHMvaW5kZXguanM/MGUyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgUkhPX09GRlNFVFM9WzEsMyw2LDEwLDE1LDIxLDI4LDM2LDQ1LDU1LDIsMTQsMjcsNDEsNTYsOCwyNSw0Myw2MiwxOCwzOSw2MSwyMCw0NF07dmFyIF9kZWZhdWx0PVJIT19PRkZTRVRTO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js\n"));

/***/ }),

/***/ "../../node_modules/sha3/sponge/permute/theta/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/sha3/sponge/permute/theta/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(/*! ../copy */ \"../../node_modules/sha3/sponge/permute/copy/index.js\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}var theta=function theta(_ref){var A=_ref.A,C=_ref.C,D=_ref.D,W=_ref.W;var H=0;var L=0;for(var x=0;x<5;x++){var x20=x*2;var x21=(x+5)*2;var x22=(x+10)*2;var x23=(x+15)*2;var x24=(x+20)*2;C[x20]=A[x20]^A[x21]^A[x22]^A[x23]^A[x24];C[x20+1]=A[x20+1]^A[x21+1]^A[x22+1]^A[x23+1]^A[x24+1]}for(var _x=0;_x<5;_x++){(0,_copy[\"default\"])(C,(_x+1)%5)(W,0);H=W[0];L=W[1];W[0]=H<<1|L>>>31;W[1]=L<<1|H>>>31;D[_x*2]=C[(_x+4)%5*2]^W[0];D[_x*2+1]=C[(_x+4)%5*2+1]^W[1];for(var y=0;y<25;y+=5){A[(y+_x)*2]^=D[_x*2];A[(y+_x)*2+1]^=D[_x*2+1]}}};var _default=theta;exports[\"default\"]=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NoYTMvc3BvbmdlL3Blcm11dGUvdGhldGEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWEsOENBQTJDLENBQUMsV0FBVyxFQUFDLENBQUMsa0JBQWtCLFFBQVEsaUNBQWlDLG1CQUFPLENBQUMscUVBQVMsR0FBRyxxQ0FBcUMsZ0NBQWdDLGVBQWUsK0JBQStCLHdDQUF3QyxRQUFRLFFBQVEsWUFBWSxJQUFJLEtBQUssWUFBWSxnQkFBZ0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsMENBQTBDLHNEQUFzRCxhQUFhLEtBQUssTUFBTSxzQ0FBc0MsT0FBTyxPQUFPLGlCQUFpQixpQkFBaUIsMkJBQTJCLCtCQUErQixZQUFZLEtBQUssTUFBTSxxQkFBcUIsNEJBQTRCLG1CQUFtQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9zaGEzL3Nwb25nZS9wZXJtdXRlL3RoZXRhL2luZGV4LmpzPzk3NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9jb3B5PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2NvcHlcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian19dmFyIHRoZXRhPWZ1bmN0aW9uIHRoZXRhKF9yZWYpe3ZhciBBPV9yZWYuQSxDPV9yZWYuQyxEPV9yZWYuRCxXPV9yZWYuVzt2YXIgSD0wO3ZhciBMPTA7Zm9yKHZhciB4PTA7eDw1O3grKyl7dmFyIHgyMD14KjI7dmFyIHgyMT0oeCs1KSoyO3ZhciB4MjI9KHgrMTApKjI7dmFyIHgyMz0oeCsxNSkqMjt2YXIgeDI0PSh4KzIwKSoyO0NbeDIwXT1BW3gyMF1eQVt4MjFdXkFbeDIyXV5BW3gyM11eQVt4MjRdO0NbeDIwKzFdPUFbeDIwKzFdXkFbeDIxKzFdXkFbeDIyKzFdXkFbeDIzKzFdXkFbeDI0KzFdfWZvcih2YXIgX3g9MDtfeDw1O194KyspeygwLF9jb3B5W1wiZGVmYXVsdFwiXSkoQywoX3grMSklNSkoVywwKTtIPVdbMF07TD1XWzFdO1dbMF09SDw8MXxMPj4+MzE7V1sxXT1MPDwxfEg+Pj4zMTtEW194KjJdPUNbKF94KzQpJTUqMl1eV1swXTtEW194KjIrMV09Q1soX3grNCklNSoyKzFdXldbMV07Zm9yKHZhciB5PTA7eTwyNTt5Kz01KXtBWyh5K194KSoyXV49RFtfeCoyXTtBWyh5K194KSoyKzFdXj1EW194KjIrMV19fX07dmFyIF9kZWZhdWx0PXRoZXRhO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sha3/sponge/permute/theta/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);